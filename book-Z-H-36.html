<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:ops="http://www.idpf.org/2007/ops">
<!-- Generated from TeX source by tex2page, v 4o,
     (c) Dorai Sitaram, http://www.cs.rice.edu/~dorai/tex2page -->
<head>
    <meta http-equiv="Content-Type: text/html; charset=utf-8">
<title>Structure and Interpretation of Computer Programs</title>
<link rel="stylesheet" type="text/css" href="book-Z-C.css" title=default>
</head>
<body>



<a name="%_chap_Temp_849"></a>
<h1 class=chapter>
<div class=chapterheading>&nbsp;</div><p>
<a href="book-Z-H-4.html#%_toc_%_chap_Temp_849">References</a></h1><p>

<p>

Abelson, Harold, Andrew Berlin, Jacob Katzenelson,
William McAllister,
Guillermo Rozas, Gerald Jay Sussman, and Jack Wisdom. 1992.  The
Supercomputer Toolkit: A general framework for special-purpose
computing.  <em>International Journal of High-Speed Electronics</em>
3(3):337-361.<p>

Allen, John.  1978.  <em>Anatomy of Lisp.</em> New York: McGraw-Hill.<p>

ANSI X3.226-1994. <em>American National Standard for Information
Systems -- Programming Language -- Common Lisp.</em><p>

Appel, Andrew W.  1987.  Garbage collection can be faster than stack
allocation.  <em>Information Processing Letters</em> 25(4):275-279.<p>

Backus, John.  1978.  Can programming be liberated from the von
Neumann style?  <em>Communications of the ACM</em> 21(8):613-641.<p>

Baker, Henry G., Jr.  1978.  List processing in real time on a serial
computer.  <em>Communications of the ACM</em> 21(4):280-293.<p>

Batali, John, Neil Mayle, Howard Shrobe, Gerald Jay Sussman, and
Daniel Weise.  1982.  The Scheme-81 architecture -- System and chip.
In <em>Proceedings of the MIT Conference on Advanced Research in
VLSI,</em> edited by Paul Penfield, Jr. Dedham, MA: Artech House.<p>

Borning, Alan.  1977.  ThingLab -- An object-oriented system for
building simulations using constraints. In <em>Proceedings of the 5th
International Joint Conference on Artificial Intelligence.</em><p>

Borodin, Alan, and Ian Munro.  1975.  <em>The Computational
Complexity of Algebraic and Numeric Problems.</em> New York: American
Elsevier.<p>

Chaitin, Gregory J.  1975.  Randomness and mathematical proof.  <em>Scientific American</em> 232(5):47-52.<p>

Church, Alonzo.  1941.  <em>The Calculi of Lambda-Conversion.</em>
Princeton, N.J.: Princeton University Press.<p>

Clark, Keith L.  1978.  Negation as failure.  In <em>Logic and Data
Bases.</em> New York: Plenum Press, pp. 293-322.<p>

Clinger, William.  1982.  Nondeterministic call by need is neither
lazy nor by name. In <em>Proceedings of the ACM Symposium on Lisp and
Functional Programming,</em> pp. 226-234.<p>

Clinger, William, and Jonathan Rees.  1991.  Macros that work.  In
<em>Proceedings of the 1991 ACM Conference on Principles of
Programming Languages,</em> pp. 155-162.<p>

Colmerauer A., H. Kanoui, R. Pasero, and P. Roussel.  1973.  Un syst&egrave;me
de communication homme-machine en fran&ccedil;ais.  Technical report,
Groupe Intelligence Artificielle, Universit&eacute; d'Aix Marseille,
Luminy.<p>

Cormen, Thomas, Charles Leiserson, and Ronald Rivest.  1990. <em>Introduction to Algorithms.</em> Cambridge, MA: MIT Press.<p>

Darlington, John, Peter Henderson, and David Turner.  1982.  <em>Functional Programming and Its Applications.</em> New York: Cambridge
University Press.<p>

Dijkstra, Edsger W. 1968a.  The structure of the ``THE''
multiprogramming system.  <em>Communications of the ACM</em>
11(5):341-346.<p>

Dijkstra, Edsger W. 1968b.  Cooperating sequential processes.  In <em>Programming Languages</em>, edited by F. Genuys. New York: Academic Press, pp.
43-112.<p>

Dinesman, Howard P.  1968.  <em>Superior Mathematical Puzzles</em>.  New
York: Simon and Schuster.<p>

deKleer, Johan, Jon Doyle, Guy Steele, and Gerald J. Sussman.  1977.
AMORD: Explicit control of reasoning.  In <em>Proceedings of the ACM
Symposium on Artificial Intelligence and Programming Languages,</em> pp.
116-125.<p>

Doyle, Jon. 1979. A truth maintenance system. <em>Artificial
Intelligence</em> 12:231-272.<p>

Feigenbaum, Edward, and Howard Shrobe. 1993. The Japanese National
Fifth Generation Project: Introduction, survey, and evaluation.  In <em>Future Generation Computer Systems,</em> vol. 9, pp. 105-117.<p>

Feeley, Marc.  1986.  Deux approches &agrave; l'implantation du
language Scheme.  Masters thesis, Universit&eacute; de Montr&eacute;al.<p>

Feeley, Marc and Guy Lapalme.  1987.  Using closures for code
generation.  <em>Journal of Computer Languages</em> 12(1):47-66.<p>

Feller, William.  1957.  <em>An Introduction to Probability Theory
and Its Applications,</em> volume 1. New York: John Wiley & Sons.<p>

Fenichel, R., and J. Yochelson.  1969.  A Lisp garbage collector for
virtual memory computer systems.  <em>Communications of the ACM</em>
12(11):611-612.<p>

Floyd, Robert. 1967. Nondeterministic algorithms. <em>JACM,</em> 14(4):636-644.<p>

Forbus, Kenneth D., and Johan deKleer.  1993. <em>Building Problem
Solvers.</em> Cambridge, MA: MIT Press.<p>

Friedman, Daniel P., and David S. Wise.  1976.  CONS should not
evaluate its arguments. In <em>Automata, Languages, and Programming:
Third International Colloquium,</em> edited by S. Michaelson and R.
Milner, pp. 257-284.<p>

Friedman, Daniel P., Mitchell Wand, and Christopher T. Haynes. 1992.
<em>Essentials of Programming Languages.</em>  Cambridge, MA: MIT
Press/McGraw-Hill.<p>

Gabriel, Richard P. 1988.  The Why of <em>Y</em>.  <em>Lisp Pointers</em>
2(2):15-25.<p>

Goldberg, Adele, and David Robson.  1983.  <em>Smalltalk-80: The
Language and Its Implementation.</em> Reading, MA: Addison-Wesley.<p>

Gordon, Michael, Robin Milner, and Christopher Wadsworth.  1979.  <em>Edinburgh LCF.</em> Lecture Notes in Computer Science, volume 78. New
York: Springer-Verlag.<p>

Gray, Jim, and Andreas Reuter. 1993. <em>Transaction Processing:
Concepts and Models.</em> San Mateo, CA: Morgan-Kaufman.<p>

Green, Cordell.  1969.  Application of theorem proving to problem
solving.  In <em>Proceedings of the International Joint Conference on
Artificial Intelligence,</em> pp. 219-240.<p>

Green, Cordell, and Bertram Raphael.  1968.  The use of
theorem-proving techniques in question-answering systems.  In <em>Proceedings of the ACM National Conference,</em> pp. 169-181.<p>

Griss, Martin L.  1981.  Portable Standard Lisp, a brief overview.
Utah Symbolic Computation Group Operating Note 58, University of Utah.<p>

Guttag, John V.  1977.  Abstract data types and the development of
data structures.  <em>Communications of the ACM</em> 20(6):397-404.<p>

Hamming, Richard W.  1980.  <em>Coding and Information Theory.</em>
Englewood Cliffs, N.J.: Prentice-Hall.<p>

Hanson, Christopher P.  1990.  Efficient stack allocation for
tail-recursive languages.  In <em>Proceedings of ACM Conference on
Lisp and Functional Programming,</em> pp. 106-118.<p>

Hanson, Christopher P.  1991.  A syntactic closures macro facility.
<em>Lisp Pointers,</em> 4(3).<p>

Hardy, Godfrey H.  1921.  Srinivasa Ramanujan.  <em>Proceedings of
the London Mathematical Society</em> XIX(2).<p>

Hardy, Godfrey H., and E. M. Wright.  1960.  <em>An Introduction to
the Theory of Numbers.</em>  4th edition.  New York: Oxford University
Press.<p>

Havender, J. 1968. Avoiding deadlocks in multi-tasking systems. <em>IBM Systems Journal</em> 7(2):74-84.<p>

Hearn, Anthony C.  1969.  Standard Lisp.  Technical report AIM-90,
Artificial Intelligence Project, Stanford University.<p>

Henderson, Peter. 1980.  <em>Functional Programming: Application and
Implementation.</em> Englewood Cliffs, N.J.: Prentice-Hall.<p>

Henderson. Peter. 1982. Functional Geometry. In <em>Conference Record
of the 1982 ACM Symposium on Lisp and Functional Programming,</em>
pp. 179-187.<p>

Hewitt, Carl E.  1969.  PLANNER: A language for proving theorems in
robots.  In <em>Proceedings of the International Joint Conference on
Artificial Intelligence,</em> pp. 295-301.<p>

Hewitt, Carl E.  1977.  Viewing control structures as patterns of
passing messages.  <em>Journal of Artificial Intelligence</em>
8(3):323-364.<p>

Hoare, C. A. R. 1972.  Proof of correctness of data representations.
<em>Acta Informatica</em> 1(1).<p>

Hodges, Andrew. 1983.  <em>Alan Turing: The Enigma.</em> New York: Simon
and Schuster.<p>

Hofstadter, Douglas R.  1979.  <em>G&ouml;del, Escher, Bach: An Eternal
Golden Braid.</em> New York: Basic Books.<p>

Hughes, R. J. M.  1990.  Why functional programming matters.  In <em>Research Topics in Functional Programming</em>, edited by David Turner.
Reading, MA: Addison-Wesley, pp. 17-42.<p>

IEEE Std 1178-1990.  1990.  <em>IEEE Standard for the Scheme
Programming Language.</em><p>

Ingerman, Peter, Edgar Irons, Kirk Sattley, and Wallace Feurzeig;
assisted by M. Lind, Herbert Kanner, and Robert Floyd.  1960.  THUNKS:
A way of compiling procedure statements, with some comments on
procedure declarations.  Unpublished manuscript.  (Also, private
communication from Wallace Feurzeig.)<p>

Kaldewaij, Anne. 1990.  <em>Programming: The Derivation of
Algorithms.</em> New York: Prentice-Hall.<p>

Kohlbecker, Eugene Edmund, Jr. 1986.  Syntactic extensions in the
programming language Lisp.  Ph.D. thesis, Indiana University.<p>

Konopasek, Milos, and Sundaresan Jayaraman.  1984.  <em>The TK!Solver
Book: A Guide to Problem-Solving in Science, Engineering, Business,
and Education.</em> Berkeley, CA: Osborne/McGraw-Hill.<p>

Knuth, Donald E.  1973.  <em>Fundamental Algorithms.</em> Volume 1 of
<em>The Art of Computer Programming.</em>  2nd edition. Reading, MA:
Addison-Wesley.<p>

Knuth, Donald E.  1981.  <em>Seminumerical Algorithms.</em> Volume 2 of
<em>The Art of Computer Programming.</em>  2nd edition. Reading, MA:
Addison-Wesley.<p>

Kowalski, Robert.  1973.  Predicate logic as a programming language.
Technical report 70, Department of Computational Logic, School of
Artificial Intelligence, University of Edinburgh.<p>

Kowalski, Robert.  1979.  <em>Logic for Problem Solving.</em> New York:
North-Holland.<p>

Lamport, Leslie. 1978.  Time, clocks, and the ordering of events in a
distributed system.  <em>Communications of the ACM</em> 21(7):558-565.<p>

Lampson, Butler, J. J. Horning, R.  London, J. G. Mitchell, and G. K.
Popek.  1981.  Report on the programming language Euclid.  Technical
report, Computer Systems Research Group, University of Toronto.<p>

Landin, Peter.  1965.  A correspondence between Algol 60 and Church's
lambda notation: Part I.  <em>Communications of the ACM</em>
8(2):89-101.<p>

Lieberman, Henry, and Carl E. Hewitt. 1983. A real-time garbage
collector based on the lifetimes of objects. <em>Communications of
the ACM</em> 26(6):419-429.<p>

Liskov, Barbara H., and Stephen N. Zilles.  1975.  Specification
techniques for data abstractions.  <em>IEEE Transactions on Software
Engineering</em> 1(1):7-19.<p>

McAllester, David Allen.  1978.  A three-valued truth-maintenance
system.  Memo 473, MIT Artificial Intelligence Laboratory.<p>

McAllester, David Allen.  1980.  An outlook on truth maintenance.
Memo 551, MIT Artificial Intelligence Laboratory.<p>

McCarthy, John.  1960.  Recursive functions of symbolic expressions
and their computation by machine.  <em>Communications of the ACM</em>
3(4):184-195.<p>

McCarthy, John.  1967.  A basis for a mathematical theory of
computation.  In <em>Computer Programing and Formal Systems</em>, edited
by P. Braffort and D. Hirschberg.  North-Holland.<p>

McCarthy, John.  1978.  The history of Lisp.  In <em>Proceedings of
the ACM SIGPLAN Conference on the History of Programming Languages.</em><p>

McCarthy, John, P. W. Abrahams, D. J. Edwards, T. P. Hart, and M. I.
Levin.  1965.  <em>Lisp 1.5 Programmer's Manual.</em>  2nd edition.
Cambridge, MA: MIT Press.<p>

McDermott, Drew, and Gerald Jay Sussman.  1972. Conniver reference
manual.  Memo 259, MIT Artificial Intelligence Laboratory.<p>

Miller, Gary L.  1976.  Riemann's Hypothesis and tests for primality.
<em>Journal of Computer and System Sciences</em> 13(3):300-317.<p>

Miller, James S., and Guillermo J. Rozas. 1994.  Garbage collection is
fast, but a stack is faster.  Memo 1462, MIT Artificial Intelligence
Laboratory.<p>

Moon, David.  1978.  MacLisp reference manual, Version 0.  Technical
report, MIT Laboratory for Computer Science.<p>

Moon, David, and Daniel Weinreb.  1981.  Lisp machine manual.
Technical report, MIT Artificial Intelligence Laboratory.<p>

Morris, J. H., Eric Schmidt, and Philip Wadler.  1980.  Experience
with an applicative string processing language.  In <em>Proceedings
of the 7th Annual ACM SIGACT/SIGPLAN Symposium on the Principles of
Programming Languages.</em><p>

Phillips, Hubert.  1934. <em>The Sphinx Problem Book</em>.  London: Faber
and Faber.<p>

Pitman, Kent.  1983.  The revised MacLisp Manual (Saturday evening
edition).  Technical report 295, MIT Laboratory for Computer Science.<p>

Rabin, Michael O. 1980. Probabilistic algorithm for testing primality.
<em>Journal of Number Theory</em> 12:128-138.<p>

Raymond, Eric.  1993. <em>The New Hacker's Dictionary.</em> 2nd edition.
Cambridge, MA: MIT Press.<p>

Raynal, Michel. 1986. <em>Algorithms for Mutual Exclusion.</em>
Cambridge, MA: MIT Press.<p>

Rees, Jonathan A., and Norman I. Adams IV. 1982.  T: A dialect of Lisp
or, lambda: The ultimate software tool.  In <em>Conference Record of
the 1982 ACM Symposium on Lisp and Functional Programming,</em> pp.
114-122.<p>

Rees, Jonathan, and William Clinger (eds). 1991.  The revised<sup>4</sup>
report on the algorithmic language Scheme.  <em>Lisp Pointers,</em> 4(3).<p>

Rivest, Ronald, Adi Shamir, and Leonard Adleman.  1977.  A method for
obtaining digital signatures and public-key cryptosystems. Technical
memo LCS/TM82, MIT Laboratory for Computer Science.<p>

Robinson, J. A. 1965.  A machine-oriented logic based on the
resolution principle.  <em>Journal of the ACM</em> 12(1):23.<p>

Robinson, J. A. 1983.  Logic programming -- Past, present, and future.
<em>New Generation Computing</em> 1:107-124.<p>

Spafford, Eugene H.  1989.  The Internet Worm: Crisis and aftermath.
<em>Communications of the ACM</em> 32(6):678-688.<p>

Steele, Guy Lewis, Jr.  1977.  Debunking the ``expensive procedure
call'' myth.  In <em>Proceedings of the National Conference of the
ACM,</em> pp. 153-62.<p>

Steele, Guy Lewis, Jr.  1982.  An overview of Common Lisp.  In <em>Proceedings of the ACM Symposium on Lisp and Functional Programming,</em>
pp. 98-107.<p>

Steele, Guy Lewis, Jr.  1990.  <em>Common Lisp: The Language.</em> 2nd
edition.  Digital Press.<p>

Steele, Guy Lewis, Jr., and Gerald Jay Sussman.  1975.  Scheme: An
interpreter for the extended lambda calculus.  Memo 349, MIT
Artificial Intelligence Laboratory.<p>

Steele, Guy Lewis, Jr., Donald R. Woods, Raphael A. Finkel, Mark R.
Crispin, Richard M. Stallman, and Geoffrey S. Goodfellow.  1983.  <em>The Hacker's Dictionary.</em> New York: Harper & Row.<p>

Stoy, Joseph E.  1977.  <em>Denotational Semantics.</em> Cambridge, MA:
MIT Press.<p>

Sussman, Gerald Jay, and Richard M. Stallman.  1975.  Heuristic
techniques in computer-aided circuit analysis.  <em>IEEE Transactions
on Circuits and Systems</em> CAS-22(11):857-865.<p>

Sussman, Gerald Jay, and Guy Lewis Steele Jr.  1980.  Constraints -- A
language for expressing almost-hierachical descriptions.  <em>AI
Journal</em> 14:1-39.<p>

Sussman, Gerald Jay, and Jack Wisdom.  1992. Chaotic evolution of the
solar system.  <em>Science</em> 257:256-262.<p>

Sussman, Gerald Jay, Terry Winograd, and Eugene Charniak.  1971.
Microplanner reference manual.  Memo 203A, MIT Artificial Intelligence
Laboratory.<p>

Sutherland, Ivan E.  1963.  SKETCHPAD: A man-machine graphical
communication system.  Technical report 296, MIT Lincoln Laboratory.<p>

Teitelman, Warren.  1974.  Interlisp reference manual.  Technical
report, Xerox Palo Alto Research Center.<p>

Thatcher, James W., Eric G. Wagner, and Jesse B. Wright. 1978.
Data type specification: Parameterization and the power of
specification techniques. In <em>Conference Record of the Tenth Annual ACM
Symposium on Theory of Computing</em>, pp. 119-132.

Turner, David.  1981.  The future of applicative languages.  In <em>Proceedings of the 3rd European Conference on Informatics,</em> Lecture
Notes in Computer Science, volume 123. New York: Springer-Verlag, pp.
334-348.<p>

Wand, Mitchell.  1980.  Continuation-based program transformation
strategies.  <em>Journal of the ACM</em> 27(1):164-180.<p>

Waters, Richard C.  1979.  A method for analyzing loop programs.  <em>IEEE Transactions on Software Engineering</em> 5(3):237-247.<p>

Winograd, Terry.  1971.  Procedures as a representation for data in a
computer program for understanding natural language.  Technical report
AI TR-17, MIT Artificial Intelligence Laboratory.<p>

Winston, Patrick. 1992. <em>Artificial Intelligence</em>.  3rd edition.
Reading, MA: Addison-Wesley.<p>

Zabih, Ramin, David McAllester, and David Chapman.  1987.
Non-deterministic Lisp with dependency-directed backtracking.
<em>AAAI-87</em>, pp. 59-64.<p>

Zippel, Richard.  1979.  Probabilistic algorithms for sparse
polynomials.  Ph.D. dissertation, Department of Electrical Engineering
and Computer Science, MIT.<p>

Zippel, Richard.  1993.  <em>Effective Polynomial Computation.</em>
Boston, MA: Kluwer Academic Publishers.<p>

<p>





</body>
</html>
