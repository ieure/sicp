<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:ops="http://www.idpf.org/2007/ops">
<!-- Generated from TeX source by tex2page, v 4o,
     (c) Dorai Sitaram, http://www.cs.rice.edu/~dorai/tex2page -->
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta http-equiv="Content-Type: text/html; charset=utf-8" />
    <title>Structure and Interpretation of Computer Programs</title>
    <link rel="stylesheet" type="text/css" href="book-Z-C.css" title="default" />
  </head>
  <body>



<a name="%_chap_1" id="%_chap_1"></a>
<h1 class="chapter chapterheading"><a href="book-Z-H-4.html#%_toc_%_chap_1">Chapter 1</a></h1>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_6">Programming in Lisp</a></h4>

<p>We need an appropriate language for describing processes, and we will
use for this purpose the programming language Lisp.  Just as our
everyday thoughts are usually expressed in our natural language (such
as English, French, or Japanese), and descriptions of quantitative
phenomena are expressed with mathematical notations, our procedural
thoughts will be expressed in Lisp.  <a name="%_idx_24" id="%_idx_24"></a>Lisp was invented in the late
1950s as a formalism for reasoning about the use of certain kinds of
logical expressions, called <a name="%_idx_26" id="%_idx_26"></a><em>recursion equations</em>, as a model for
computation.  The language was conceived by <a name="%_idx_28" id="%_idx_28"></a>John McCarthy and is based
on his paper “Recursive Functions of Symbolic Expressions and Their
Computation by Machine” (McCarthy 1960).</p>

<p>Despite its inception as a mathematical formalism, Lisp is a practical
programming language.  A Lisp <a name="%_idx_30" id="%_idx_30"></a><em>interpreter</em> is a machine that
carries out processes described in the Lisp language.  The first Lisp
interpreter was implemented by <a name="%_idx_32" id="%_idx_32"></a>McCarthy with the help of colleagues
and students in the Artificial Intelligence Group of the <a name="%_idx_34" id="%_idx_34"></a>MIT Research
Laboratory of Electronics and in the MIT Computation
Center.<a name="call_footnote_Temp_7" href="#footnote_Temp_7" id="call_footnote_Temp_7"><sup><small>1</small></sup></a> <a name="%_idx_38" id="%_idx_38"></a>Lisp, whose name is an acronym for LISt Processing,
was designed to provide symbol-manipulating capabilities for
attacking programming problems such as the symbolic differentiation
and integration of algebraic expressions.  It included for this
purpose new data objects known as atoms and lists, which most
strikingly set it apart from all other languages of the period.</p>

<p>Lisp was not the product of a concerted design effort.  Instead, it
evolved informally in an experimental manner in response to users'
needs and to pragmatic implementation considerations.  Lisp's informal
evolution has continued through the years, and the community of Lisp
users has traditionally resisted attempts to promulgate any
“official” definition of the language.  This evolution, together
with the flexibility and elegance of the initial conception, has
enabled Lisp, which is the second oldest language in widespread use
today (only <a name="%_idx_40" id="%_idx_40"></a>Fortran is older), to continually adapt to encompass the
most modern ideas about program design.  Thus, Lisp is by now a family
of dialects, which, while sharing most of the original features, may
differ from one another in significant ways.  The dialect of Lisp used
in this book is called <a name="%_idx_42" id="%_idx_42"></a><a name="%_idx_44" id="%_idx_44"></a>Scheme.<a name="call_footnote_Temp_8" href="#footnote_Temp_8" id="call_footnote_Temp_8"><sup><small>2</small></sup></a></p>

<p>Because of its experimental character and its emphasis on symbol
manipulation, <a name="%_idx_96" id="%_idx_96"></a><a name="%_idx_98" id="%_idx_98"></a><a name="%_idx_100" id="%_idx_100"></a>Lisp was at first very inefficient for numerical
computations, at least in comparison with Fortran.  Over the years,
however, Lisp compilers have been developed that translate programs
into machine code that can perform numerical computations reasonably
efficiently.  And for special applications, Lisp has been used with
great effectiveness.<a name="call_footnote_Temp_9" href="#footnote_Temp_9" id="call_footnote_Temp_9"><sup><small>3</small></sup></a>  Although Lisp has not yet overcome its old reputation
as hopelessly inefficient, Lisp is now used in many applications where
efficiency is not the central concern.  For example, Lisp has become
a language of choice for operating-system shell languages and for
extension languages for editors and computer-aided design systems.</p>

<p>If Lisp is not a mainstream language, why are we using it as the
framework for our discussion of programming?  Because the language
possesses <a name="%_idx_112" id="%_idx_112"></a>unique features that make it an excellent medium for
studying important programming constructs and data structures and for
relating them to the linguistic features that support them.  The most
significant of these features is the fact that Lisp descriptions of
processes, called <a name="%_idx_114" id="%_idx_114"></a><a name="%_idx_116" id="%_idx_116"></a><em>procedures</em>, can
themselves be represented and manipulated as Lisp data.  The
importance of this is that there are powerful program-design
techniques that rely on the ability to blur the traditional
distinction between “passive” data and “active” processes.  As we
shall discover, Lisp's flexibility in handling procedures as data
makes it one of the most convenient languages in existence for
exploring these techniques.  The ability to represent procedures as
data also makes Lisp an excellent language for writing programs that
must manipulate other programs as data, such as the interpreters and
compilers that support computer languages.  Above and beyond these
considerations, programming in Lisp is great fun.</p>

<div class="smallprint"><hr /></div>
<div class="footnote">
<p><a name="footnote_Temp_7" href="#call_footnote_Temp_7" id="footnote_Temp_7"><sup><small>1</small></sup></a> The <em>Lisp 1 Programmer's Manual</em> appeared in
1960, and the <em>Lisp 1.5 Programmer's Manual</em> <a name="%_idx_36" id="%_idx_36"></a>(McCarthy 1965)
was published in 1962.  The early history of Lisp is described in
McCarthy 1978.</p>

<p><a name="footnote_Temp_8" href="#call_footnote_Temp_8" id="footnote_Temp_8"><sup><small>2</small></sup></a> The two dialects in which most
major Lisp programs of the 1970s were written are <a name="%_idx_46" id="%_idx_46"></a><a name="%_idx_48" id="%_idx_48"></a>MacLisp <a name="%_idx_50" id="%_idx_50"></a>(Moon 1978;
<a name="%_idx_52" id="%_idx_52"></a>Pitman 1983), developed at the <a name="%_idx_54" id="%_idx_54"></a>MIT Project MAC, and <a name="%_idx_56" id="%_idx_56"></a><a name="%_idx_58" id="%_idx_58"></a>Interlisp
<a name="%_idx_60" id="%_idx_60"></a>(Teitelman 1974), developed at <a name="%_idx_62" id="%_idx_62"></a>Bolt Beranek and Newman Inc. and the
<a name="%_idx_64" id="%_idx_64"></a>Xerox Palo Alto Research Center.  <a name="%_idx_66" id="%_idx_66"></a><a name="%_idx_68" id="%_idx_68"></a>Portable Standard Lisp <a name="%_idx_70" id="%_idx_70"></a>(Hearn 1969;
<a name="%_idx_72" id="%_idx_72"></a>Griss 1981) was a Lisp dialect designed to be easily portable
between different machines.  MacLisp spawned a number of subdialects,
such as <a name="%_idx_74" id="%_idx_74"></a><a name="%_idx_76" id="%_idx_76"></a>Franz Lisp, which was developed at the <a name="%_idx_78" id="%_idx_78"></a>University of
California at Berkeley, and <a name="%_idx_80" id="%_idx_80"></a><a name="%_idx_82" id="%_idx_82"></a>Zetalisp (Moon 1981), which was based on a
special-purpose processor designed at the <a name="%_idx_84" id="%_idx_84"></a>MIT Artificial Intelligence
Laboratory to run Lisp very efficiently.  The Lisp dialect used in
this book, called <a name="%_idx_86" id="%_idx_86"></a>Scheme (Steele 1975), was invented in 1975 by <a name="%_idx_88" id="%_idx_88"></a><a name="%_idx_90" id="%_idx_90"></a>Guy
Lewis Steele Jr. and Gerald Jay Sussman of the MIT Artificial
Intelligence Laboratory and later reimplemented for instructional use
at MIT.  Scheme became an IEEE standard in 1990 (IEEE 1990).  The
<a name="%_idx_92" id="%_idx_92"></a><a name="%_idx_94" id="%_idx_94"></a>Common Lisp dialect (Steele 1982, Steele 1990) was developed by the
Lisp community to combine features from the earlier Lisp dialects
to make an industrial standard for Lisp.  Common Lisp became an ANSI
standard in 1994 (ANSI 1994).</p>

<p><a name="footnote_Temp_9" href="#call_footnote_Temp_9" id="footnote_Temp_9"><sup><small>3</small></sup></a> One such special application was a
breakthrough computation of scientific importance – an integration of
the motion of the <a name="%_idx_102" id="%_idx_102"></a><a name="%_idx_104" id="%_idx_104"></a>Solar System that extended previous results by
nearly two orders of magnitude, and demonstrated that the dynamics of
the Solar System is chaotic.  This computation was made possible by
new integration algorithms, a special-purpose compiler, and a
special-purpose computer all implemented with the aid of software
tools written in Lisp <a name="%_idx_106" id="%_idx_106"></a>(Abelson et al. 1992; <a name="%_idx_108" id="%_idx_108"></a><a name="%_idx_110" id="%_idx_110"></a>Sussman and
Wisdom 1992).</p>
</div>
</body>
</html>

