<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<?xml version="1.0" encoding="utf-8"?><html xmlns="http://www.w3.org/1999/xhtml" xmlns:ops="http://www.idpf.org/2007/ops">
<!-- Generated from TeX source by tex2page, v 4o,
     (c) Dorai Sitaram, http://www.cs.rice.edu/~dorai/tex2page --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Type: text/html; charset=utf-8">
<title>Structure and Interpretation of Computer Programs</title>
<link rel="stylesheet" type="text/css" href="book-Z-C.css" title="default">
</head>
<body><a name="%_sec_3.4" id="%_sec_3.4"></a><h2><a href="book-Z-H-4.html#%_toc_%_sec_3.4">3.4  Concurrency: Time Is of the Essence</a></h2>
<p><a name="%_idx_3578" id="%_idx_3578"></a>We've seen the power of computational objects with local state astools for modeling.  Yet, as section <a href="book-Z-H-20.html#%_sec_3.1.3">3.1.3</a>warned, this power extracts a price: the loss of referentialtransparency, giving rise to a thicket of questions about sameness andchange, and the need to abandon the substitution model of evaluation infavor of the more intricate environment model.</p>
<p><a name="%_idx_3580" id="%_idx_3580"></a>The central issue lurking beneath the complexity of state, sameness,and change is that by introducing assignment we are forced to admit<em>time</em> into our computational models.  Before we introducedassignment, all our programs were timeless, in the sense that anyexpression that has a value always has the same value.  In contrast,recall the example of modeling withdrawals from a bank accountand returning the resulting balance,introduced at the beginning ofsection <a href="book-Z-H-20.html#%_sec_3.1.1">3.1.1</a>:</p>
<p></p>
<p></p>
<p><pre>(withdraw 25)
<i>75</i>
(withdraw 25)
<i>50</i>
</pre></p>
<p></p>
<p>Here successive evaluations of the same expression yield differentvalues.  This behavior arises from the fact that the execution ofassignment statements (in this case, assignments to the variable <code>balance</code>) delineates <em>moments in time</em> when values change.  Theresult of evaluating an expression depends not only on the expressionitself, but also on whether the evaluation occurs before or afterthese moments.  Building models in terms of computational objects withlocal state forces us to confront time as an essential concept inprogramming.</p>
<p>We can go further in structuring computational models to match ourperception of the physical world.  Objects in the world do not changeone at a time in sequence.  Rather we perceive them as acting <em>concurrently</em> – all at once.  So it is often natural to model systemsas collections of computational processes that execute concurrently.Just as we can make our programs modular by organizing models interms of objects with separate local state, it is often appropriate todivide computational models into parts that evolve separately andconcurrently.  Even if the programs are to be executed on a sequentialcomputer, the practice of writing programs as if they were to beexecuted concurrently forces the programmer to avoid inessentialtiming constraints and thus makes programs more modular.</p>
<p>In addition to making programs more modular, concurrent computationcan provide a speed advantage over sequential computation.  Sequentialcomputers execute only one operation at a time, so the amount of timeit takes to perform a task is proportional to the total number ofoperations performed.<a name="call_footnote_Temp_405" href="#footnote_Temp_405" id="call_footnote_Temp_405"><sup><small>34</small></sup></a>However, if it is possible to decompose a problem into pieces that arerelatively independent and need to communicate only rarely, it may bepossible to allocate pieces to separate computing processors,producing a speed advantage proportional to the number of processorsavailable.</p>
<p>Unfortunately, the complexities introduced by assignment become evenmore problematic in the presence of concurrency.  The fact ofconcurrent execution, either because the world operates in parallel orbecause our computers do, entails additional complexity in ourunderstanding of time.</p>
<p><a name="%_sec_3.4.1" id="%_sec_3.4.1"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_3.4.1">3.4.1  The Nature of Time in Concurrent Systems</a></h3>
<p><a name="%_idx_3584" id="%_idx_3584"></a>On the surface, time seems straightforward.  Itis an ordering imposed on events.<a name="call_footnote_Temp_406" href="#footnote_Temp_406" id="call_footnote_Temp_406"><sup><small>35</small></sup></a>For any events <em>A</em> and <em>B</em>, either <em>A</em> occurs before <em>B</em>, <em>A</em> and <em>B</em>are simultaneous, or <em>A</em> occurs after <em>B</em>.  For instance,returning to the bank account example, suppose that Peter withdraws$10 and Paul withdraws $25 from a <a name="%_idx_3588" id="%_idx_3588"></a>joint account that initiallycontains $100, leaving $65 in the account.  Depending on the orderof the two withdrawals, the sequence of balances in the account iseither $100 ⟶ $90 ⟶ $65 or$100 ⟶ $75 ⟶ $65.  In a computer implementationof the banking system, this changing sequence of balances could bemodeled by successive assignments to a variable <code>balance</code>.</p>
<p>In complex situations, however, such a view can be problematic.Suppose that Peter and Paul, and other people besides, areaccessing the same bank account through a network of banking machinesdistributed all over the world.  The actual sequence of balances inthe account will depend critically on the detailed timing of theaccesses and the details of the communication among the machines.</p>
<p><a name="%_idx_3590" id="%_idx_3590"></a>This indeterminacy in the order of events can pose serious problems inthe design of concurrent systems.  For instance, suppose that thewithdrawals made by Peter and Paul are implemented as two separateprocesses sharing a common variable <code>balance</code>, each processspecified by the procedure given insection <a href="book-Z-H-20.html#%_sec_3.1.1">3.1.1</a>:</p>
<p></p>
<p><pre><a name="%_idx_3592" id="%_idx_3592"></a>(define (withdraw amount)
  (if (&gt;= balance amount)
      (begin (set! balance (- balance amount))
             balance)
      "Insufficient funds"))
</pre></p>
<p></p>
<p>If the two processes operate independently, then Peter might test thebalance and attempt to withdraw a legitimate amount.  However, Paulmight withdraw some funds in between the time that Peter checks thebalance and the time Peter completes the withdrawal, thus invalidatingPeter's test.</p>
<p>Things can be worse still.  Consider the expression</p>
<p></p>
<p><pre>(set! balance (- balance amount))
</pre></p>
<p></p>
<p>executed as part of each withdrawal process.  This consists of threesteps: (1) accessing the value of the <code>balance</code> variable; (2)computing the new balance; (3) setting <code>balance</code> to this newvalue.  If Peter and Paul's withdrawals execute this statementconcurrently, then the two withdrawals might interleave the order inwhich they access <code>balance</code> and set it to the new value.</p>
<p>The timing diagram in figure <a href="#%_fig_3.29">3.29</a> depicts an order ofevents where <code>balance</code> starts at 100, Peter withdraws 10,Paul withdraws 25, and yet the final value of <code>balance</code> is 75.  Asshown in the diagram, the reason for this anomaly is that Paul'sassignment of 75 to <code>balance</code> is made under the assumption thatthe value of <code>balance</code> to be decremented is 100.  That assumption,however, became invalid when Peter changed <code>balance</code> to 90.  Thisis a catastrophic failure for the banking system, because the totalamount of money in the system is not conserved.  Before the transactions,the total amount of money was $100.  Afterwards, Peter has $10, Paulhas $25, and the bank has $75.<a name="call_footnote_Temp_407" href="#footnote_Temp_407" id="call_footnote_Temp_407"><sup><small>36</small></sup></a></p>
<p><a name="%_idx_3596" id="%_idx_3596"></a><a name="%_idx_3598" id="%_idx_3598"></a>The general phenomenon illustratedhere is that several processes may share  acommon state variable.  What makes this complicated is that more thanone process may be trying to manipulate the shared state at the sametime.  For the bank account example, during each transaction, eachcustomer should be able to act as if the other customers did notexist.  When a customer changes the balance in a way that depends onthe balance, he must be able to assume that, just before the moment ofchange, the balance is still what he thought it was.</p>
<p><a name="%_sec_Temp_408" id="%_sec_Temp_408"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_408">Correct behavior of concurrent programs</a></h4>
<p><a name="%_idx_3600" id="%_idx_3600"></a>The above example typifies the subtle bugs that can creep intoconcurrent programs.  The root of this complexity lies in theassignments to variables that are shared among the differentprocesses.  We already know that we must be careful in writingprograms that use <code>set!</code>, because the results of a computationdepend on the order in which the assignments occur.<a name="call_footnote_Temp_409" href="#footnote_Temp_409" id="call_footnote_Temp_409"><sup><small>37</small></sup></a>With concurrent processes we must be especially careful aboutassignments, because we may not be able to control the order of theassignments made by the different processes.  If several such changesmight be made concurrently (as with two depositors accessing a jointaccount) we need some way to ensure that our system behaves correctly.For example, in the case of withdrawals from a joint bank account, wemust ensure that money is conserved.To make concurrent programs behave correctly, we may have toplace some restrictions on concurrent execution.</p>
<p><a name="%_fig_3.29" id="%_fig_3.29"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch3-Z-G-31.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 3.29:</b>  Timing diagram showing how interleaving the order of eventsin two banking withdrawals can lead to an incorrect final balance.</div></caption>
<tr><td><a name="%_idx_3602" id="%_idx_3602"></a></td></tr>
</table></div>
<p>One possible restriction on concurrency wouldstipulate that no two operations thatchange any shared state variables can occur at the same time.  This is anextremely stringent requirement.  For distributed banking, it wouldrequire the system designer to ensure that only one transaction couldproceed at a time.  This would be both inefficient and overlyconservative.  Figure <a href="#%_fig_3.30">3.30</a> shows Peter andPaul sharing a bank account, where Paul has a private account as well.The diagram illustrates two withdrawals from the shared account(one by Peter and one by Paul) and a deposit to Paul's private account.<a name="call_footnote_Temp_410" href="#footnote_Temp_410" id="call_footnote_Temp_410"><sup><small>38</small></sup></a>The two withdrawals from the shared account must not beconcurrent (since both access and update the same account), and Paul'sdeposit and withdrawal must not be concurrent (since both access andupdate the amount in Paul's wallet).But there should be no problempermitting Paul's deposit to his private account to proceedconcurrently with Peter's withdrawal from the shared account.</p>
<p><a name="%_fig_3.30" id="%_fig_3.30"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch3-Z-G-32.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 3.30:</b>  Concurrent deposits and withdrawals from a joint accountin Bank1 and a private account in Bank2.</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p>A less stringent restriction on concurrency would ensure that aconcurrent system produces the same resultas if the processes had run sequentially in some order.There are two important aspects to this requirement.First, it does not require the processes to actually run sequentially,but only to produce results that are the same <em>as if</em> they had runsequentially.  For the example infigure <a href="#%_fig_3.30">3.30</a>, the designer of the bank accountsystem can safely allow Paul's deposit and Peter's withdrawal tohappen concurrently, because the net result will be the same as if thetwo operations had happened sequentially.  Second, there may be morethan one possible “correct” result produced by a concurrent program,because we require only that the result be the same as for <em>some</em>sequential order.For example, suppose that Peter and Paul's joint account starts outwith $100, and Peter deposits $40 while Paul concurrently withdrawshalf the money in the account.Then sequential execution could result in the account balance beingeither $70 or $90 (see exercise <a href="#%_thm_3.38">3.38</a>).<a name="call_footnote_Temp_411" href="#footnote_Temp_411" id="call_footnote_Temp_411"><sup><small>39</small></sup></a></p>
<p>There are still weaker requirements for correct execution ofconcurrent programs.  A program for simulating <a name="%_idx_3606" id="%_idx_3606"></a>diffusion (say, theflow of heat in an object) might consist of a large number ofprocesses, each one representing a small volume of space, that updatetheir values concurrently.  Each process repeatedly changes itsvalue to the average of its own value and its neighbors' values.This algorithmconverges to the right answer independent of the order in which theoperations are done; there is no need for any restrictions onconcurrent use of the shared values.</p>
<p></p>
<p><a name="%_thm_3.38" id="%_thm_3.38"></a><b>Exercise 3.38.</b>  Suppose that Peter, Paul, and Mary share a joint bank account thatinitially contains $100.  Concurrently, Peter deposits $10, Paulwithdraws $20, and Mary withdraws half the money in the account, byexecuting the following commands:</p>
<table border="0">
<tr>
<td valign="top">Peter: </td>
<td valign="top"><code>(set! balance (+ balance 10))</code></td>
</tr>
<tr>
<td valign="top">Paul: </td>
<td valign="top"><code>(set! balance (- balance 20))</code></td>
</tr>
<tr>
<td valign="top">Mary: </td>
<td valign="top">
<code>(set! balance (- balance (/ balance 2)))</code></td>
</tr>
</table>
<p></p>
<p></p>
<p>a. List all the different possible values for <code>balance</code> after thesethree transactions have been completed, assuming that the bankingsystem forces the three processes to run sequentially in some order.</p>
<p></p>
<p></p>
<p>b. What are some other valuesthat could be produced if the system allows the processes to be interleaved?Draw timing diagrams like the one in figure <a href="#%_fig_3.29">3.29</a> toexplain how these values can occur.</p>
<p><a name="%_sec_3.4.2" id="%_sec_3.4.2"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_3.4.2">3.4.2  Mechanisms for Controlling Concurrency</a></h3>
<p><a name="%_idx_3608" id="%_idx_3608"></a>We've seen that the difficulty in dealing with concurrent processes isrooted in the need to consider the interleaving of the order of eventsin the different processes.  For example, suppose we have twoprocesses, one with three ordered events (<em>a</em>,<em>b</em>,<em>c</em>) and one with threeordered events (<em>x</em>,<em>y</em>,<em>z</em>).  If the two processes run concurrently, withno constraints on how their execution is interleaved, then there are20 different possible orderings for the events that are consistentwith the individual orderings for the two processes:</p><p>    (<em>a</em>, <em>b</em>, <em>c</em>, <em>x</em>, <em>y</em>, <em>z</em>) (<em>a</em>, <em>x</em>, <em>b</em>, <em>y</em>, <em>c</em>, <em>z</em>) (<em>x</em>, <em>a</em>, <em>b</em>, <em>c</em>, <em>y</em>, <em>z</em>) (<em>x</em>, <em>a</em>, <em>y</em>, <em>z</em>, <em>b</em>, <em>c</em>)
    (<em>a</em>, <em>b</em>, <em>x</em>, <em>c</em>, <em>y</em>, <em>z</em>) (<em>a</em>, <em>x</em>, <em>b</em>, <em>y</em>, <em>z</em>, <em>c</em>) (<em>x</em>, <em>a</em>, <em>b</em>, <em>y</em>, <em>c</em>, <em>z</em>) (<em>x</em>, <em>y</em>, <em>a</em>, <em>b</em>, <em>c</em>, <em>z</em>)
    (<em>a</em>, <em>b</em>, <em>x</em>, <em>y</em>, <em>c</em>, <em>z</em>) (<em>a</em>, <em>x</em>, <em>y</em>, <em>b</em>, <em>c</em>, <em>z</em>) (<em>x</em>, <em>a</em>, <em>b</em>, <em>y</em>, <em>z</em>, <em>c</em>) (<em>x</em>, <em>y</em>, <em>a</em>, <em>b</em>, <em>z</em>, <em>c</em>)
    (<em>a</em>, <em>b</em>, <em>x</em>, <em>y</em>, <em>z</em>, <em>c</em>) (<em>a</em>, <em>x</em>, <em>y</em>, <em>b</em>, <em>c</em>, <em>z</em>) (<em>x</em>, <em>a</em>, <em>y</em>, <em>b</em>, <em>c</em>, <em>z</em>) (<em>x</em>, <em>y</em>, <em>a</em>, <em>z</em>, <em>b</em>, <em>c</em>)
    (<em>a</em>, <em>x</em>, <em>b</em>, <em>c</em>, <em>y</em>, <em>z</em>) (<em>a</em>, <em>x</em>, <em>y</em>, <em>z</em>, <em>b</em>, <em>c</em>) (<em>x</em>, <em>a</em>, <em>y</em>, <em>b</em>, <em>z</em>, <em>c</em>) (<em>x</em>, <em>y</em>, <em>z</em>, <em>a</em>, <em>b</em>, <em>c</em>)</p><p>As programmers designing this system, we would have to consider theeffects of each of these 20 orderings and check that each behavior isacceptable.  Such an approach rapidly becomes unwieldy as the numbersof processes and events increase.</p>
<p>A more practical approach to the design of concurrent systems is todevise general mechanisms that allow us to constrain the interleavingof concurrent processes so that we can be sure that the programbehavior is correct.  Many mechanisms have been developed for thispurpose.  In this section, we describe one of them, the <em>serializer</em>.</p>
<p><a name="%_sec_Temp_413" id="%_sec_Temp_413"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_413">Serializing access to shared state</a></h4>
<p><a name="%_idx_3610" id="%_idx_3610"></a>Serialization implements the following idea: Processes will executeconcurrently, but there will be certain collections of procedures thatcannot be executed concurrently.  More precisely, serialization createsdistinguished sets of procedures such that only one execution of aprocedure in each serialized set is permitted to happen at a time.If some procedure in the set is being executed, then a process thatattempts to execute any procedure in the set will be forced to waituntil the first execution has finished.</p>
<p>We can use serialization to control access to shared variables.For example, if we want to update a shared variable based on theprevious value of that variable, we put the access to the previousvalue of the variable and the assignment of the new value to thevariable in the same procedure.  We then ensure that no otherprocedure that assigns to the variable can run concurrently with thisprocedure by serializing all of these procedures with the sameserializer.  This guarantees that the value of the variable cannot bechanged between an access and the corresponding assignment.</p>
<p><a name="%_sec_Temp_414" id="%_sec_Temp_414"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_414">Serializers in Scheme</a></h4>
<p>To make the above mechanism more concrete, suppose that we haveextended Scheme to include a procedure called <a name="%_idx_3612" id="%_idx_3612"></a><code>parallel-execute</code>:</p>
<p></p>
<p></p>
<p><pre>(parallel-execute &lt;<em>p<sub>1</sub></em>&gt; &lt;<em>p<sub>2</sub></em>&gt; <code>...</code> &lt;<em>p<sub><em>k</em></sub></em>&gt;)
</pre></p>
<p></p>
<p>Each &lt;<em>p</em>&gt; must be a procedure of no arguments.  <code>Parallel-execute</code>creates a separate process for each&lt;<em>p</em>&gt;, which applies &lt;<em>p</em>&gt; (to no arguments).  These processes allrun concurrently.<a name="call_footnote_Temp_415" href="#footnote_Temp_415" id="call_footnote_Temp_415"><sup><small>40</small></sup></a></p>
<p>As an example of how this is used, consider</p>
<p></p>
<p></p>
<p><pre>(define x 10)

(parallel-execute (lambda () (set! x (* x x)))
                  (lambda () (set! x (+ x 1))))
</pre></p>
<p></p>
<p>This creates two concurrent processes – <em>P</em><sub>1</sub>, which sets <code>x</code> to<code>x</code> times <code>x</code>, and <em>P</em><sub>2</sub>, which increments <code>x</code>.  Afterexecution is complete, <code>x</code> will be left with one of five possiblevalues, depending on the interleaving of the events of <em>P</em><sub>1</sub> and<em>P</em><sub>2</sub>:</p>
<table border="0">
<tr>
<td valign="top">101: </td>
<td valign="top">
<em>P</em><sub>1</sub> sets <code>x</code> to 100 and then <em>P</em><sub>2</sub> increments <code>x</code> to 101.</td>
</tr>
<tr>
<td valign="top">121: </td>
<td valign="top">
<em>P</em><sub>2</sub> increments <code>x</code> to 11 and then <em>P</em><sub>1</sub> sets <code>x</code> to<code>x</code> times <code>x</code>.</td>
</tr>
<tr>
<td valign="top">110: </td>
<td valign="top">
<em>P</em><sub>2</sub> changes <code>x</code> from 10 to 11 between the two times that<em>P</em><sub>1</sub> accesses the value of <code>x</code> during the evaluation of <code>(* x x)</code>.</td>
</tr>
<tr>
<td valign="top">11:  </td>
<td valign="top">
<em>P</em><sub>2</sub> accesses <code>x</code>, then <em>P</em><sub>1</sub> sets <code>x</code> to 100,then <em>P</em><sub>2</sub> sets <code>x</code>.</td>
</tr>
<tr>
<td valign="top">100: </td>
<td valign="top">
<em>P</em><sub>1</sub> accesses <code>x</code> (twice), then <em>P</em><sub>2</sub> sets <code>x</code> to 11,then <em>P</em><sub>1</sub> sets <code>x</code>.</td>
</tr>
<tr><td valign="top"></td></tr>
</table>
<p>We can constrain the concurrency by using serialized procedures,which are created by <em>serializers</em>. Serializers are constructed by <code>make-serializer</code>, whose implementation is given below.  A serializertakes a procedure as argument and returns a serialized procedure thatbehaves like the original procedure.  All calls to a given serializerreturn serialized procedures in the same set.</p>
<p>Thus, in contrast to the example above, executing</p>
<p></p>
<p></p>
<p><pre>(define x 10)

(define s (make-serializer))

(parallel-execute (s (lambda () (set! x (* x x))))
                  (s (lambda () (set! x (+ x 1)))))
</pre></p>
<p></p>
<p>can produce only two possible values for <code>x</code>, 101 or 121.  Theother possibilities are eliminated, because the execution of <em>P</em><sub>1</sub> and<em>P</em><sub>2</sub> cannot be interleaved.</p>
<p>Here is a version of the <code>make-account</code> procedure fromsection <a href="book-Z-H-20.html#%_sec_3.1.1">3.1.1</a>, where the deposits andwithdrawals have been serialized:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3614" id="%_idx_3614"></a><a name="%_idx_3616" id="%_idx_3616"></a>(define (make-account balance)
  (define (withdraw amount)
    (if (&gt;= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (let ((protected (make-serializer)))
    (define (dispatch m)
      (cond ((eq? m 'withdraw) (protected withdraw))
            ((eq? m 'deposit) (protected deposit))
            ((eq? m 'balance) balance)
            (else (error "Unknown request -- MAKE-ACCOUNT"
                         m))))
    dispatch))
</pre></p>
<p></p>
<p>With this implementation, two processes cannot be withdrawing from ordepositing into a single account concurrently.  This eliminates the sourceof the error illustrated in figure <a href="#%_fig_3.29">3.29</a>, where Peterchanges the account balance between the times when Paul accesses thebalance to compute the new value and when Paul actually performs theassignment.  On the other hand, each account has its own serializer,so that deposits and withdrawals for different accounts can proceedconcurrently.</p>
<p></p>
<p><a name="%_thm_3.39" id="%_thm_3.39"></a><b>Exercise 3.39.</b>  Which of the five possibilities in the parallel execution shown aboveremain if we instead serialize execution as follows:</p>
<p></p>
<p></p>
<p><pre>(define x 10)

(define s (make-serializer))

(parallel-execute (lambda () (set! x ((s (lambda () (* x x))))))
                  (s (lambda () (set! x (+ x 1)))))
</pre></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_3.40" id="%_thm_3.40"></a><b>Exercise 3.40.</b>  Give all possible values of <code>x</code> that can result from executing</p>
<p></p>
<p></p>
<p><pre>(define x 10)

(parallel-execute (lambda () (set! x (* x x)))
                  (lambda () (set! x (* x x x))))
</pre></p>
<p></p>
<p>Which of these possibilities remain if we instead use serializedprocedures:</p>
<p></p>
<p></p>
<p><pre>(define x 10)

(define s (make-serializer))

(parallel-execute (s (lambda () (set! x (* x x))))
                  (s (lambda () (set! x (* x x x)))))
</pre></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_3.41" id="%_thm_3.41"></a><b>Exercise 3.41.</b>  Ben Bitdiddle worries that it would be better to implement the bankaccount as follows (where the commented line has been changed):</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3618" id="%_idx_3618"></a>(define (make-account balance)
  (define (withdraw amount)
    (if (&gt;= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  <em>;; continued on next page</em>

  (let ((protected (make-serializer)))
    (define (dispatch m)
      (cond ((eq? m 'withdraw) (protected withdraw))
            ((eq? m 'deposit) (protected deposit))
            ((eq? m 'balance)
             ((protected (lambda () balance)))) <em>; serialized</em>
            (else (error "Unknown request -- MAKE-ACCOUNT"
                         m))))
    dispatch))
</pre></p>
<p></p>
<p>because allowing unserialized access to the bank balance can result inanomalous behavior.  Do you agree?  Is there any scenario thatdemonstrates Ben's concern?</p>
<p></p>
<p></p>
<p><a name="%_thm_3.42" id="%_thm_3.42"></a><b>Exercise 3.42.</b>  Ben Bitdiddle suggests that it's a waste of time to create a newserialized procedure in response to every <code>withdraw</code> and <code>deposit</code> message.  He says that <code>make-account</code> could be changed sothat the calls to <code>protected</code> are done outside the <code>dispatch</code>procedure.  That is, an account would return the same serializedprocedure (which was created at the same time as the account) each timeit is asked for a withdrawal procedure.</p>
<p></p>
<p><pre><a name="%_idx_3620" id="%_idx_3620"></a>(define (make-account balance)
  (define (withdraw amount)
    (if (&gt;= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (let ((protected (make-serializer)))
    (let ((protected-withdraw (protected withdraw))
          (protected-deposit (protected deposit)))
      (define (dispatch m)
        (cond ((eq? m 'withdraw) protected-withdraw)
              ((eq? m 'deposit) protected-deposit)
              ((eq? m 'balance) balance)
              (else (error "Unknown request -- MAKE-ACCOUNT"
                           m))))
      dispatch)))
</pre></p>
<p></p>
<p>Is this a safe change to make?  In particular, is there any difference inwhat concurrency is allowed by these two versions of <code>make-account</code> ?</p>
<p><a name="%_sec_Temp_420" id="%_sec_Temp_420"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_420">Complexity of using multiple shared resources</a></h4>
<p><a name="%_idx_3622" id="%_idx_3622"></a><a name="%_idx_3624" id="%_idx_3624"></a>Serializers provide a powerful abstraction that helps isolate thecomplexities of concurrent programs so that they can be dealt withcarefully and (hopefully) correctly.  However, while using serializersis relatively straightforward when there is only a single sharedresource (such as a single bank account), concurrent programming canbe treacherously difficult when there are multiple shared resources.</p>
<p>To illustrate one of the difficulties that can arise, suppose we wish to swapthe balances in two bank accounts.  We access each account to find thebalance, compute the difference between the balances, withdraw thisdifference from one account, and deposit it in the other account.  Wecould implement this as follows:<a name="call_footnote_Temp_421" href="#footnote_Temp_421" id="call_footnote_Temp_421"><sup><small>41</small></sup></a></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3626" id="%_idx_3626"></a><a name="%_idx_3628" id="%_idx_3628"></a>(define (exchange account1 account2)
  (let ((difference (- (account1 'balance)
                       (account2 'balance))))
    ((account1 'withdraw) difference)
    ((account2 'deposit) difference)))
</pre></p>
<p></p>
<p></p>
<p>This procedure works well when only a single process is trying to dothe exchange.  Suppose, however, that Peter and Paul both have accessto accounts <em>a</em>1, <em>a</em>2, and <em>a</em>3, and thatPeter exchanges <em>a</em>1 and<em>a</em>2 while Paul concurrently exchanges <em>a</em>1 and <em>a</em>3.Even with account deposits and withdrawalsserialized for individual accounts (as in the <code>make-account</code>procedure shown above in this section), <code>exchange</code> can stillproduce incorrect results.  For example, Peter might compute thedifference in the balances for <em>a</em>1 and <em>a</em>2, but then Paulmight change the balance in <em>a</em>1 before Peter is able to completethe exchange.<a name="call_footnote_Temp_422" href="#footnote_Temp_422" id="call_footnote_Temp_422"><sup><small>42</small></sup></a>For correct behavior, we must arrange for the <code>exchange</code> procedureto lock out any other concurrent accesses to the accounts during theentire time of the exchange.</p>
<p>One way we can accomplish this is by using both accounts' serializersto serialize the entire <code>exchange</code> procedure.To do this, we will arrange for access to an account's serializer.Note that we are deliberatelybreaking the modularity of the bank-account object by exposing theserializer.  The following version of <code>make-account</code> is identicalto the original version given insection <a href="book-Z-H-20.html#%_sec_3.1.1">3.1.1</a>, except that a serializer isprovided to protect the balance variable, and the serializer isexported via message passing:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3630" id="%_idx_3630"></a>(define (make-account-and-serializer balance)
  (define (withdraw amount)
    (if (&gt;= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (let ((balance-serializer (make-serializer)))
    (define (dispatch m)
      (cond ((eq? m 'withdraw) withdraw)
            ((eq? m 'deposit) deposit)
            ((eq? m 'balance) balance)
            ((eq? m 'serializer) balance-serializer)
            (else (error "Unknown request -- MAKE-ACCOUNT"
                         m))))
    dispatch))
</pre></p>
<p></p>
<p></p>
<p>We can use this to do serialized deposits and withdrawals.  However,unlike our earlier serialized account, it is now the responsibility ofeach user of bank-account objects to explicitly manage theserialization, for example as follows:<a name="call_footnote_Temp_423" href="#footnote_Temp_423" id="call_footnote_Temp_423"><sup><small>43</small></sup></a></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3632" id="%_idx_3632"></a>(define (deposit account amount)
  (let ((s (account 'serializer))
        (d (account 'deposit)))
    ((s d) amount)))
</pre></p>
<p></p>
<p></p>
<p>Exporting the serializer in this way gives us enough flexibility toimplement a serialized exchange program.  We simplyserialize the original<code>exchange</code> procedure with the serializers for both accounts:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3634" id="%_idx_3634"></a>(define (serialized-exchange account1 account2)
  (let ((serializer1 (account1 'serializer))
        (serializer2 (account2 'serializer)))
    ((serializer1 (serializer2 exchange))
     account1
     account2)))
</pre></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_3.43" id="%_thm_3.43"></a><b>Exercise 3.43.</b>  Suppose that the balances in three accounts start out as $10, $20,and $30, and that multiple processes run, exchanging the balances inthe accounts.  Argue that if the processes are run sequentially,after any number of concurrent exchanges, the account balances should be$10, $20, and $30 in some order.Draw a timing diagram like the one in figure <a href="#%_fig_3.29">3.29</a> toshow how this condition can be violated if the exchanges areimplemented using the first version of the account-exchange program inthis section.  On the other hand, argue that even with this <code>exchange</code> program, the sum of the balances in the accounts will bepreserved.  Draw a timing diagram to show how even this condition wouldbe violated if we did not serialize the transactionson individual accounts.</p>
<p></p>
<p></p>
<p><a name="%_thm_3.44" id="%_thm_3.44"></a><b>Exercise 3.44.</b>  <a name="%_idx_3636" id="%_idx_3636"></a>Consider the problem of transferring an amount from one account toanother.  Ben Bitdiddle claims that this can be accomplished with thefollowing procedure, even if there are multiple people concurrentlytransferring money among multiple accounts, using any accountmechanism that serializes deposit and withdrawal transactions, forexample, the version of <code>make-account</code> in the text above.</p>
<p></p>
<p></p>
<p><pre>(define (transfer from-account to-account amount)
  ((from-account 'withdraw) amount)
  ((to-account 'deposit) amount))
</pre></p>
<p></p>
<p>Louis Reasoner claims that there is a problem here, and that we needto use a more sophisticated method, such as the one required fordealing with the exchange problem.  Is Louis right?  If not, what isthe essential difference between the transfer problem and the exchangeproblem?  (You should assume that the balance in <code>from-account</code>is at least <code>amount</code>.)</p>
<p></p>
<p></p>
<p><a name="%_thm_3.45" id="%_thm_3.45"></a><b>Exercise 3.45.</b>  Louis Reasoner thinks our bank-account system is unnecessarily complex anderror-prone now that deposits and withdrawals aren't automatically serialized.He suggests that <code>make-account-and-serializer</code> should haveexported the serializer (for use by such procedures as<code>serialized-exchange</code>) in addition to (rather than instead of)using it to serialize accounts and deposits as <code>make-account</code> did.He proposes to redefine accounts as follows:</p>
<p></p>
<p></p>
<p><pre>(define (make-account-and-serializer balance)
  (define (withdraw amount)
    (if (&gt;= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (let ((balance-serializer (make-serializer)))
    (define (dispatch m)
      (cond ((eq? m 'withdraw) (balance-serializer withdraw))
            ((eq? m 'deposit) (balance-serializer deposit))
            ((eq? m 'balance) balance)
            ((eq? m 'serializer) balance-serializer)
            (else (error "Unknown request -- MAKE-ACCOUNT"
                         m))))
    dispatch))
</pre></p>
<p></p>
<p>Then deposits are handled as with the original <code>make-account</code>:</p>
<p></p>
<p><pre>(define (deposit account amount)
 ((account 'deposit) amount))
</pre></p>
<p></p>
<p>Explain what is wrong with Louis's reasoning.  In particular,consider what happens when <code>serialized-exchange</code> is called.</p>
<p><a name="%_sec_Temp_427" id="%_sec_Temp_427"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_427">Implementing serializers</a></h4>
<p><a name="%_idx_3638" id="%_idx_3638"></a>We implement serializers in terms of a more primitive synchronizationmechanism called a <a name="%_idx_3640" id="%_idx_3640"></a><em>mutex</em>.  A mutex is an object that supportstwo operations – the mutex can be <a name="%_idx_3642" id="%_idx_3642"></a><em>acquired</em>, and the mutex can be<a name="%_idx_3644" id="%_idx_3644"></a><em>released</em>.  Once a mutex has been acquired, no other acquireoperations on that mutex may proceed until the mutex is released.<a name="call_footnote_Temp_428" href="#footnote_Temp_428" id="call_footnote_Temp_428"><sup><small>44</small></sup></a> In our implementation, eachserializer has an associated mutex.  Given a procedure <code>p</code>, theserializer returns a procedure that acquires the mutex, runs <code>p</code>,and then releases the mutex.  This ensures that only one of theprocedures produced by the serializer can be running at once, which isprecisely the serialization property that we need to guarantee.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3660" id="%_idx_3660"></a>(define (make-serializer)
  (let ((mutex (make-mutex)))
    (lambda (p)
      (define (serialized-p . args)
        (mutex 'acquire)
        (let ((val (apply p args)))
          (mutex 'release)
          val))
      serialized-p)))
</pre></p>
<p></p>
<p></p>
<p>The mutex is a mutable object (here we'll use a one-elementlist, which we'll refer to as a <a name="%_idx_3662" id="%_idx_3662"></a><em>cell</em>) that can hold the valuetrue or false.  When the value is false, the mutex is available to beacquired.  When the value is true, the mutex is unavailable, and anyprocess that attempts to acquire the mutex must wait.</p>
<p>Our mutex constructor <code>make-mutex</code> begins by initializing the cellcontents to false.  To acquire the mutex, we test the cell.  If themutex is available, we set the cell contents to true and proceed.Otherwise, we wait in a loop, attempting to acquire over and overagain, until we find that the mutex is available.<a name="call_footnote_Temp_429" href="#footnote_Temp_429" id="call_footnote_Temp_429"><sup><small>45</small></sup></a>  To release themutex, we set the cell contents to false.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3668" id="%_idx_3668"></a>(define (make-mutex)
  (let ((cell (list false)))            
    (define (the-mutex m)
      (cond ((eq? m 'acquire)
             (if (test-and-set! cell)
                 (the-mutex 'acquire))) <em>; retry</em>
            ((eq? m 'release) (clear! cell))))
    the-mutex))
(define (clear! cell)
  (set-car! cell false))
</pre></p>
<p></p>
<p></p>
<p><code>Test-and-set!</code> tests the cell and returns the result of thetest.  In addition, if the test was false, <code>test-and-set!</code> setsthe cell contents to true before returning false.  We can express thisbehavior as the following procedure:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3670" id="%_idx_3670"></a>(define (test-and-set! cell)
  (if (car cell)
      true
      (begin (set-car! cell true)
             false)))
</pre></p>
<p></p>
<p></p>
<p>However, this implementation of <code>test-and-set!</code> does not sufficeas it stands.  There is a crucial subtlety here, which is theessential place where concurrency control enters the system: The <code>test-and-set!</code> operation must be performed <a name="%_idx_3672" id="%_idx_3672"></a><em>atomically</em>.  Thatis, we must guarantee that, once a process has tested the cell andfound it to be false, the cell contents will actually be set to truebefore any other process can test the cell.  If we do not make thisguarantee, then the mutex can fail in a way similar to thebank-account failure in figure <a href="#%_fig_3.29">3.29</a>.  (Seeexercise <a href="#%_thm_3.46">3.46</a>.)</p>
<p>The actual implementation of <code>test-and-set!</code> depends on thedetails of how our system runs concurrent processes.  For example, wemight be executing concurrent processes on a sequential processorusing a <a name="%_idx_3674" id="%_idx_3674"></a>time-slicing mechanism that cycles through the processes,permitting each process to run for a short time before interrupting itand moving on to the next process.  In that case, <code>test-and-set!</code>can work by disabling time slicing during the testing and setting.<a name="call_footnote_Temp_430" href="#footnote_Temp_430" id="call_footnote_Temp_430"><sup><small>46</small></sup></a>Alternatively, multiprocessing computers provide instructions thatsupport atomic operations directly in hardware.<a name="call_footnote_Temp_431" href="#footnote_Temp_431" id="call_footnote_Temp_431"><sup><small>47</small></sup></a></p>
<p></p>
<p><a name="%_thm_3.46" id="%_thm_3.46"></a><b>Exercise 3.46.</b>  Suppose that we implement <code>test-and-set!</code>  using an ordinaryprocedure as shown in the text, without attempting to make the operationatomic.  Draw a timing diagram like the one infigure <a href="#%_fig_3.29">3.29</a> to demonstrate how the muteximplementation can fail by allowing two processes to acquire the mutexat the same time.</p>
<p></p>
<p></p>
<p><a name="%_thm_3.47" id="%_thm_3.47"></a><b>Exercise 3.47.</b>  <a name="%_idx_3692" id="%_idx_3692"></a>A semaphore (of size <em>n</em>) is a generalization of a mutex.  Like amutex, a semaphore supports acquire and release operations, but it ismore general in that up to <em>n</em> processes can acquire itconcurrently.  Additional processes that attempt to acquire thesemaphore must wait for release operations.  Give implementations ofsemaphores</p>
<p></p>
<p></p>
<p>a. in terms of mutexes</p>
<p></p>
<p></p>
<p>b. in terms of atomic <code>test-and-set!</code> operations.</p>
<p><a name="%_sec_Temp_434" id="%_sec_Temp_434"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_434">Deadlock</a></h4>
<p><a name="%_idx_3694" id="%_idx_3694"></a><a name="%_idx_3696" id="%_idx_3696"></a>Now that we have seen how to implement serializers, we can seethat account exchanging still has a problem, even with the<code>serialized-exchange</code> procedure above.Imagine that Peter attempts to exchange <em>a</em>1with <em>a</em>2 while Paul concurrently attempts to exchange <em>a</em>2with <em>a</em>1.  Suppose that Peter's process reaches the point whereit has entered a serialized procedure protecting <em>a</em>1 and, justafter that, Paul's process enters a serialized procedure protecting<em>a</em>2.  Now Peter cannot proceed (to enter a serialized procedureprotecting <em>a</em>2) until Paul exits the serialized procedureprotecting <em>a</em>2.  Similarly, Paul cannot proceed until Peter exitsthe serialized procedure protecting <em>a</em>1.  Each process is stalledforever, waiting for the other.  This situation is called a <em>deadlock</em>.  Deadlock is always a danger in systems that provideconcurrent access to multiple shared resources.</p>
<p><a name="%_idx_3698" id="%_idx_3698"></a>One way to avoid the deadlock in this situation is to give eachaccount a unique identification number and rewrite <code>serialized-exchange</code> sothat a process will always attempt to enter a procedure protecting thelowest-numbered account first.  Although this method works well forthe exchange problem, there are other situations that require moresophisticated deadlock-avoidance techniques, or where deadlock cannotbe avoided at all.  (See exercises <a href="#%_thm_3.48">3.48</a>and <a href="#%_thm_3.49">3.49</a>.)<a name="call_footnote_Temp_435" href="#footnote_Temp_435" id="call_footnote_Temp_435"><sup><small>48</small></sup></a></p>
<p></p>
<p><a name="%_thm_3.48" id="%_thm_3.48"></a><b>Exercise 3.48.</b>  <a name="%_idx_3708" id="%_idx_3708"></a>Explain in detail why the deadlock-avoidance method described above,(i.e., the accounts are numbered, and each process attempts to acquirethe smaller-numbered account first) avoids deadlock in the exchangeproblem.  Rewrite <code>serialized-exchange</code> to incorporate this idea.(You willalso need to modify <code>make-account</code> so that each account is createdwith a number, which can be accessed by sending an appropriatemessage.)</p>
<p></p>
<p></p>
<p><a name="%_thm_3.49" id="%_thm_3.49"></a><b>Exercise 3.49.</b>  Give a scenario where the deadlock-avoidance mechanism describedabove does not work.  (Hint: In the exchange problem, each processknows in advance which accounts it will need to get access to.  Consider asituation where a process must get access to some shared resources before itcan know which additional shared resources it will require.)</p>
<p></p>
<p><a name="%_sec_Temp_438" id="%_sec_Temp_438"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_438">Concurrency, time, and communication</a></h4>
<p>We've seen how programming concurrent systems requires controlling theordering of events when different processes access sharedstate, and we've seen how to achieve this control through judicioususe of serializers.  But the problems of concurrencylie deeper than this, because, from a fundamental point of view, it'snot always clear what is meant by “shared state.”</p>
<p>Mechanisms such as <code>test-and-set!</code> require processes to examine aglobal shared flag at arbitrary times.  This is problematic andinefficient to implement in modern high-speed processors, wheredue to optimization techniques such as pipelining and cached memory,the contents of memorymay not be in a consistent state at every instant.  In contemporarymultiprocessing systems, therefore, the serializer paradigm is beingsupplanted by new approaches to concurrency control.<a name="call_footnote_Temp_439" href="#footnote_Temp_439" id="call_footnote_Temp_439"><sup><small>49</small></sup></a></p>
<p>The problematic aspects of shared state also arisein large, distributed systems.  Forinstance, imagine adistributed banking system where individual branch banks maintainlocal values for bank balances and periodically compare these withvalues maintained by other branches.  In such a system the value of“the account balance” would be undetermined, except right aftersynchronization.If Peter deposits money in an account he holdsjointly with Paul, when should we say that the account balance haschanged – when the balance in the local branch changes, or not untilafter the synchronization?And if Paul accesses the account from adifferent branch, what are the reasonable constraints to place on thebanking system such that the behavior is “correct”?The only thing that might matter forcorrectness is the behavior observed by Peter and Paul individuallyand the “state” of the account immediately after synchronization.Questions about the“real” account balance or the order of events between synchronizationsmay be irrelevant or meaningless.<a name="call_footnote_Temp_440" href="#footnote_Temp_440" id="call_footnote_Temp_440"><sup><small>50</small></sup></a></p>
<p><a name="%_idx_3720" id="%_idx_3720"></a>The basic phenomenon here is that synchronizing different processes,establishing shared state, or imposing an order on events requirescommunication among the processes.  In essence, any notion of time inconcurrency control must be intimately tied to communication.<a name="call_footnote_Temp_441" href="#footnote_Temp_441" id="call_footnote_Temp_441"><sup><small>51</small></sup></a>  It isintriguing that a similar connection between time and communicationalso arises in the <a name="%_idx_3724" id="%_idx_3724"></a>Theory of Relativity, where the speed of light (thefastest signal that can be used to synchronize events) is afundamental constant relating time and space.  Thecomplexities we encounter in dealing with time and state in ourcomputational models may in fact mirror a fundamental complexity ofthe physical universe.</p>
<p></p>
<p></p>
<div class="smallprint"><hr></div>
<p></p>
<div class="footnote">
<p><a name="footnote_Temp_405" href="#call_footnote_Temp_405" id="footnote_Temp_405"><sup><small>34</small></sup></a> Most real processors actually execute a fewoperations at a time, following a strategy called <a name="%_idx_3582" id="%_idx_3582"></a><em>pipelining</em>.  Although this technique greatly improves the effectiveutilization of the hardware, it is used only to speed up the executionof a sequential instruction stream, while retaining the behavior ofthe sequential program.</p>
<p><a name="footnote_Temp_406" href="#call_footnote_Temp_406" id="footnote_Temp_406"><sup><small>35</small></sup></a> To quote some graffiti seen on a Cambridge<a name="%_idx_3586" id="%_idx_3586"></a>building wall: “Time is a device that was invented to keep everythingfrom happening at once.”</p>
<p><a name="footnote_Temp_407" href="#call_footnote_Temp_407" id="footnote_Temp_407"><sup><small>36</small></sup></a> An even worse failure for this systemcould occur if the two <code>set!</code> operations attempt to change thebalance simultaneously, in which case the actual data appearing inmemory might end up being a random combination of the informationbeing written by the two processes.  Most computers have interlocks onthe primitive memory-write operations, which protect against suchsimultaneous access.  Even this seemingly simple kind of protection,however, raises implementation challenges in the design ofmultiprocessing computers, where elaborate <a name="%_idx_3594" id="%_idx_3594"></a><em>cache-coherence</em>protocols are required to ensure that the various processors willmaintain a consistent view of memory contents, despite the fact thatdata may be replicated (“cached”) among the different processors toincrease the speed of memory access.</p>
<p><a name="footnote_Temp_409" href="#call_footnote_Temp_409" id="footnote_Temp_409"><sup><small>37</small></sup></a> The factorial program insection <a href="book-Z-H-20.html#%_sec_3.1.3">3.1.3</a> illustrates this for a singlesequential process.</p>
<p><a name="footnote_Temp_410" href="#call_footnote_Temp_410" id="footnote_Temp_410"><sup><small>38</small></sup></a> The columns show the contents of Peter's wallet,the joint account (in Bank1), Paul's wallet, and Paul's private account(in Bank2), before and after each withdrawal (W) and deposit (D).Peter withdraws $10 from Bank1; Paul deposits $5 in Bank2,then withdraws $25 from Bank1.</p>
<p><a name="footnote_Temp_411" href="#call_footnote_Temp_411" id="footnote_Temp_411"><sup><small>39</small></sup></a> A more formal way to express this idea is to say thatconcurrent programs are inherently <a name="%_idx_3604" id="%_idx_3604"></a><em>nondeterministic</em>. Thatis, they are described not by single-valued functions, but byfunctions whose results are sets of possible values.  Insection <a href="book-Z-H-28.html#%_sec_4.3">4.3</a> we will study alanguage for expressing nondeterministiccomputations.</p>
<p><a name="footnote_Temp_415" href="#call_footnote_Temp_415" id="footnote_Temp_415"><sup><small>40</small></sup></a> <code>Parallel-execute</code> is not part of standard Scheme, butit can be implemented in MIT Scheme.  In our implementation, thenew concurrent processes also run concurrently with the originalScheme process.  Also, in our implementation, the value returnedby <code>parallel-execute</code> is a special control object that can be usedto halt the newly created processes.</p>
<p><a name="footnote_Temp_421" href="#call_footnote_Temp_421" id="footnote_Temp_421"><sup><small>41</small></sup></a> We have simplified <code>exchange</code> by exploiting the factthat our <code>deposit</code> message accepts negative amounts.  (This is aserious bug in our banking system!)</p>
<p><a name="footnote_Temp_422" href="#call_footnote_Temp_422" id="footnote_Temp_422"><sup><small>42</small></sup></a> If the account balances start out as $10,$20, and $30, then after any number of concurrent exchanges, thebalances should still be $10, $20, and$30 in some order.  Serializing the deposits to individual accounts is notsufficient to guarantee this.  See exercise <a href="#%_thm_3.43">3.43</a>.</p>
<p><a name="footnote_Temp_423" href="#call_footnote_Temp_423" id="footnote_Temp_423"><sup><small>43</small></sup></a> Exercise <a href="#%_thm_3.45">3.45</a> investigates whydeposits and withdrawals are no longer automatically serializedby the account.</p>
<p><a name="footnote_Temp_428" href="#call_footnote_Temp_428" id="footnote_Temp_428"><sup><small>44</small></sup></a> The term “mutex” is an abbreviation for <a name="%_idx_3646" id="%_idx_3646"></a><em>mutualexclusion</em>.  The general problem of arranging a mechanism that permitsconcurrent processes to safely share resources is called the mutualexclusion problem.  Our mutex is a simple variant of the <a name="%_idx_3648" id="%_idx_3648"></a><em>semaphore</em> mechanism (see exercise <a href="#%_thm_3.47">3.47</a>), which wasintroduced in the <a name="%_idx_3650" id="%_idx_3650"></a>“THE” Multiprogramming System developed at the<a name="%_idx_3652" id="%_idx_3652"></a>Technological University of Eindhoven and named for the university'sinitials in Dutch (Dijkstra 1968a).  The acquire andrelease operations were originally called <a name="%_idx_3654" id="%_idx_3654"></a><a name="%_idx_3656" id="%_idx_3656"></a><a name="%_idx_3658" id="%_idx_3658"></a>P and V, from the Dutchwords <em>passeren</em> (to pass) and <em>vrijgeven</em> (to release), inreference to the semaphores used on railroad systems.  Dijkstra'sclassic exposition (1968b) was one of the first to clearly present theissues of concurrency control, and showed how to use semaphores tohandle a variety of concurrency problems.</p>
<p><a name="footnote_Temp_429" href="#call_footnote_Temp_429" id="footnote_Temp_429"><sup><small>45</small></sup></a> In mosttime-shared operating systems, processes that are <a name="%_idx_3664" id="%_idx_3664"></a>blocked by a mutex do<a name="%_idx_3666" id="%_idx_3666"></a>not waste time “busy-waiting” as above.  Instead, the systemschedules another process to run while the first is waiting, and the blockedprocess is awakened when the mutex becomes available.</p>
<p><a name="footnote_Temp_430" href="#call_footnote_Temp_430" id="footnote_Temp_430"><sup><small>46</small></sup></a> In MIT Scheme for a single processor, which uses a time-slicingmodel, <code>test-and-set!</code> can be implemented as follows:<a name="%_idx_3676" id="%_idx_3676"></a><a name="%_idx_3678" id="%_idx_3678"></a></p>
<p></p>
<p><pre><a name="%_idx_3680" id="%_idx_3680"></a>(define (test-and-set! cell)
  (without-interrupts
   (lambda ()
     (if (car cell)
         true
         (begin (set-car! cell true)
                false)))))
</pre></p>
<p></p>
<p><code>Without-interrupts</code> disablestime-slicing interrupts while its procedure argument is being executed.</p>
<p><a name="footnote_Temp_431" href="#call_footnote_Temp_431" id="footnote_Temp_431"><sup><small>47</small></sup></a> There are many variants of such<a name="%_idx_3682" id="%_idx_3682"></a>instructions – including test-and-set, test-and-clear, swap,compare-and-exchange, load-reserve, and store-conditional – whosedesign must be carefully matched to the machine's processor-memoryinterface.One issue that arises here is to determine what happensif two processes attempt to acquire the same resourceat exactly the same time by using such an instruction.This requires some mechanismfor making a decision about which process gets control.  Such amechanism is called an <a name="%_idx_3684" id="%_idx_3684"></a><em>arbiter</em>.  Arbiters usually boil down tosome sort of hardware device.Unfortunately, it is possible to prove that one cannot physicallyconstruct a fair arbiter that works 100% of the time unless oneallows the arbiter an arbitrarily long time to make its decision.  Thefundamental phenomenon here was originally observed by the fourteenth-centuryFrench philosopher <a name="%_idx_3686" id="%_idx_3686"></a>Jean Buridan in his commentary on<a name="%_idx_3688" id="%_idx_3688"></a>Aristotle's <i>De caelo</i>.  Buridan argued that a perfectly rational<a name="%_idx_3690" id="%_idx_3690"></a>dog placed between two equally attractive sources of food will starveto death, because it is incapable of deciding which to go to first.</p>
<p><a name="footnote_Temp_435" href="#call_footnote_Temp_435" id="footnote_Temp_435"><sup><small>48</small></sup></a> The general technique for avoiding deadlock by numbering the<a name="%_idx_3700" id="%_idx_3700"></a>shared resources and acquiring them in order is due to <a name="%_idx_3702" id="%_idx_3702"></a><a name="%_idx_3704" id="%_idx_3704"></a><a name="%_idx_3706" id="%_idx_3706"></a>Havender(1968).  Situations where deadlock cannot be avoided require <em>deadlock-recovery</em> methods, which entail having processes “back out”of the deadlocked state and try again.  Deadlock-recoverymechanisms are widely used in database management systems, a topic thatis treated in detail in Gray and Reuter 1993.</p>
<p><a name="footnote_Temp_439" href="#call_footnote_Temp_439" id="footnote_Temp_439"><sup><small>49</small></sup></a> One such alternative to serialization is called <a name="%_idx_3710" id="%_idx_3710"></a><em>barriersynchronization</em>.  The programmer permits concurrent processes toexecute as they please, but establishes certain synchronization points(“barriers”) through which no process can proceed until all theprocesses have reached the barrier.  Modern processors provide machineinstructions that permit programmers to establish synchronizationpoints at places where consistency is required.  The <a name="%_idx_3712" id="%_idx_3712"></a>PowerPC<sup><em>T</em><em>M</em></sup>, for example, includes for this purpose two instructions called<a name="%_idx_3714" id="%_idx_3714"></a>SYNC and <a name="%_idx_3716" id="%_idx_3716"></a>EIEIO (Enforced In-order Execution of Input/Output).</p>
<p><a name="footnote_Temp_440" href="#call_footnote_Temp_440" id="footnote_Temp_440"><sup><small>50</small></sup></a> This may seem like a strange point of view, but there are<a name="%_idx_3718" id="%_idx_3718"></a>systems that work this way.  International charges to credit-cardaccounts, for example, are normally cleared on a per-country basis,and the charges made in different countries are periodicallyreconciled.  Thus the account balance may be different indifferent countries.</p>
<p><a name="footnote_Temp_441" href="#call_footnote_Temp_441" id="footnote_Temp_441"><sup><small>51</small></sup></a> For distributedsystems, this perspective was pursued by <a name="%_idx_3722" id="%_idx_3722"></a>Lamport (1978), who showed howto use communication to establish “global clocks” that can be usedto establish orderings on events in distributed systems.</p>
</div></body>
</html>
