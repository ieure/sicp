<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<?xml version="1.0" encoding="utf-8"?><html xmlns="http://www.w3.org/1999/xhtml" xmlns:ops="http://www.idpf.org/2007/ops">
<!-- Generated from TeX source by tex2page, v 4o,
     (c) Dorai Sitaram, http://www.cs.rice.edu/~dorai/tex2page --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Type: text/html; charset=utf-8">
<title>Structure and Interpretation of Computer Programs</title>
<link rel="stylesheet" type="text/css" href="book-Z-C.css" title="default">
</head>
<body><a name="%_sec_4.3" id="%_sec_4.3"></a><h2><a href="book-Z-H-4.html#%_toc_%_sec_4.3">4.3  Variations on a Scheme – Nondeterministic Computing</a></h2>
<p><a name="%_idx_4806" id="%_idx_4806"></a><a name="%_idx_4808" id="%_idx_4808"></a>In this section, we extend the Scheme evaluator to support aprogramming paradigm called <em>nondeterministic computing</em> bybuilding into the evaluator a facility to support automatic search.This is a much more profound change to the language than theintroduction of lazy evaluation in section <a href="book-Z-H-27.html#%_sec_4.2">4.2</a>.</p>
<p><a name="%_idx_4810" id="%_idx_4810"></a>Nondeterministic computing, like stream processing, is useful for“generate and test” applications.  Consider the task of starting withtwo lists of positive integers and finding a pair of integers – onefrom the first list and one from the second list – whose sum is prime.We saw how to handle this with finite sequence operations insection <a href="book-Z-H-15.html#%_sec_2.2.3">2.2.3</a> and with infinite streams insection <a href="book-Z-H-24.html#%_sec_3.5.3">3.5.3</a>.  Our approach was to generatethe sequence of all possible pairs and filter these to select thepairs whose sum is prime.  Whether we actually generate the entiresequence of pairs first as in chapter 2, or interleave the generatingand filtering as in chapter 3, is immaterial to the essential image ofhow the computation is organized.</p>
<p><a name="%_idx_4812" id="%_idx_4812"></a>The nondeterministic approach evokes a different image.  Imagine simplythat we choose (in some way) a number from the first list and a numberfrom the second list and require (using some mechanism) that their sumbe prime.  This is expressed by following procedure:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4814" id="%_idx_4814"></a>(define (prime-sum-pair list1 list2)
  (let ((a (an-element-of list1))
        (b (an-element-of list2)))
    (require (prime? (+ a b)))
    (list a b)))
</pre></p>
<p></p>
<p>It might seem as if this procedure merely restates the problem,rather than specifying a way to solve it.  Nevertheless, this isa legitimate nondeterministic program.<a name="call_footnote_Temp_598" href="#footnote_Temp_598" id="call_footnote_Temp_598"><sup><small>42</small></sup></a></p>
<p>The key idea here is that expressions in a nondeterministic languagecan have more than one possible value.  For instance,<code>an-element-of</code> might return any element of the given list.  Ournondeterministic program evaluator will work by automatically choosinga possible value and keeping track of the choice.  If a subsequentrequirement is not met, the evaluator will try a different choice, andit will keep trying new choices until the evaluation succeeds, oruntil we run out of choices.  Just as the lazy evaluator freed theprogrammer from the details of how values are delayed and forced, thenondeterministic program evaluator will free the programmer from thedetails of how choices are made.</p>
<p><a name="%_idx_4820" id="%_idx_4820"></a>It is instructive to contrast the different images of time evoked bynondeterministic evaluation and stream processing.  Stream processinguses lazy evaluation to decouple the time when the stream of possibleanswers is assembled from the time when the actual stream elements areproduced.  The evaluator supports the illusion that all the possibleanswers are laid out before us in a timeless sequence.  Withnondeterministic evaluation, an expression represents the explorationof a set of possible worlds, each determined by a set of choices.Some of the possible worlds lead to dead ends, while others haveuseful values.  The nondeterministic program evaluator supports theillusion that time branches, and that our programs have differentpossible execution histories.  When we reach a dead end, we canrevisit a previous choice point and proceed along a different branch.</p>
<p>The nondeterministic program evaluator implemented below is called the<code>amb</code> evaluator because it is based on a new special form called<code>amb</code>.  We can type the above definition of <code>prime-sum-pair</code>at the <code>amb</code> evaluator driver loop (along with definitions of <code>prime?</code>, <code>an-element-of</code>, and <code>require</code>) and run theprocedure as follows:</p>
<p></p>
<p></p>
<p><pre><i>;;; Amb-Eval input:</i>
(prime-sum-pair '(1 3 5 8) '(20 35 110))
<i>;;; Starting a new problem</i>
<i>;;; Amb-Eval value:</i>
<i>(3 20)</i>
</pre></p>
<p></p>
<p>The value returned was obtained after the evaluator repeatedly choseelements from each of the lists, until a successful choice was made.</p>
<p>Section <a href="#%_sec_4.3.1">4.3.1</a> introduces <code>amb</code> and explains how itsupports nondeterminism through the evaluator's automatic searchmechanism.  Section <a href="#%_sec_4.3.2">4.3.2</a> presents examples ofnondeterministic programs, and section <a href="#%_sec_4.3.3">4.3.3</a>gives the details of how to implement the <code>amb</code> evaluator bymodifying the ordinary Scheme evaluator.</p>
<p><a name="%_sec_4.3.1" id="%_sec_4.3.1"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_4.3.1">4.3.1  Amb and Search</a></h3>
<p></p>
<p><a name="%_idx_4822" id="%_idx_4822"></a>To extend Scheme to support nondeterminism, we introduce a new specialform called <code>amb</code>.<a name="call_footnote_Temp_599" href="#footnote_Temp_599" id="call_footnote_Temp_599"><sup><small>43</small></sup></a>The expression <code>(amb &lt;<em><em>e</em><sub>1</sub></em>&gt; &lt;<em><em>e</em><sub>2</sub></em>&gt; <code>...</code> &lt;<em><em>e</em><sub><em>n</em></sub></em>&gt;)</code>returns the value of one of the <em>n</em> expressions &lt;<em><em>e</em><sub><em>i</em></sub></em>&gt; “ambiguously.”For example, the expression</p>
<p></p>
<p></p>
<p><pre>(list (amb 1 2 3) (amb 'a 'b))
</pre></p>
<p></p>
<p>can have six possible values:</p>
<table border="0"><tr>
<td valign="top"><code>(1 a) </code></td>
<td valign="top"><code>(1 b) </code></td>
<td valign="top"><code>(2 a) </code></td>
<td valign="top"><code>(2 b) </code></td>
<td valign="top"><code>(3 a) </code></td>
<td valign="top"><code>(3 b)</code></td>
</tr></table>
<code>Amb</code> with a single choice produces an ordinary (single) value.<p><a name="%_idx_4826" id="%_idx_4826"></a><code>Amb</code> with no choices – the expression <code>(amb)</code> – is anexpression with no acceptable values.  Operationally, we can think of<code>(amb)</code> as an expression that when evaluated causes thecomputation to “fail”: The computation aborts and no value isproduced.  Using this idea, we can express the requirement that aparticular predicate expression <code>p</code> must be true as follows:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4828" id="%_idx_4828"></a>(define (require p)
  (if (not p) (amb)))
</pre></p>
<p></p>
<p></p>
<p>With <code>amb</code> and <code>require</code>, we can implement the <code>an-element-of</code> procedure used above:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4830" id="%_idx_4830"></a>(define (an-element-of items)
  (require (not (null? items)))
  (amb (car items) (an-element-of (cdr items))))
</pre></p>
<p></p>
<p><code>An-element-of</code> fails if the list is empty.  Otherwise itambiguously returns either the first element of the list or an elementchosen from the rest of the list.</p>
<p>We can also express infinite ranges of choices.  The followingprocedure potentially returns any integer greater than or equal tosome given <em>n</em>:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4832" id="%_idx_4832"></a>(define (an-integer-starting-from n)
  (amb n (an-integer-starting-from (+ n 1))))
</pre></p>
<p></p>
<p>This is like the stream procedure <code>integers-starting-from</code>described in section <a href="book-Z-H-24.html#%_sec_3.5.2">3.5.2</a>, but with an importantdifference: The stream procedure returns an object that represents thesequence of all integers beginning with <em>n</em>, whereas the <code>amb</code>procedure returns a single integer.<a name="call_footnote_Temp_600" href="#footnote_Temp_600" id="call_footnote_Temp_600"><sup><small>44</small></sup></a></p>
<p><a name="%_idx_4834" id="%_idx_4834"></a>Abstractly, we can imagine that evaluating an <code>amb</code> expressioncauses time to split into branches, where the computation continues oneach branch with one of the possible values of the expression.  We saythat <code>amb</code> represents a <a name="%_idx_4836" id="%_idx_4836"></a><em>nondeterministic choice point</em>.If we had a machine with a sufficient number of processors that couldbe dynamically allocated, we could implement the search in astraightforward way.  Execution would proceed as in a sequentialmachine, until an <code>amb</code> expression is encountered.  At this point,more processors would be allocated and initialized to continue all ofthe parallel executions implied by the choice.  Each processor wouldproceed sequentially as if it were the only choice, until it eitherterminates by encountering a failure, or it further subdivides, orit finishes.<a name="call_footnote_Temp_601" href="#footnote_Temp_601" id="call_footnote_Temp_601"><sup><small>45</small></sup></a></p>
<p><a name="%_idx_4840" id="%_idx_4840"></a>On the other hand, if we have a machine that can executeonly one process (or a few concurrent processes),we must consider the alternatives sequentially.One could imagine modifying an evaluatorto pick at random a branch to follow whenever it encounters a choicepoint.  Random choice, however, can easily lead to failing values.We might try running the evaluator over and over, making randomchoices and hoping to find a non-failing value, but it is better to <a name="%_idx_4842" id="%_idx_4842"></a><a name="%_idx_4844" id="%_idx_4844"></a><em>systematically search</em> all possible execution paths.The <code>amb</code> evaluator that we will develop and work with in this sectionimplements a systematic search as follows: When the evaluatorencounters an application of <code>amb</code>, it initially selects the firstalternative.  This selection may itself lead to a further choice.  Theevaluator will always initially choose the first alternative at eachchoice point.  If a choice results in a failure, then the evaluator<a name="%_idx_4846" id="%_idx_4846"></a><a name="%_idx_4848" id="%_idx_4848"></a><a name="%_idx_4850" id="%_idx_4850"></a>automagically<a name="call_footnote_Temp_602" href="#footnote_Temp_602" id="call_footnote_Temp_602"><sup><small>46</small></sup></a> <a name="%_idx_4852" id="%_idx_4852"></a><em>backtracks</em>to the most recent choice point and tries the nextalternative.  If it runs out of alternatives at any choice point, theevaluator will back up to the previous choice point and resume fromthere.  This process leads to a search strategy known as <a name="%_idx_4854" id="%_idx_4854"></a><a name="%_idx_4856" id="%_idx_4856"></a><a name="%_idx_4858" id="%_idx_4858"></a><em>depth-first search</em> or <em>chronological backtracking</em>.<a name="call_footnote_Temp_603" href="#footnote_Temp_603" id="call_footnote_Temp_603"><sup><small>47</small></sup></a></p>
<p><a name="%_sec_Temp_604" id="%_sec_Temp_604"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_604">Driver loop</a></h4>
<p><a name="%_idx_4908" id="%_idx_4908"></a>The driver loop for the <code>amb</code> evaluatorhas some unusual properties.  It reads anexpression and prints the value of the first non-failing execution, asin the <code>prime-sum-pair</code> example shown above.  If wewant to see the value of the next successful execution, we canask the interpreter to backtrack and attempt to generate a secondnon-failing execution.  This is signaled by typing the symbol <a name="%_idx_4910" id="%_idx_4910"></a><code>try-again</code>.  If any expression except <code>try-again</code> is given, theinterpreter will start a new problem, discarding the unexploredalternatives in the previous problem.  Here is a sampleinteraction:</p>
<p></p>
<p></p>
<p><pre><i>;;; Amb-Eval input:</i>
(prime-sum-pair '(1 3 5 8) '(20 35 110))
<i>;;; Starting a new problem</i>
<i>;;; Amb-Eval value:</i>
<i>(3 20)</i>
<i>;;; Amb-Eval input:</i>
try-again
<i>;;; Amb-Eval value:</i>
<i>(3 110)</i>
<i>;;; Amb-Eval input:</i>
try-again
<i>;;; Amb-Eval value:</i>
<i>(8 35)</i>
<i>;;; Amb-Eval input:</i>
try-again
<i>;;; There are no more values of</i>
<i>(prime-sum-pair (quote (1 3 5 8)) (quote (20 35 110)))</i>
<i>;;; Amb-Eval input:</i>
(prime-sum-pair '(19 27 30) '(11 36 58))
<i>;;; Starting a new problem</i>
<i>;;; Amb-Eval value:</i>
<i>(30 11)</i>
</pre></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_4.35" id="%_thm_4.35"></a><b>Exercise 4.35.</b>  <a name="%_idx_4912" id="%_idx_4912"></a><a name="%_idx_4914" id="%_idx_4914"></a>Write a procedure <code>an-integer-between</code> that returns an integerbetween two given bounds.  This can be used to implement aprocedure that finds Pythagorean triples,i.e., triples of integers (<em>i</em>,<em>j</em>,<em>k</em>) between the given bounds suchthat <em>i</em> <u>&lt;</u> <em>j</em> and <em>i</em><sup>2</sup>  +  <em>j</em><sup>2</sup>  = <em>k</em><sup>2</sup>, as follows:</p>
<p></p>
<p><pre>(define (a-pythagorean-triple-between low high)
  (let ((i (an-integer-between low high)))
    (let ((j (an-integer-between i high)))
      (let ((k (an-integer-between j high)))
        (require (= (+ (* i i) (* j j)) (* k k)))
        (list i j k)))))
</pre></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_4.36" id="%_thm_4.36"></a><b>Exercise 4.36.</b>  <a name="%_idx_4916" id="%_idx_4916"></a><a name="%_idx_4918" id="%_idx_4918"></a>Exercise <a href="book-Z-H-24.html#%_thm_3.69">3.69</a> discussed how to generatethe stream of <em>all</em> Pythagorean triples, with no upper bound on thesize of the integers to be searched.  Explain why simply replacing<code>an-integer-between</code> by <code>an-integer-starting-from</code> in the procedure inexercise <a href="#%_thm_4.35">4.35</a> is not an adequate way togenerate arbitrary Pythagorean triples.  Write a procedure thatactually will accomplish this.  (That is, write a procedure for whichrepeatedly typing <code>try-again</code> would in principle eventuallygenerate all Pythagorean triples.)</p>
<p></p>
<p></p>
<p><a name="%_thm_4.37" id="%_thm_4.37"></a><b>Exercise 4.37.</b>  <a name="%_idx_4920" id="%_idx_4920"></a><a name="%_idx_4922" id="%_idx_4922"></a>Ben Bitdiddle claims that the following method for generatingPythagorean triples is more efficient than the one inexercise <a href="#%_thm_4.35">4.35</a>.  Is he correct?  (Hint: Considerthe number of possibilities that must be explored.)</p>
<p></p>
<p></p>
<p><pre>(define (a-pythagorean-triple-between low high)
  (let ((i (an-integer-between low high))
        (hsq (* high high)))
    (let ((j (an-integer-between i high)))
      (let ((ksq (+ (* i i) (* j j))))
        (require (&gt;= hsq ksq))
        (let ((k (sqrt ksq)))
          (require (integer? k))
          (list i j k))))))
</pre></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_sec_4.3.2" id="%_sec_4.3.2"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_4.3.2">4.3.2  Examples of Nondeterministic Programs</a></h3>
<p></p>
<p>Section <a href="#%_sec_4.3.3">4.3.3</a> describes the implementation ofthe <code>amb</code> evaluator.  First, however, we give some examples of howit can be used.  The advantage of nondeterministic programming is thatwe can suppress the details of how search is carried out, thereby<a name="%_idx_4924" id="%_idx_4924"></a>expressing our programs at a higher level of abstraction.</p>
<p><a name="%_sec_Temp_608" id="%_sec_Temp_608"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_608">Logic Puzzles</a></h4>
<p><a name="%_idx_4926" id="%_idx_4926"></a><a name="%_idx_4928" id="%_idx_4928"></a><a name="%_idx_4930" id="%_idx_4930"></a><a name="%_idx_4932" id="%_idx_4932"></a>The following puzzle (taken from Dinesman 1968) is typical of a largeclass of simple logic puzzles:</p>
<p></p>
<blockquote>Baker, Cooper, Fletcher, Miller, and Smith live on different floors ofan apartment house that contains only five floors.  Baker does notlive on the top floor.  Cooper does not live on the bottom floor.Fletcher does not live on either the top or the bottom floor.  Millerlives on a higher floor than does Cooper.  Smith does not live on afloor adjacent to Fletcher's.  Fletcher does not live on a flooradjacent to Cooper's.  Where does everyone live?</blockquote>
<p>We can determine who lives on each floor in a straightforward way byenumerating all the possibilities and imposing the givenrestrictions:<a name="call_footnote_Temp_609" href="#footnote_Temp_609" id="call_footnote_Temp_609"><sup><small>48</small></sup></a></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4938" id="%_idx_4938"></a>(define (multiple-dwelling)
  (let ((baker (amb 1 2 3 4 5))
        (cooper (amb 1 2 3 4 5))
        (fletcher (amb 1 2 3 4 5))
        (miller (amb 1 2 3 4 5))
        (smith (amb 1 2 3 4 5)))
    (require
     (distinct? (list baker cooper fletcher miller smith)))
    (require (not (= baker 5)))
    (require (not (= cooper 1)))
    (require (not (= fletcher 5)))
    (require (not (= fletcher 1)))
    (require (&gt; miller cooper))
    (require (not (= (abs (- smith fletcher)) 1)))
    (require (not (= (abs (- fletcher cooper)) 1)))
    (list (list 'baker baker)
          (list 'cooper cooper)
          (list 'fletcher fletcher)
          (list 'miller miller)
          (list 'smith smith))))
</pre></p>
<p></p>
<p></p>
<p>Evaluating the expression <code>(multiple-dwelling)</code> produces theresult</p>
<p></p>
<p><pre>((baker 3) (cooper 2) (fletcher 4) (miller 5) (smith 1))
</pre></p>
<p></p>
<p>Although this simple procedure works, it is very slow.Exercises <a href="#%_thm_4.39">4.39</a>and <a href="#%_thm_4.40">4.40</a> discuss some possibleimprovements.</p>
<p></p>
<p><a name="%_thm_4.38" id="%_thm_4.38"></a><b>Exercise 4.38.</b>  Modify the multiple-dwelling procedure to omit the requirement thatSmith and Fletcher do not live on adjacent floors.  How many solutionsare there to this modified puzzle?</p>
<p></p>
<p></p>
<p><a name="%_thm_4.39" id="%_thm_4.39"></a><b>Exercise 4.39.</b>  Does the order of the restrictions in the multiple-dwelling procedureaffect the answer? Does it affect the time to find an answer?  If youthink it matters, demonstrate a faster program obtained from the givenone by reordering the restrictions.  If you think it does not matter,argue your case.</p>
<p></p>
<p></p>
<p><a name="%_thm_4.40" id="%_thm_4.40"></a><b>Exercise 4.40.</b>  In the multiple dwelling problem, how many sets of assignments arethere of people to floors, both before and after the requirement thatfloor assignments be distinct?  It is very inefficient to generate allpossible assignments of people to floors and then leave it tobacktracking to eliminate them.  For example, most of the restrictionsdepend on only one or two of the person-floor variables, and can thusbe imposed before floors have been selected for all the people.Write and demonstrate a much more efficientnondeterministic procedure that solves this problem based upongenerating only those possibilities that are not already ruled out byprevious restrictions.  (Hint: This will require a nest of <code>let</code>expressions.)</p>
<p></p>
<p></p>
<p><a name="%_thm_4.41" id="%_thm_4.41"></a><b>Exercise 4.41.</b>  <a name="%_idx_4940" id="%_idx_4940"></a>Write an ordinary Scheme program to solve the multiple dwelling puzzle.</p>
<p></p>
<p></p>
<p><a name="%_thm_4.42" id="%_thm_4.42"></a><b>Exercise 4.42.</b>  <a name="%_idx_4942" id="%_idx_4942"></a>Solve the following “Liars” puzzle (from Phillips 1934):</p>
<blockquote>Five schoolgirls sat for an examination.  Their parents – so theythought – showed an undue degree of interest in the result.  Theytherefore agreed that, in writing home about the examination, eachgirl should make one true statement and one untrue one.  The followingare the relevant passages from their letters:<p></p>
<ul>
<li>Betty: “Kitty was second in the examination.  I was only third.”</li>
<li>Ethel: “You'll be glad to hear that I was on top.  Joan was second.”</li>
<li>Joan: “I was third, and poor old Ethel was bottom.”</li>
<li>Kitty: “I came out second.  Mary was only fourth.”</li>
<li>Mary: “I was fourth.  Top place was taken by Betty.”</li>
</ul>
<p>What in fact was the order in which the five girls were placed?</p>
</blockquote><p></p>
<p></p>
<p><a name="%_thm_4.43" id="%_thm_4.43"></a><b>Exercise 4.43.</b>  Use the <code>amb</code> evaluator to solve the following puzzle:<a name="call_footnote_Temp_616" href="#footnote_Temp_616" id="call_footnote_Temp_616"><sup><small>49</small></sup></a></p>
<blockquote>Mary Ann Moore's father has a yacht and so has each of his fourfriends:  Colonel Downing, Mr. Hall, Sir Barnacle Hood, and Dr.Parker.  Each of the five also has one daughter and each has named hisyacht after a daughter of one of the others.  Sir Barnacle's yacht isthe Gabrielle, Mr. Moore owns the Lorna; Mr. Hall the Rosalind.  TheMelissa, owned by Colonel Downing, is named after Sir Barnacle'sdaughter.  Gabrielle's father owns the yacht that is named after Dr.Parker's daughter.  Who is Lorna's father?</blockquote>Try to write the program so that it runs efficiently (seeexercise <a href="#%_thm_4.40">4.40</a>).  Also determine how manysolutions there are if we are not told that Mary Ann's last name isMoore.<p></p>
<p></p>
<p><a name="%_thm_4.44" id="%_thm_4.44"></a><b>Exercise 4.44.</b>  <a name="%_idx_4944" id="%_idx_4944"></a><a name="%_idx_4946" id="%_idx_4946"></a><a name="%_idx_4948" id="%_idx_4948"></a><a name="%_idx_4950" id="%_idx_4950"></a>Exercise <a href="book-Z-H-15.html#%_thm_2.42">2.42</a> described the “eight-queens puzzle” ofplacing queens on a chessboard so that no two attack each other.Write a nondeterministic program to solve this puzzle.</p>
<p></p>
<p><a name="%_sec_Temp_618" id="%_sec_Temp_618"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_618">Parsing natural language</a></h4>
<p><a name="%_idx_4952" id="%_idx_4952"></a><a name="%_idx_4954" id="%_idx_4954"></a>Programs designed to accept natural language as input usually start byattempting to <em>parse</em> the input, that is, to match the inputagainst some grammatical structure.  For example, we might try torecognize simple sentences consisting of an article followed by a nounfollowed by a verb, such as “The cat eats.”  To accomplish such ananalysis, we must be able to identify the parts of speech ofindividual words.  We could start with some lists that classifyvarious words:<a name="call_footnote_Temp_619" href="#footnote_Temp_619" id="call_footnote_Temp_619"><sup><small>50</small></sup></a></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4956" id="%_idx_4956"></a>(define nouns '(noun student professor cat class))
<a name="%_idx_4958" id="%_idx_4958"></a>(define verbs '(verb studies lectures eats sleeps))
<a name="%_idx_4960" id="%_idx_4960"></a>(define articles '(article the a))
</pre></p>
<p></p>
<p><a name="%_idx_4962" id="%_idx_4962"></a>We also need a <em>grammar</em>, that is, a set of rules describing howgrammatical elements are composed from simpler elements.  A verysimple grammar might stipulate that a sentence always consists of twopieces – a noun phrase followed by a verb – and that a noun phraseconsists of an article followed by a noun.  With this grammar, thesentence “The cat eats” is parsed as follows:</p>
<p></p>
<p></p>
<p><pre>(sentence (noun-phrase (article the) (noun cat))
          (verb eats))
</pre></p>
<p></p>
<p></p>
<p>We can generate such a parse with a simple program that has separateprocedures for each of the grammatical rules.  To parse a sentence, weidentify its two constituent pieces and return a list ofthese two elements, tagged with the symbol <code>sentence</code>:</p>
<p><a name="%_idx_4964" id="%_idx_4964"></a></p>
<p></p>
<p><pre>(define (parse-sentence)
  (list 'sentence
         (parse-noun-phrase)
         (parse-word verbs)))
</pre></p>
<p></p>
<p>A noun phrase, similarly, is parsed by finding an article followed by anoun:</p>
<p></p>
<p><pre>(define (parse-noun-phrase)
  (list 'noun-phrase
        (parse-word articles)
        (parse-word nouns)))
</pre></p>
<p></p>
<p></p>
<p>At the lowest level, parsing boils down to repeatedly checking thatthe next unparsed word is a member of the list of words for therequired part of speech.  To implement this, we maintain a globalvariable <code>*unparsed*</code>, which is the input that has not yet beenparsed.  Each time we check a word, we require that <code>*unparsed*</code>must be non-empty and that it should begin with a word from thedesignated list.  If so, we remove that word from <code>*unparsed*</code> andreturn the word together with its part of speech (which is found atthe head of the list):<a name="call_footnote_Temp_620" href="#footnote_Temp_620" id="call_footnote_Temp_620"><sup><small>51</small></sup></a></p>
<p></p>
<p></p>
<p><pre>(define (parse-word word-list)
  (require (not (null? *unparsed*)))
  (require (memq (car *unparsed*) (cdr word-list)))
  (let ((found-word (car *unparsed*)))
    (set! *unparsed* (cdr *unparsed*))
    (list (car word-list) found-word)))
</pre></p>
<p></p>
<p></p>
<p>To start the parsing, all we need to do is set <code>*unparsed*</code> to bethe entire input, try to parse a sentence, and check that nothing isleft over:</p>
<p></p>
<p></p>
<p><pre>(define *unparsed* '())
<a name="%_idx_4966" id="%_idx_4966"></a>(define (parse input)
  (set! *unparsed* input)
  (let ((sent (parse-sentence)))
    (require (null? *unparsed*))
    sent))
</pre></p>
<p></p>
<p></p>
<p>We can now try the parser and verify that it works for our simple testsentence:</p>
<p></p>
<p></p>
<p><pre><i>;;; Amb-Eval input:</i>
(parse '(the cat eats))
<i>;;; Starting a new problem</i>
<i>;;; Amb-Eval value:</i>
<i>(sentence (noun-phrase (article the) (noun cat)) (verb eats))</i>
</pre></p>
<p></p>
<p></p>
<p>The <code>amb</code> evaluator is useful here because it is convenient toexpress the parsing constraints with the aid of <code>require</code>.Automatic search and backtracking really pay off, however, when weconsider more complex grammars where there are choices for how theunits can be decomposed.</p>
<p>Let's add to our grammar a list of prepositions:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4968" id="%_idx_4968"></a>(define prepositions '(prep for to in by with))
</pre></p>
<p></p>
<p>and define a prepositional phrase (e.g., “for the cat”) to bea preposition followed by a noun phrase:</p>
<p></p>
<p></p>
<p><pre>(define (parse-prepositional-phrase)
  (list 'prep-phrase
        (parse-word prepositions)
        (parse-noun-phrase)))
</pre></p>
<p></p>
<p>Now we can define a sentence to be a noun phrase followed by a verbphrase, where a verb phrase can be either a verb or a verb phraseextended by a prepositional phrase:<a name="call_footnote_Temp_621" href="#footnote_Temp_621" id="call_footnote_Temp_621"><sup><small>52</small></sup></a></p>
<p></p>
<p></p>
<p><pre>(define (parse-sentence)
  (list 'sentence
         (parse-noun-phrase)
         (parse-verb-phrase)))
(define (parse-verb-phrase)
  (define (maybe-extend verb-phrase)
    (amb verb-phrase
         (maybe-extend (list 'verb-phrase
                             verb-phrase
                             (parse-prepositional-phrase)))))
  (maybe-extend (parse-word verbs)))
</pre></p>
<p></p>
<p></p>
<p>While we're at it, we can also elaborate the definition of nounphrases to permit such things as “a cat in the class.”  What we usedto call a noun phrase, we'll now call a simple noun phrase, and a nounphrase will now be either a simple noun phrase or a noun phraseextended by a prepositional phrase:</p>
<p></p>
<p></p>
<p><pre>(define (parse-simple-noun-phrase)
  (list 'simple-noun-phrase
        (parse-word articles)
        (parse-word nouns)))
(define (parse-noun-phrase)
  (define (maybe-extend noun-phrase)
    (amb noun-phrase
         (maybe-extend (list 'noun-phrase
                             noun-phrase
                             (parse-prepositional-phrase)))))
  (maybe-extend (parse-simple-noun-phrase)))
</pre></p>
<p></p>
<p></p>
<p>Our new grammar lets us parse more complex sentences.  For example</p>
<p></p>
<p><pre>(parse '(the student with the cat sleeps in the class))
</pre></p>
<p></p>
<p>produces</p>
<p></p>
<p></p>
<p><pre>(sentence
 (noun-phrase
  (simple-noun-phrase (article the) (noun student))
  (prep-phrase (prep with)
               (simple-noun-phrase
                (article the) (noun cat))))
 (verb-phrase
  (verb sleeps)
  (prep-phrase (prep in)
               (simple-noun-phrase
                (article the) (noun class)))))
</pre></p>
<p></p>
<p></p>
<p>Observe that a given input may have more than one legal parse.  Inthe sentence “The professor lectures to the student with the cat,”it may be that the professor is lecturing with the cat, or that thestudent has the cat.  Our nondeterministic program finds bothpossibilities:</p>
<p></p>
<p></p>
<p><pre>(parse '(the professor lectures to the student with the cat))
</pre></p>
<p></p>
<p>produces</p>
<p></p>
<p></p>
<p><pre>(sentence
 (simple-noun-phrase (article the) (noun professor))
 (verb-phrase
  (verb-phrase
   (verb lectures)
   (prep-phrase (prep to)
                (simple-noun-phrase
                 (article the) (noun student))))
  (prep-phrase (prep with)
               (simple-noun-phrase
                (article the) (noun cat)))))
</pre></p>
<p></p>
<p>Asking the evaluator to try again yields</p>
<p></p>
<p><pre>(sentence
 (simple-noun-phrase (article the) (noun professor))
 (verb-phrase
  (verb lectures)
  (prep-phrase (prep to)
               (noun-phrase
                (simple-noun-phrase
                 (article the) (noun student))
                (prep-phrase (prep with)
                             (simple-noun-phrase
                              (article the) (noun cat)))))))
</pre></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_4.45" id="%_thm_4.45"></a><b>Exercise 4.45.</b>  With the grammar given above, the following sentence can be parsed infive different ways:“The professor lectures to the student in the class with the cat.”Give the five parses and explain the differences in shades ofmeaning among them.</p>
<p></p>
<p></p>
<p><a name="%_thm_4.46" id="%_thm_4.46"></a><b>Exercise 4.46.</b>  <a name="%_idx_4970" id="%_idx_4970"></a>The evaluators in sections <a href="book-Z-H-26.html#%_sec_4.1">4.1</a> and <a href="book-Z-H-27.html#%_sec_4.2">4.2</a>do not determine what order operands are evaluated in.We will see that the <code>amb</code> evaluator evaluates them from left to right.Explain why our parsing program wouldn't work if the operands were evaluatedin some other order.</p>
<p></p>
<p></p>
<p><a name="%_thm_4.47" id="%_thm_4.47"></a><b>Exercise 4.47.</b>  Louis Reasoner suggests that, since a verb phrase is either a verb ora verb phrase followed by a prepositional phrase, it would be much morestraightforward to define the procedure <code>parse-verb-phrase</code> asfollows (and similarly for noun phrases):</p>
<p></p>
<p><pre>(define (parse-verb-phrase)
  (amb (parse-word verbs)
       (list 'verb-phrase
             (parse-verb-phrase)
             (parse-prepositional-phrase))))
</pre></p>
<p></p>
<p>Does this work?  Does the program's behavior change if we interchangethe order of expressions in the <code>amb</code>?</p>
<p></p>
<p></p>
<p><a name="%_thm_4.48" id="%_thm_4.48"></a><b>Exercise 4.48.</b>  Extend the grammar given above to handle more complex sentences.  Forexample, you could extend noun phrases and verb phrases to includeadjectives and adverbs, or you could handle compound sentences.<a name="call_footnote_Temp_626" href="#footnote_Temp_626" id="call_footnote_Temp_626"><sup><small>53</small></sup></a></p>
<p></p>
<p></p>
<p><a name="%_thm_4.49" id="%_thm_4.49"></a><b>Exercise 4.49.</b>  <a name="%_idx_4976" id="%_idx_4976"></a>Alyssa P. Hacker is more interested in generating interestingsentences than in parsing them.  She reasons that by simply changingthe procedure <code>parse-word</code> so that it ignores the “inputsentence” and instead always succeeds and generates an appropriateword, we can use the programs we had built for parsing to dogeneration instead.  Implement Alyssa's idea, and show the firsthalf-dozen or so sentences generated.<a name="call_footnote_Temp_628" href="#footnote_Temp_628" id="call_footnote_Temp_628"><sup><small>54</small></sup></a></p>
<p></p>
<p><a name="%_sec_4.3.3" id="%_sec_4.3.3"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_4.3.3">4.3.3  Implementing the <code>Amb</code> Evaluator</a></h3>
<p><a name="%_idx_4978" id="%_idx_4978"></a>The evaluation of an ordinary Scheme expression may return a value,may never terminate, or may signal an error.  In nondeterministicScheme the evaluation of an expression may in addition result in thediscovery of a dead end, in which case evaluation must backtrack to a previouschoice point.  The interpretation of nondeterministic Scheme iscomplicated by this extra case.</p>
<p><a name="%_idx_4980" id="%_idx_4980"></a>We will construct the <code>amb</code> evaluator for nondeterministic Schemeby modifying the analyzing evaluator of section <a href="book-Z-H-26.html#%_sec_4.1.7">4.1.7</a>.<a name="call_footnote_Temp_629" href="#footnote_Temp_629" id="call_footnote_Temp_629"><sup><small>55</small></sup></a>As in the analyzing evaluator, evaluation of an expression isaccomplished by calling an <a name="%_idx_4982" id="%_idx_4982"></a>execution procedure produced by analysis ofthat expression.  The difference between the interpretation of ordinaryScheme and the interpretation of nondeterministic Scheme will be entirelyin the execution procedures.</p>
<p><a name="%_sec_Temp_630" id="%_sec_Temp_630"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_630">Execution procedures and continuations</a></h4>
<p><a name="%_idx_4984" id="%_idx_4984"></a><a name="%_idx_4986" id="%_idx_4986"></a>Recall that the execution procedures for the ordinary evaluator takeone argument: the environment of execution.  In contrast, theexecution procedures in the <code>amb</code> evaluator take three arguments:the environment, and two procedures called <em>continuationprocedures</em>.  The evaluation of an expression will finish by callingone of these two continuations: If the evaluation results in a value,the <a name="%_idx_4988" id="%_idx_4988"></a><em>success continuation</em> is called with that value; if theevaluation results in the discovery of a dead end, the <a name="%_idx_4990" id="%_idx_4990"></a><em>failurecontinuation</em> is called.  Constructing and calling appropriatecontinuations is the mechanism by which the nondeterministic evaluatorimplements backtracking.</p>
<p>It is the job of the success continuation to receive a value andproceed with the computation.  Along with that value, the successcontinuation is passed another failure continuation, which is to becalled subsequently if the use of that value leads to a dead end.</p>
<p>It is the job of the failure continuation to try another branch of thenondeterministic process.  The essence of the nondeterministiclanguage is in the fact that expressions may represent choices amongalternatives.  The evaluation of such an expression must proceed withone of the indicated alternative choices, even though it is not knownin advance which choices will lead to acceptable results.  To dealwith this, the evaluator picks one of the alternatives and passes thisvalue to the success continuation.  Together with this value, theevaluator constructs and passes along a failure continuation that canbe called later to choose a different alternative.</p>
<p>A failure is triggered during evaluation (that is, a failurecontinuation is called) when a user program explicitly rejects thecurrent line of attack (for example, a call to <code>require</code> mayresult in execution of <code>(amb)</code>, an expression that alwaysfails – see section <a href="#%_sec_4.3.1">4.3.1</a>).  The failure continuation in handat that point will cause the most recent choice point to chooseanother alternative.  If there are no more alternatives to beconsidered at that choice point, a failure at an earlier choice pointis triggered, and so on.  Failure continuations are also invoked bythe driver loop in response to a <code>try-again</code> request, to findanother value of the expression.</p>
<p>In addition, if a side-effect operation (such as assignment to avariable) occurs on a branch of the process resulting from a choice,it may be necessary, when the process finds a dead end, to undo theside effect before making a new choice.  This is accomplished byhaving the side-effect operation produce a failure continuation thatundoes the side effect and propagates the failure.</p>
<p>In summary, failure continuations are constructed by</p>
<p></p>
<ul>
<li>
<code>amb</code> expressions – to provide a mechanism to makealternative choices if the current choice made by the <code>amb</code>expression leads to a dead end;<p></p>
</li>
<li>the top-level driver – to provide a mechanism to report failurewhen the choices are exhausted;<p></p>
</li>
<li>assignments – to intercept failures and undo assignmentsduring backtracking.</li>
</ul>
<p></p>
<p>Failures are initiated only when a dead end is encountered.This occurs</p>
<p></p>
<ul>
<li>if the user program executes <code>(amb)</code>;<p></p>
</li>
<li>if the user types <code>try-again</code> at the top-level driver.</li>
</ul>
<p></p>
<p>Failure continuations are also called during processing of a failure:</p>
<p></p>
<ul>
<li>When the failure continuation created by an assignment finishesundoing a side effect, it calls the failure continuation it intercepted,in order to propagate the failure back to the choice point thatled to this assignment or to the top level.<p></p>
</li>
<li>When the failure continuation for an <code>amb</code> runs out of choices,it calls the failure continuation that was originally given to the <code>amb</code>,in order to propagate the failure back to the previous choice pointor to the top level.</li>
</ul>
<p></p>
<p><a name="%_sec_Temp_631" id="%_sec_Temp_631"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_631">Structure of the evaluator</a></h4>
<p><a name="%_idx_4992" id="%_idx_4992"></a>The syntax- and data-representation procedures for the <code>amb</code>evaluator, and also the basic <code>analyze</code> procedure, are identicalto those in the evaluator of section <a href="book-Z-H-26.html#%_sec_4.1.7">4.1.7</a>,except for the fact that we need additional syntax procedures torecognize the <code>amb</code> special form:<a name="call_footnote_Temp_632" href="#footnote_Temp_632" id="call_footnote_Temp_632"><sup><small>56</small></sup></a></p>
<p></p>
<p><pre>(define (amb? exp) (tagged-list? exp 'amb))
(define (amb-choices exp) (cdr exp))
</pre></p>
<p></p>
<p>We must also add to the dispatch in <code>analyze</code> a clause that willrecognize this special form and generate an appropriate execution procedure:</p>
<p></p>
<p></p>
<p><pre>((amb? exp) (analyze-amb exp))
</pre></p>
<p></p>
<p></p>
<p>The top-level procedure <code>ambeval</code> (similar to the version of <code>eval</code> given in section <a href="book-Z-H-26.html#%_sec_4.1.7">4.1.7</a>) analyzes thegiven expression and applies the resulting execution procedure to thegiven environment, together with two given continuations:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4994" id="%_idx_4994"></a>(define (ambeval exp env succeed fail)
  ((analyze exp) env succeed fail))
</pre></p>
<p></p>
<p></p>
<p><a name="%_idx_4996" id="%_idx_4996"></a><a name="%_idx_4998" id="%_idx_4998"></a><a name="%_idx_5000" id="%_idx_5000"></a>A success continuation is a procedure of two arguments: the value justobtained and another failure continuation to be used if that value leadsto a subsequent failure. A failure continuation is a procedure of noarguments.  So <a name="%_idx_5002" id="%_idx_5002"></a>the general form of an execution procedure is</p>
<p></p>
<p></p>
<p><pre>(lambda (env succeed fail)
  <em>;; <code>succeed</code> is <code>(lambda (value fail) <code>...</code>)</code></em>
  <em>;; <code>fail</code> is <code>(lambda () <code>...</code>)</code></em>
  <code>...</code>)
</pre></p>
<p></p>
<p></p>
<p>For example, executing</p>
<p></p>
<p></p>
<p><pre>(ambeval &lt;<em>exp</em>&gt;
         the-global-environment
         (lambda (value fail) value)
         (lambda () 'failed))
</pre></p>
<p></p>
<p>will attempt to evaluate the given expression and will returneither the expression's value (if the evaluation succeeds) orthe symbol <code>failed</code> (if the evaluation fails).The call to <code>ambeval</code> in the driver loop shown below usesmuch more complicated continuation procedures, which continue theloop and support the <code>try-again</code> request.</p>
<p>Most of the complexity of the <code>amb</code> evaluator resultsfrom the mechanics of passing the continuations around as theexecution procedures call each other.  In going through the following code,you should compare each of the execution procedures with thecorresponding procedure for the ordinary evaluator given insection <a href="book-Z-H-26.html#%_sec_4.1.7">4.1.7</a>.</p>
<p><a name="%_sec_Temp_633" id="%_sec_Temp_633"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_633">Simple expressions</a></h4>
<p>The execution procedures for the simplest kinds of expressions areessentially the same as those for the ordinary evaluator, except for theneed to manage the continuations.  The execution procedures simplysucceed with the value of the expression, passing along the failurecontinuation that was passed to them.</p>
<p><a name="%_idx_5004" id="%_idx_5004"></a></p>
<p></p>
<p><pre>(define (analyze-self-evaluating exp)
  (lambda (env succeed fail)
    (succeed exp fail)))
(define (analyze-quoted exp)
  (let ((qval (text-of-quotation exp)))
    (lambda (env succeed fail)
      (succeed qval fail))))
(define (analyze-variable exp)
  (lambda (env succeed fail)
    (succeed (lookup-variable-value exp env)
             fail)))
(define (analyze-lambda exp)
  (let ((vars (lambda-parameters exp))
        (bproc (analyze-sequence (lambda-body exp))))
    (lambda (env succeed fail)
      (succeed (make-procedure vars bproc env)
               fail))))
</pre></p>
<p></p>
<p></p>
<p><a name="%_idx_5006" id="%_idx_5006"></a>Notice that looking up a variable always “succeeds.”  If <code>lookup-variable-value</code> fails to find the variable, it signals anerror, as usual.  Such a “failure” indicates a program bug – areference to an unbound variable; it is not an indication that weshould try another nondeterministic choice instead of the one that iscurrently being tried.</p>
<p><a name="%_sec_Temp_634" id="%_sec_Temp_634"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_634">Conditionals and sequences</a></h4>
<p>Conditionals are also handled in a similar way as in the ordinaryevaluator.  The execution procedure generated by <code>analyze-if</code>invokes the predicate execution procedure <code>pproc</code> with a successcontinuation that checks whether the predicate value is true and goeson to execute either the consequent or the alternative.  If theexecution of <code>pproc</code> fails, the original failure continuation forthe <code>if</code> expression is called.</p>
<p></p>
<p></p>
<p><pre>(define (analyze-if exp)
  (let ((pproc (analyze (if-predicate exp)))
        (cproc (analyze (if-consequent exp)))
        (aproc (analyze (if-alternative exp))))
    (lambda (env succeed fail)
      (pproc env
             <em>;; success continuation for evaluating the predicate</em>
             <em>;; to obtain <code>pred-value</code></em>
             (lambda (pred-value fail2)
               (if (true? pred-value)
                   (cproc env succeed fail2)
                   (aproc env succeed fail2)))
             <em>;; failure continuation for evaluating the predicate</em>
             fail))))
</pre></p>
<p></p>
<p></p>
<p>Sequences are also handled in the same way as in the previousevaluator, except for the machinations in the subprocedure <code>sequentially</code> that are required for passing the continuations.Namely, to sequentially execute <code>a</code> and then <code>b</code>, we call <code>a</code> with a success continuation that calls <code>b</code>.</p>
<p></p>
<p></p>
<p><pre>(define (analyze-sequence exps)
  (define (sequentially a b)
    (lambda (env succeed fail)
      (a env
         <em>;; success continuation for calling <code>a</code></em>
         (lambda (a-value fail2)
           (b env succeed fail2))
         <em>;; failure continuation for calling <code>a</code></em>
         fail)))
  (define (loop first-proc rest-procs)
    (if (null? rest-procs)
        first-proc
        (loop (sequentially first-proc (car rest-procs))
              (cdr rest-procs))))
  (let ((procs (map analyze exps)))
    (if (null? procs)
        (error "Empty sequence -- ANALYZE"))
    (loop (car procs) (cdr procs))))
</pre></p>
<p></p>
<p></p>
<p><a name="%_sec_Temp_635" id="%_sec_Temp_635"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_635">Definitions and assignments</a></h4>
<p>Definitions are another case where we must go to some trouble tomanage the continuations, because it is necessary to evaluate thedefinition-value expression before actually defining the new variable.To accomplish this, the definition-value execution procedure <code>vproc</code> is called with the environment, a success continuation, and thefailure continuation.  If the execution of <code>vproc</code> succeeds,obtaining a value <code>val</code> for the defined variable, the variable isdefined and the success is propagated:</p>
<p></p>
<p></p>
<p><pre>(define (analyze-definition exp)
  (let ((var (definition-variable exp))
        (vproc (analyze (definition-value exp))))
    (lambda (env succeed fail)
      (vproc env                        
             (lambda (val fail2)
               (define-variable! var val env)
               (succeed 'ok fail2))
             fail))))
</pre></p>
<p></p>
<p></p>
<p><a name="%_idx_5008" id="%_idx_5008"></a>Assignments are more interesting.  This is the first place where wereally use the continuations, rather than just passing them around.The execution procedure for assignments starts out like the one fordefinitions.  It first attempts to obtain the new value to be assignedto the variable. If this evaluation of <code>vproc</code> fails, theassignment fails.</p>
<p>If <code>vproc</code> succeeds, however, and we go on to make the assignment,we must consider the possibility that this branch of the computationmight later fail, which will require us to backtrack out of theassignment.  Thus, we must arrange to undo the assignment aspart of the backtracking process.<a name="call_footnote_Temp_636" href="#footnote_Temp_636" id="call_footnote_Temp_636"><sup><small>57</small></sup></a></p>
<p>This is accomplished by giving <code>vproc</code> a success continuation(marked with the comment “*1*” below) that saves the old value ofthe variable before assigning the new value to thevariable and proceeding from the assignment.  The failure continuationthat is passed along with the value of the assignment (marked with thecomment “*2*” below) restores the old value of the variablebefore continuing the failure.That is, a successful assignment provides a failure continuation thatwill intercept a subsequent failure; whatever failure would otherwisehave called <code>fail2</code> calls this procedure instead, to undo theassignment before actually calling <code>fail2</code>.</p>
<p></p>
<p></p>
<p><pre>(define (analyze-assignment exp)
  (let ((var (assignment-variable exp))
        (vproc (analyze (assignment-value exp))))
    (lambda (env succeed fail)
      (vproc env
             (lambda (val fail2)        <em>; *1*</em>
               (let ((old-value
                      (lookup-variable-value var env))) 
                 (set-variable-value! var val env)
                 (succeed 'ok
                          (lambda ()    <em>; *2*</em>
                            (set-variable-value! var
                                                 old-value
                                                 env)
                            (fail2)))))
             fail))))
</pre></p>
<p></p>
<p></p>
<p><a name="%_sec_Temp_637" id="%_sec_Temp_637"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_637">Procedure applications</a></h4>
<p>The execution procedure for applications contains no new ideas exceptfor the technical complexity of managing the continuations.  Thiscomplexity arises in <code>analyze-application</code>, due to the need tokeep track of the success and failure continuations as we evaluate theoperands.  We use a procedure <code>get-args</code> to evaluate the list ofoperands, rather than a simple <code>map</code> as in the ordinary evaluator.</p>
<p></p>
<p></p>
<p><pre>(define (analyze-application exp)
  (let ((fproc (analyze (operator exp)))
        (aprocs (map analyze (operands exp))))
    (lambda (env succeed fail)
      (fproc env
             (lambda (proc fail2)
               (get-args aprocs
                         env
                         (lambda (args fail3)
                           (execute-application
                            proc args succeed fail3))
                         fail2))
             fail))))
</pre></p>
<p></p>
<p></p>
<p>In <code>get-args</code>, notice how <code>cdr</code>ing down the list of <code>aproc</code> execution procedures and <code>cons</code>ing up the resulting list of<code>args</code> is accomplished by calling each <code>aproc</code> in the listwith a success continuation that recursively calls <code>get-args</code>.Each of these recursive calls to <code>get-args</code> has a successcontinuation whose value is the <code>cons</code> of the newly obtainedargument onto the list of accumulated arguments:</p>
<p></p>
<p></p>
<p><pre>(define (get-args aprocs env succeed fail)
  (if (null? aprocs)
      (succeed '() fail)
      ((car aprocs) env
                    <em>;; success continuation for this <code>aproc</code></em>
                    (lambda (arg fail2)
                      (get-args (cdr aprocs)
                                env
                                <em>;; success continuation for recursive</em>
                                <em>;; call to <code>get-args</code></em>
                                (lambda (args fail3)
                                  (succeed (cons arg args)
                                           fail3))
                                fail2))
                    fail)))
</pre></p>
<p></p>
<p></p>
<p>The actual procedure application, which isperformed by <code>execute-application</code>, isaccomplished in the same way as for the ordinary evaluator, except forthe need to manage the continuations.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_5012" id="%_idx_5012"></a>(define (execute-application proc args succeed fail)
  (cond ((primitive-procedure? proc)
         (succeed (apply-primitive-procedure proc args)
                  fail))
        ((compound-procedure? proc)
         ((procedure-body proc)
          (extend-environment (procedure-parameters proc)
                              args
                              (procedure-environment proc))
          succeed
          fail))
        (else
         (error
          "Unknown procedure type -- EXECUTE-APPLICATION"
          proc))))
</pre></p>
<p></p>
<p></p>
<p><a name="%_sec_Temp_638" id="%_sec_Temp_638"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_638">Evaluating <code>amb</code> expressions</a></h4>
<p><a name="%_idx_5014" id="%_idx_5014"></a>The <code>amb</code> special form is the key element in the nondeterministiclanguage.  Here we see the essence of the interpretation process andthe reason for keeping track of the continuations.  The executionprocedure for <code>amb</code> defines a loop <code>try-next</code> that cyclesthrough the execution procedures for all the possible values of the<code>amb</code> expression.  Each execution procedure is called with afailure continuation that will try the next one.  When there are nomore alternatives to try, the entire <code>amb</code> expression fails.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_5016" id="%_idx_5016"></a>(define (analyze-amb exp)
  (let ((cprocs (map analyze (amb-choices exp))))
    (lambda (env succeed fail)
      (define (try-next choices)
        (if (null? choices)
            (fail)
            ((car choices) env
                           succeed
                           (lambda ()
                             (try-next (cdr choices))))))
      (try-next cprocs))))
</pre></p>
<p></p>
<p></p>
<p><a name="%_sec_Temp_639" id="%_sec_Temp_639"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_639">Driver loop</a></h4>
<p><a name="%_idx_5018" id="%_idx_5018"></a><a name="%_idx_5020" id="%_idx_5020"></a>The driver loop for the <code>amb</code> evaluator is complex, due tothe mechanism that permits the user to try again in evaluating anexpression.  The driver uses a procedure called <code>internal-loop</code>,which takes as argument a procedure <code>try-again</code>.  The intent isthat calling <code>try-again</code> should go on to the next untriedalternative in the nondeterministic evaluation.  <code>Internal-loop</code>either calls <code>try-again</code> in response to the user typing <code>try-again</code> at the driver loop, or else starts a new evaluation bycalling <code>ambeval</code>.  </p>
<p>The failure continuation for this call to <code>ambeval</code>informs the user that there are no more values and re-invokes the driver loop.</p>
<p>The success continuation for the call to <code>ambeval</code>is more subtle.  We print the obtained value and then invokethe internal loop again with a <code>try-again</code> procedure that will beable to try the next alternative.  This <code>next-alternative</code>procedure is the second argument that was passed to thesuccess continuation.  Ordinarily, we think of this second argumentas a failure continuation to be used if the current evaluation branchlater fails.  In this case, however, we have completed a successfulevaluation, so we can invoke the “failure” alternative branch inorder to search for additional successful evaluations.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_5022" id="%_idx_5022"></a>(define input-prompt ";;; Amb-Eval input:")
(define output-prompt ";;; Amb-Eval value:")
<a name="%_idx_5024" id="%_idx_5024"></a>(define (driver-loop)
  (define (internal-loop try-again)
    (prompt-for-input input-prompt)
    (let ((input (read)))
      (if (eq? input 'try-again)
          (try-again)
          (begin
            (newline)
            (display ";;; Starting a new problem ")
            (ambeval input
                     the-global-environment
                     <em>;; <code>ambeval</code> success</em>
                     (lambda (val next-alternative)
                       (announce-output output-prompt)
                       (user-print val)
                       (internal-loop next-alternative))
                     <em>;; <code>ambeval</code> failure</em>
                     (lambda ()
                       (announce-output
                        ";;; There are no more values of")
                       (user-print input)
                       (driver-loop)))))))
  (internal-loop
   (lambda ()
     (newline)
     (display ";;; There is no current problem")
     (driver-loop))))
</pre></p>
<p></p>
<p>The initial call to <code>internal-loop</code> uses a <code>try-again</code> procedure that complains that there is no currentproblem and restarts the driver loop.  This is the behavior that willhappen if the user types <code>try-again</code> when there is no evaluationin progress.</p>
<p></p>
<p><a name="%_thm_4.50" id="%_thm_4.50"></a><b>Exercise 4.50.</b>  Implement a new special form <code>ramb</code> that is like <code>amb</code> except that it searches alternatives in a random order, ratherthan from left to right.  Show how this can help with Alyssa's problemin exercise <a href="#%_thm_4.49">4.49</a>.</p>
<p></p>
<p></p>
<p><a name="%_thm_4.51" id="%_thm_4.51"></a><b>Exercise 4.51.</b>  Implement a new kind of assignment called <code>permanent-set!</code> thatis not undone upon failure.  For example, we can choose two distinctelements from a list and count the number of trials required to make asuccessful choice as follows:</p>
<p></p>
<p></p>
<p><pre>(define count 0)
(let ((x (an-element-of '(a b c)))
      (y (an-element-of '(a b c))))
  (permanent-set! count (+ count 1))
  (require (not (eq? x y)))
  (list x y count))
<i>;;; Starting a new problem</i>
<i>;;; Amb-Eval value:</i>
<i>(a b 2)</i>
<i>;;; Amb-Eval input:</i>
try-again
<i>;;; Amb-Eval value:</i>
<i>(a c 3)</i>
</pre></p>
<p></p>
<p>What values would have been displayed if we had used <code>set!</code> hererather than <code>permanent-set!</code> ?</p>
<p></p>
<p></p>
<p><a name="%_thm_4.52" id="%_thm_4.52"></a><b>Exercise 4.52.</b>  Implement a new construct called <code>if-fail</code> that permits the user tocatch the failure of an expression.  <code>If-fail</code> takes twoexpressions.  It evaluates the first expression as usual and returnsas usual if the evaluation succeeds.  If the evaluation fails,however, the value of the second expression is returned, as in thefollowing example:</p>
<p></p>
<p><pre><i>;;; Amb-Eval input:</i>
(if-fail (let ((x (an-element-of '(1 3 5))))
           (require (even? x))
           x)
         'all-odd)
<i>;;; Starting a new problem</i>
<i>;;; Amb-Eval value:</i>
<i>all-odd</i>
<i>;;; Amb-Eval input:</i>
(if-fail (let ((x (an-element-of '(1 3 5 8))))
           (require (even? x))
           x)
         'all-odd)
<i>;;; Starting a new problem</i>
<i>;;; Amb-Eval value:</i>
<i>8</i>
</pre></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_4.53" id="%_thm_4.53"></a><b>Exercise 4.53.</b>  With <code>permanent-set!</code> as described inexercise <a href="#%_thm_4.51">4.51</a> and <code>if-fail</code> as inexercise <a href="#%_thm_4.52">4.52</a>, what will be the result of evaluating</p>
<p></p>
<p><pre>(let ((pairs '()))
  (if-fail (let ((p (prime-sum-pair '(1 3 5 8) '(20 35 110))))
             (permanent-set! pairs (cons p pairs))
             (amb))
           pairs))
</pre></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_4.54" id="%_thm_4.54"></a><b>Exercise 4.54.</b>  <a name="%_idx_5026" id="%_idx_5026"></a>If we had not realized that <code>require</code> could be implemented as anordinary procedure that uses <code>amb</code>, to be defined by the user aspart of a nondeterministic program, we would have had to implement itas a special form.  This would require syntax procedures</p>
<p></p>
<p></p>
<p><pre>(define (require? exp) (tagged-list? exp 'require))

(define (require-predicate exp) (cadr exp))
</pre></p>
<p></p>
<p>and a new clause in the dispatch in <code>analyze</code></p>
<p></p>
<p></p>
<p><pre>((require? exp) (analyze-require exp))
</pre></p>
<p></p>
<p>as well the procedure <code>analyze-require</code> that handles <code>require</code>expressions.  Complete the following definition of <code>analyze-require</code>.</p>
<p></p>
<p></p>
<p><pre>(define (analyze-require exp)
  (let ((pproc (analyze (require-predicate exp))))
    (lambda (env succeed fail)
      (pproc env
             (lambda (pred-value fail2)
               (if &lt;<em>??</em>&gt;
                   &lt;<em>??</em>&gt;
                   (succeed 'ok fail2)))
             fail))))
</pre></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<div class="smallprint"><hr></div>
<p></p>
<div class="footnote">
<p><a name="footnote_Temp_598" href="#call_footnote_Temp_598" id="footnote_Temp_598"><sup><small>42</small></sup></a> We assume that we have previously defined aprocedure <code>prime?</code> that tests whether numbers are prime.  Even with<code>prime?</code> defined, the <code>prime-sum-pair</code> procedure may looksuspiciously like the unhelpful “pseudo-Lisp” attempt to define thesquare-root function, which we described at the beginning ofsection <a href="book-Z-H-10.html#%_sec_1.1.7">1.1.7</a>.  In fact, a square-root procedure along thoselines can actually be formulated as a nondeterministic program.By incorporating a search mechanism into the evaluator, weare eroding the <a name="%_idx_4816" id="%_idx_4816"></a><a name="%_idx_4818" id="%_idx_4818"></a>distinction between purely declarative descriptionsand imperative specifications of how to compute answers.  We'll goeven farther in this direction insection <a href="book-Z-H-29.html#%_sec_4.4">4.4</a>.</p>
<p><a name="footnote_Temp_599" href="#call_footnote_Temp_599" id="footnote_Temp_599"><sup><small>43</small></sup></a> The idea of <code>amb</code> for nondeterministic programming was<a name="%_idx_4824" id="%_idx_4824"></a>first described in 1961 by John McCarthy (see McCarthy 1967).</p>
<p><a name="footnote_Temp_600" href="#call_footnote_Temp_600" id="footnote_Temp_600"><sup><small>44</small></sup></a> In actuality, the distinction between nondeterministicallyreturning a single choice and returning all choices depends somewhaton our point of view.  From the perspective of the code that uses thevalue, the nondeterministic choice returns a single value.  From theperspective of the programmer designing the code, the nondeterministicchoice potentially returns all possible values, and the computationbranches so that each value is investigated separately.</p>
<p><a name="footnote_Temp_601" href="#call_footnote_Temp_601" id="footnote_Temp_601"><sup><small>45</small></sup></a> One might object that this is a hopelesslyinefficient mechanism.  It might require millions of processors tosolve some easily stated problem this way, and most of the time mostof those processors would be idle.  This objection should be taken inthe context of history.  Memory used to be considered just such anexpensive commodity.  <a name="%_idx_4838" id="%_idx_4838"></a>In 1964 a megabyte of RAM cost about $400,000.Now every personal computer has many megabytes of RAM, and most of thetime most of that RAM is unused.  It is hard to underestimate the costof mass-produced electronics.</p>
<p><a name="footnote_Temp_602" href="#call_footnote_Temp_602" id="footnote_Temp_602"><sup><small>46</small></sup></a> Automagically: “Automatically, but in a waywhich, for some reason (typically because it is too complicated, ortoo ugly, or perhaps even too trivial), the speaker doesn't feel likeexplaining.”  (Steele 1983, Raymond 1993)</p>
<p><a name="footnote_Temp_603" href="#call_footnote_Temp_603" id="footnote_Temp_603"><sup><small>47</small></sup></a> The integration of automatic search strategies<a name="%_idx_4860" id="%_idx_4860"></a>into programming languages has had a long and checkered history.  Thefirst suggestions that nondeterministic algorithms might be elegantlyencoded in a programming language with search and automaticbacktracking came from <a name="%_idx_4862" id="%_idx_4862"></a>Robert Floyd (1967).  <a name="%_idx_4864" id="%_idx_4864"></a>Carl Hewitt(1969) invented a programming language called <a name="%_idx_4866" id="%_idx_4866"></a>Planner that explicitlysupported automatic chronological backtracking, providing for abuilt-in depth-first search strategy.  <a name="%_idx_4868" id="%_idx_4868"></a><a name="%_idx_4870" id="%_idx_4870"></a><a name="%_idx_4872" id="%_idx_4872"></a>Sussman, Winograd, and Charniak(1971) implemented a subset of this language, called <a name="%_idx_4874" id="%_idx_4874"></a>MicroPlanner,which was used to support work in problem solving and robot planning.Similar ideas, arising from logic and theorem proving, led to thegenesis in Edinburgh and Marseille of the elegant language <a name="%_idx_4876" id="%_idx_4876"></a>Prolog(which we will discuss in section <a href="book-Z-H-29.html#%_sec_4.4">4.4</a>).  Aftersufficient frustration with automatic search, <a name="%_idx_4878" id="%_idx_4878"></a><a name="%_idx_4880" id="%_idx_4880"></a>McDermott and Sussman(1972) developed a language called <a name="%_idx_4882" id="%_idx_4882"></a>Conniver, which included mechanismsfor placing the search strategy under programmer control.  This provedunwieldy, however, and <a name="%_idx_4884" id="%_idx_4884"></a><a name="%_idx_4886" id="%_idx_4886"></a>Sussman and Stallman (1975) found a moretractable approach while investigating methods of symbolic analysisfor electrical circuits.  They developed a non-chronologicalbacktracking scheme that was based on tracing out the logicaldependencies connecting facts, a technique that has come to be knownas <a name="%_idx_4888" id="%_idx_4888"></a><em>dependency-directed backtracking</em>.  Although their method wascomplex, it produced reasonably efficient programs because it didlittle redundant search.  <a name="%_idx_4890" id="%_idx_4890"></a><a name="%_idx_4892" id="%_idx_4892"></a>Doyle (1979) and McAllester (1978, 1980)generalized and clarified the methods of Stallman and Sussman,developing a new paradigm for formulating search that is now called<a name="%_idx_4894" id="%_idx_4894"></a><em>truth maintenance</em>.  Modern problem-solving systems alluse some form of truth-maintenance system as a substrate.  See <a name="%_idx_4896" id="%_idx_4896"></a><a name="%_idx_4898" id="%_idx_4898"></a>Forbusand deKleer 1993 for a discussion of elegant ways to buildtruth-maintenance systems and applications using truth maintenance.<a name="%_idx_4900" id="%_idx_4900"></a><a name="%_idx_4902" id="%_idx_4902"></a><a name="%_idx_4904" id="%_idx_4904"></a>Zabih, McAllester, andChapman 1987 describes a nondeterministic extension to Scheme thatis based on <code>amb</code>; it is similar to the interpreter described inthis section, but more sophisticated, because it usesdependency-directed backtracking rather than chronological<a name="%_idx_4906" id="%_idx_4906"></a>backtracking.  Winston 1992 gives an introduction to both kinds ofbacktracking.</p>
<p><a name="footnote_Temp_609" href="#call_footnote_Temp_609" id="footnote_Temp_609"><sup><small>48</small></sup></a> Our program uses the following procedure to determineif the elements of a list are distinct:</p>
<p></p>
<p><pre><a name="%_idx_4934" id="%_idx_4934"></a>(define (distinct? items)
  (cond ((null? items) true)
        ((null? (cdr items)) true)
        ((member (car items) (cdr items)) false)
        (else (distinct? (cdr items)))))
</pre></p>
<p></p>
<p><a name="%_idx_4936" id="%_idx_4936"></a><code>Member</code> is like <code>memq</code> except that it uses <code>equal?</code> insteadof <code>eq?</code> to test for equality.</p>
<p><a name="footnote_Temp_616" href="#call_footnote_Temp_616" id="footnote_Temp_616"><sup><small>49</small></sup></a> This is taken from a booklet called “ProblematicalRecreations,” published in the 1960s by Litton Industries, where itis attributed to the <em>Kansas State Engineer</em>.</p>
<p><a name="footnote_Temp_619" href="#call_footnote_Temp_619" id="footnote_Temp_619"><sup><small>50</small></sup></a> Here we use the convention that the first element of each listdesignates the part of speech for the rest of the words in the list.</p>
<p><a name="footnote_Temp_620" href="#call_footnote_Temp_620" id="footnote_Temp_620"><sup><small>51</small></sup></a> Notice that <code>parse-word</code> uses <code>set!</code> to modify theunparsed input list.  For this to work, our <code>amb</code> evaluator mustundo the effects of <code>set!</code> operations when it backtracks.</p>
<p><a name="footnote_Temp_621" href="#call_footnote_Temp_621" id="footnote_Temp_621"><sup><small>52</small></sup></a> Observe that thisdefinition is recursive – a verb may be followed by any numberof prepositional phrases.</p>
<p><a name="footnote_Temp_626" href="#call_footnote_Temp_626" id="footnote_Temp_626"><sup><small>53</small></sup></a> This kind of grammar can become arbitrarily complex, but it<a name="%_idx_4972" id="%_idx_4972"></a>is only a toy as far as real language understanding is concerned.Real natural-language understanding by computer requires an elaboratemixture of syntactic analysis and interpretation of meaning.  On theother hand, even toy parsers can be useful in supporting flexiblecommand languages for programs such as information-retrieval systems.<a name="%_idx_4974" id="%_idx_4974"></a>Winston 1992 discusses computational approaches to reallanguage understanding and also the applications of simple grammars tocommand languages.</p>
<p><a name="footnote_Temp_628" href="#call_footnote_Temp_628" id="footnote_Temp_628"><sup><small>54</small></sup></a> Although Alyssa's idea works just fine (and issurprisingly simple), the sentences that it generates are a bitboring – they don't sample the possible sentences of this language ina very interesting way.  In fact, the grammar is highly recursive inmany places, and Alyssa's technique “falls into” one of these recursions andgets stuck.  See exercise <a href="#%_thm_4.50">4.50</a> for a way to deal with this.</p>
<p><a name="footnote_Temp_629" href="#call_footnote_Temp_629" id="footnote_Temp_629"><sup><small>55</small></sup></a> We chose to implement the lazy evaluator insection <a href="book-Z-H-27.html#%_sec_4.2">4.2</a> as a modification of the ordinarymetacircular evaluator of section <a href="book-Z-H-26.html#%_sec_4.1.1">4.1.1</a>.  Incontrast, we will base the <code>amb</code> evaluator on the analyzing evaluatorof section <a href="book-Z-H-26.html#%_sec_4.1.7">4.1.7</a>, because the execution proceduresin that evaluator provide a convenient framework for implementingbacktracking.</p>
<p><a name="footnote_Temp_632" href="#call_footnote_Temp_632" id="footnote_Temp_632"><sup><small>56</small></sup></a> We assume that the evaluator supports <code>let</code>(see exercise <a href="book-Z-H-26.html#%_thm_4.22">4.22</a>),which we have used in our nondeterministic programs.</p>
<p><a name="footnote_Temp_636" href="#call_footnote_Temp_636" id="footnote_Temp_636"><sup><small>57</small></sup></a> We didn't worry about undoing definitions, since we can<a name="%_idx_5010" id="%_idx_5010"></a>assume that internal definitions are scanned out(section <a href="book-Z-H-26.html#%_sec_4.1.6">4.1.6</a>).</p>
</div></body>
</html>
