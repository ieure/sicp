<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:ops="http://www.idpf.org/2007/ops">
<!-- Generated from TeX source by tex2page, v 4o,
     (c) Dorai Sitaram, http://www.cs.rice.edu/~dorai/tex2page -->
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta http-equiv="Content-Type: text/html; charset=utf-8" />
    <title>Structure and Interpretation of Computer Programs</title>
    <link rel="stylesheet" type="text/css" href="book-Z-C.css" title="default" />
  </head>
  <body>



<a name="%_chap_1" id="%_chap_1"></a>
<h1 class="chapter chapterheading"><a href="book-Z-H-4.html#%_toc_%_chap_1">Chapter 1</a></h1>
<p><a href="book-Z-H-4.html#%_toc_%_chap_1">Building Abstractions with Procedures</a></p>

<blockquote>The acts of the mind, wherein it exerts its power over simple ideas,
are chiefly these three: 1. Combining several simple ideas into one
compound one, and thus all complex ideas are made.  2. The second is
bringing two ideas, whether simple or complex, together, and setting
them by one another so as to take a view of them at once, without
uniting them into one, by which it gets all its ideas of relations.
3.  The third is separating them from all other ideas that accompany
them in their real existence: this is called abstraction, and thus all
its general ideas are made.</blockquote>

<p><cite><a name="%_idx_6" id="%_idx_6"></a>John Locke, An Essay Concerning Human Understanding
(1690)</cite></p>

<p>We are about to study the idea of a <a name="%_idx_8" id="%_idx_8"></a><a name="%_idx_10" id="%_idx_10"></a><em>computational process</em>.
Computational processes are abstract beings that inhabit computers.
As they evolve, processes manipulate other abstract things called <a name="%_idx_12" id="%_idx_12"></a><em>data</em>.  The evolution of a process is directed by a pattern of rules
called a <a name="%_idx_14" id="%_idx_14"></a><em>program</em>.  People create programs to direct processes.
In effect, we conjure the spirits of the computer with our spells.</p>

<p>A computational process is indeed much like a sorcerer's idea of a
spirit.  It cannot be seen or touched.  It is not composed of matter
at all.  However, it is very real.  It can perform intellectual work.
It can answer questions.  It can affect the world by disbursing money
at a bank or by controlling a robot arm in a factory.  The programs we
use to conjure processes are like a sorcerer's spells.  They are
carefully composed from symbolic expressions in arcane and esoteric
<a name="%_idx_16" id="%_idx_16"></a><em>programming languages</em> that prescribe the tasks we want our
processes to perform.</p>

<p>A computational process, in a correctly working computer, executes
programs precisely and accurately.  Thus, like the sorcerer's
apprentice, novice programmers must learn to understand and to
anticipate the consequences of their conjuring.  Even small errors
(usually called <a name="%_idx_18" id="%_idx_18"></a><em>bugs</em> or <a name="%_idx_20" id="%_idx_20"></a><em>glitches</em>) in programs can have
complex and unanticipated consequences.</p>

<p>Fortunately, learning to program is considerably less dangerous than
learning sorcery, because the spirits we deal with are conveniently
contained in a secure way.  Real-world programming, however,
requires care, expertise, and wisdom.  A small bug in a computer-aided
design program, for example, can lead to the catastrophic collapse of
an airplane or a dam or the self-destruction of an industrial robot.</p>

<p>Master software engineers have the ability to organize programs so
that they can be reasonably sure that the resulting processes will
perform the tasks intended.  They can visualize the behavior of their
systems in advance.  They know how to structure programs so that
unanticipated problems do not lead to catastrophic consequences, and
when problems do arise, they can <a name="%_idx_22" id="%_idx_22"></a><em>debug</em> their programs.  Well-designed
computational systems, like well-designed automobiles or nuclear
reactors, are designed in a modular manner, so that the parts can be
constructed, replaced, and debugged separately.</p>

<p><a name="%_sec_Temp_6" id="%_sec_Temp_6"></a></p>


</body>
</html>

