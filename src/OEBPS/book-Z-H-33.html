<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<?xml version="1.0" encoding="utf-8"?><html xmlns="http://www.w3.org/1999/xhtml" xmlns:ops="http://www.idpf.org/2007/ops">
<!-- Generated from TeX source by tex2page, v 4o,
     (c) Dorai Sitaram, http://www.cs.rice.edu/~dorai/tex2page --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Type: text/html; charset=utf-8">
<title>Structure and Interpretation of Computer Programs</title>
<link rel="stylesheet" type="text/css" href="book-Z-C.css" title="default">
</head>
<body><a name="%_sec_5.3" id="%_sec_5.3"></a><h2><a href="book-Z-H-4.html#%_toc_%_sec_5.3">5.3  Storage Allocation and Garbage Collection</a></h2>
<p><a name="%_idx_5828" id="%_idx_5828"></a><a name="%_idx_5830" id="%_idx_5830"></a>In section <a href="book-Z-H-34.html#%_sec_5.4">5.4</a>, we will show how to implement a Schemeevaluator as a register machine.  In order to simplify the discussion,we will assume that our register machines can be equipped with a <em>list-structured memory</em>, in which the basic operations formanipulating list-structured data are primitive.  Postulating theexistence of such a memory is a useful abstraction when one isfocusing on the mechanisms of control in a Scheme interpreter, butthis does not reflect a realistic view of the actual primitive dataoperations of contemporary computers.  To obtain a more completepicture of how a Lisp system operates, we must investigate how liststructure can be represented in a way that is compatible withconventional computer memories.</p>
<p>There are two considerations in implementing list structure.  Thefirst is purely an issue of representation: how to represent the“box-and-pointer” structure of Lisp pairs, using only the storageand addressing capabilities of typical computer memories.  The secondissue concerns the management of memory as a computation proceeds.The operation of a Lisp system depends crucially on the ability tocontinually create new data objects.  These include objects that areexplicitly created by the Lisp procedures being interpreted as wellas structures created by the interpreter itself, such as environmentsand argument lists.  Although the constant creation of new dataobjects would pose no problem on a computer with an infinite amount ofrapidly addressable memory, computer memories are available only infinite sizes (more's the pity).  Lisp systemsthus provide an <a name="%_idx_5832" id="%_idx_5832"></a><em>automatic storage allocation</em> facility tosupport the illusion of an infinite memory.  When a data object is nolonger needed, the memory allocated to it is automatically recycledand used to construct new data objects.  There are varioustechniques for providing such automatic storage allocation.  Themethod we shall discuss in this section is called <em>garbagecollection</em>.</p>
<p><a name="%_sec_5.3.1" id="%_sec_5.3.1"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_5.3.1">5.3.1  Memory as Vectors</a></h3>
<p></p>
<p>A conventional computer memory can be thought of as an array ofcubbyholes, each of which can contain a piece of information.  Eachcubbyhole has a unique name, called its <a name="%_idx_5834" id="%_idx_5834"></a><em>address</em> or <a name="%_idx_5836" id="%_idx_5836"></a><em>location</em>.  Typical memory systems provide two primitive operations:one that fetches the data stored in a specified location and one thatassigns new data to a specified location.  Memory addresses can beincremented to support sequential access to some set of thecubbyholes.  More generally, many important data operations requirethat memory addresses be treated as data, which can be stored inmemory locations and manipulated in machine registers.  Therepresentation of list structure is one application of such <a name="%_idx_5838" id="%_idx_5838"></a><a name="%_idx_5840" id="%_idx_5840"></a><em>address arithmetic</em>.</p>
<p>To model computer memory, we use a new kind of datastructure called a <a name="%_idx_5842" id="%_idx_5842"></a><em>vector</em>.  Abstractly, a vector is a compounddata object whose individual elements can be accessed by means of aninteger index in an amount of time that is independent of theindex.<a name="call_footnote_Temp_744" href="#footnote_Temp_744" id="call_footnote_Temp_744"><sup><small>5</small></sup></a> In order to describe memory operations, we use twoprimitive Scheme procedures for manipulating vectors:</p>
<p></p>
<p></p>
<ul>
<a name="%_idx_5844" id="%_idx_5844"></a><a name="%_idx_5846" id="%_idx_5846"></a><li>
<code>(vector-ref &lt;<em>vector</em>&gt; &lt;<em>n</em>&gt;)</code> returns the <em>n</em>thelement of the vector.<p><a name="%_idx_5848" id="%_idx_5848"></a><a name="%_idx_5850" id="%_idx_5850"></a></p>
</li>
<li>
<code>(vector-set! &lt;<em>vector</em>&gt; &lt;<em>n</em>&gt; &lt;<em>value</em>&gt;)</code> setsthe <em>n</em>th element of the vector to the designated value.</li>
</ul>
<p>For example, if <code>v</code> is a vector, then <code>(vector-ref v 5)</code> getsthe fifth entry in the vector <code>v</code> and <code>(vector-set! v 5 7)</code>changes the value of the fifth entry of the vector <code>v</code> to 7.<a name="call_footnote_Temp_745" href="#footnote_Temp_745" id="call_footnote_Temp_745"><sup><small>6</small></sup></a>For computer memory, this access can be implementedthrough the use of address arithmetic to combine a <em>base address</em>that specifies the beginning location of a vector in memory with an<em>index</em> that specifies the offset of a particular element of the vector.</p>
<p><a name="%_sec_Temp_746" id="%_sec_Temp_746"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_746">Representing Lisp data</a></h4>
<p><a name="%_idx_5852" id="%_idx_5852"></a><a name="%_idx_5854" id="%_idx_5854"></a>We can use vectors to implement the basic pair structures required fora list-structured memory.  Let us imagine that computer memory isdivided into two vectors: <a name="%_idx_5856" id="%_idx_5856"></a><code>the-cars</code> and <a name="%_idx_5858" id="%_idx_5858"></a><code>the-cdrs</code>.  We willrepresent list structure as follows: A pointer to a pair is an indexinto the two vectors.  The <code>car</code> of the pair is the entry in <code>the-cars</code> with the designated index, and the <code>cdr</code> of the pair isthe entry in <code>the-cdrs</code> with the designated index.  We also need arepresentation for objects other than pairs (such as numbers andsymbols) and a way to distinguish one kind of data from another.There are many methods of accomplishing this, but they all reduce tousing <a name="%_idx_5860" id="%_idx_5860"></a><a name="%_idx_5862" id="%_idx_5862"></a><em>typed pointers</em>, that is, to extending the notion of“pointer” to include information on data type.<a name="call_footnote_Temp_747" href="#footnote_Temp_747" id="call_footnote_Temp_747"><sup><small>7</small></sup></a> The data type enables the system todistinguish a pointer to a pair (which consists of the “pair” datatype and an index into the memory vectors) from pointers to otherkinds of data (which consist of some other data type and whatever isbeing used to represent data of that type).  Two data objects are<a name="%_idx_5868" id="%_idx_5868"></a>considered to be the same (<code>eq?</code>) if their pointers areidentical.<a name="call_footnote_Temp_748" href="#footnote_Temp_748" id="call_footnote_Temp_748"><sup><small>8</small></sup></a> Figure <a href="#%_fig_5.14">5.14</a>illustrates the use of this method to represent the list <code>((1 2) 34)</code>, whose box-and-pointer diagram is also shown.  We use letterprefixes to denote the data-type information.  Thus, a pointer to thepair with index 5 is denoted <code>p5</code>, the empty list is denoted bythe pointer <code>e0</code>, and a pointer to the number 4 is denoted <code>n4</code>.  In the box-and-pointer diagram, we have indicated at the lowerleft of each pair the vector index that specifies where the <code>car</code>and <code>cdr</code> of the pair are stored.  The blank locations in <code>the-cars</code> and <code>the-cdrs</code> may contain parts of other liststructures (not of interest here).</p>
<p><a name="%_fig_5.14" id="%_fig_5.14"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch5-Z-G-7.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 5.14:</b>  Box-and-pointer and memory-vector representationsof the list <code>((1 2) 3 4)</code>.</div></caption>
<tr><td></td></tr>
</table></div>
<p>                                                         </p>
<p>A pointer to a number, such as <code>n4</code>,might consist of a type indicating numeric data together with theactual representation of the number 4.<a name="call_footnote_Temp_749" href="#footnote_Temp_749" id="call_footnote_Temp_749"><sup><small>9</small></sup></a>To deal with numbers that are too large tobe represented in the fixed amount of space allocated for a singlepointer, we could use a distinct <a name="%_idx_5880" id="%_idx_5880"></a><em>bignum</em> data type, for which thepointer designates a list in which the parts of the number arestored.<a name="call_footnote_Temp_750" href="#footnote_Temp_750" id="call_footnote_Temp_750"><sup><small>10</small></sup></a></p>
<p><a name="%_idx_5882" id="%_idx_5882"></a>A symbol might be represented as a typed pointer that designates asequence of the characters that form the symbol's printed representation.This sequence is constructed by the Lisp reader when the character stringis initially encountered in input.  Since we want two instances of asymbol to be recognized as the “same” symbol by <code>eq?</code> and we<a name="%_idx_5884" id="%_idx_5884"></a>want <code>eq?</code> to be a simple test for equality of pointers, we mustensure that if the reader sees the same character string twice, itwill use the same pointer (to the same sequence of characters) torepresent both occurrences.  To accomplish this, the reader maintainsa table, traditionally called the <a name="%_idx_5886" id="%_idx_5886"></a><em>obarray</em>, of all the symbols ithas ever encountered.  When the reader encounters a character stringand is about to construct a symbol, it checks the obarray to see if ithas ever before seen the same character string.  If it has not, ituses the characters to construct a new symbol (a typed pointer to anew character sequence) and enters this pointer in the obarray.  If thereader has seen the string before, it returns the symbol pointerstored in the obarray.  This process of replacing character strings byunique pointers is called <a name="%_idx_5888" id="%_idx_5888"></a><a name="%_idx_5890" id="%_idx_5890"></a><em>interning</em> symbols.</p>
<p><a name="%_sec_Temp_751" id="%_sec_Temp_751"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_751">Implementing the primitive list operations</a></h4>
<p></p>
<p><a name="%_idx_5892" id="%_idx_5892"></a><a name="%_idx_5894" id="%_idx_5894"></a>Given the above representation scheme, we can replace each“primitive” list operation of a register machine with one or moreprimitive vector operations.  We will use two registers, <code>the-cars</code> and <code>the-cdrs</code>, to identify the memory vectors, and willassume that <code>vector-ref</code> and <code>vector-set!</code> are available asprimitive operations.  We also assume that numeric operations onpointers (such as incrementing a pointer, using a pair pointer toindex a vector, or adding two numbers) use only the index portion ofthe typed pointer.</p>
<p>For example, we can make a register machine support the instructions</p>
<p><a name="%_idx_5896" id="%_idx_5896"></a><a name="%_idx_5898" id="%_idx_5898"></a></p>
<p></p>
<p><pre>(assign &lt;<em>reg<sub>1</sub></em>&gt; (op car) (reg &lt;<em>reg<sub>2</sub></em>&gt;))

(assign &lt;<em>reg<sub>1</sub></em>&gt; (op cdr) (reg &lt;<em>reg<sub>2</sub></em>&gt;))
</pre></p>
<p></p>
<p>if we implement these, respectively, as</p>
<p></p>
<p></p>
<p><pre>(assign &lt;<em>reg<sub>1</sub></em>&gt; (op vector-ref) (reg the-cars) (reg &lt;<em>reg<sub>2</sub></em>&gt;))

(assign &lt;<em>reg<sub>1</sub></em>&gt; (op vector-ref) (reg the-cdrs) (reg &lt;<em>reg<sub>2</sub></em>&gt;))
</pre></p>
<p></p>
<p>The instructions</p>
<p><a name="%_idx_5900" id="%_idx_5900"></a><a name="%_idx_5902" id="%_idx_5902"></a></p>
<p></p>
<p><pre>(perform (op set-car!) (reg &lt;<em>reg<sub>1</sub></em>&gt;) (reg &lt;<em>reg<sub>2</sub></em>&gt;))

(perform (op set-cdr!) (reg &lt;<em>reg<sub>1</sub></em>&gt;) (reg &lt;<em>reg<sub>2</sub></em>&gt;))
</pre></p>
<p></p>
<p>are implemented as</p>
<p></p>
<p><pre>(perform
 (op vector-set!) (reg the-cars) (reg &lt;<em>reg<sub>1</sub></em>&gt;) (reg &lt;<em>reg<sub>2</sub></em>&gt;))

(perform
 (op vector-set!) (reg the-cdrs) (reg &lt;<em>reg<sub>1</sub></em>&gt;) (reg &lt;<em>reg<sub>2</sub></em>&gt;))
</pre></p>
<p></p>
<p></p>
<p><a name="%_idx_5904" id="%_idx_5904"></a><code>Cons</code> is performed by allocating an unused index and storing thearguments to <code>cons</code> in <code>the-cars</code> and <code>the-cdrs</code> at thatindexed vector position.  We presume that there is a special register,<a name="%_idx_5906" id="%_idx_5906"></a><code>free</code>, that always holds a pair pointer containing the nextavailable index, and that we can increment the index part of thatpointer to find the next free location.<a name="call_footnote_Temp_752" href="#footnote_Temp_752" id="call_footnote_Temp_752"><sup><small>11</small></sup></a>For example, the instruction</p>
<p></p>
<p></p>
<p><pre>(assign &lt;<em>reg<sub>1</sub></em>&gt; (op cons) (reg &lt;<em>reg<sub>2</sub></em>&gt;) (reg &lt;<em>reg<sub>3</sub></em>&gt;))
</pre></p>
<p></p>
<p>is implemented as the following sequence of vectoroperations:<a name="call_footnote_Temp_753" href="#footnote_Temp_753" id="call_footnote_Temp_753"><sup><small>12</small></sup></a></p>
<p></p>
<p></p>
<p><pre>(perform
 (op vector-set!) (reg the-cars) (reg free) (reg &lt;<em>reg<sub>2</sub></em>&gt;))
(perform
 (op vector-set!) (reg the-cdrs) (reg free) (reg &lt;<em>reg<sub>3</sub></em>&gt;))
(assign &lt;<em>reg<sub>1</sub></em>&gt; (reg free))
(assign free (op +) (reg free) (const 1))
</pre></p>
<p></p>
<p>The <code>eq?</code> operation</p>
<p></p>
<p></p>
<p><pre>(op eq?) (reg &lt;<em>reg<sub>1</sub></em>&gt;) (reg &lt;<em>reg<sub>2</sub></em>&gt;)
</pre></p>
<p></p>
<p>simply tests the equality of all fields in the registers, and<a name="%_idx_5910" id="%_idx_5910"></a><a name="%_idx_5912" id="%_idx_5912"></a><a name="%_idx_5914" id="%_idx_5914"></a><a name="%_idx_5916" id="%_idx_5916"></a>predicates such as <code>pair?</code>, <code>null?</code>, <code>symbol?</code>, and <code>number?</code> need only check the type field.</p>
<p><a name="%_sec_Temp_754" id="%_sec_Temp_754"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_754">Implementing stacks</a></h4>
<p><a name="%_idx_5918" id="%_idx_5918"></a>Although our register machines use stacks, we need do nothing specialhere, since stacks can be modeled in terms of lists.  The stack can bea list of the saved values, pointed to by a special register <code>the-stack</code>.  Thus, <code>(save &lt;<em>reg</em>&gt;)</code> can be implemented as</p>
<p><a name="%_idx_5920" id="%_idx_5920"></a></p>
<p></p>
<p><pre>(assign the-stack (op cons) (reg &lt;<em>reg</em>&gt;) (reg the-stack))
</pre></p>
<p></p>
<p><a name="%_idx_5922" id="%_idx_5922"></a>Similarly, <code>(restore &lt;<em>reg</em>&gt;)</code> can be implemented as</p>
<p></p>
<p><pre>(assign &lt;<em>reg</em>&gt; (op car) (reg the-stack))
(assign the-stack (op cdr) (reg the-stack))
</pre></p>
<p></p>
<p>and <code>(perform (op initialize-stack))</code> can be implemented as</p>
<p></p>
<p><pre>(assign the-stack (const ()))
</pre></p>
<p></p>
<p>These operations can be further expanded in terms of the vectoroperations given above.  In conventional computer architectures,however, it is usually advantageous to allocate the stack as aseparate vector.  Then pushing and popping the stack can beaccomplished by incrementing or decrementing an index into thatvector.</p>
<p></p>
<p><a name="%_thm_5.20" id="%_thm_5.20"></a><b>Exercise 5.20.</b>  Draw the box-and-pointer representation and the memory-vectorrepresentation (as in figure <a href="#%_fig_5.14">5.14</a>) of thelist structure produced by</p>
<p></p>
<p></p>
<p><pre>(define x (cons 1 2))
(define y (list x x))
</pre></p>
<p></p>
<p>with the <code>free</code> pointer initially <code>p1</code>.  What is the finalvalue of <code>free</code> ?  What pointers represent the values of <code>x</code> and <code>y</code> ?</p>
<p></p>
<p></p>
<p><a name="%_thm_5.21" id="%_thm_5.21"></a><b>Exercise 5.21.</b>  <a name="%_idx_5924" id="%_idx_5924"></a>Implement register machines for the following procedures.Assume that the list-structure memory operations are available asmachine primitives.</p>
<p></p>
<p></p>
<p>a. Recursive <code>count-leaves</code>:</p>
<p></p>
<p></p>
<p><pre>(define (count-leaves tree)
  (cond ((null? tree) 0)
        ((not (pair? tree)) 1)
        (else (+ (count-leaves (car tree))
                 (count-leaves (cdr tree))))))
</pre></p>
<p></p>
<p></p>
<p></p>
<p>b. Recursive <code>count-leaves</code> with explicit counter:</p>
<p></p>
<p></p>
<p><pre>(define (count-leaves tree)
  (define (count-iter tree n)
    (cond ((null? tree) n)
          ((not (pair? tree)) (+ n 1))
          (else (count-iter (cdr tree)
                            (count-iter (car tree) n)))))
  (count-iter tree 0))
</pre></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_5.22" id="%_thm_5.22"></a><b>Exercise 5.22.</b>  <a name="%_idx_5926" id="%_idx_5926"></a><a name="%_idx_5928" id="%_idx_5928"></a>Exercise <a href="book-Z-H-22.html#%_thm_3.12">3.12</a> of section <a href="book-Z-H-22.html#%_sec_3.3.1">3.3.1</a>presented an <code>append</code> procedure that appends two lists to form anew list and an <code>append!</code> procedure that splices two liststogether.  Design a register machine to implement each of theseprocedures.  Assume that the list-structure memory operations areavailable as primitive operations.</p>
<p><a name="%_sec_5.3.2" id="%_sec_5.3.2"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_5.3.2">5.3.2  Maintaining the Illusion of Infinite Memory</a></h3>
<p><a name="%_idx_5930" id="%_idx_5930"></a></p>
<p>The representation method outlined insection <a href="#%_sec_5.3.1">5.3.1</a> solves the problem of implementinglist structure, provided that we have an infinite amount of memory.With a real computer we will eventually run out of free space in whichto construct new pairs.<a name="call_footnote_Temp_758" href="#footnote_Temp_758" id="call_footnote_Temp_758"><sup><small>13</small></sup></a>However, most of the pairs generated in a typicalcomputation are used only to hold intermediate results.  After theseresults are accessed, the pairs are no longer needed – they are <em>garbage</em>.  For instance, the computation</p>
<p></p>
<p></p>
<p><pre>(accumulate + 0 (filter odd? (enumerate-interval 0 n)))
</pre></p>
<p></p>
<p>constructs two lists: the enumeration and the result of filteringthe enumeration.  When the accumulation is complete, these lists areno longer needed, and the allocated memory can be reclaimed.  If wecan arrange to collect all the garbage periodically, and if this turnsout to recycle memory at about the same rate at which we construct newpairs, we will have preserved the illusion that there is an infiniteamount of memory.</p>
<p>In order to recycle pairs, we must have a way to determine whichallocated pairs are not needed (in the sense that their contents canno longer influence the future of the computation).  The method weshall examine for accomplishing this is known as <em>garbagecollection</em>.  Garbage collection is based on the observation that, atany moment in a Lisp interpretation, the only objects that canaffect the future of the computation are those that can be reached bysome succession of <code>car</code> and <code>cdr</code> operations starting fromthe pointers that are currently in the machine registers.<a name="call_footnote_Temp_759" href="#footnote_Temp_759" id="call_footnote_Temp_759"><sup><small>14</small></sup></a>  Any memory cellthat is not so accessible may be recycled.</p>
<p>There are many ways to perform garbage collection.  The method weshall examine here is called <a name="%_idx_5932" id="%_idx_5932"></a><a name="%_idx_5934" id="%_idx_5934"></a><em>stop-and-copy</em>.  The basic idea isto divide memory into two halves: “working memory” and “freememory.”  When <code>cons</code> constructs pairs, it allocates these inworking memory.  When working memory is full, we perform garbagecollection by locating all the useful pairs in working memory andcopying these into consecutive locations in free memory.  (The usefulpairs are located by tracing all the <code>car</code> and <code>cdr</code> pointers,starting with the machine registers.)  Since we do not copy thegarbage, there will presumably be additional free memory that we canuse to allocate new pairs.  In addition, nothing in the working memoryis needed, since all the useful pairs in it have been copied.  Thus,if we interchange the roles of working memory and free memory, we cancontinue processing; new pairs will be allocated in the new workingmemory (which was the old free memory).  When this is full, we cancopy the useful pairs into the new free memory (which was the oldworking memory).<a name="call_footnote_Temp_760" href="#footnote_Temp_760" id="call_footnote_Temp_760"><sup><small>15</small></sup></a></p>
<p><a name="%_sec_Temp_761" id="%_sec_Temp_761"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_761">Implementation of a stop-and-copy garbage collector</a></h4>
<p>We now use our register-machine language to describe the stop-and-copyalgorithm in more detail.  We will assume that there is a registercalled <a name="%_idx_5966" id="%_idx_5966"></a><code>root</code> that contains a pointer to a structure thateventually points at all accessible data.  This can be arranged bystoring the contents of all the machine registers in apre-allocated list pointed at by <code>root</code> just before startinggarbage collection.<a name="call_footnote_Temp_762" href="#footnote_Temp_762" id="call_footnote_Temp_762"><sup><small>16</small></sup></a> We also assume that, in addition to thecurrent working memory, there is free memory available into which wecan copy the useful data.  The current working memory consists ofvectors whose base addresses are in <a name="%_idx_5968" id="%_idx_5968"></a><a name="%_idx_5970" id="%_idx_5970"></a>registers called <code>the-cars</code>and <code>the-cdrs</code>, and the free memory is in registers called <a name="%_idx_5972" id="%_idx_5972"></a><a name="%_idx_5974" id="%_idx_5974"></a><code>new-cars</code> and <code>new-cdrs</code>.</p>
<p>Garbage collection is triggered when we exhaust the free cells in thecurrent working memory, that is, when a <code>cons</code> operation attemptsto increment the <code>free</code> pointer beyond the end of the memoryvector.  When the garbage-collection process is complete, the <code>root</code> pointer will point into the new memory, all objects accessiblefrom the <code>root</code> will have been moved to the new memory, and the<code>free</code> pointer will indicate the next place in the new memorywhere a new pair can be allocated.  In addition, the roles of workingmemory and new memory will have been interchanged – new pairs will beconstructed in the new memory, beginning at the place indicated by<code>free</code>, and the (previous) working memory will be available as thenew memory for the next garbage collection.Figure <a href="#%_fig_5.15">5.15</a> shows the arrangement of memory justbefore and just after garbage collection.</p>
<p><a name="%_fig_5.15" id="%_fig_5.15"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch5-Z-G-8.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 5.15:</b>  Reconfiguration of memory by the garbage-collectionprocess.</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p><a name="%_idx_5976" id="%_idx_5976"></a><a name="%_idx_5978" id="%_idx_5978"></a>The state of the garbage-collection process is controlled bymaintaining two pointers: <code>free</code> and <code>scan</code>.  These areinitialized to point to the beginning of the new memory.  Thealgorithm begins by relocating the pair pointed at by <code>root</code> tothe beginning of the new memory.  The pair is copied, the <code>root</code>pointer is adjusted to point to the new location, and the <code>free</code>pointer is incremented.  In addition, the old location of the pair ismarked to show that its contents have been moved.  This marking isdone as follows: In the <code>car</code> position, we place a special tagthat signals that this is an already-moved object.  (Such an object istraditionally called a <a name="%_idx_5980" id="%_idx_5980"></a><em>broken heart</em>.)<a name="call_footnote_Temp_763" href="#footnote_Temp_763" id="call_footnote_Temp_763"><sup><small>17</small></sup></a>  In the <code>cdr</code> position we place a <a name="%_idx_5988" id="%_idx_5988"></a><em>forwardingaddress</em> that points at the location to which the object has beenmoved.</p>
<p>After relocating the root, the garbage collector enters its basiccycle.  At each step in the algorithm, the <code>scan</code> pointer(initially pointing at the relocated root) points at a pair that hasbeen moved to the new memory but whose <code>car</code> and <code>cdr</code>pointers still refer to objects in the old memory.  These objects areeach relocated, and the <code>scan</code> pointer is incremented.  Torelocate an object (for example, the object indicated by the <code>car</code>pointer of the pair we are scanning) we check to see if the object hasalready been moved (as indicated by the presence of a broken-heart tagin the <code>car</code> position of the object).  If the object has notalready been moved, we copy it to the place indicated by <code>free</code>,update <code>free</code>, set up a broken heart at the object's old location,and update the pointer to the object (in thisexample, the <code>car</code> pointer of the pair we are scanning) to pointto the new location.  If the object has already been moved, itsforwarding address (found in the <code>cdr</code> position of the brokenheart) is substituted for the pointer in the pair being scanned.Eventually, all accessible objects will have been moved and scanned,at which point the <code>scan</code> pointer will overtake the <code>free</code>pointer and the process will terminate.</p>
<p></p>
<p>We can specify the stop-and-copy algorithm as a sequence ofinstructions for a registermachine.  The basic step of relocating an object is accomplished by asubroutine called <code>relocate-old-result-in-new</code>.  Thissubroutine gets its argument, a pointer to the object to be relocated,from a register named <a name="%_idx_5990" id="%_idx_5990"></a><code>old</code>.  It relocates the designated object(incrementing <code>free</code> in the process),puts a pointer to the relocated object into a register called <a name="%_idx_5992" id="%_idx_5992"></a><code>new</code>, and returns by branching to the entry point stored in the register<code>relocate-continue</code>.  To begin garbage collection, we invoke thissubroutine to relocate the <code>root</code> pointer, after initializing <code>free</code> and <code>scan</code>.  When the relocation of <code>root</code> has beenaccomplished, we install the new pointer as the new <code>root</code> andenter the main loop of the garbage collector.</p>
<p></p>
<p></p>
<p><pre>begin-garbage-collection
  (assign free (const 0))
  (assign scan (const 0))
  (assign old (reg root))
  (assign relocate-continue (label reassign-root))
  (goto (label relocate-old-result-in-new))
reassign-root
  (assign root (reg new))
  (goto (label gc-loop))
</pre></p>
<p></p>
<p></p>
<p>In the main loop of the garbage collector we must determine whetherthere are any more objects to be scanned.  We do this by testingwhether the <code>scan</code> pointer is coincident with the <code>free</code>pointer.  If the pointers are equal, then all accessible objects havebeen relocated, and we branch to <code>gc-flip</code>, which cleans things upso that we can continue the interrupted computation.  If there arestill pairs to be scanned, we call the relocate subroutine to relocatethe <code>car</code> of the next pair (by placing the <code>car</code> pointer in <code>old</code>).  The <code>relocate-continue</code> register is set up so that thesubroutine will return to update the <code>car</code> pointer.</p>
<p></p>
<p></p>
<p><pre>gc-loop
  (test (op =) (reg scan) (reg free))
  (branch (label gc-flip))
  (assign old (op vector-ref) (reg new-cars) (reg scan))
  (assign relocate-continue (label update-car))
  (goto (label relocate-old-result-in-new))
</pre></p>
<p></p>
<p></p>
<p></p>
<p>At <code>update-car</code>, we modify the <code>car</code> pointer of the pair beingscanned, then proceed to relocate the <code>cdr</code> of the pair.  Wereturn to <code>update-cdr</code> when that relocation has been accomplished.After relocating and updating the <code>cdr</code>, we are finished scanningthat pair, so we continue with the main loop.</p>
<p></p>
<p></p>
<p><pre>update-car
  (perform
   (op vector-set!) (reg new-cars) (reg scan) (reg new))
  (assign old (op vector-ref) (reg new-cdrs) (reg scan))
  (assign relocate-continue (label update-cdr))
  (goto (label relocate-old-result-in-new))

update-cdr
  (perform
   (op vector-set!) (reg new-cdrs) (reg scan) (reg new))
  (assign scan (op +) (reg scan) (const 1))
  (goto (label gc-loop))
</pre></p>
<p></p>
<p></p>
<p>The subroutine <code>relocate-old-result-in-new</code> relocates objects asfollows: If the object to be relocated (pointed at by <code>old</code>) isnot a pair, then we return the same pointer to the object unchanged(in <code>new</code>).  (For example, we may be scanning a pair whose <code>car</code> is the number 4.  If we represent the <code>car</code> by <code>n4</code>, asdescribed in section <a href="#%_sec_5.3.1">5.3.1</a>, then we want the“relocated” <code>car</code> pointer to still be <code>n4</code>.)  Otherwise, wemust perform the relocation.  If the <code>car</code> position of the pair tobe relocated contains a broken-heart tag, then the pair has in factalready been moved, so we retrieve the forwarding address (from the<code>cdr</code> position of the broken heart) and return this in <code>new</code>.If the pointer in <code>old</code> points at a yet-unmoved pair, then we movethe pair to the first free cell in new memory (pointed at by <code>free</code>) and set up the broken heart by storing a broken-heart tag andforwarding address at the old location.<code>Relocate-old-result-in-new</code> uses a register <a name="%_idx_5994" id="%_idx_5994"></a><code>oldcr</code>to hold the <code>car</code> or the <code>cdr</code> of the object pointed at by<code>old</code>.<a name="call_footnote_Temp_764" href="#footnote_Temp_764" id="call_footnote_Temp_764"><sup><small>18</small></sup></a></p>
<p></p>
<p></p>
<p><pre>relocate-old-result-in-new
  (test (op pointer-to-pair?) (reg old))
  (branch (label pair))
  (assign new (reg old))
  (goto (reg relocate-continue))
pair
  (assign oldcr (op vector-ref) (reg the-cars) (reg old))
  (test (op broken-heart?) (reg oldcr))
  (branch (label already-moved))
  (assign new (reg free)) <em>; new location for pair</em>
  <em>;; Update <code>free</code> pointer.</em>
  (assign free (op +) (reg free) (const 1))
  <em>;; Copy the <code>car</code> and <code>cdr</code> to new memory.</em>
  (perform (op vector-set!)
           (reg new-cars) (reg new) (reg oldcr))
  (assign oldcr (op vector-ref) (reg the-cdrs) (reg old))
  (perform (op vector-set!)
           (reg new-cdrs) (reg new) (reg oldcr))
  <em>;; Construct the broken heart.</em>
  (perform (op vector-set!)
           (reg the-cars) (reg old) (const broken-heart))
  (perform
   (op vector-set!) (reg the-cdrs) (reg old) (reg new))
  (goto (reg relocate-continue))
already-moved
  (assign new (op vector-ref) (reg the-cdrs) (reg old))
  (goto (reg relocate-continue))
</pre></p>
<p></p>
<p></p>
<p>At the very end of the garbage-collection process, we interchange therole of old and new memories by interchanging pointers: interchanging<code>the-cars</code> with <code>new-cars</code>, and <code>the-cdrs</code> with <code>new-cdrs</code>.  We will then be ready to perform another garbagecollection the next time memory runs out.</p>
<p></p>
<p></p>
<p><pre>gc-flip
  (assign temp (reg the-cdrs))
  (assign the-cdrs (reg new-cdrs))
  (assign new-cdrs (reg temp))
  (assign temp (reg the-cars))
  (assign the-cars (reg new-cars))
  (assign new-cars (reg temp))
</pre></p>
<p></p>
<p></p>
<p></p>
<p></p>
<div class="smallprint"><hr></div>
<p></p>
<div class="footnote">
<p><a name="footnote_Temp_744" href="#call_footnote_Temp_744" id="footnote_Temp_744"><sup><small>5</small></sup></a> We could represent memory as lists of items.However, the access time would then not be independent of the index,since accessing the <em>n</em>th element of a list requires <em>n</em> - 1 <code>cdr</code>operations.</p>
<p><a name="footnote_Temp_745" href="#call_footnote_Temp_745" id="footnote_Temp_745"><sup><small>6</small></sup></a> For completeness, we should specify a <code>make-vector</code>operation that constructs vectors.  However, in the presentapplication we will use vectors only to model fixed divisions of thecomputer memory.</p>
<p><a name="footnote_Temp_747" href="#call_footnote_Temp_747" id="footnote_Temp_747"><sup><small>7</small></sup></a> This isprecisely the same <a name="%_idx_5864" id="%_idx_5864"></a><a name="%_idx_5866" id="%_idx_5866"></a>“tagged data” idea we introduced in chapter 2 fordealing with generic operations.  Here, however, the data types areincluded at the primitive machine level rather than constructedthrough the use of lists.</p>
<p><a name="footnote_Temp_748" href="#call_footnote_Temp_748" id="footnote_Temp_748"><sup><small>8</small></sup></a> Type information may be encoded in a variety ofways, depending on the details of the machine on which the Lispsystem is to be implemented.  The execution efficiency of Lispprograms will be strongly dependent on how cleverly this choice ismade, but it is difficult to formulate general design rules for goodchoices.  The most straightforward way to implement typed pointers isto allocate a fixed set of bits in each pointer to be a <a name="%_idx_5870" id="%_idx_5870"></a><em>typefield</em> that encodes the data type.  Important questions to beaddressed in designing such a representation include the following:How many type bits are required?  How large must the vector indicesbe?  How efficiently can the primitive machine instructions be used tomanipulate the type fields of pointers?  Machines that include specialhardware for the efficient handling of type fields are said to have<a name="%_idx_5872" id="%_idx_5872"></a><em>tagged architectures</em>.</p>
<p><a name="footnote_Temp_749" href="#call_footnote_Temp_749" id="footnote_Temp_749"><sup><small>9</small></sup></a> This decision on the<a name="%_idx_5874" id="%_idx_5874"></a><a name="%_idx_5876" id="%_idx_5876"></a><a name="%_idx_5878" id="%_idx_5878"></a>representation of numbers determines whether <code>eq?</code>, which testsequality of pointers, can be used to test for equality of numbers.  Ifthe pointer contains the number itself, then equal numbers will havethe same pointer.  But if the pointer contains the index of a locationwhere the number is stored, equal numbers will be guaranteed to haveequal pointers only if we are careful never to store the same numberin more than one location.</p>
<p><a name="footnote_Temp_750" href="#call_footnote_Temp_750" id="footnote_Temp_750"><sup><small>10</small></sup></a> This is just like writing a number as a sequence ofdigits, except that each “digit” is a number between 0 and thelargest number that can be stored in a single pointer.</p>
<p><a name="footnote_Temp_752" href="#call_footnote_Temp_752" id="footnote_Temp_752"><sup><small>11</small></sup></a> There are other waysof finding free storage.  For example, we could link together all theunused pairs into a <a name="%_idx_5908" id="%_idx_5908"></a><em>free list</em>.  Our free locations areconsecutive (and hence can be accessed by incrementing a pointer)because we are using a compacting garbage collector, as we will see insection <a href="#%_sec_5.3.2">5.3.2</a>.</p>
<p><a name="footnote_Temp_753" href="#call_footnote_Temp_753" id="footnote_Temp_753"><sup><small>12</small></sup></a> This is essentially the implementation of <code>cons</code> in terms of <code>set-car!</code> and <code>set-cdr!</code>, as described insection <a href="book-Z-H-22.html#%_sec_3.3.1">3.3.1</a>.  The operation <code>get-new-pair</code> used in that implementation is realized here by the <code>free</code> pointer.</p>
<p><a name="footnote_Temp_758" href="#call_footnote_Temp_758" id="footnote_Temp_758"><sup><small>13</small></sup></a> This may not be true eventually,because memories may get large enough so that it would be impossibleto run out of free memory in the lifetime of the computer.  Forexample, there are about 3× 10<sup>13</sup>, microseconds in a year, soif we were to <code>cons</code> once per microsecond we would need about10<sup>15</sup> cells of memory to build a machine that could operate for 30years without running out of memory.  That much memory seems absurdlylarge by today's standards, but it is not physically impossible.  Onthe other hand, processors are getting faster and a future computermay have large numbers of processors operating in parallel on a singlememory, so it may be possible to use up memory much faster than wehave postulated.</p>
<p><a name="footnote_Temp_759" href="#call_footnote_Temp_759" id="footnote_Temp_759"><sup><small>14</small></sup></a> Weassume here that the stack is represented as a list as described insection <a href="#%_sec_5.3.1">5.3.1</a>, so that items on the stack areaccessible via the pointer in the stack register.</p>
<p><a name="footnote_Temp_760" href="#call_footnote_Temp_760" id="footnote_Temp_760"><sup><small>15</small></sup></a> This idea was invented and first implemented<a name="%_idx_5936" id="%_idx_5936"></a>by Minsky, as part of the implementation of <a name="%_idx_5938" id="%_idx_5938"></a>Lisp for the PDP-1 at the<a name="%_idx_5940" id="%_idx_5940"></a>MIT Research Laboratory of Electronics.  It was further developed by<a name="%_idx_5942" id="%_idx_5942"></a><a name="%_idx_5944" id="%_idx_5944"></a>Fenichel and Yochelson (1969) for use in the Lisp implementation for<a name="%_idx_5946" id="%_idx_5946"></a>the Multics time-sharing system.  Later, <a name="%_idx_5948" id="%_idx_5948"></a>Baker (1978) developed a“real-time” version of the method, which does not require thecomputation to stop during garbage collection.  Baker's idea wasextended by <a name="%_idx_5950" id="%_idx_5950"></a><a name="%_idx_5952" id="%_idx_5952"></a><a name="%_idx_5954" id="%_idx_5954"></a>Hewitt, Lieberman, and Moon (see Lieberman and Hewitt1983) to take advantage of the fact that some structure is more volatileand other structure is more permanent.  </p>
<p>An alternative commonly used garbage-collection technique is the <a name="%_idx_5956" id="%_idx_5956"></a><a name="%_idx_5958" id="%_idx_5958"></a><em>mark-sweep</em> method.  This consists of tracing all the structureaccessible from the machine registers and marking each pair we reach.We then scan all of memory, and any location that is unmarked is“swept up” as garbage and made available for reuse.  A full<a name="%_idx_5960" id="%_idx_5960"></a>discussion of the mark-sweep method can be found in Allen 1978.</p>
<p>The Minsky-Fenichel-Yochelson algorithm is the dominant algorithm inuse for large-memory systems because it examines only the useful partof memory.  This is in contrast to mark-sweep, in which the sweepphase must check all of memory.  A second advantage of stop-and-copyis that it is a <a name="%_idx_5962" id="%_idx_5962"></a><a name="%_idx_5964" id="%_idx_5964"></a><em>compacting</em> garbage collector.  That is, at theend of the garbage-collection phase the useful data will have beenmoved to consecutive memory locations, with all garbage pairscompressed out.  This can be an extremely important performanceconsideration in machines with virtual memory, in which accesses towidely separated memory addresses may require extra pagingoperations.</p>
<p><a name="footnote_Temp_762" href="#call_footnote_Temp_762" id="footnote_Temp_762"><sup><small>16</small></sup></a> This list of registers does not includethe registers used by the storage-allocation system – <code>root</code>, <code>the-cars</code>, <code>the-cdrs</code>, and the other registers that will beintroduced in this section.</p>
<p><a name="footnote_Temp_763" href="#call_footnote_Temp_763" id="footnote_Temp_763"><sup><small>17</small></sup></a> The term <em><a name="%_idx_5982" id="%_idx_5982"></a>broken heart</em> was coined by David Cressey, who wrote a garbagecollector for <a name="%_idx_5984" id="%_idx_5984"></a><a name="%_idx_5986" id="%_idx_5986"></a>MDL, a dialect of Lisp developed at MIT during the early1970s.</p>
<p><a name="footnote_Temp_764" href="#call_footnote_Temp_764" id="footnote_Temp_764"><sup><small>18</small></sup></a> The garbage collector uses the low-level predicate<code>pointer-to-pair?</code> instead of the list-structure <code>pair?</code>operation because in a real system there might be various thingsthat are treated as pairs for garbage-collection purposes.For example, in a Scheme system that conforms to the IEEE standarda procedure object may be implemented as a special kind of “pair”that doesn't satisfy the <code>pair?</code> predicate.For simulation purposes, <code>pointer-to-pair?</code> can be implemented as<code>pair?</code>.</p>
</div></body>
</html>
