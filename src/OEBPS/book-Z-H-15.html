<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<?xml version="1.0" encoding="utf-8"?><html xmlns="http://www.w3.org/1999/xhtml" xmlns:ops="http://www.idpf.org/2007/ops">
<!-- Generated from TeX source by tex2page, v 4o,
     (c) Dorai Sitaram, http://www.cs.rice.edu/~dorai/tex2page --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Type: text/html; charset=utf-8">
<title>Structure and Interpretation of Computer Programs</title>
<link rel="stylesheet" type="text/css" href="book-Z-C.css" title="default">
</head>
<body><a name="%_sec_2.2" id="%_sec_2.2"></a><h2><a href="book-Z-H-4.html#%_toc_%_sec_2.2">2.2  Hierarchical Data and the Closure Property</a></h2>
<p></p>
<p>As we have seen, pairs provide a primitive “glue” that we can use toconstruct compound data objects.Figure <a href="#%_fig_2.2">2.2</a> shows a standard way tovisualize a <a name="%_idx_1526" id="%_idx_1526"></a>pair – in this case, the pair formed by <code>(cons 1 2)</code>.In this representation, which is called <a name="%_idx_1528" id="%_idx_1528"></a><em>box-and-pointernotation</em>, each object is shown as a <a name="%_idx_1530" id="%_idx_1530"></a><em>pointer</em> to a box.  The boxfor a primitive object contains a representation of the object.  Forexample, the box for a number contains a numeral.  The box for a pairis actually a double box, the left part containing (a pointer to) the<code>car</code> of the pair and the right part containing the <code>cdr</code>.</p>
<p>We have already seen that <code>cons</code> can be used to combine notonly numbers but pairs as well.  (You made use of this fact, orshould have, in doing exercises <a href="book-Z-H-14.html#%_thm_2.2">2.2</a>and <a href="book-Z-H-14.html#%_thm_2.3">2.3</a>.)  As a consequence, pairs provide a universalbuilding block from which we can construct all sorts of datastructures.  Figure <a href="#%_fig_2.3">2.3</a> shows two waysto use pairs to combine the numbers 1, 2, 3, and 4.</p>
<p><a name="%_fig_2.2" id="%_fig_2.2"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch2-Z-G-11.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 2.2:</b>  Box-and-pointer representation of <code>(cons 1 2)</code>.</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p><a name="%_fig_2.3" id="%_fig_2.3"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch2-Z-G-12.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 2.3:</b>  Two ways to combine 1, 2, 3, and 4 using pairs.</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p>The ability to create pairs whose elements are pairs is the essence oflist structure's importance as a representational tool.  We refer tothis ability as the <a name="%_idx_1532" id="%_idx_1532"></a><a name="%_idx_1534" id="%_idx_1534"></a><em>closure property</em> of <code>cons</code>.  In general,an operation for combining data objects satisfies the closure propertyif the results of combining things with that operation can themselvesbe combined using the same operation.<a name="call_footnote_Temp_154" href="#footnote_Temp_154" id="call_footnote_Temp_154"><sup><small>6</small></sup></a>Closure is the key to power inany means of combination because it permits us to create <a name="%_idx_1538" id="%_idx_1538"></a><a name="%_idx_1540" id="%_idx_1540"></a><em>hierarchical</em> structures – structures made up of parts, whichthemselves are made up of parts, and so on.</p>
<p>From the outset of chapter 1, we've made essential use of closure indealing with procedures, because all but the very simplest programsrely on the fact that the elements of a combination can themselves becombinations.  In this section, we take up the consequences of closurefor compound data.  We describe some conventional techniques for usingpairs to represent sequences and trees, and we exhibit a graphicslanguage that illustrates closure in a vivid way.<a name="call_footnote_Temp_155" href="#footnote_Temp_155" id="call_footnote_Temp_155"><sup><small>7</small></sup></a></p>
<p><a name="%_sec_2.2.1" id="%_sec_2.2.1"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_2.2.1">2.2.1  Representing Sequences</a></h3>
<p></p>
<p><a name="%_fig_2.4" id="%_fig_2.4"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch2-Z-G-13.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 2.4:</b>  The sequence 1, 2, 3, 4 represented as a chain of pairs.</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p>One of the useful structures we can build with pairs is a <a name="%_idx_1554" id="%_idx_1554"></a><a name="%_idx_1556" id="%_idx_1556"></a><a name="%_idx_1558" id="%_idx_1558"></a><em>sequence</em> – an ordered collection of data objects.  There are, ofcourse, many ways to represent sequences in terms of pairs.  Oneparticularly straightforward representation is illustrated infigure <a href="#%_fig_2.4">2.4</a>, where the sequence 1, 2, 3, 4 isrepresented as a chain of pairs.  The <code>car</code> of each pair is thecorresponding item in the chain, and the <code>cdr</code> of the pair isthe next pair in the chain.  The <code>cdr</code> of the final pairsignals the end of the sequence by pointing to a distinguishedvalue that is not a pair,represented in box-and-pointer diagrams as a diagonal line<a name="%_idx_1560" id="%_idx_1560"></a>and in programs as the value of the variable <a name="%_idx_1562" id="%_idx_1562"></a><a name="%_idx_1564" id="%_idx_1564"></a><code>nil</code>.The entire sequence is constructed by nested <code>cons</code> operations:</p>
<p></p>
<p></p>
<p><pre>(cons 1
      (cons 2
            (cons 3
                  (cons 4 nil))))
</pre></p>
<p></p>
<p></p>
<p>Such a sequence of pairs, formed by nested <code>cons</code>es, is called a<a name="%_idx_1566" id="%_idx_1566"></a><em>list</em>, and Scheme provides aprimitive called <a name="%_idx_1568" id="%_idx_1568"></a><a name="%_idx_1570" id="%_idx_1570"></a><code>list</code> to help in constructing lists.<a name="call_footnote_Temp_156" href="#footnote_Temp_156" id="call_footnote_Temp_156"><sup><small>8</small></sup></a>The above sequence could be produced by <code>(list 1 2 3 4)</code>.  Ingeneral,</p>
<p></p>
<p></p>
<p><pre>(list &lt;<em>a<sub>1</sub></em>&gt; &lt;<em>a<sub>2</sub></em>&gt; <code>...</code> &lt;<em>a<sub><em>n</em></sub></em>&gt;)
</pre></p>
<p></p>
<p>is equivalent to</p>
<p></p>
<p></p>
<p><pre>(cons &lt;<em>a<sub>1</sub></em>&gt; (cons &lt;<em>a<sub>2</sub></em>&gt; (cons <code>...</code> (cons &lt;<em>a<sub><em>n</em></sub></em>&gt; nil) <code>...</code>)))
</pre></p>
<p></p>
<p>Lisp systems conventionally print lists by printing the sequence of<a name="%_idx_1576" id="%_idx_1576"></a>elements, enclosed in parentheses.  Thus, the data object infigure <a href="#%_fig_2.4">2.4</a> is printed as <code>(1 2 3 4)</code>:</p>
<p></p>
<p></p>
<p><pre>(define one-through-four (list 1 2 3 4))

one-through-four
<i>(1 2 3 4)</i>
</pre></p>
<p></p>
<p>Be careful not to confuse the expression <code>(list 1 2 3 4)</code> with thelist <code>(1 2 3 4)</code>, which is the result obtained when the expressionis evaluated.  Attempting to evaluate the expression <code>(1 2 3 4)</code> willsignal an error when the interpreter tries to apply the procedure <code>1</code> to arguments <code>2</code>, <code>3</code>, and <code>4</code>.</p>
<p>We can think of <a name="%_idx_1578" id="%_idx_1578"></a><a name="%_idx_1580" id="%_idx_1580"></a><code>car</code> as selecting the first item in the list, andof <a name="%_idx_1582" id="%_idx_1582"></a><code>cdr</code> as selecting the sublist consisting of all but the firstitem.  Nested applications of <code>car</code> and <code>cdr</code> can be used toextract the second, third, and subsequent items in thelist.<a name="call_footnote_Temp_157" href="#footnote_Temp_157" id="call_footnote_Temp_157"><sup><small>9</small></sup></a>The constructor <a name="%_idx_1592" id="%_idx_1592"></a><code>cons</code> makes a list like the original one,but with an additional item at the beginning.</p>
<p></p>
<p></p>
<p><pre>(car one-through-four)
<i>1</i>

(cdr one-through-four)
<i>(2 3 4)</i>
(car (cdr one-through-four))
<i>2</i>

(cons 10 one-through-four)
<i>(10 1 2 3 4)</i>

(cons 5 one-through-four)
<i>(5 1 2 3 4)</i>
</pre></p>
<p></p>
<p>The value of <code>nil</code>, used to terminate the chain of pairs, can bethought of as a sequence of no elements, the <a name="%_idx_1594" id="%_idx_1594"></a><a name="%_idx_1596" id="%_idx_1596"></a><em>empty list</em>.  Theword <em>nil</em> is a contraction of the Latin word <em>nihil</em>, whichmeans “nothing.”<a name="call_footnote_Temp_158" href="#footnote_Temp_158" id="call_footnote_Temp_158"><sup><small>10</small></sup></a></p>
<p><a name="%_sec_Temp_159" id="%_sec_Temp_159"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_159">List operations</a></h4>
<p><a name="%_idx_1602" id="%_idx_1602"></a><a name="%_idx_1604" id="%_idx_1604"></a>The use of pairs to represent sequences of elements as lists isaccompanied by conventional programming techniques for manipulatinglists by successively <a name="%_idx_1606" id="%_idx_1606"></a><a name="%_idx_1608" id="%_idx_1608"></a>“<code>cdr</code>ing down” the lists.  For example,the procedure <a name="%_idx_1610" id="%_idx_1610"></a><code>list-ref</code> takes as arguments a list and a number<em>n</em> and returns the <em>n</em>th item of the list.  It is customary tonumber the elements of the list beginning with 0.  The method forcomputing <code>list-ref</code> is the following:</p>
<p></p>
<p></p>
<ul>
<li>For <em>n</em> = 0, <code>list-ref</code> should return the <code>car</code> of the list.<p></p>
</li>
<li>Otherwise, <code>list-ref</code> should return  the (<em>n</em> - 1)st item of the<code>cdr</code> of the list.</li>
</ul>
<p></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_1612" id="%_idx_1612"></a>(define (list-ref items n)
  (if (= n 0)
      (car items)
      (list-ref (cdr items) (- n 1))))
(define squares (list 1 4 9 16 25))

(list-ref squares 3)
<i>16</i>
</pre></p>
<p></p>
<p></p>
<p>Often we <code>cdr</code> down the whole list.  To aid in this, Scheme includesa primitive predicate <a name="%_idx_1614" id="%_idx_1614"></a><a name="%_idx_1616" id="%_idx_1616"></a><a name="%_idx_1618" id="%_idx_1618"></a><code>null?</code>, which tests whether its argument isthe empty list.  The procedure <a name="%_idx_1620" id="%_idx_1620"></a><a name="%_idx_1622" id="%_idx_1622"></a><code>length</code>, whichreturns the number of items in a list, illustrates this typicalpattern of use:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_1624" id="%_idx_1624"></a>(define (length items)
  (if (null? items)
      0
      (+ 1 (length (cdr items)))))
(define odds (list 1 3 5 7))

(length odds)
<i>4</i>
</pre></p>
<p></p>
<p>The <code>length</code> procedure implements a simple recursive plan. Thereduction step is:</p>
<p></p>
<p></p>
<ul><li>The <code>length</code> of any list is 1 plus the <code>length</code> of the<code>cdr</code> of the list.</li></ul>
<p></p>
<p>This is applied successively until we reach the base case:</p>
<p></p>
<p></p>
<ul><li>The <code>length</code> of the empty list is 0.</li></ul>
<p></p>
<p>We could also compute <code>length</code> in an iterative style:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_1626" id="%_idx_1626"></a>(define (length items)
  (define (length-iter a count)
    (if (null? a)
        count
        (length-iter (cdr a) (+ 1 count))))
  (length-iter items 0))
</pre></p>
<p></p>
<p></p>
<p>Another conventional programming technique is to <a name="%_idx_1628" id="%_idx_1628"></a><a name="%_idx_1630" id="%_idx_1630"></a>“<code>cons</code> up” ananswer list while <code>cdr</code>ing down a list, as in the procedure <a name="%_idx_1632" id="%_idx_1632"></a><a name="%_idx_1634" id="%_idx_1634"></a><code>append</code>, which takes two lists as arguments and combines theirelements to make a new list:</p>
<p></p>
<p></p>
<p><pre>(append squares odds)
<i>(1 4 9 16 25 1 3 5 7)</i>

(append odds squares)
<i>(1 3 5 7 1 4 9 16 25)</i>
</pre></p>
<p></p>
<p><code>Append</code> is also implemented using a recursive plan.  To <code>append</code>lists <code>list1</code> and <code>list2</code>, do the following:</p>
<p></p>
<p></p>
<ul>
<li>If <code>list1</code> is the empty list, then the result is just <code>list2</code>.<p></p>
</li>
<li>Otherwise, <code>append</code> the <code>cdr</code> of <code>list1</code> and<code>list2</code>, and <code>cons</code> the <code>car</code> of <code>list1</code> onto the result:</li>
</ul>
<p></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_1636" id="%_idx_1636"></a>(define (append list1 list2)
  (if (null? list1)
      list2
      (cons (car list1) (append (cdr list1) list2))))
</pre></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_2.17" id="%_thm_2.17"></a><b>Exercise 2.17.</b>  Define a procedure <a name="%_idx_1638" id="%_idx_1638"></a><a name="%_idx_1640" id="%_idx_1640"></a><code>last-pair</code> that returns the list that contains onlythe last element of a given (nonempty) list:</p>
<p></p>
<p></p>
<p><pre>(last-pair (list 23 72 149 34))
<i>(34)</i>
</pre></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_2.18" id="%_thm_2.18"></a><b>Exercise 2.18.</b>  Define a procedure <a name="%_idx_1642" id="%_idx_1642"></a><a name="%_idx_1644" id="%_idx_1644"></a><code>reverse</code> that takes a list as argument andreturns a list of the same elements in reverse order:</p>
<p></p>
<p></p>
<p><pre>(reverse (list 1 4 9 16 25))
<i>(25 16 9 4 1)</i>
</pre></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_2.19" id="%_thm_2.19"></a><b>Exercise 2.19.</b>  Consider the <a name="%_idx_1646" id="%_idx_1646"></a>change-counting program ofsection <a href="book-Z-H-11.html#%_sec_1.2.2">1.2.2</a>.  It would be nice to be able toeasily change the currency used by the program, so that we couldcompute the number of ways to change a British pound, for example.  Asthe program is written, the knowledge of the currency is distributedpartly into the procedure <code>first-denomination</code> and partly into theprocedure <code>count-change</code> (which knows that there are fivekinds of U.S. coins).  It would be nicer to be able tosupply a list of coins to be used for making change.</p>
<p>We want to rewrite the procedure <code>cc</code> so that itssecond argument is a list of the values of thecoins to use rather than an integer specifying which coins to use.  Wecould then have lists that defined each kind of currency:</p>
<p></p>
<p></p>
<p><pre>(define us-coins (list 50 25 10 5 1))
(define uk-coins (list 100 50 20 10 5 2 1 0.5))
</pre></p>
<p></p>
<p>We could then call <code>cc</code> as follows:</p>
<p></p>
<p></p>
<p><pre>(cc 100 us-coins)
<i>292</i>
</pre></p>
<p></p>
<p>To do this will require changing the program <code>cc</code> somewhat.  It willstill have the same form, but it will access its second argumentdifferently, as follows:</p>
<p></p>
<p></p>
<p><pre>(define (cc amount coin-values)
  (cond ((= amount 0) 1)
        ((or (&lt; amount 0) (no-more? coin-values)) 0)
        (else
         (+ (cc amount
                (except-first-denomination coin-values))
            (cc (- amount
                   (first-denomination coin-values))
                coin-values)))))
</pre></p>
<p></p>
<p>Define the procedures <code>first-denomination</code>, <code>except-first-denomination</code>, and <code>no-more?</code> in terms of primitiveoperations on list structures.  Does the order of the list <code>coin-values</code> affect the answer produced by <code>cc</code>?  Why or why not?</p>
<p></p>
<p></p>
<p><a name="%_thm_2.20" id="%_thm_2.20"></a><b>Exercise 2.20.</b>  <a name="%_idx_1648" id="%_idx_1648"></a><a name="%_idx_1650" id="%_idx_1650"></a><a name="%_idx_1652" id="%_idx_1652"></a><a name="%_idx_1654" id="%_idx_1654"></a>The procedures <code>+</code>, <code>*</code>, and <code>list</code> take arbitrary numbersof arguments. One way to define such procedures is to use <code>define</code>with <em>dotted-tail notation</em>.  In a procedure definition, a parameterlist that has a dot before the last parameter name indicates that, when theprocedure is called, the initial parameters (if any) will have as valuesthe initial arguments,as usual, but the final parameter's value will be a <em>list</em> ofany remaining arguments.For instance, given the definition</p>
<p></p>
<p><pre>(define (f x y . z) <em>&lt;body&gt;</em>)
</pre></p>
<p></p>
<p>the procedure <code>f</code> can be called with two or more arguments.If we evaluate</p>
<p></p>
<p><pre>(f 1 2 3 4 5 6)
</pre></p>
<p></p>
<p>then in the body of <code>f</code>, <code>x</code> will be 1, <code>y</code> will be2, and <code>z</code> will be the list <code>(3 4 5 6)</code>.Given the definition</p>
<p></p>
<p><pre>(define (g . w) <em>&lt;body&gt;</em>)
</pre></p>
<p></p>
<p>the procedure <code>g</code> can be called with zero or more arguments.If we evaluate</p>
<p></p>
<p><pre>(g 1 2 3 4 5 6)
</pre></p>
<p></p>
<p>then in the body of <code>g</code>, <code>w</code> will be thelist <code>(1 2 3 4 5 6)</code>.<a name="call_footnote_Temp_164" href="#footnote_Temp_164" id="call_footnote_Temp_164"><sup><small>11</small></sup></a></p>
<p>Use this notationto write a procedure <code>same-parity</code> that takes one or more integersand returns a list of all the arguments that have the same even-oddparity as the first argument.  For example,</p>
<p></p>
<p><pre>(same-parity 1 2 3 4 5 6 7)
<i>(1 3 5 7)</i>

(same-parity 2 3 4 5 6 7)
<i>(2 4 6)</i>
</pre></p>
<p></p>
<p></p>
<p><a name="%_sec_Temp_165" id="%_sec_Temp_165"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_165">Mapping over lists</a></h4>
<p><a name="%_idx_1658" id="%_idx_1658"></a><a name="%_idx_1660" id="%_idx_1660"></a>One extremely useful operation is to apply some transformationto each element in a list and generate the list of results.For instance, the following procedure scales each number in a list bya given factor:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_1662" id="%_idx_1662"></a>(define (scale-list items factor)
  (if (null? items)
      nil
      (cons (* (car items) factor)
            (scale-list (cdr items) factor))))
(scale-list (list 1 2 3 4 5) 10)
<i>(10 20 30 40 50)</i>
</pre></p>
<p></p>
<p></p>
<p>We can abstract this general idea and capture it as a common patternexpressed as a higher-order procedure, just as insection <a href="book-Z-H-12.html#%_sec_1.3">1.3</a>.  The higher-order procedurehere is called <code>map</code>.  <code>Map</code> takes as arguments a procedureof one argumentand a list, and returns a list of the results produced byapplying the procedure to each element in the list:<a name="call_footnote_Temp_166" href="#footnote_Temp_166" id="call_footnote_Temp_166"><sup><small>12</small></sup></a></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_1666" id="%_idx_1666"></a>(define (map proc items)
  (if (null? items)
      nil
      (cons (proc (car items))
            (map proc (cdr items)))))
(map abs (list -10 2.5 -11.6 17))
<i>(10 2.5 11.6 17)</i>
(map (lambda (x) (* x x))
     (list 1 2 3 4))
<i>(1 4 9 16)</i>
</pre></p>
<p></p>
<p>Now we can give a new definition of <code>scale-list</code> in terms of <code>map</code>:</p>
<p></p>
<p><pre><a name="%_idx_1668" id="%_idx_1668"></a>(define (scale-list items factor)
  (map (lambda (x) (* x factor))
       items))
</pre></p>
<p></p>
<p></p>
<p><code>Map</code> is an important construct, not only because it captures acommon pattern, but because it establishes a higher level ofabstraction in dealing with lists.  In the original definition of <code>scale-list</code>, the recursive structure of the program draws attention tothe element-by-element processing of the list.  Defining <code>scale-list</code> in terms of <code>map</code> suppresses that level of detail andemphasizes that scaling transforms a list of elements to a list ofresults.  The difference between the two definitions is not that thecomputer is performing a different process (it isn't) but that wethink about the process differently.  In effect, <code>map</code> helpsestablish an abstraction barrier that isolates the implementation ofprocedures that transform lists from the details of how theelements of the list are extracted and combined.  Like the barriersshown in figure <a href="book-Z-H-14.html#%_fig_2.1">2.1</a>, this abstraction givesus the flexibility to change the low-level details of how sequencesare implemented, while preserving the conceptual framework ofoperations that transform sequences to sequences.Section <a href="#%_sec_2.2.3">2.2.3</a> expands on this useof sequences as a framework for organizing programs.</p>
<p></p>
<p><a name="%_thm_2.21" id="%_thm_2.21"></a><b>Exercise 2.21.</b>  The procedure <code>square-list</code> takes a list ofnumbers as argument and returns a list of the squares of thosenumbers.</p>
<p></p>
<p></p>
<p><pre>(square-list (list 1 2 3 4))
<i>(1 4 9 16)</i>
</pre></p>
<p></p>
<p>Here are two different definitions of <code>square-list</code>.  Completeboth of them by filling in the missing expressions:</p>
<p></p>
<p></p>
<p><pre>(define (square-list items)
  (if (null? items)
      nil
      (cons &lt;<em>??</em>&gt; &lt;<em>??</em>&gt;)))
(define (square-list items)
  (map &lt;<em>??</em>&gt; &lt;<em>??</em>&gt;))
</pre></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_2.22" id="%_thm_2.22"></a><b>Exercise 2.22.</b>  Louis Reasoner tries to rewrite the first <code>square-list</code> procedure ofexercise <a href="#%_thm_2.21">2.21</a> so that it evolves an iterativeprocess:</p>
<p></p>
<p></p>
<p><pre>(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things) 
              (cons (square (car things))
                    answer))))
  (iter items nil))
</pre></p>
<p></p>
<p>Unfortunately, defining <code>square-list</code> this way produces the answerlist in the reverse order of the one desired.  Why?</p>
<p>Louis then tries to fix his bug by interchanging the arguments to<code>cons</code>:</p>
<p></p>
<p></p>
<p><pre>(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things)
              (cons answer
                    (square (car things))))))
  (iter items nil))
</pre></p>
<p></p>
<p>This doesn't work either.  Explain.</p>
<p></p>
<p></p>
<p><a name="%_thm_2.23" id="%_thm_2.23"></a><b>Exercise 2.23.</b>  The procedure <a name="%_idx_1670" id="%_idx_1670"></a><code>for-each</code> is similar to <code>map</code>.  It takes asarguments a procedure and a list of elements.  However, rather thanforming a list of the  results, <code>for-each</code> just applies the procedureto each of the elements in turn, from left to right.  The valuesreturned by applying the procedure to the elements are not used atall – <code>for-each</code> is used with procedures that perform an action,such as printing.  For example,</p>
<p></p>
<p><pre>(for-each (lambda (x) (newline) (display x))
          (list 57 321 88))
<i>57</i>
<i>321</i>
<i>88</i>
</pre></p>
<p></p>
<p>The value returned by the call to <code>for-each</code> (not illustrated above)can be something arbitrary, such as true.  Give animplementation of <code>for-each</code>.</p>
<p></p>
<p><a name="%_sec_2.2.2" id="%_sec_2.2.2"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_2.2.2">2.2.2  Hierarchical Structures</a></h3>
<p><a name="%_idx_1672" id="%_idx_1672"></a><a name="%_idx_1674" id="%_idx_1674"></a><a name="%_idx_1676" id="%_idx_1676"></a><a name="%_idx_1678" id="%_idx_1678"></a>The representation of sequences in terms of lists generalizesnaturally to represent sequences whose elements maythemselves be sequences.  For example, we can regard the object<code>((1 2) 3 4)</code> constructed by</p>
<p></p>
<p></p>
<p><pre>(cons (list 1 2) (list 3 4))
</pre></p>
<p></p>
<p>as a list of three items, the first of which is itself a list, <code>(1 2)</code>.  Indeed, this is suggested by the form in which the result isprinted by the interpreter.  Figure <a href="#%_fig_2.5">2.5</a> showsthe representation of this structure in terms of pairs.</p>
<p><a name="%_fig_2.5" id="%_fig_2.5"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch2-Z-G-15.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 2.5:</b>  Structure formed by <code>(cons (list 1 2) (list 3 4))</code>.</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p>Another way to think of sequences whose elements are sequences is as<em>trees</em>.  The elements of the sequence are the branches of thetree, and elements that are themselves sequences are subtrees.Figure <a href="#%_fig_2.6">2.6</a> shows the structure infigure <a href="#%_fig_2.5">2.5</a> viewed as a tree.</p>
<p><a name="%_fig_2.6" id="%_fig_2.6"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch2-Z-G-16.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 2.6:</b>  The list structure in figure <a href="#%_fig_2.5">2.5</a> viewed as a tree.</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p><a name="%_idx_1680" id="%_idx_1680"></a>Recursion is a natural tool for dealing with tree structures, sincewe can often reduce operations on trees to operations on theirbranches, which reduce in turn to operations on the branches of thebranches, and so on, until we reach the leaves of the tree.As an example, compare the <code>length</code> procedure ofsection <a href="#%_sec_2.2.1">2.2.1</a> with the <a name="%_idx_1682" id="%_idx_1682"></a><a name="%_idx_1684" id="%_idx_1684"></a><code>count-leaves</code> procedure, whichreturns the total number of leaves of a tree:</p>
<p></p>
<p></p>
<p><pre>(define x (cons (list 1 2) (list 3 4)))

(length x)
<i>3</i>
(count-leaves x)
<i>4</i>

(list x x)
<i>(((1 2) 3 4) ((1 2) 3 4))</i>

(length (list x x))
<i>2</i>

(count-leaves (list x x))
<i>8</i>
</pre></p>
<p></p>
<p></p>
<p>To implement <code>count-leaves</code>, recall the recursive plan for computing<code>length</code>:</p>
<p></p>
<p></p>
<ul>
<li>
<code>Length</code> of a list <code>x</code> is 1 plus <code>length</code> of the<code>cdr</code> of <code>x</code>.<p></p>
</li>
<li>
<code>Length</code> of the empty list is 0.</li>
</ul>
<p></p>
<p><code>Count-leaves</code> is similar.  The value for the empty list is the same:</p>
<p></p>
<p></p>
<ul><li>
<code>Count-leaves</code> of the empty list is 0.</li></ul>
<p></p>
<p>But in the reduction step, where we strip off the <code>car</code> of thelist, we must take into account that the <code>car</code> may itself be atree whose leaves we need to count.  Thus, the appropriate reductionstep is</p>
<p></p>
<p></p>
<ul><li>
<code>Count-leaves</code> of a tree <code>x</code> is <code>count-leaves</code> of the <code>car</code> of <code>x</code> plus <code>count-leaves</code> of the<code>cdr</code> of <code>x</code>.</li></ul>
<p></p>
<p>Finally, by taking <code>car</code>s we reachactual leaves, so we need another base case:</p>
<p></p>
<p></p>
<ul><li>
<code>Count-leaves</code> of a leaf is 1.</li></ul>
<p></p>
<p>To aidin writing recursive procedures on trees, Scheme provides the primitivepredicate <a name="%_idx_1686" id="%_idx_1686"></a><a name="%_idx_1688" id="%_idx_1688"></a><code>pair?</code>, which tests whether its argument is a pair.Here is the complete procedure:<a name="call_footnote_Temp_170" href="#footnote_Temp_170" id="call_footnote_Temp_170"><sup><small>13</small></sup></a></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_1690" id="%_idx_1690"></a>(define (count-leaves x)
  (cond ((null? x) 0)  
        ((not (pair? x)) 1)
        (else (+ (count-leaves (car x))
                 (count-leaves (cdr x))))))
</pre></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_2.24" id="%_thm_2.24"></a><b>Exercise 2.24.</b>  Suppose we evaluate the expression <code>(list 1 (list 2 (list 3 4)))</code>.Give the result printed by the interpreter, the correspondingbox-and-pointer structure, and the interpretation of this as a tree(as in figure <a href="#%_fig_2.6">2.6</a>).</p>
<p></p>
<p></p>
<p><a name="%_thm_2.25" id="%_thm_2.25"></a><b>Exercise 2.25.</b>  Give combinations of <code>car</code>s and <code>cdr</code>s that will pick 7 fromeach of the following lists:</p>
<p></p>
<p></p>
<p><pre>(1 3 (5 7) 9)

((7))

(1 (2 (3 (4 (5 (6 7))))))
</pre></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_2.26" id="%_thm_2.26"></a><b>Exercise 2.26.</b>  Suppose we define <code>x</code> and <code>y</code> to be two lists:</p>
<p></p>
<p></p>
<p><pre>(define x (list 1 2 3))
(define y (list 4 5 6))
</pre></p>
<p></p>
<p>What result is printed by the interpreter in response to evaluatingeach of the following expressions:</p>
<p></p>
<p></p>
<p><pre>(append x y)

(cons x y)

(list x y)
</pre></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_2.27" id="%_thm_2.27"></a><b>Exercise 2.27.</b>  Modify your <code>reverse</code> procedure of exercise <a href="#%_thm_2.18">2.18</a> toproduce a <a name="%_idx_1692" id="%_idx_1692"></a><a name="%_idx_1694" id="%_idx_1694"></a><code>deep-reverse</code> procedure that takes a list as argumentand returns as its value the list with its elements reversed and withall sublists deep-reversed as well.  For example,</p>
<p></p>
<p></p>
<p><pre>(define x (list (list 1 2) (list 3 4)))

x
<i>((1 2) (3 4))</i>

(reverse x)
<i>((3 4) (1 2))</i>

(deep-reverse x)
<i>((4 3) (2 1))</i>
</pre></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_2.28" id="%_thm_2.28"></a><b>Exercise 2.28.</b>  Write a procedure <a name="%_idx_1696" id="%_idx_1696"></a><a name="%_idx_1698" id="%_idx_1698"></a><code>fringe</code> that takes as argument a tree(represented as a list) and returns a list whose elements are all theleaves of the tree arranged in left-to-right order.  For example,</p>
<p></p>
<p></p>
<p><pre>(define x (list (list 1 2) (list 3 4)))

(fringe x)
<i>(1 2 3 4)</i>

(fringe (list x x))
<i>(1 2 3 4 1 2 3 4)</i>
</pre></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_2.29" id="%_thm_2.29"></a><b>Exercise 2.29.</b>  <a name="%_idx_1700" id="%_idx_1700"></a>A binary mobile consists of two branches, a left branch and a rightbranch.  Each branch is a rod of a certain length, from which hangseither a weight or another binary mobile.  We can represent a binarymobile using compound data by constructing it from two branches (forexample, using <code>list</code>):</p>
<p></p>
<p></p>
<p><pre>(define (make-mobile left right)
  (list left right))
</pre></p>
<p></p>
<p>A branch is constructed from a <code>length</code> (which must be a number)together with a <code>structure</code>, which may be either a number(representing a simple weight) or another mobile:</p>
<p></p>
<p></p>
<p><pre>(define (make-branch length structure)
  (list length structure))
</pre></p>
<p></p>
<p></p>
<p>a.  Write the corresponding selectors <code>left-branch</code> and<code>right-branch</code>, which return the branches of a mobile, and<code>branch-length</code> and <code>branch-structure</code>, which returnthe components of a branch.</p>
<p>b.  Using your selectors, define a procedure <code>total-weight</code>that returns the total weight of a mobile.</p>
<p>c.  A mobile is said to be <a name="%_idx_1702" id="%_idx_1702"></a><em>balanced</em> if the torque appliedby its top-left branch is equal to that applied by its top-rightbranch (that is, if the length of the left rod multiplied by theweight hanging from that rod is equal to the corresponding product forthe right side) and if each of the submobiles hanging off its branchesis balanced. Design a predicate that tests whether a binary mobile isbalanced.</p>
<p>d.  Suppose we change the representation of mobiles so that theconstructors are</p>
<p></p>
<p></p>
<p><pre>(define (make-mobile left right)
  (cons left right))
(define (make-branch length structure)
  (cons length structure))
</pre></p>
<p></p>
<p>How much do you need to change your programs to convert to the newrepresentation?</p>
<p></p>
<p><a name="%_sec_Temp_177" id="%_sec_Temp_177"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_177">Mapping over trees</a></h4>
<p><a name="%_idx_1704" id="%_idx_1704"></a><a name="%_idx_1706" id="%_idx_1706"></a>Just as <code>map</code> is a powerful abstraction for dealing with sequences,<code>map</code> together with recursion is a powerful abstraction fordealing with trees.  For instance, the <code>scale-tree</code>procedure, analogous to <code>scale-list</code> ofsection <a href="#%_sec_2.2.1">2.2.1</a>, takes as arguments a numeric factor and atree whose leaves are numbers.  It returns a tree of the same shape,where each number is multiplied by the factor.The recursive plan for <code>scale-tree</code> is similar to the one for<code>count-leaves</code>:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_1708" id="%_idx_1708"></a>(define (scale-tree tree factor)
  (cond ((null? tree) nil)
        ((not (pair? tree)) (* tree factor))
        (else (cons (scale-tree (car tree) factor)
                    (scale-tree (cdr tree) factor)))))
(scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7))
            10)
<i>(10 (20 (30 40) 50) (60 70))</i>
</pre></p>
<p></p>
<p></p>
<p>Another way to implement <code>scale-tree</code> is to regard thetree as a sequence of sub-trees and use <code>map</code>.  We mapover the sequence, scaling each sub-tree in turn, and return the listof results.  In the base case, where the tree is a leaf, we simplymultiply by the factor:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_1710" id="%_idx_1710"></a>(define (scale-tree tree factor)
  (map (lambda (sub-tree)
         (if (pair? sub-tree)
             (scale-tree sub-tree factor)
             (* sub-tree factor)))
       tree))
</pre></p>
<p></p>
<p>Many tree operations can be implemented by similar combinations ofsequence operations and recursion.</p>
<p></p>
<p><a name="%_thm_2.30" id="%_thm_2.30"></a><b>Exercise 2.30.</b>  Define a procedure <code>square-tree</code> analogous to the <code>square-list</code>procedure of exercise <a href="#%_thm_2.21">2.21</a>.  That is, <code>square-list</code> should behave as follows:</p>
<p></p>
<p></p>
<p><pre>(square-tree
 (list 1
       (list 2 (list 3 4) 5)
       (list 6 7)))
<i>(1 (4 (9 16) 25) (36 49))</i>
</pre></p>
<p></p>
<p>Define <code>square-tree</code> both directly (i.e., without using anyhigher-order procedures) and also by using <code>map</code> and recursion.</p>
<p></p>
<p></p>
<p><a name="%_thm_2.31" id="%_thm_2.31"></a><b>Exercise 2.31.</b>  Abstract your answer to exercise <a href="#%_thm_2.30">2.30</a> to produce aprocedure <a name="%_idx_1712" id="%_idx_1712"></a><code>tree-map</code> with the property that <code>square-tree</code>could be defined as</p>
<p></p>
<p></p>
<p><pre>(define (square-tree tree) (tree-map square tree))
</pre></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_2.32" id="%_thm_2.32"></a><b>Exercise 2.32.</b>  We can represent a <a name="%_idx_1714" id="%_idx_1714"></a>set as a list of distinct elements, and we canrepresent the set of all subsets of the set as a list of lists.  Forexample, if the set is <code>(1 2 3)</code>, then the set of all subsets is<code>(() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3))</code>.  Complete thefollowing definition of a procedure that generates the set of subsetsof a set and give a clear explanation of why it works:</p>
<p></p>
<p><pre><a name="%_idx_1716" id="%_idx_1716"></a>(define (subsets s)
  (if (null? s)
      (list nil)
      (let ((rest (subsets (cdr s))))
        (append rest (map &lt;<em>??</em>&gt; rest)))))
</pre></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_sec_2.2.3" id="%_sec_2.2.3"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_2.2.3">2.2.3  Sequences as Conventional Interfaces</a></h3>
<p><a name="%_idx_1718" id="%_idx_1718"></a><a name="%_idx_1720" id="%_idx_1720"></a>In working with compound data, we've stressed how data abstractionpermits us to design programs without becoming enmeshed in the detailsof data representations, and how abstraction preserves for us theflexibility to experiment with alternative representations.  In thissection, we introduce another powerful design principle for workingwith data structures – the use of <em>conventional interfaces</em>.</p>
<p>In section <a href="book-Z-H-12.html#%_sec_1.3">1.3</a> we saw how programabstractions, implemented as higher-order procedures, can capturecommon patterns in programs that deal with numerical data.  Ourability to formulate analogous operations for working with compounddata depends crucially on the style in which we manipulate our datastructures.  Consider, for example, the following procedure, analogousto the <code>count-leaves</code> procedure of section <a href="#%_sec_2.2.2">2.2.2</a>, whichtakes a tree as argument and computes the sum of the squares of theleaves that are odd:</p>
<p></p>
<p><pre><a name="%_idx_1722" id="%_idx_1722"></a>(define (sum-odd-squares tree)
  (cond ((null? tree) 0)  
        ((not (pair? tree))
         (if (odd? tree) (square tree) 0))
        (else (+ (sum-odd-squares (car tree))
                 (sum-odd-squares (cdr tree))))))
</pre></p>
<p></p>
<p>On the surface, this procedure is very different from the followingone, which constructs a list of all the even Fibonacci numbers <em>F</em><em>i</em><em>b</em>(<em>k</em>), where <em>k</em> is less than or equal to a given integer <em>n</em>:</p>
<p></p>
<p><pre><a name="%_idx_1724" id="%_idx_1724"></a>(define (even-fibs n)
  (define (next k)
    (if (&gt; k n)
        nil
        (let ((f (fib k)))
          (if (even? f)
              (cons f (next (+ k 1)))
              (next (+ k 1))))))
  (next 0))
</pre></p>
<p></p>
<p></p>
<p>Despite the fact that these two procedures are structurally verydifferent, a more abstract description of the two computations revealsa great deal of similarity.  The first program</p>
<p></p>
<ul>
<li>enumerates the leaves of a tree;</li>
<li>filters them, selecting the odd ones;</li>
<li>squares each of the selected ones; and</li>
<li>accumulates the results using <code>+</code>, starting with 0.</li>
</ul>
<p>The second program</p>
<p></p>
<ul>
<li>enumerates the integers from 0 to <em>n</em>;</li>
<li>computes the Fibonacci number for each integer;</li>
<li>filters them, selecting the even ones; and</li>
<li>accumulates the results using <code>cons</code>,  starting with theempty list.</li>
</ul>
<p></p>
<p><a name="%_idx_1726" id="%_idx_1726"></a><a name="%_idx_1728" id="%_idx_1728"></a>A signal-processing engineer would find it natural to conceptualizethese processes in terms of signals flowing through a cascade ofstages, each of which implements part of the program plan, as shown infigure <a href="#%_fig_2.7">2.7</a>.  In <code>sum-odd-squares</code>, webegin with an <a name="%_idx_1730" id="%_idx_1730"></a><em>enumerator</em>, which generates a “signal”consisting of the leaves of a given tree.  This signal is passedthrough a <a name="%_idx_1732" id="%_idx_1732"></a><em>filter</em>, which eliminates all but the odd elements.The resulting signal is in turn passed through a <a name="%_idx_1734" id="%_idx_1734"></a><em>map</em>, which is a“transducer” that applies the <code>square</code> procedure to eachelement.  The output of the map is then fed to an <a name="%_idx_1736" id="%_idx_1736"></a><em>accumulator</em>,which combines the elements using <code>+</code>, starting from an initial 0.The plan for <code>even-fibs</code> is analogous.</p>
<p><a name="%_fig_2.7" id="%_fig_2.7"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch2-Z-G-17.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 2.7:</b>  The signal-flow plans for the procedures <code>sum-odd-squares</code> (top) and <code>even-fibs</code> (bottom) reveal thecommonality between the two programs.</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p>Unfortunately, the two procedure definitions above fail to exhibit thissignal-flow structure.  For instance, if we examine the <code>sum-odd-squares</code> procedure, we find that the enumeration isimplemented partly by the <code>null?</code> and <code>pair?</code> tests and partlyby the tree-recursive structure of the procedure.  Similarly, theaccumulation is found partly in the tests and partly in the addition usedin the recursion.  In general, there are no distinct parts of eitherprocedure that correspond to the elements in the signal-flowdescription.Our two procedures decompose the computations in a different way,spreading the enumeration over the program and mingling it with themap, the filter, and the accumulation.  If we could organize ourprograms to make the signal-flow structure manifest in the procedureswe write, this would increase the conceptual clarity of the resultingcode.</p>
<p><a name="%_sec_Temp_181" id="%_sec_Temp_181"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_181">Sequence Operations</a></h4>
<p><a name="%_idx_1738" id="%_idx_1738"></a>The key to organizing programs so as to more clearly reflect thesignal-flow structure is to concentrate on the “signals” that flowfrom one stage in the process to the next.  If we represent thesesignals as lists, then we can use list operations to implement theprocessing at each of the stages.  For instance, we can implement themapping stages of the signal-flow diagrams using the <code>map</code>procedure from section <a href="#%_sec_2.2.1">2.2.1</a>:</p>
<p></p>
<p><pre>(map square (list 1 2 3 4 5))
<i>(1 4 9 16 25)</i>
</pre></p>
<p></p>
<p></p>
<p>Filtering a sequence to select only those elements that satisfy agiven predicate is accomplished by</p>
<p></p>
<p><pre><a name="%_idx_1740" id="%_idx_1740"></a>(define (filter predicate sequence)
  (cond ((null? sequence) nil)
        ((predicate (car sequence))
         (cons (car sequence)
               (filter predicate (cdr sequence))))
        (else (filter predicate (cdr sequence)))))
</pre></p>
<p></p>
<p>For example,</p>
<p></p>
<p><pre>(filter odd? (list 1 2 3 4 5))
<i>(1 3 5)</i>
</pre></p>
<p></p>
<p></p>
<p>Accumulations can be implemented by</p>
<p></p>
<p><pre><a name="%_idx_1742" id="%_idx_1742"></a>(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))
(accumulate + 0 (list 1 2 3 4 5))
<i>15</i>
(accumulate * 1 (list 1 2 3 4 5))
<i>120</i>
(accumulate cons nil (list 1 2 3 4 5))
<i>(1 2 3 4 5)</i>
</pre></p>
<p></p>
<p></p>
<p>All that remains to implement signal-flow diagrams is to enumerate thesequence of elements to be processed.  For <code>even-fibs</code>, we need togenerate the sequence ofintegers in a given range, which we can do as follows:</p>
<p></p>
<p><pre><a name="%_idx_1744" id="%_idx_1744"></a>(define (enumerate-interval low high)
  (if (&gt; low high)
      nil
      (cons low (enumerate-interval (+ low 1) high))))
(enumerate-interval 2 7)
<i>(2 3 4 5 6 7)</i>
</pre></p>
<p></p>
<p>To enumerate the leaves of a tree, we can use<a name="call_footnote_Temp_182" href="#footnote_Temp_182" id="call_footnote_Temp_182"><sup><small>14</small></sup></a></p>
<p></p>
<p><pre><a name="%_idx_1748" id="%_idx_1748"></a><a name="%_idx_1750" id="%_idx_1750"></a>(define (enumerate-tree tree)
  (cond ((null? tree) nil)
        ((not (pair? tree)) (list tree))
        (else (append (enumerate-tree (car tree))
                      (enumerate-tree (cdr tree))))))
(enumerate-tree (list 1 (list 2 (list 3 4)) 5))
<i>(1 2 3 4 5)</i>
</pre></p>
<p></p>
<p></p>
<p>Now we can reformulate <code>sum-odd-squares</code> and <code>even-fibs</code> as inthe signal-flow diagrams.  For <code>sum-odd-squares</code>, we enumerate thesequence of leaves of the tree, filter this to keep only the oddnumbers in the sequence, square each element, and sum the results:</p>
<p></p>
<p><pre><a name="%_idx_1752" id="%_idx_1752"></a>(define (sum-odd-squares tree)
  (accumulate +
              0
              (map square
                   (filter odd?
                           (enumerate-tree tree)))))
</pre></p>
<p></p>
<p>For <code>even-fibs</code>, we enumerate the integers from 0 to <em>n</em>, generatethe Fibonacci number for each of these integers, filter the resultingsequence to keep only the even elements, and accumulate the resultsinto a list:</p>
<p></p>
<p><pre><a name="%_idx_1754" id="%_idx_1754"></a>(define (even-fibs n)
  (accumulate cons
              nil
              (filter even?
                      (map fib
                           (enumerate-interval 0 n)))))
</pre></p>
<p></p>
<p></p>
<p>The value of expressing programs as sequence operations is that thishelps us make program designs that are modular, that is, designs thatare constructed by combining relatively independent pieces.  We canencourage modular design by providing a library of standard componentstogether with a conventional interface for connecting the componentsin flexible ways.</p>
<p><a name="%_idx_1756" id="%_idx_1756"></a><a name="%_idx_1758" id="%_idx_1758"></a>Modular construction is a powerful strategy forcontrolling complexity in engineering design.  In realsignal-processing applications, for example, designers regularly buildsystems by cascading elements selected from standardized families offilters and transducers.  Similarly, sequence operations provide alibrary of standard program elements that we can mix and match.  Forinstance, we can reuse pieces from the <code>sum-odd-squares</code> and <code>even-fibs</code> procedures in a program that constructs a list of thesquares of the first <em>n</em> + 1 Fibonacci numbers:</p>
<p></p>
<p><pre>(define (list-fib-squares n)
  (accumulate cons
              nil
              (map square
                   (map fib
                        (enumerate-interval 0 n)))))
(list-fib-squares 10)
<i>(0 1 1 4 9 25 64 169 441 1156 3025)</i>
</pre></p>
<p></p>
<p>We can rearrange the pieces and use them in computing the product ofthe odd integers in a sequence:</p>
<p></p>
<p><pre>(define (product-of-squares-of-odd-elements sequence)
  (accumulate *
              1
              (map square
                   (filter odd? sequence))))
(product-of-squares-of-odd-elements (list 1 2 3 4 5))
<i>225</i>
</pre></p>
<p></p>
<p></p>
<p>We can also formulate conventional data-processing applications interms of sequence operations.  Suppose we have a sequence of personnelrecords and we want to find the salary of the highest-paid programmer.Assume that we have a selector <code>salary</code> that returns the salary ofa record, and a predicate <code>programmer?</code> that tests if a record isfor a programmer.  Then we can write</p>
<p></p>
<p><pre>(define (salary-of-highest-paid-programmer records)
  (accumulate max
              0
              (map salary
                   (filter programmer? records))))
</pre></p>
<p></p>
<p>These examples give just a hint of the vast range of operations thatcan be expressed as sequence operations.<a name="call_footnote_Temp_183" href="#footnote_Temp_183" id="call_footnote_Temp_183"><sup><small>15</small></sup></a></p>
<p>Sequences, implemented here as lists, serveas a conventional interface that permits us to combine processingmodules.  Additionally, when we uniformly represent structures assequences, we have localized the data-structure dependencies in ourprograms to a small number of sequence operations.  By changing these,we can experiment with alternative representations of sequences, whileleaving the overall design of our programs intact.  We will exploitthis capability in section <a href="book-Z-H-24.html#%_sec_3.5">3.5</a>, when we generalize thesequence-processing paradigm to admit infinite sequences.</p>
<p></p>
<p><a name="%_thm_2.33" id="%_thm_2.33"></a><b>Exercise 2.33.</b>  Fill in the missing expressions to complete the following definitionsof some basic list-manipulation operations as accumulations:</p>
<p></p>
<p><pre><a name="%_idx_1766" id="%_idx_1766"></a>(define (map p sequence)
  (accumulate (lambda (x y) &lt;<em>??</em>&gt;) nil sequence))
<a name="%_idx_1768" id="%_idx_1768"></a>(define (append seq1 seq2)
  (accumulate cons &lt;<em>??</em>&gt; &lt;<em>??</em>&gt;))
<a name="%_idx_1770" id="%_idx_1770"></a>(define (length sequence)
  (accumulate &lt;<em>??</em>&gt; 0 sequence))
</pre></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_2.34" id="%_thm_2.34"></a><b>Exercise 2.34.</b>  <a name="%_idx_1772" id="%_idx_1772"></a>Evaluating a polynomial in <em>x</em> at a given value of <em>x</em> can beformulated as an accumulation.  We evaluate the polynomial</p><p><em>a<sub>n</sub>x<sup>n</sup></em> + <em>a</em><sub><em>n</em>-1</sub><em>x</em><sup><em>n</em>-1</sup> + ⋯ + <em>a</em><sub>1</sub><em>x</em> + <em>a</em><sub>0</sub></p><p>using a well-known algorithm called <a name="%_idx_1774" id="%_idx_1774"></a><em>Horner's rule</em>, whichstructures the computation as</p><p>(⋯ (<em>a<sub>n</sub>x</em> + <em>a</em><sub><em>n</em>-1</sub>)<em>x</em> + ⋯ + <em>a</em><sub>1</sub>) <em>x</em> + <em>a</em><sub>0</sub></p><p>In other words, we start with <em>a</em><sub><em>n</em></sub>, multiply by <em>x</em>, add <em>a</em><sub><em>n</em>-1</sub>,multiply by <em>x</em>, and so on, until we reach <em>a</em><sub>0</sub>.<a name="call_footnote_Temp_186" href="#footnote_Temp_186" id="call_footnote_Temp_186"><sup><small>16</small></sup></a>Fill in the following template to produce a procedure that evaluates apolynomial using Horner's rule.Assume that the coefficients of thepolynomial are arranged in a sequence, from <em>a</em><sub>0</sub> through <em>a</em><sub><em>n</em></sub>.</p>
<p></p>
<p><pre>(define (horner-eval x coefficient-sequence)
  (accumulate (lambda (this-coeff higher-terms) &lt;<em>??</em>&gt;)
              0
              coefficient-sequence))
</pre></p>
<p></p>
<p>For example, to compute 1 + 3<em>x</em> + 5<em>x</em><sup>3</sup> + <em>x</em><sup>5</sup> at <em>x</em> = 2 you would evaluate</p>
<p></p>
<p><pre>(horner-eval 2 (list 1 3 0 5 0 1))
</pre></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_2.35" id="%_thm_2.35"></a><b>Exercise 2.35.</b>  Redefine <code>count-leaves</code> from section <a href="#%_sec_2.2.2">2.2.2</a> as anaccumulation:</p>
<p></p>
<p><pre><a name="%_idx_1792" id="%_idx_1792"></a>(define (count-leaves t)
  (accumulate &lt;<em>??</em>&gt; &lt;<em>??</em>&gt; (map &lt;<em>??</em>&gt; &lt;<em>??</em>&gt;)))
</pre></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_2.36" id="%_thm_2.36"></a><b>Exercise 2.36.</b>  The procedure <code>accumulate-n</code> is similar to <code>accumulate</code> exceptthat it takes as its third argument a sequence of sequences, which are allassumed to have the same number of elements.  It applies thedesignated accumulation procedure to combine all the first elements ofthe sequences, all the second elements of the sequences, and so on, andreturns a sequence of the results.  For instance, if <code>s</code> is a sequencecontaining four sequences, <code>((1 2 3) (4 5 6) (7 8 9) (10 11 12)),</code>then the value of <code>(accumulate-n + 0 s)</code> should be the sequence <code>(22 26 30)</code>.  Fill in the missing expressionsin the following definition of <code>accumulate-n</code>:</p>
<p></p>
<p><pre><a name="%_idx_1794" id="%_idx_1794"></a>(define (accumulate-n op init seqs)
  (if (null? (car seqs))
      nil
      (cons (accumulate op init &lt;<em>??</em>&gt;)
            (accumulate-n op init &lt;<em>??</em>&gt;))))
</pre></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_2.37" id="%_thm_2.37"></a><b>Exercise 2.37.</b>  <a name="%_idx_1796" id="%_idx_1796"></a><a name="%_idx_1798" id="%_idx_1798"></a><a name="%_idx_1800" id="%_idx_1800"></a>Suppose we represent vectors <em>v</em> = (<em>v</em><sub><em>i</em></sub>) as sequences of numbers, andmatrices <em>m</em> = (<em>m</em><sub><em>i</em><em>j</em></sub>) as sequences of vectors (the rows of the matrix).For example, the matrix</p><table id="ch2-Z-G-20">
<tr>
<td class="cap left top"></td>        <td>1</td>        <td>2</td>        <td>3</td>        <td>4</td>        <td class="cap right top"></td>    </tr>
<tr>
<td class="cap left"></td>        <td>4</td>        <td>5</td>        <td>6</td>        <td>6</td>        <td class="cap right"></td>    </tr>
<tr>
<td class="cap left bottom"></td>        <td>6</td>        <td>7</td>        <td>8</td>        <td>9</td>        <td class="cap right bottom"></td>    </tr>
</table>
<p>is represented as the sequence <code>((1 2 3 4) (4 5 6 6) (6 7 8 9))</code>.With this representation, we can use sequence operations to conciselyexpress the basic matrix and vector operations.  These operations(which are described in any book on matrix algebra) are the following:</p><p>    <code>(dot-product <em>v w</em>)      </code>returns the sum ∑<sub><em>i</em></sub><em>v<sub>i</sub>w<sub>i</sub></em>;</p><p>    <code>(matrix-*-vector <em>m v</em>)  </code>returns the vector <em>t</em>, where <em>t<sub>i</sub></em> = ∑<em><sub>j</sub> m<sub>ij</sub>v<sub>j</sub></em>;</p><p>    <code>(matrix-*-vector <em>m n</em>)  </code>returns the matrix <em>p</em>, where <em>p<sub>ij</sub></em> = ∑<em><sub>k</sub> m<sub>ik</sub>n<sub>kj</sub></em>;</p><p>    <code>(transpose <em>m</em>)          </code>returns the matrix <em>n</em>, where <em>n<sub>ij</sub></em> = <em>m<sub>ji</sub></em>.</p><p>We can define the dot product as<a name="call_footnote_Temp_190" href="#footnote_Temp_190" id="call_footnote_Temp_190"><sup><small>17</small></sup></a></p>
<p></p>
<p><pre><a name="%_idx_1802" id="%_idx_1802"></a>(define (dot-product v w)
  (accumulate + 0 (map * v w)))
</pre></p>
<p></p>
<p>Fill in the missing expressions in the following procedures forcomputing the other matrix operations.  (The procedure <code>accumulate-n</code> isdefined in exercise <a href="#%_thm_2.36">2.36</a>.)</p>
<p></p>
<p><pre><a name="%_idx_1804" id="%_idx_1804"></a>(define (matrix-*-vector m v)
  (map &lt;<em>??</em>&gt; m))
<a name="%_idx_1806" id="%_idx_1806"></a>(define (transpose mat)
  (accumulate-n &lt;<em>??</em>&gt; &lt;<em>??</em>&gt; mat))
<a name="%_idx_1808" id="%_idx_1808"></a>(define (matrix-*-matrix m n)
  (let ((cols (transpose n)))
    (map &lt;<em>??</em>&gt; m)))
</pre></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_2.38" id="%_thm_2.38"></a><b>Exercise 2.38.</b>  <a name="%_idx_1810" id="%_idx_1810"></a><a name="%_idx_1812" id="%_idx_1812"></a>The <code>accumulate</code> procedure is also known as <code>fold-right</code>,because it combines the first element of the sequence with the resultof combining all the elements to the right.  There is also a <code>fold-left</code>, which issimilar to <code>fold-right</code>, exceptthat it combines elements working in the opposite direction:</p>
<p></p>
<p><pre><a name="%_idx_1814" id="%_idx_1814"></a>(define (fold-left op initial sequence)
  (define (iter result rest)
    (if (null? rest)
        result
        (iter (op result (car rest))
              (cdr rest))))
  (iter initial sequence))
</pre></p>
<p></p>
<p>What are the values of</p>
<p></p>
<p><pre>(fold-right / 1 (list 1 2 3))
(fold-left / 1 (list 1 2 3))
(fold-right list nil (list 1 2 3))
(fold-left list nil (list 1 2 3))
</pre></p>
<p></p>
<p>Give a property that <code>op</code> should satisfy to guarantee that <code>fold-right</code> and <code>fold-left</code> will produce the same values for anysequence.</p>
<p></p>
<p></p>
<p><a name="%_thm_2.39" id="%_thm_2.39"></a><b>Exercise 2.39.</b>  Complete the following definitions of <code>reverse</code><a name="%_idx_1816" id="%_idx_1816"></a>(exercise <a href="#%_thm_2.18">2.18</a>) in terms of <code>fold-right</code> and <code>fold-left</code> from exercise <a href="#%_thm_2.38">2.38</a>:</p>
<p></p>
<p><pre>(define (reverse sequence)
  (fold-right (lambda (x y) &lt;<em>??</em>&gt;) nil sequence))
(define (reverse sequence)
  (fold-left (lambda (x y) &lt;<em>??</em>&gt;) nil sequence))
</pre></p>
<p></p>
<p></p>
<p><a name="%_sec_Temp_193" id="%_sec_Temp_193"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_193">Nested Mappings</a></h4>
<p><a name="%_idx_1818" id="%_idx_1818"></a>We can extend the sequence paradigm to include manycomputations that are commonly expressed using nested loops.<a name="call_footnote_Temp_194" href="#footnote_Temp_194" id="call_footnote_Temp_194"><sup><small>18</small></sup></a>Considerthis problem: Given a positive integer <em>n</em>, find all ordered pairs ofdistinct positive integers <em>i</em> and <em>j</em>, where 1<u>&lt;</u> <em>j</em>&lt; <em>i</em><u>&lt;</u> <em>n</em>, suchthat <em>i</em>  + <em>j</em> is prime.  For example, if <em>n</em> is 6, then the pairs arethe following:</p><table id="ch2-Z-G-22">
<tr>
<td class="label"><em>i</em></td>        <td>2</td>        <td>3</td>        <td>4</td>        <td>4</td>        <td>5</td>        <td>6</td>        <td>6</td>    </tr>
<tr>
<td class="label"><em>j</em></td>        <td>1</td>        <td>2</td>        <td>1</td>        <td>3</td>        <td>2</td>        <td>1</td>        <td>5</td>    </tr>
<tr class="sum">
<td class="label">
<em>i</em> + <em>j</em>
</td>        <td>3</td>        <td>5</td>        <td>5</td>        <td>7</td>        <td>7</td>        <td>7</td>        <td>11</td>    </tr>
</table>
<p>A natural way to organize this computation is to generate the sequenceof all ordered pairs of positive integers less than or equal to <em>n</em>,filter to select those pairs whose sum is prime, andthen, for each pair (<em>i</em>, <em>j</em>) that passes through the filter, produce the triple(<em>i</em>,<em>j</em>,<em>i</em> + <em>j</em>).</p>
<p>Here is a way to generate the sequence of pairs: For each integer<em>i</em><u>&lt;</u> <em>n</em>, enumerate the integers <em>j</em>&lt;<em>i</em>, and for each such <em>i</em> and <em>j</em>generate the pair (<em>i</em>,<em>j</em>).  In terms of sequence operations, we mapalong the sequence <code>(enumerate-interval 1 n)</code>.  For each <em>i</em> inthis sequence, we map along the sequence <code>(enumerate-interval 1 (-i 1))</code>.  For each <em>j</em> in this latter sequence, we generate the pair<code>(list i j)</code>.  This gives us a sequence of pairs for each <em>i</em>.Combining all the sequences for all the <em>i</em> (by accumulating with <code>append</code>) produces the required sequence of pairs:<a name="call_footnote_Temp_195" href="#footnote_Temp_195" id="call_footnote_Temp_195"><sup><small>19</small></sup></a></p>
<p></p>
<p><pre>(accumulate append
            nil
            (map (lambda (i)
                   (map (lambda (j) (list i j))
                        (enumerate-interval 1 (- i 1))))
                 (enumerate-interval 1 n)))
</pre></p>
<p></p>
<p>The combination of mapping and accumulating with <code>append</code> is so common in thissort of program that we will isolate it as a separate procedure:</p>
<p></p>
<p><pre><a name="%_idx_1826" id="%_idx_1826"></a>(define (flatmap proc seq)
  (accumulate append nil (map proc seq)))
</pre></p>
<p></p>
<p>Now filter this sequence of pairs to find those whose sum is prime. Thefilter predicate is called for each element of the sequence; itsargument is a pair and it must extract the integers from the pair.Thus, the predicate to apply to each element in the sequence is</p>
<p></p>
<p><pre>(define (prime-sum? pair)
  (prime? (+ (car pair) (cadr pair))))
</pre></p>
<p></p>
<p>Finally, generate the sequence of results by mapping over the filteredpairs using the following procedure, which constructs a tripleconsisting of the two elements of the pair along with their sum:</p>
<p></p>
<p><pre>(define (make-pair-sum pair)
  (list (car pair) (cadr pair) (+ (car pair) (cadr pair))))
</pre></p>
<p></p>
<p>Combining all these steps yields the complete procedure:</p>
<p></p>
<p><pre><a name="%_idx_1828" id="%_idx_1828"></a>(define (prime-sum-pairs n)
  (map make-pair-sum
       (filter prime-sum?
               (flatmap
                (lambda (i)
                  (map (lambda (j) (list i j))
                       (enumerate-interval 1 (- i 1))))
                (enumerate-interval 1 n)))))
</pre></p>
<p></p>
<p></p>
<p>Nested mappings are also useful for sequences other than those thatenumerate intervals.  Suppose we wish to generate all the <a name="%_idx_1830" id="%_idx_1830"></a><a name="%_idx_1832" id="%_idx_1832"></a>permutationsof a set <em>S</em>; that is, all the ways of ordering the items inthe set.  For instance, the permutations of {1,2,3} are{1,2,3}, { 1,3,2}, {2,1,3}, { 2,3,1}, { 3,1,2}, and{ 3,2,1}.  Here is a plan for generating the permutations of <em>S</em>:For each item <em>x</em> in <em>S</em>, recursively generate the sequence ofpermutations of <em>S</em> - <em>x</em>,<a name="call_footnote_Temp_196" href="#footnote_Temp_196" id="call_footnote_Temp_196"><sup><small>20</small></sup></a> and adjoin<em>x</em> to the front of each one.  This yields, for each <em>x</em> in <em>S</em>, the sequenceof permutations of <em>S</em> that begin with <em>x</em>.  Combining thesesequences for all <em>x</em> gives all the permutations of <em>S</em>:<a name="call_footnote_Temp_197" href="#footnote_Temp_197" id="call_footnote_Temp_197"><sup><small>21</small></sup></a></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_1840" id="%_idx_1840"></a>(define (permutations s)
  (if (null? s)                    <em>; empty set?</em>
      (list nil)                   <em>; sequence containing empty set</em>
      (flatmap (lambda (x)
                 (map (lambda (p) (cons x p))
                      (permutations (remove x s))))
               s)))
</pre></p>
<p></p>
<p>Notice how this strategy reduces the problem of generatingpermutations of <em>S</em> to the problem of generating the permutations ofsets with fewer elements than <em>S</em>.  In the terminal case, we work ourway down to the empty list, which represents a set of no elements.For this, we generate <code>(list nil)</code>, which is a sequence with oneitem, namely the set with no elements.  The <code>remove</code> procedureused in <code>permutations</code> returns all the items in a given sequenceexcept for a given item.  This can be expressed as a simple filter:</p>
<p></p>
<p><pre><a name="%_idx_1842" id="%_idx_1842"></a>(define (remove item sequence)
  (filter (lambda (x) (not (= x item)))
          sequence))
</pre></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_2.40" id="%_thm_2.40"></a><b>Exercise 2.40.</b>  Define a procedure <a name="%_idx_1844" id="%_idx_1844"></a><code>unique-pairs</code> that, given an integer <em>n</em>,generates the sequence of pairs (<em>i</em>,<em>j</em>) with 1<u>&lt;</u> <em>j</em>&lt; <em>i</em><u>&lt;</u> <em>n</em>.  Use <code>unique-pairs</code> to simplify the definition of <code>prime-sum-pairs</code>given above.</p>
<p></p>
<p></p>
<p><a name="%_thm_2.41" id="%_thm_2.41"></a><b>Exercise 2.41.</b>  Write a procedure to find all orderedtriples of distinct positive integers <em>i</em>, <em>j</em>, and <em>k</em> less than orequal to a given integer <em>n</em> that sum to a given integer <em>s</em>.</p>
<p></p>
<p></p>
<p><a name="%_thm_2.42" id="%_thm_2.42"></a><b>Exercise 2.42.</b>  <a name="%_fig_2.8" id="%_fig_2.8"></a></p>
<p></p>
<div align="left">    <table id="ch2-Z-G-23">
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>♕</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>♕</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>♕</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>♕</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>♕</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>♕</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>♕</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>♕</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<caption align="bottom">
<b>Figure 2.8:</b>  A solution to the eight-queens puzzle.</caption>    </table>
</div><p>The <a name="%_idx_1846" id="%_idx_1846"></a><a name="%_idx_1848" id="%_idx_1848"></a><a name="%_idx_1850" id="%_idx_1850"></a>“eight-queens puzzle” asks how to place eight queens on achessboard so that no queen is in check from any other (i.e., no twoqueens are in the same row, column, or diagonal).  One possiblesolution is shown in figure <a href="#%_fig_2.8">2.8</a>.  One way to solve thepuzzle is to work across the board, placing a queen in each column.Once we have placed <em>k</em> - 1 queens, we must place the <em>k</em>th queen in aposition where it does not check any of the queens already on theboard.  We can formulate this approach recursively: Assume that wehave already generated the sequence of all possible ways to place<em>k</em> - 1 queens in the first <em>k</em> - 1 columns of the board.  For each ofthese ways, generate an extended set of positions by placing a queenin each row of the <em>k</em>th column.  Now filter these, keeping onlythe positions for which the queen in the <em>k</em>th column is safe withrespect to the other queens.  This produces the sequence of all waysto place <em>k</em> queens in the first <em>k</em> columns.  By continuing thisprocess, we will produce not only one solution, but all solutions tothe puzzle.</p>
<p>We implement this solution as a procedure <code>queens</code>, which returnsa sequence of all solutions to the problem of placing <em>n</em> queens on an<em>n</em>× <em>n</em> chessboard.  <code>Queens</code> has an internal procedure <code>queen-cols</code> that returns the sequence of all ways to place queens inthe first <em>k</em> columns of the board.</p>
<p></p>
<p><pre><a name="%_idx_1852" id="%_idx_1852"></a>(define (queens board-size)
  (define (queen-cols k)  
    (if (= k 0)
        (list empty-board)
        (filter
         (lambda (positions) (safe? k positions))
         (flatmap
          (lambda (rest-of-queens)
            (map (lambda (new-row)
                   (adjoin-position new-row k rest-of-queens))
                 (enumerate-interval 1 board-size)))
          (queen-cols (- k 1))))))
  (queen-cols board-size))
</pre></p>
<p></p>
<p>In this procedure <code>rest-of-queens</code> is a way to place <em>k</em> - 1 queensin the first <em>k</em> - 1 columns, and <code>new-row</code> is a proposed row inwhich to place the queen for the <em>k</em>th column.  Complete the programby implementing the representation for sets of board positions,including the procedure <code>adjoin-position</code>, which adjoins a new row-columnposition to a set of positions, and <code>empty-board</code>, whichrepresents an empty set of positions.  You must also write theprocedure <code>safe?</code>, which determines for a set of positions,whether the queen in the <em>k</em>th column is safe with respect to theothers.  (Note that we need only check whether the new queen issafe – the other queens are already guaranteed safe with respect toeach other.)</p>
<p></p>
<p></p>
<p><a name="%_thm_2.43" id="%_thm_2.43"></a><b>Exercise 2.43.</b>  Louis Reasoner is having a terrible time doing exercise <a href="#%_thm_2.42">2.42</a>.  His<code>queens</code> procedure seems to work, but it runs extremely slowly.(Louis never does manage to wait long enough for it to solve even the6× 6 case.)  When Louis asks Eva Lu Ator for help, she pointsout that he has interchanged the order of the nested mappings in the<code>flatmap</code>, writing it as</p>
<p></p>
<p><pre>(flatmap
 (lambda (new-row)
   (map (lambda (rest-of-queens)
          (adjoin-position new-row k rest-of-queens))
        (queen-cols (- k 1))))
 (enumerate-interval 1 board-size))
</pre></p>
<p></p>
<p>Explain why this interchange makes the program run slowly.  Estimatehow long it will take Louis's program to solve the eight-queenspuzzle, assuming that the program in exercise <a href="#%_thm_2.42">2.42</a> solvesthe puzzle in time <em>T</em>.</p>
<p></p>
<p><a name="%_sec_2.2.4" id="%_sec_2.2.4"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_2.2.4">2.2.4  Example: A Picture Language</a></h3>
<p><a name="%_idx_1854" id="%_idx_1854"></a>This section presents a simple language for drawingpictures that illustrates thepower of data abstraction and closure,and also exploits higher-order procedures inan essential way.  The languageis designed to make it easy to experiment with patternssuch as the ones in figure <a href="#%_fig_2.9">2.9</a>, which arecomposed of repeated elements that are shifted and scaled.<a name="call_footnote_Temp_202" href="#footnote_Temp_202" id="call_footnote_Temp_202"><sup><small>22</small></sup></a> In this language,the data objects being combinedare represented as procedures rather than as list structure.Just as <code>cons</code>, which satisfies the <a name="%_idx_1860" id="%_idx_1860"></a>closure property,allowed us to easily build arbitrarily complicatedlist structure, the operations in this language, which alsosatisfy the closure property, allow us to easily buildarbitrarily complicated patterns.</p>
<p><a name="%_fig_2.9" id="%_fig_2.9"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td>
<div align="left">
<img src="images/ch2-Z-G-24.gif" border="0">          <img src="images/ch2-Z-G-25.gif" border="0"> </div></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 2.9:</b>  Designs generated with the picture language.</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p><a name="%_sec_Temp_203" id="%_sec_Temp_203"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_203">The picture language</a></h4>
<p>When we began our study of programming insection <a href="book-Z-H-10.html#%_sec_1.1">1.1</a>, we emphasized theimportance of describing a language by focusing on the language'sprimitives, its means of combination, and its means of abstraction.We'll follow that framework here.</p>
<p>Part of the elegance of this picture language is that there isonly one kind of element, called a <a name="%_idx_1862" id="%_idx_1862"></a><em>painter</em>.  A painterdraws an image that is shifted and scaled to fit within a designated<a name="%_idx_1864" id="%_idx_1864"></a>parallelogram-shaped frame.  For example, there's a primitive painterwe'll call <code>wave</code> that makes a crude line drawing, asshown in figure <a href="#%_fig_2.10">2.10</a>.The actual shape of the drawing depends on the frame – allfour images in figure <a href="#%_fig_2.10">2.10</a> are produced by the same <code>wave</code> painter, but with respect to four different frames.  Painterscan be more elaborate than this:The primitivepainter called <code>rogers</code> paints a picture of MIT's founder,William Barton Rogers, as shown in figure <a href="#%_fig_2.11">2.11</a>.<a name="call_footnote_Temp_204" href="#footnote_Temp_204" id="call_footnote_Temp_204"><sup><small>23</small></sup></a>The four images in figure <a href="#%_fig_2.11">2.11</a>are drawn with respect to the same four framesas the <code>wave</code> images in figure <a href="#%_fig_2.10">2.10</a>.</p>
<p><a name="%_idx_1876" id="%_idx_1876"></a>To combine images,we use various operations that construct new paintersfrom given painters.For example, the <a name="%_idx_1878" id="%_idx_1878"></a><code>beside</code> operation takes two painters and produces a new,compound painter that draws the first painter's image in the left halfof the frame and the second painter's image in the right half of the frame.Similarly, <a name="%_idx_1880" id="%_idx_1880"></a><code>below</code> takes two painters and produces a compoundpainter that draws the first painter's image below the secondpainter's image.Some operations transform a single painter to producea new painter.  For example, <a name="%_idx_1882" id="%_idx_1882"></a><code>flip-vert</code> takes a painter andproduces a painter that draws its image upside-down, and<a name="%_idx_1884" id="%_idx_1884"></a><code>flip-horiz</code> produces a painter that draws the originalpainter's image left-to-right reversed.</p>
<p><a name="%_fig_2.10" id="%_fig_2.10"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td>
<div align="left">
<img src="images/ch2-Z-G-26.gif" border="0">          <img src="images/ch2-Z-G-27.gif" border="0"> </div><div align="left">
<img src="images/ch2-Z-G-28.gif" border="0">          <img src="images/ch2-Z-G-29.gif" border="0"> </div></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 2.10:</b>  Images produced by the <code>wave</code> painter, with respectto four different frames.  The frames, shown with dotted lines, are notpart of the images.</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p><a name="%_fig_2.11" id="%_fig_2.11"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td>
<div align="left">
<img src="images/ch2-Z-G-30.gif" border="0">          <img src="images/ch2-Z-G-31.gif" border="0"> </div><div align="left">
<img src="images/ch2-Z-G-32.gif" border="0">          <img src="images/ch2-Z-G-33.gif" border="0"> </div></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 2.11:</b>  Images of William Barton Rogers, founder and firstpresident of MIT, painted with respect to the same four frames as infigure <a href="#%_fig_2.10">2.10</a> (original image reprinted with the permissionof the MIT Museum).</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p>Figure <a href="#%_fig_2.12">2.12</a> shows the drawing of a painter called<code>wave4</code> that is built up in two stages starting from <code>wave</code>:</p>
<p></p>
<p><pre>(define wave2 (beside wave (flip-vert wave)))
(define wave4 (below wave2 wave2))
</pre></p>
<p></p>
<p></p>
<p><a name="%_fig_2.12" id="%_fig_2.12"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td>
<div align="left">
<img src="images/ch2-Z-G-34.gif" border="0">          <img src="images/ch2-Z-G-35.gif" border="0"> </div><p></p>
<p><pre>(define wave2                         (define wave4
  (beside wave (flip-vert wave)))       (below wave2 wave2))
</pre></p>
<p></p>
<p></p>
<p></p>
<p></p>
</td></tr>
<caption align="bottom"><div align="left">
<b>Figure 2.12:</b>  Creating a complex figure,starting from the <code>wave</code> painter of figure <a href="#%_fig_2.10">2.10</a>.</div></caption>
<tr><td></td></tr>
</table></div>
<p> </p>
<p><a name="%_idx_1886" id="%_idx_1886"></a>In building up a complex image in this manner we are exploiting thefact that painters are closed under the language's means ofcombination.  The <code>beside</code> or <code>below</code> of two painters isitself a painter; therefore, we can use it as an element in makingmore complex painters.  As with building up list structure using <code>cons</code>, the closure of our data under the means of combination iscrucial to the ability to create complex structures while using only afew operations.</p>
<p>Once we can combine painters, we would like to be able to abstracttypical patterns of combining painters.We will implement the painter operations as Scheme procedures.This means that we don't need a special abstraction mechanismin the picture language:Since the means of combinationare ordinary Scheme procedures, we automatically have the capabilityto do anything with painter operations that we can do withprocedures.For example, we can abstract the pattern in <code>wave4</code> as</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_1888" id="%_idx_1888"></a>(define (flipped-pairs painter)
  (let ((painter2 (beside painter (flip-vert painter))))
    (below painter2 painter2)))
</pre></p>
<p></p>
<p>and define <code>wave4</code> as an instance of this pattern:</p>
<p></p>
<p></p>
<p><pre>(define wave4 (flipped-pairs wave))
</pre></p>
<p></p>
<p></p>
<p>We can also define recursive operations.Here's one that makes painters split and branchtowards the right as shown in figures <a href="#%_fig_2.13">2.13</a>and  <a href="#%_fig_2.14">2.14</a>:</p>
<p></p>
<p><pre><a name="%_idx_1890" id="%_idx_1890"></a>(define (right-split painter n)
  (if (= n 0)
      painter
      (let ((smaller (right-split painter (- n 1))))
        (beside painter (below smaller smaller)))))
</pre></p>
<p></p>
<p></p>
<p><a name="%_fig_2.13" id="%_fig_2.13"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td>
<div align="left">
<img src="images/ch2-Z-G-36.gif" border="0">                   <img src="images/ch2-Z-G-37.gif" border="0"> </div><p></p>
<p><pre>     right-split <em>n</em>                   corner-split <em>n</em>
</pre></p>
<p></p>
<p></p>
<p></p>
<p></p>
</td></tr>
<caption align="bottom"><div align="left">
<b>Figure 2.13:</b>  Recursive plans for <code>right-split</code> and <code>corner-split</code>.</div></caption>
<tr><td></td></tr>
</table></div>
<p> </p>
<p>We can produce balanced patterns by branching upwardsas well as towards the right (see exercise <a href="#%_thm_2.44">2.44</a>and figures <a href="#%_fig_2.13">2.13</a> and  <a href="#%_fig_2.14">2.14</a>):</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_1892" id="%_idx_1892"></a>(define (corner-split painter n)
  (if (= n 0)
      painter
      (let ((up (up-split painter (- n 1)))
            (right (right-split painter (- n 1))))
        (let ((top-left (beside up up))
              (bottom-right (below right right))
              (corner (corner-split painter (- n 1))))
          (beside (below painter top-left)
                  (below bottom-right corner))))))
</pre></p>
<p></p>
<p></p>
<p><a name="%_fig_2.14" id="%_fig_2.14"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td>
<div align="left">
<img src="images/ch2-Z-G-38.gif" border="0">          <img src="images/ch2-Z-G-39.gif" border="0"> </div><p></p>
<p><pre>     (right-split wave 4)         (right-split rogers 4)
</pre></p>
<p></p>
<p></p>
<p></p>
<p></p>
<div align="left">
<img src="images/ch2-Z-G-40.gif" border="0">          <img src="images/ch2-Z-G-41.gif" border="0"> </div><p></p>
<p><pre>    (corner-split wave 4)         (corner-split rogers 4)
</pre></p>
<p></p>
<p></p>
<p></p>
<p></p>
</td></tr>
<caption align="bottom"><div align="left">
<b>Figure 2.14:</b>  The recursive operations <code>right-split</code> and <code>corner-split</code> applied to the painters <code>wave</code> and <code>rogers</code>.Combining four <code>corner-split</code> figures producessymmetric <code>square-limit</code> designs as shownin figure <a href="#%_fig_2.9">2.9</a>.</div></caption>
<tr><td></td></tr>
</table></div>
<p> </p>
<p>By placing four copies of a <code>corner-split</code>appropriately, we obtain a pattern called <code>square-limit</code>, whoseapplication to <code>wave</code> and <code>rogers</code> is shown infigure <a href="#%_fig_2.9">2.9</a>:</p>
<p></p>
<p><pre><a name="%_idx_1894" id="%_idx_1894"></a>(define (square-limit painter n)
  (let ((quarter (corner-split painter n)))
    (let ((half (beside (flip-horiz quarter) quarter)))
      (below (flip-vert half) half))))
</pre></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_2.44" id="%_thm_2.44"></a><b>Exercise 2.44.</b>  Define the procedure <a name="%_idx_1896" id="%_idx_1896"></a><code>up-split</code> used by <code>corner-split</code>.It is similar to <code>right-split</code>, except that it switches theroles of <code>below</code> and <code>beside</code>.</p>
<p></p>
<p><a name="%_sec_Temp_206" id="%_sec_Temp_206"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_206">Higher-order operations</a></h4>
<p><a name="%_idx_1898" id="%_idx_1898"></a>In addition to abstracting patterns of combining painters, we can workat a higher level, abstracting patterns of combining painter operations.That is, we can view the painter operations as elements to manipulateand can write means of combination for these elements – procedures thattake painter operations as arguments and create new painter operations.</p>
<p>For example, <code>flipped-pairs</code> and <code>square-limit</code> eacharrange four copies of a painter's image in a square pattern; they differonly in how they orient the copies.One way to abstract this pattern of painter combination is withthe following procedure, which takes four one-argument painter operationsand produces a painter operation that transforms a givenpainter with those four operations and arranges the results in a square.<code>Tl</code>, <code>tr</code>, <code>bl</code>, and <code>br</code> are thetransformations to apply to the top left copy, the top right copy,the bottom left copy, and the bottom right copy, respectively.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_1900" id="%_idx_1900"></a>(define (square-of-four tl tr bl br)
  (lambda (painter)
    (let ((top (beside (tl painter) (tr painter)))
          (bottom (beside (bl painter) (br painter))))
      (below bottom top))))
</pre></p>
<p></p>
<p>Then <code>flipped-pairs</code> can be defined in termsof <code>square-of-four</code> as follows:<a name="call_footnote_Temp_207" href="#footnote_Temp_207" id="call_footnote_Temp_207"><sup><small>24</small></sup></a></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_1904" id="%_idx_1904"></a>(define (flipped-pairs painter)
  (let ((combine4 (square-of-four identity flip-vert
                                  identity flip-vert)))
    (combine4 painter)))
</pre></p>
<p></p>
<p>and <code>square-limit</code> can be expressed as<a name="call_footnote_Temp_208" href="#footnote_Temp_208" id="call_footnote_Temp_208"><sup><small>25</small></sup></a></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_1906" id="%_idx_1906"></a>(define (square-limit painter n)
  (let ((combine4 (square-of-four flip-horiz identity
                                  rotate180 flip-vert)))
    (combine4 (corner-split painter n))))
</pre></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_2.45" id="%_thm_2.45"></a><b>Exercise 2.45.</b>  <code>Right-split</code> and <code>up-split</code> can be expressed asinstances of a general splitting operation.Define a procedure <a name="%_idx_1908" id="%_idx_1908"></a><code>split</code> with the property that evaluating</p>
<p></p>
<p><pre>(define right-split (split beside below))
(define up-split (split below beside))
</pre></p>
<p></p>
<p>produces procedures <code>right-split</code> and <code>up-split</code> with the samebehaviors as the ones already defined.</p>
<p></p>
<p><a name="%_sec_Temp_210" id="%_sec_Temp_210"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_210">Frames</a></h4>
<p><a name="%_idx_1910" id="%_idx_1910"></a>Before we can show how to implement painters and theirmeans of combination, we must first consider<a name="%_idx_1912" id="%_idx_1912"></a>frames.  A frame can be described by three vectors – an origin vectorand two edge vectors.  The origin vector specifies the offset of theframe's origin from some absolute origin in the plane, and the edgevectors specify the offsets of the frame's corners from its origin.If the edges are perpendicular, the frame will be rectangular.Otherwise the frame will be a more general parallelogram.</p>
<p>Figure <a href="#%_fig_2.15">2.15</a> shows a frame and its associated vectors.  Inaccordance with data abstraction, we need not bespecific yet about how frames are represented, other than to say thatthere is a constructor <a name="%_idx_1914" id="%_idx_1914"></a><code>make-frame</code>, which takes three vectors andproduces a frame, and three corresponding selectors <a name="%_idx_1916" id="%_idx_1916"></a><code>origin-frame</code>, <a name="%_idx_1918" id="%_idx_1918"></a><code>edge1-frame</code>, and <a name="%_idx_1920" id="%_idx_1920"></a><code>edge2-frame</code> (seeexercise <a href="#%_thm_2.47">2.47</a>).</p>
<p><a name="%_fig_2.15" id="%_fig_2.15"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch2-Z-G-42.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 2.15:</b>  A frame is described by three vectors – anorigin and two edges.</div></caption>
<tr><td></td></tr>
</table></div>
<p> </p>
<p><a name="%_idx_1922" id="%_idx_1922"></a>We will use coordinates in the unit square (0<u>&lt;</u> <em>x</em>,<em>y</em><u>&lt;</u> 1)to specify images.With each frame, we associate a <a name="%_idx_1924" id="%_idx_1924"></a><em>frame coordinate map</em>, whichwill be used to shift and scale images to fit the frame.  The maptransforms the unit square into the frame bymapping the vector <strong><em>v</em></strong> = (<em>x</em>,<em>y</em>) to the vector sum</p>
<p></p>
<div align="left"><img src="images/ch2-Z-G-43.gif" border="0"></div>
<p>For example, (0,0) is mapped to the origin of the frame, (1,1) tothe vertex diagonally opposite the origin, and (0.5,0.5) to thecenter of the frame.  We can create a frame's coordinate map with thefollowing procedure:<a name="call_footnote_Temp_211" href="#footnote_Temp_211" id="call_footnote_Temp_211"><sup><small>26</small></sup></a></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_1926" id="%_idx_1926"></a>(define (frame-coord-map frame)
  (lambda (v)
    (add-vect
     (origin-frame frame)
     (add-vect (scale-vect (xcor-vect v)
                           (edge1-frame frame))
               (scale-vect (ycor-vect v)
                           (edge2-frame frame))))))
</pre></p>
<p></p>
<p>Observe that applying <code>frame-coord-map</code> to a frame returnsa procedure that, given a vector, returns a vector.If the argument vector is in the unit square, the result vectorwill be in the frame.  For example,</p>
<p></p>
<p><pre>((frame-coord-map a-frame) (make-vect 0 0))
</pre></p>
<p></p>
<p>returns the same vector as</p>
<p></p>
<p><pre>(origin-frame a-frame)
</pre></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_2.46" id="%_thm_2.46"></a><b>Exercise 2.46.</b>  <a name="%_idx_1928" id="%_idx_1928"></a><a name="%_idx_1930" id="%_idx_1930"></a>A two-dimensional vector <strong>v</strong> running from the origin to a pointcan be represented as a pairconsisting of an <em>x</em>-coordinate and a <em>y</em>-coordinate.  Implement a dataabstraction for vectors by giving a constructor <a name="%_idx_1932" id="%_idx_1932"></a><code>make-vect</code> andcorresponding selectors <a name="%_idx_1934" id="%_idx_1934"></a><code>xcor-vect</code> and <a name="%_idx_1936" id="%_idx_1936"></a><code>ycor-vect</code>.  Interms of your selectors and constructor, implement procedures <a name="%_idx_1938" id="%_idx_1938"></a><code>add-vect</code>, <a name="%_idx_1940" id="%_idx_1940"></a><code>sub-vect</code>, and <a name="%_idx_1942" id="%_idx_1942"></a><code>scale-vect</code> that performthe operations vector addition, vector subtraction, and multiplying avector by a scalar:</p><p class="centered">    (<em>x</em><sub>1</sub>, <em>y</em><sub>1</sub>) + (<em>x</em><sub>2</sub>, <em>y</em><sub>2</sub>) = (<em>x</em><sub>1</sub> + <em>x</em><sub>2</sub>, <em>y</em><sub>1</sub> + <em>y</em><sub>2</sub>)
    (<em>x</em><sub>1</sub>, <em>y</em><sub>1</sub>) - (<em>x</em><sub>2</sub>, <em>y</em><sub>2</sub>) = (<em>x</em><sub>1</sub> - <em>x</em><sub>2</sub>, <em>y</em><sub>1</sub> - <em>y</em><sub>2</sub>)
<em>s</em> · (<em>x</em>, <em>y</em>) = (<em>sx</em>, <em>sy</em>)</p><p><a name="%_thm_2.47" id="%_thm_2.47"></a><b>Exercise 2.47.</b>  Here are two possible constructors for frames:</p>
<p></p>
<p><pre><a name="%_idx_1944" id="%_idx_1944"></a>(define (make-frame origin edge1 edge2)
  (list origin edge1 edge2))

(define (make-frame origin edge1 edge2)
  (cons origin (cons edge1 edge2)))
</pre></p>
<p></p>
<p>For each constructor supply the appropriate selectors to produce animplementation for frames.</p>
<p></p>
<p><a name="%_sec_Temp_214" id="%_sec_Temp_214"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_214">Painters</a></h4>
<p><a name="%_idx_1946" id="%_idx_1946"></a>A painter is represented as a procedure that, given a frameas argument, draws a particular image shifted and scaled to fit the frame.That is to say, if <code>p</code> is a painter and <code>f</code> is a frame, then weproduce <code>p</code>'s image in <code>f</code> by calling <code>p</code> with <code>f</code> asargument.</p>
<p>The details of how primitive painters are implemented depend on theparticular characteristics of the graphics system and the type ofimage to be drawn.  For instance, suppose we have a procedure <a name="%_idx_1948" id="%_idx_1948"></a><code>draw-line</code> that draws a line on the screen between two specifiedpoints.  Then we can create painters for line drawings, such as the<code>wave</code> painter in figure <a href="#%_fig_2.10">2.10</a>, from lists of linesegments as follows:<a name="call_footnote_Temp_215" href="#footnote_Temp_215" id="call_footnote_Temp_215"><sup><small>27</small></sup></a></p>
<p></p>
<p><pre><a name="%_idx_1950" id="%_idx_1950"></a>(define (segments-&gt;painter segment-list)
  (lambda (frame)
    (for-each
     (lambda (segment)
       (draw-line
        ((frame-coord-map frame) (start-segment segment))
        ((frame-coord-map frame) (end-segment segment))))
     segment-list)))
</pre></p>
<p></p>
<p>The segments are given using coordinates with respect to the unitsquare.  For each segment in the list, the painter transforms thesegment endpoints with the frame coordinate map and draws a linebetween the transformed points.</p>
<p>Representing painters as procedures erects a powerful abstractionbarrier in the picture language.  We can create and intermixall sorts of primitive painters, based on a variety of graphicscapabilities. The details of their implementation do not matter.  Anyprocedure can serve as a painter, provided that it takes a frame asargument and draws something scaled to fit the frame.<a name="call_footnote_Temp_216" href="#footnote_Temp_216" id="call_footnote_Temp_216"><sup><small>28</small></sup></a></p>
<p><a name="%_thm_2.48" id="%_thm_2.48"></a><b>Exercise 2.48.</b>  <a name="%_idx_1952" id="%_idx_1952"></a>A directed line segment in theplane can be represented as a pair of vectors – thevector running from the origin to the start-point of the segment, andthe vector running from the origin to the end-point of the segment.Use your vector representation from exercise <a href="#%_thm_2.46">2.46</a> todefine a representation for segments with a constructor <a name="%_idx_1954" id="%_idx_1954"></a><code>make-segment</code> and selectors <a name="%_idx_1956" id="%_idx_1956"></a><code>start-segment</code> and <a name="%_idx_1958" id="%_idx_1958"></a><code>end-segment</code>.</p>
<p></p>
<p></p>
<p><a name="%_thm_2.49" id="%_thm_2.49"></a><b>Exercise 2.49.</b>  Use <code>segments-&gt;painter</code> to define the following primitive painters:</p>
<p>a.  The painter that draws the outline of the designated frame.</p>
<p>b.  The painter that draws an “X” by connecting opposite corners ofthe frame.</p>
<p>c.  The painter that draws a diamond shape by connecting the midpoints ofthe sides of the frame.</p>
<p>d.  The <code>wave</code> painter.</p>
<p></p>
<p><a name="%_sec_Temp_219" id="%_sec_Temp_219"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_219">Transforming and combining painters</a></h4>
<p><a name="%_idx_1960" id="%_idx_1960"></a>An operation on painters (such as <code>flip-vert</code> or <code>beside</code>)works by creating a painter that invokes the original painterswith respect to frames derived from the argument frame.Thus, for example, <code>flip-vert</code> doesn't have to know how a painterworks in order to flip it – it just has to know how to turn a frameupside down:The flipped painter just uses the original painter,but in the inverted frame.</p>
<p>Painter operations are based onthe procedure <code>transform-painter</code>, which takes as arguments a painter andinformation on how to transform a frame andproduces a new painter.  The transformed painter, when called on a frame,transforms the frame andcalls the original painter on the transformed frame.The arguments to <code>transform-painter</code> are points (represented as vectors)that specify the corners of the new frame:When mapped intothe frame, the first point specifies the new frame's originand the other two specify the ends of its edge vectors.Thus, arguments within theunit square specify a frame contained within the original frame.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_1962" id="%_idx_1962"></a>(define (transform-painter painter origin corner1 corner2)
  (lambda (frame)
    (let ((m (frame-coord-map frame)))
      (let ((new-origin (m origin)))
        (painter
         (make-frame new-origin
                     (sub-vect (m corner1) new-origin)
                     (sub-vect (m corner2) new-origin)))))))
</pre></p>
<p></p>
<p></p>
<p>Here's how to flip painter images vertically:</p>
<p></p>
<p><pre><a name="%_idx_1964" id="%_idx_1964"></a>(define (flip-vert painter)
  (transform-painter painter
                     (make-vect 0.0 1.0)   <em>; new <code>origin</code></em>
                     (make-vect 1.0 1.0)   <em>; new end of <code>edge1</code></em>
                     (make-vect 0.0 0.0))) <em>; new end of <code>edge2</code></em>
</pre></p>
<p></p>
<p>Using <code>transform-painter</code>, we can easily define new transformations.For example, we can define a painter that shrinks its image to theupper-right quarter of the frame it is given:</p>
<p></p>
<p><pre><a name="%_idx_1966" id="%_idx_1966"></a>(define (shrink-to-upper-right painter)
  (transform-painter painter
                     (make-vect 0.5 0.5)
                     (make-vect 1.0 0.5)
                     (make-vect 0.5 1.0)))
</pre></p>
<p></p>
<p>Other transformations rotate images counterclockwise by 90 degrees<a name="call_footnote_Temp_220" href="#footnote_Temp_220" id="call_footnote_Temp_220"><sup><small>29</small></sup></a></p>
<p></p>
<p><pre><a name="%_idx_1968" id="%_idx_1968"></a>(define (rotate90 painter)
  (transform-painter painter
                     (make-vect 1.0 0.0)
                     (make-vect 1.0 1.0)
                     (make-vect 0.0 0.0)))
</pre></p>
<p></p>
<p>or squash images towards the center of the frame:<a name="call_footnote_Temp_221" href="#footnote_Temp_221" id="call_footnote_Temp_221"><sup><small>30</small></sup></a></p>
<p></p>
<p><pre><a name="%_idx_1970" id="%_idx_1970"></a>(define (squash-inwards painter)
  (transform-painter painter
                     (make-vect 0.0 0.0)
                     (make-vect 0.65 0.35)
                     (make-vect 0.35 0.65)))
</pre></p>
<p></p>
<p></p>
<p>Frame transformation is also the key todefining means of combining two or more painters.The <code>beside</code> procedure,for example, takes two painters, transforms themto paint in the left and right halves of an argument frame respectively,and produces a new, compound painter.When the compound painter is given a frame, itcalls the first transformed painter to paint in the left half ofthe frame and calls the second transformed painter to paint in theright half of the frame:</p>
<p></p>
<p><pre><a name="%_idx_1972" id="%_idx_1972"></a>(define (beside painter1 painter2)
  (let ((split-point (make-vect 0.5 0.0)))
    (let ((paint-left
           (transform-painter painter1
                              (make-vect 0.0 0.0)
                              split-point
                              (make-vect 0.0 1.0)))
          (paint-right
           (transform-painter painter2
                              split-point
                              (make-vect 1.0 0.0)
                              (make-vect 0.5 1.0))))
      (lambda (frame)
        (paint-left frame)
        (paint-right frame)))))
</pre></p>
<p></p>
<p></p>
<p>Observe how the painter data abstraction, and in particular therepresentation of painters as procedures, makes <code>beside</code> easy toimplement.  The <code>beside</code> procedure need not know anythingabout the details of the component painters other than that eachpainter will draw something in its designated frame.</p>
<p></p>
<p><a name="%_thm_2.50" id="%_thm_2.50"></a><b>Exercise 2.50.</b>  Define the transformation <a name="%_idx_1974" id="%_idx_1974"></a><code>flip-horiz</code>, which flipspainters horizontally, and transformations that rotatepainters counterclockwise by 180 degrees and 270 degrees.</p>
<p></p>
<p></p>
<p><a name="%_thm_2.51" id="%_thm_2.51"></a><b>Exercise 2.51.</b>  Define the <a name="%_idx_1976" id="%_idx_1976"></a><code>below</code> operation for painters.  <code>Below</code> takes twopainters as arguments.  The resulting painter, given a frame,draws with the first painter in thebottom of the frame and with the second painter in the top.  Define <code>below</code> in two different ways – first by writing a procedure that isanalogous to the <code>beside</code> procedure given above, andagain in terms of <code>beside</code> and suitablerotation operations (from exercise <a href="#%_thm_2.50">2.50</a>).</p>
<p></p>
<p><a name="%_sec_Temp_224" id="%_sec_Temp_224"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_224">Levels of language for robust design</a></h4>
<p>The picture language exercises some of the critical ideaswe've introduced about abstraction with procedures and data.  Thefundamental data abstractions, painters, are implemented usingprocedural representations, which enables the language tohandle different basic drawing capabilities in a uniform way.  Themeans of combination satisfy the closure property, which permits us toeasily build up complex designs.  Finally, all the tools forabstracting procedures are available to us for abstracting means ofcombination for painters.</p>
<p>We have also obtained a glimpse of another crucial idea aboutlanguages and program design.  This is the approach of <a name="%_idx_1978" id="%_idx_1978"></a><a name="%_idx_1980" id="%_idx_1980"></a><em>stratifieddesign</em>, the notion that a complex system should be structured as asequence of levels that are described using a sequence of languages.Each level is constructed by combining parts that are regarded asprimitive at that level, and the parts constructed at each level areused as primitives at the next level.  The language used at each levelof a stratified design has primitives, means of combination, and meansof abstraction appropriate to that level of detail.</p>
<p>Stratified design pervades the engineering of complex systems.  Forexample, in computer engineering, resistors and transistors arecombined (and described using a language of analog circuits) toproduce parts such as and-gates and or-gates, which form theprimitives of a language for digital-circuit design.<a name="call_footnote_Temp_225" href="#footnote_Temp_225" id="call_footnote_Temp_225"><sup><small>31</small></sup></a>These parts are combined to buildprocessors, bus structures, and memory systems, which are in turncombined to form computers, using languages appropriate to computerarchitecture.  Computers are combined to form distributed systems,using languages appropriate for describing network interconnections,and so on.</p>
<p>As a tiny example of stratification, our picture language usesprimitive elements (primitive painters) that are created using alanguage that specifies points and lines to provide the lists of linesegments for <code>segments-&gt;painter</code>, or theshading details for a painter like <code>rogers</code>.  The bulk of ourdescription of the picture language focused on combining theseprimitives, using geometric combiners such as <code>beside</code> and <code>below</code>.  We also worked at a higher level, regarding <code>beside</code> and<code>below</code> as primitives to be manipulated in a language whoseoperations, such as <code>square-of-four</code>, capture common patterns ofcombining geometric combiners.</p>
<p><a name="%_idx_1982" id="%_idx_1982"></a>Stratified design helps make programs <em>robust</em>, that is, it makesit likely that small changes in a specification will requirecorrespondingly small changes in the program.  For instance, supposewe wanted to change the image based on <code>wave</code> shown infigure <a href="#%_fig_2.9">2.9</a>.  We could work at the lowest levelto change the detailed appearance of the <code>wave</code> element; we couldwork at the middle level to change the way <code>corner-split</code>replicates the <code>wave</code>; we could work at the highest level tochange how <code>square-limit</code> arranges the four copies of the corner.In general, each level of a stratified design provides a differentvocabulary for expressing the characteristics of the system, and adifferent kind of ability to change it.</p>
<p></p>
<p><a name="%_thm_2.52" id="%_thm_2.52"></a><b>Exercise 2.52.</b>  Make changes to the square limit of <code>wave</code> shown infigure <a href="#%_fig_2.9">2.9</a> by working at each of the levelsdescribed above.  In particular:</p>
<p>a.  Add some segments to the primitive <code>wave</code> painterof exercise  <a href="#%_thm_2.49">2.49</a> (to add a smile, for example).</p>
<p>b.  Change the pattern constructed by <code>corner-split</code>(for example, by using only one copy of the<code>up-split</code> and <code>right-split</code> images instead of two).</p>
<p>c.  Modify the version of <code>square-limit</code> that uses <code>square-of-four</code>so as to assemble the corners in a different pattern.  (For example, youmight make the big Mr. Rogers look outward from each corner of the square.)</p>
<p></p>
<p></p>
<div class="smallprint"><hr></div>
<p></p>
<div class="footnote">
<p><a name="footnote_Temp_154" href="#call_footnote_Temp_154" id="footnote_Temp_154"><sup><small>6</small></sup></a> The use of the word <a name="%_idx_1536" id="%_idx_1536"></a>“closure” here comes from abstract algebra,where a set of elements is said to be closed under an operation ifapplying the operation to elements in the set produces an element thatis again an element of the set.  The Lisp communityalso (unfortunately) uses the word “closure” to describe a totally unrelatedconcept: A closure is an implementation technique for representingprocedures with free variables.  We do not use the word “closure” inthis second sense in this book.</p>
<p><a name="footnote_Temp_155" href="#call_footnote_Temp_155" id="footnote_Temp_155"><sup><small>7</small></sup></a> The notion that a means of<a name="%_idx_1542" id="%_idx_1542"></a>combination should satisfy closure is a straightforward idea.Unfortunately, the data combiners provided in many popular programminglanguages do not satisfy closure, or make closure cumbersome toexploit.  In <a name="%_idx_1544" id="%_idx_1544"></a>Fortran or <a name="%_idx_1546" id="%_idx_1546"></a>Basic, one typically combines data elements byassembling them into arrays – but one cannot form arrays whoseelements are themselves arrays.  <a name="%_idx_1548" id="%_idx_1548"></a>Pascal and <a name="%_idx_1550" id="%_idx_1550"></a>C admit structures whoseelements are structures.  However, this requires that the programmermanipulate pointers explicitly, and adhere to the restriction thateach field of a structure can contain only elements of a prespecified form.UnlikeLisp with its pairs, these languages have no built-in general-purposeglue that makes it easy to manipulate compound data in a uniform way.This limitation lies behind Alan <a name="%_idx_1552" id="%_idx_1552"></a>Perlis's comment in his foreword tothis book: “In Pascal the plethora of declarable data structuresinduces a specialization within functions that inhibits and penalizescasual cooperation.  It is better to have 100 functions operate on onedata structure than to have 10 functions operate on 10 datastructures.”</p>
<p><a name="footnote_Temp_156" href="#call_footnote_Temp_156" id="footnote_Temp_156"><sup><small>8</small></sup></a> In this book, we use <em>list</em> to mean a chain ofpairs terminated by the end-of-list marker.  In contrast, the term<a name="%_idx_1572" id="%_idx_1572"></a><a name="%_idx_1574" id="%_idx_1574"></a><em>list structure</em> refers to any data structure made out of pairs,not just to lists.</p>
<p><a name="footnote_Temp_157" href="#call_footnote_Temp_157" id="footnote_Temp_157"><sup><small>9</small></sup></a> Since nested applications of <code>car</code> and <code>cdr</code>are cumbersome to write, Lisp dialects provide abbreviations forthem – for instance,<a name="%_idx_1584" id="%_idx_1584"></a><a name="%_idx_1586" id="%_idx_1586"></a></p><p><code>(cadr ⟨arg⟩) = (car (cdr ⟨arg⟩))</code></p><p>The names of all such procedures start with <code>c</code> and end with <code>r</code>.  Each <code>a</code> between them stands for a <a name="%_idx_1588" id="%_idx_1588"></a><a name="%_idx_1590" id="%_idx_1590"></a><code>car</code> operation andeach <code>d</code> for a <code>cdr</code> operation, to be applied in the same orderin which they appear in the name.  The names <code>car</code> and <code>cdr</code>persist because simple combinations like <code>cadr</code> arepronounceable.</p>
<p><a name="footnote_Temp_158" href="#call_footnote_Temp_158" id="footnote_Temp_158"><sup><small>10</small></sup></a> It's remarkable how much energy in thestandardization of Lisp dialects has been dissipated in arguments thatare literally over nothing: Should <code>nil</code> be an ordinary name?Should the value of <code>nil</code> be a symbol?  Should it be a list?Should it be a pair?  <a name="%_idx_1598" id="%_idx_1598"></a>In Scheme, <code>nil</code> is an ordinary name,which we use in this section as a variable whose value isthe end-of-list marker (just as <code>true</code> is an ordinary variablethat has a true value).  Other dialects ofLisp, including Common Lisp, treat <code>nil</code> as a special symbol.  The<a name="%_idx_1600" id="%_idx_1600"></a>authors of this book, who have endured too many languagestandardization brawls, would like to avoid the entire issue.  Once wehave introduced quotation in section <a href="book-Z-H-16.html#%_sec_2.3">2.3</a>, we willdenote the empty list as <code>'()</code> and dispense with thevariable <code>nil</code> entirely.</p>
<p><a name="footnote_Temp_164" href="#call_footnote_Temp_164" id="footnote_Temp_164"><sup><small>11</small></sup></a> To define <code>f</code> and <code>g</code> using<a name="%_idx_1656" id="%_idx_1656"></a><code>lambda</code> we would write</p>
<p></p>
<p><pre>(define f (lambda (x y . z) &lt;<em>body</em>&gt;))
(define g (lambda w &lt;<em>body</em>&gt;))
</pre></p>
<p></p>
<p></p>
<p><a name="footnote_Temp_166" href="#call_footnote_Temp_166" id="footnote_Temp_166"><sup><small>12</small></sup></a> Schemestandardly provides a <a name="%_idx_1664" id="%_idx_1664"></a><code>map</code> procedure that is more generalthan the one described here.This more general <code>map</code>takes a procedure of <em>n</em> arguments, together with <em>n</em> lists, andapplies the procedure to all the first elements ofthe lists, all the second elements of the lists, and so on,returning a list of the results.  For example:</p>
<p></p>
<p><pre>(map + (list 1 2 3) (list 40 50 60) (list 700 800 900))
<i>(741 852 963)</i>

(map (lambda (x y) (+ x (* 2 y)))
     (list 1 2 3)
     (list 4 5 6))
<i>(9 12 15)</i>
</pre></p>
<p></p>
<p></p>
<p><a name="footnote_Temp_170" href="#call_footnote_Temp_170" id="footnote_Temp_170"><sup><small>13</small></sup></a> The order of thefirst two clauses in the <code>cond</code> matters, since the empty listsatisfies <code>null?</code> and also is not a pair.</p>
<p><a name="footnote_Temp_182" href="#call_footnote_Temp_182" id="footnote_Temp_182"><sup><small>14</small></sup></a> This is, in fact, precisely the <a name="%_idx_1746" id="%_idx_1746"></a><code>fringe</code> procedure fromexercise <a href="#%_thm_2.28">2.28</a>.  Here we've renamed it to emphasize thatit is part of a family of general sequence-manipulation procedures.</p>
<p><a name="footnote_Temp_183" href="#call_footnote_Temp_183" id="footnote_Temp_183"><sup><small>15</small></sup></a> <a name="%_idx_1760" id="%_idx_1760"></a>Richard Waters (1979)developed a program that automatically analyzes traditional <a name="%_idx_1762" id="%_idx_1762"></a>Fortranprograms, viewing them in terms of maps, filters, and accumulations.He found that fully 90 percent of the code in the Fortran ScientificSubroutine Package fits neatly into this paradigm.  One of the reasonsfor the success of Lisp as a programming language is that listsprovide a standard medium for expressing ordered collections so thatthey can be manipulated using higher-order operations.  Theprogramming language <a name="%_idx_1764" id="%_idx_1764"></a>APL owes much of its power and appeal to asimilar choice. In APL all data are represented as arrays, and there is auniversal and convenient set of generic operators for all sorts ofarray operations.</p>
<p><a name="footnote_Temp_186" href="#call_footnote_Temp_186" id="footnote_Temp_186"><sup><small>16</small></sup></a> According to <a name="%_idx_1776" id="%_idx_1776"></a>Knuth (1981), this rule was formulated by<a name="%_idx_1778" id="%_idx_1778"></a>W. G. Horner early in the nineteenth century, but the method wasactually used by Newton over a hundred years earlier.  Horner's ruleevaluates the polynomial using fewer additions and multiplicationsthan does the straightforward method of first computing <em>a</em><sub><em>n</em></sub><em>x</em><sup><em>n</em></sup>,then adding <em>a</em><sub><em>n</em>-1</sub><em>x</em><sup><em>n</em>-1</sup>, and so on.  In fact, it is possible toprove that any algorithm for evaluating arbitrary polynomials must useat least as many additions and multiplications as does Horner's rule,and thus Horner's rule is an <a name="%_idx_1780" id="%_idx_1780"></a><a name="%_idx_1782" id="%_idx_1782"></a>optimal algorithm for polynomialevaluation.  This was proved (for the number of additions) by<a name="%_idx_1784" id="%_idx_1784"></a>A. M. Ostrowski in a 1954 paper that essentially founded the modernstudy of optimal algorithms.  The analogous statement formultiplications was proved by <a name="%_idx_1786" id="%_idx_1786"></a>V. Y. Pan in 1966.  The book by <a name="%_idx_1788" id="%_idx_1788"></a>Borodinand <a name="%_idx_1790" id="%_idx_1790"></a>Munro (1975) provides an overview of these and other results aboutoptimal algorithms.</p>
<p><a name="footnote_Temp_190" href="#call_footnote_Temp_190" id="footnote_Temp_190"><sup><small>17</small></sup></a> This definition uses theextended version of <code>map</code> described in footnote <a href="#footnote_Temp_166">12</a>.</p>
<p><a name="footnote_Temp_194" href="#call_footnote_Temp_194" id="footnote_Temp_194"><sup><small>18</small></sup></a> This approach to nested mappings was shownto us by <a name="%_idx_1820" id="%_idx_1820"></a>David Turner, whose languages <a name="%_idx_1822" id="%_idx_1822"></a>KRC and <a name="%_idx_1824" id="%_idx_1824"></a>Miranda provide elegantformalisms for dealing with these constructs.  The examples in thissection (see also exercise <a href="#%_thm_2.42">2.42</a>) are adapted from Turner1981.  In section <a href="book-Z-H-24.html#%_sec_3.5.3">3.5.3</a>, we'll see how thisapproach generalizes to infinite sequences.</p>
<p><a name="footnote_Temp_195" href="#call_footnote_Temp_195" id="footnote_Temp_195"><sup><small>19</small></sup></a> We'rerepresenting a pair here as a list of two elements rather than as aLisp pair.  Thus, the “pair” (<em>i</em>,<em>j</em>) is represented as <code>(list ij)</code>, not <code>(cons i j)</code>.</p>
<p><a name="footnote_Temp_196" href="#call_footnote_Temp_196" id="footnote_Temp_196"><sup><small>20</small></sup></a> The set <em>S</em> - <em>x</em> is the set of all elementsof <em>S</em>, excluding <em>x</em>.</p>
<p><a name="footnote_Temp_197" href="#call_footnote_Temp_197" id="footnote_Temp_197"><sup><small>21</small></sup></a> <a name="%_idx_1834" id="%_idx_1834"></a><a name="%_idx_1836" id="%_idx_1836"></a><a name="%_idx_1838" id="%_idx_1838"></a>Semicolons in Scheme code are used tointroduce <em>comments</em>.  Everything from the semicolon to the end ofthe line is ignored by the interpreter.  In this book we don't usemany comments; we try to make our programs self-documenting by usingdescriptive names.</p>
<p><a name="footnote_Temp_202" href="#call_footnote_Temp_202" id="footnote_Temp_202"><sup><small>22</small></sup></a> The picture language is based on the language<a name="%_idx_1856" id="%_idx_1856"></a>Peter Henderson created to constructimages like <a name="%_idx_1858" id="%_idx_1858"></a>M.C. Escher's “Square Limit” woodcut (see Henderson 1982).The woodcut incorporates arepeated scaled pattern, similar to the arrangements drawn usingthe <code>square-limit</code> procedure in this section.</p>
<p><a name="footnote_Temp_204" href="#call_footnote_Temp_204" id="footnote_Temp_204"><sup><small>23</small></sup></a> <a name="%_idx_1866" id="%_idx_1866"></a><a name="%_idx_1868" id="%_idx_1868"></a>William Barton Rogers (1804-1882) was the founder and first presidentof MIT.  A geologist and talented teacher, he taught at William andMary College and at the University of Virginia.  In 1859 he moved toBoston, where he had more time for research, worked on a planfor establishing a “polytechnic institute,” and served asMassachusetts's first State Inspector of Gas Meters.</p>
<p>When MIT was established in 1861, Rogers was elected its firstpresident.  Rogers espoused an ideal of “useful learning” that wasdifferent from the university education of the time, with itsoveremphasis on the classics, which, as he wrote, “stand in the way ofthe broader, higher and more practical instruction and discipline ofthe natural and social sciences.”  This education was likewise to bedifferent from narrow trade-school education.  In Rogers's words:</p>
<blockquote><p>The world-enforced distinction between the practical and thescientific worker is utterly futile, and the whole experience ofmodern times has demonstrated its utter worthlessness.</p>
</blockquote>
<p>Rogers served as president of MIT until 1870, when he resigned due toill health.  In 1878 the second president of MIT, <a name="%_idx_1870" id="%_idx_1870"></a>John Runkle,resigned under the pressure of a financial crisis brought on by thePanic of 1873 and strain of fighting off attempts by Harvard to takeover MIT.  Rogers returned to hold the office of president until1881.</p>
<p>Rogers collapsed and died while addressing MIT's graduating class atthe commencement exercises of 1882.  Runkle quoted Rogers's lastwords in a memorial address delivered that same year:</p>
<blockquote><p>“As I stand here today and see what the Institute is, <code>...</code> I callto mind the beginnings of science.  I remember one hundred and fiftyyears ago Stephen Hales published a pamphlet on the subject ofilluminating gas, in which he stated that his researches haddemonstrated that 128 grains of bituminous coal – ”<a name="%_idx_1872" id="%_idx_1872"></a></p>
<p>“Bituminous coal,” these were his last words on earth.  Here he bentforward, as if consulting some notes on the table before him, thenslowly regaining an erect position, threw up his hands, and wastranslated from the scene of his earthly labors and triumphs to “thetomorrow of death,” where the mysteries of life are solved, and thedisembodied spirit finds unending satisfaction in contemplating thenew and still unfathomable mysteries of the infinite future.</p>
</blockquote>In the words of  Francis A. Walker<a name="%_idx_1874" id="%_idx_1874"></a>(MIT's third president):<blockquote><p>All his life he had borne himself most faithfully and heroically, andhe died as so good a knight would surely have wished, in harness, athis post, and in the very part and act of public duty.</p>
</blockquote><p><a name="footnote_Temp_207" href="#call_footnote_Temp_207" id="footnote_Temp_207"><sup><small>24</small></sup></a> Equivalently, we couldwrite</p>
<p></p>
<p><pre><a name="%_idx_1902" id="%_idx_1902"></a>(define flipped-pairs
  (square-of-four identity flip-vert identity flip-vert))
</pre></p>
<p></p>
<p></p>
<p><a name="footnote_Temp_208" href="#call_footnote_Temp_208" id="footnote_Temp_208"><sup><small>25</small></sup></a> <code>Rotate180</code>rotates a painter by 180 degrees (see exercise <a href="#%_thm_2.50">2.50</a>).Instead of <code>rotate180</code> we could say <code>(compose flip-vert flip-horiz)</code>, usingthe <code>compose</code> procedure from exercise <a href="book-Z-H-12.html#%_thm_1.42">1.42</a>.</p>
<p><a name="footnote_Temp_211" href="#call_footnote_Temp_211" id="footnote_Temp_211"><sup><small>26</small></sup></a> <code>Frame-coord-map</code> usesthe vector operations described in exercise <a href="#%_thm_2.46">2.46</a> below, which weassume have been implemented using some representation for vectors.Because of data abstraction, it doesn't matter what this vectorrepresentation is, so long as the vector operations behave correctly.</p>
<p><a name="footnote_Temp_215" href="#call_footnote_Temp_215" id="footnote_Temp_215"><sup><small>27</small></sup></a> <code>Segments-&gt;painter</code> uses the representation for linesegments described in exercise <a href="#%_thm_2.48">2.48</a> below.It also uses the <code>for-each</code> procedure described in exercise <a href="#%_thm_2.23">2.23</a>.</p>
<p><a name="footnote_Temp_216" href="#call_footnote_Temp_216" id="footnote_Temp_216"><sup><small>28</small></sup></a> For example, the <code>rogers</code> painter offigure <a href="#%_fig_2.11">2.11</a> was constructed from a gray-level image.For each point in a given frame,the <code>rogers</code> painter determines the point in the image that is mapped to itunder the frame coordinate map, and shades itaccordingly.  By allowing different types of painters, we are capitalizing on theabstract data idea discussed in section <a href="book-Z-H-14.html#%_sec_2.1.3">2.1.3</a>, where weargued that a rational-number representation could be anything at all thatsatisfies an appropriate condition.  Here we're using the fact that apainter can be implemented in any way at all, so long as it drawssomething in the designated frame.  Section <a href="book-Z-H-14.html#%_sec_2.1.3">2.1.3</a> alsoshowed how pairs could be implemented as procedures.  Painters are oursecond example of a procedural representation for data.</p>
<p><a name="footnote_Temp_220" href="#call_footnote_Temp_220" id="footnote_Temp_220"><sup><small>29</small></sup></a> <code>Rotate90</code> is a pure rotation only for squareframes, because it also stretches and shrinks the image to fit intothe rotated frame.</p>
<p><a name="footnote_Temp_221" href="#call_footnote_Temp_221" id="footnote_Temp_221"><sup><small>30</small></sup></a> The diamond-shaped images in figures <a href="#%_fig_2.10">2.10</a>and <a href="#%_fig_2.11">2.11</a> were created with <code>squash-inwards</code> applied to<code>wave</code> and <code>rogers</code>.</p>
<p><a name="footnote_Temp_225" href="#call_footnote_Temp_225" id="footnote_Temp_225"><sup><small>31</small></sup></a> Section <a href="book-Z-H-22.html#%_sec_3.3.4">3.3.4</a> describes one such language.</p>
</div></body>
</html>
