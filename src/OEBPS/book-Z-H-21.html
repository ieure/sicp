<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<?xml version="1.0" encoding="utf-8"?><html xmlns="http://www.w3.org/1999/xhtml" xmlns:ops="http://www.idpf.org/2007/ops">
<!-- Generated from TeX source by tex2page, v 4o,
     (c) Dorai Sitaram, http://www.cs.rice.edu/~dorai/tex2page --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Type: text/html; charset=utf-8">
<title>Structure and Interpretation of Computer Programs</title>
<link rel="stylesheet" type="text/css" href="book-Z-C.css" title="default">
</head>
<body><a name="%_sec_3.2" id="%_sec_3.2"></a><h2><a href="book-Z-H-4.html#%_toc_%_sec_3.2">3.2  The Environment Model of Evaluation</a></h2>
<p><a name="%_idx_3034" id="%_idx_3034"></a>When we introduced compound procedures in chapter 1, we used the<a name="%_idx_3036" id="%_idx_3036"></a>substitution model of evaluation(section <a href="book-Z-H-10.html#%_sec_1.1.5">1.1.5</a>) to define what is meant byapplying a procedure to arguments:</p>
<p></p>
<p></p>
<ul><li>To apply a compound procedure to arguments, evaluate the body of theprocedure with each formal parameter replaced by the correspondingargument.</li></ul>
<p></p>
<p>Once we admit assignment into our programming language, such adefinition is no longer adequate.  In particular,section <a href="book-Z-H-20.html#%_sec_3.1.3">3.1.3</a> argued that, in the presence ofassignment, a variable can no longer be considered to be merely a namefor a value.  Rather, a variable must somehow designate a “place” inwhich values can be stored.  In our new model of evaluation, theseplaces will be maintained in structures called <a name="%_idx_3038" id="%_idx_3038"></a><em>environments</em>.</p>
<p>An environment is a sequence of <a name="%_idx_3040" id="%_idx_3040"></a><em>frames</em>.  Each frame is a table(possibly empty) of <a name="%_idx_3042" id="%_idx_3042"></a><em>bindings</em>, which associate variable names withtheir corresponding values.  (A single frame may contain at most onebinding for any variable.)  Each frame also has a pointer to its <a name="%_idx_3044" id="%_idx_3044"></a><a name="%_idx_3046" id="%_idx_3046"></a><em>enclosing environment</em>, unless, for the purposes of discussion, theframe is considered to be <a name="%_idx_3048" id="%_idx_3048"></a><a name="%_idx_3050" id="%_idx_3050"></a><em>global</em>.  The <a name="%_idx_3052" id="%_idx_3052"></a><em>value of a variable</em>with respect to an environment is the value given by the binding ofthe variable in the first frame in the environment that contains abinding for that variable.  If no frame in the sequence specifies abinding for the variable, then the variable is said to be <a name="%_idx_3054" id="%_idx_3054"></a><a name="%_idx_3056" id="%_idx_3056"></a><em>unbound</em> in the environment.</p>
<p><a name="%_fig_3.1" id="%_fig_3.1"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch3-Z-G-2.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 3.1:</b>  A simple environment structure.</div></caption>
<tr><td><a name="%_idx_3058" id="%_idx_3058"></a>
</td></tr>
</table></div>
<p></p>
<p>Figure <a href="#%_fig_3.1">3.1</a> shows a simple environmentstructure consisting of three frames, labeled I, II, and III.  In thediagram, A, B, C, and D are pointers to environments.  C and D pointto the same environment.  The variables <code>z</code> and <code>x</code> are boundin frame II, while <code>y</code> and <code>x</code> are bound in frame I.  Thevalue of <code>x</code> in environment D is 3.  The value of <code>x</code> withrespect to environment B is also 3.  This is determined as follows: Weexamine the first frame in the sequence (frame III) and do not find abinding for <code>x</code>, so we proceed to the enclosing environment D andfind the binding in frame I.  On the other hand, the value of <code>x</code>in environment A is 7, because the first frame in the sequence (frameII) contains a binding of <code>x</code> to 7.  With respect to environmentA, the binding of <code>x</code> to 7 in frame II is said to <a name="%_idx_3060" id="%_idx_3060"></a><em>shadow</em> thebinding of <code>x</code> to 3 in frame I.</p>
<p>The environment is crucial to the evaluation process,because it determines the context in which an expression should beevaluated.  Indeed, one could say that expressions in a programminglanguage do not, in themselves, have any meaning.  Rather, anexpression acquires a meaning only with respect to some environment inwhich it is evaluated.  Even the interpretation of an expression asstraightforward as <code>(+ 1 1)</code> depends on an understanding that oneis operating in a context in which <code>+</code> is the symbol for addition.Thus, in our model of evaluation we will always speak of evaluating anexpression with respect to some environment.  To describe interactionswith the interpreter, we will suppose that there is a <a name="%_idx_3062" id="%_idx_3062"></a>globalenvironment, consisting of a single frame (with no enclosingenvironment) that includes values for the symbols associated with theprimitive procedures.  For example, the idea that <code>+</code> is thesymbol for addition is captured by saying that the symbol <code>+</code> isbound in the global environment to the primitive addition procedure.</p>
<p><a name="%_sec_3.2.1" id="%_sec_3.2.1"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_3.2.1">3.2.1  The Rules for Evaluation</a></h3>
<p><a name="%_idx_3064" id="%_idx_3064"></a>The overall specification of how the interpreter evaluates acombination remains the same as when we first introduced it insection <a href="book-Z-H-10.html#%_sec_1.1.3">1.1.3</a>:</p>
<p></p>
<p></p>
<ul><li>To evaluate a combination:</li></ul>
<p></p>
<p></p>
<blockquote><p>1.  Evaluate the subexpressions of thecombination.<a name="call_footnote_Temp_342" href="#footnote_Temp_342" id="call_footnote_Temp_342"><sup><small>12</small></sup></a></p>
<p></p>
<p>2.  Apply the value of the operator subexpression to the values of theoperand subexpressions.</p>
</blockquote>
<p>The environment model of evaluation replaces the substitution model inspecifying what it means to apply a compound procedure to arguments.</p>
<p>In the environment model of evaluation, a procedure is always a pairconsisting of some code and a pointer to an environment.  Proceduresare created in one way only: by evaluating a <code>lambda</code> expression.<a name="%_idx_3070" id="%_idx_3070"></a>This produces a procedure whose code is obtained from the text of the<code>lambda</code> expression and whose environment is the environment inwhich the <code>lambda</code> expression was evaluated to produce theprocedure.  For example, consider the procedure definition</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3072" id="%_idx_3072"></a>(define (square x)
  (* x x))
</pre></p>
<p></p>
<p>evaluated in the global environment.  The procedure definition syntaxis just syntactic sugar for an underlying implicit <code>lambda</code>expression.  It would have been equivalent to have used</p>
<p></p>
<p></p>
<p><pre>(define square
  (lambda (x) (* x x)))
</pre></p>
<p></p>
<p>which evaluates <code>(lambda (x) (* x x))</code> and binds <code>square</code> to the resulting value, all in the global environment.</p>
<p>Figure <a href="#%_fig_3.2">3.2</a> shows the result of evaluating this<code>define</code> expression.  The procedure object is a pair whose codespecifies that the procedure has one formal parameter, namely <code>x</code>,and a procedure body <code>(* x x)</code>.  The environment part of theprocedure is a pointer to the global environment, since that is theenvironment in which the <code>lambda</code> expression was evaluated toproduce the procedure. A new binding, which associates the procedureobject with the symbol <code>square</code>, has been added to the globalframe.  In general, <code>define</code> creates definitions by addingbindings to frames.</p>
<p><a name="%_fig_3.2" id="%_fig_3.2"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch3-Z-G-3.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 3.2:</b>  Environment structure produced byevaluating<code>(define (square x) (* x x))</code> in the global environment.</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p>Now that we have seen how procedures are created, we can describe howprocedures are applied.  The environment model specifies: To apply aprocedure to arguments, create a new environment containing a framethat binds the parameters to the values of the arguments.  Theenclosing environment of this frame is the environment specified bythe procedure.  Now, within this new environment, evaluate theprocedure body.</p>
<p>To show how this rule is followed, figure <a href="#%_fig_3.3">3.3</a>illustrates the environment structure created by evaluating theexpression <code>(square 5)</code> in the global environment, where <code>square</code> is the procedure generated infigure <a href="#%_fig_3.2">3.2</a>.  Applying the procedure results inthe creation of a new environment, labeled E1 in the figure, thatbegins with a frame in which <code>x</code>, the formal parameter for theprocedure, is bound to the argument 5.  The pointer leading upwardfrom this frame shows that the frame's enclosing environment is theglobal environment.  The global environment is chosen here, becausethis is the environment that is indicated as part of the <code>square</code>procedure object.  Within E1, we evaluate the body of the procedure,<code>(* x x)</code>.  Since the value of <code>x</code> in E1 is 5, the result is<code>(* 5 5)</code>, or 25.<a name="%_fig_3.3" id="%_fig_3.3"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch3-Z-G-4.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 3.3:</b>  Environment created by evaluating <code>(square 5)</code>in the global environment.</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p>The environment model of procedure application can be summarized bytwo rules:</p>
<p></p>
<p></p>
<ul>
<li>A procedure object is applied to a set of arguments byconstructing a frame, binding the formal parameters of the procedureto the arguments of the call, and then evaluating the body ofthe procedure in the context of the new environment constructed.  Thenew frame has as its enclosing environment the environment part of theprocedure object being applied.<p><a name="%_idx_3074" id="%_idx_3074"></a><a name="%_idx_3076" id="%_idx_3076"></a></p>
</li>
<li>A procedure is created by evaluating a <code>lambda</code>expression relative to a given environment.  The resulting procedureobject is a pair consisting of the text of the <code>lambda</code> expressionand a pointer to the environment in which the procedure was created.</li>
</ul>
<p></p>
<p><a name="%_idx_3078" id="%_idx_3078"></a>We also specify that defining a symbol using <code>define</code> creates abinding in the current environment frame and assigns to the symbol theindicated value.<a name="call_footnote_Temp_343" href="#footnote_Temp_343" id="call_footnote_Temp_343"><sup><small>13</small></sup></a>  Finally, we specify the behavior of<code>set!</code>, the operation that forced us to introduce the environmentmodel in the first place.  Evaluating the expression <code>(set!&lt;<em>variable</em>&gt; &lt;<em>value</em>&gt;)</code> in some environment locates the binding ofthe variable in the environment and changes that binding to indicatethe new value.  That is, one finds the first frame in the environmentthat contains a binding for the variable and modifies that frame.  Ifthe variable is unbound in the environment, then <code>set!</code> signalsan error.</p>
<p>These evaluation rules, though considerably more complex than thesubstitution model, are still reasonably straightforward.  Moreover,the evaluation model, though abstract, provides a correct descriptionof how the interpreter evaluates expressions.  In chapter 4 we shallsee how this model can serve as a blueprint for implementing a workinginterpreter.  The following sections elaborate the details of themodel by analyzing some illustrative programs.<a name="%_sec_3.2.2" id="%_sec_3.2.2"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_3.2.2">3.2.2  Applying Simple Procedures</a></h3>
<p><a name="%_idx_3082" id="%_idx_3082"></a><a name="%_idx_3084" id="%_idx_3084"></a><a name="%_idx_3086" id="%_idx_3086"></a>When we introduced the substitution model insection <a href="book-Z-H-10.html#%_sec_1.1.5">1.1.5</a> we showed how the combination<code>(f 5)</code> evaluates to 136, given the following proceduredefinitions:</p>
<p></p>
<p></p>
<p><pre>(define (square x)
  (* x x))
(define (sum-of-squares x y)
  (+ (square x) (square y)))
(define (f a)
  (sum-of-squares (+ a 1) (* a 2)))
</pre></p>
<p></p>
<p>We can analyze the same example using the environment model.Figure <a href="#%_fig_3.4">3.4</a> shows the three procedure objectscreated by evaluating the definitions of <code>f</code>, <code>square</code>, and<code>sum-of-squares</code> in the global environment.  Each procedure objectconsists of some code, together with a pointer to the globalenvironment.</p>
<p><a name="%_fig_3.4" id="%_fig_3.4"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch3-Z-G-5.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 3.4:</b>  Procedure objects in the global frame.</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p>In figure <a href="#%_fig_3.5">3.5</a> we see the environment structure createdby evaluating the expression <code>(f 5)</code>.  The call to <code>f</code> createsa new environment E1 beginning with a frame in which <code>a</code>, theformal parameter of <code>f</code>, is bound to the argument 5.  In E1, weevaluate the body of <code>f</code>:</p>
<p></p>
<p></p>
<p><pre>(sum-of-squares (+ a 1) (* a 2))
</pre></p>
<p></p>
<p></p>
<p><a name="%_fig_3.5" id="%_fig_3.5"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch3-Z-G-6.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 3.5:</b>  Environments created by evaluating <code>(f 5)</code>using the procedures in figure <a href="#%_fig_3.4">3.4</a>.</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p>To evaluate this combination, we first evaluate the subexpressions.The first subexpression, <code>sum-of-squares</code>, has a value that is aprocedure object.  (Notice how this value is found: We first look inthe first frame of E1, which contains no binding for <code>sum-of-squares</code>.  Then we proceed to the enclosing environment,i.e. the global environment, and find the binding shown infigure <a href="#%_fig_3.4">3.4</a>.)  The other two subexpressions areevaluated by applying the primitive operations <code>+</code> and <code>*</code> toevaluate the two combinations <code>(+ a 1)</code> and <code>(* a 2)</code> toobtain 6 and 10, respectively.</p>
<p>Now we apply the procedure object <code>sum-of-squares</code> to thearguments 6 and 10.  This results in a new environment E2 in which theformal parameters <code>x</code> and <code>y</code> are bound to the arguments.Within E2 we evaluate the combination <code>(+ (square x) (square y))</code>.This leads us to evaluate <code>(square x)</code>, where <code>square</code> isfound in the global frame and <code>x</code> is 6.  Once again, we set up anew environment, E3, in which <code>x</code> is bound to 6, and within thiswe evaluate the body of <code>square</code>, which is <code>(* x x)</code>.  Also aspart of applying <code>sum-of-squares</code>, we must evaluate thesubexpression <code>(square y)</code>, where <code>y</code> is 10.  This second callto <code>square</code> creates another environment, E4, in which <code>x</code>, theformal parameter of <code>square</code>, is bound to 10.  And within E4 wemust evaluate <code>(* x x)</code>.</p>
<p>The important point to observe is that each call to <code>square</code>creates a new environment containing a binding for <code>x</code>.  We cansee here how the different frames serve to keep separate the differentlocal variables all named <code>x</code>.  Notice that each frame created by<code>square</code> points to the global environment, since this is theenvironment indicated by the <code>square</code> procedure object.</p>
<p>After the subexpressions are evaluated, the results arereturned.  The values generated by the two calls to <code>square</code> areadded by <code>sum-of-squares</code>, and this result is returned by <code>f</code>.Since our focus here is on the environment structures, we will notdwell on how these returned values are passed from call to call;however, this is also an important aspect of the evaluation process,and we will return to it in detail in chapter 5.</p>
<p><a name="%_thm_3.9" id="%_thm_3.9"></a><b>Exercise 3.9.</b>  <a name="%_idx_3088" id="%_idx_3088"></a><a name="%_idx_3090" id="%_idx_3090"></a><a name="%_idx_3092" id="%_idx_3092"></a>In section <a href="book-Z-H-11.html#%_sec_1.2.1">1.2.1</a>we used the substitution model to analyze twoprocedures for computing factorials, a recursive version</p>
<p></p>
<p></p>
<p><pre>(define (factorial n)
  (if (= n 1)
      1
      (* n (factorial (- n 1)))))
</pre></p>
<p></p>
<p>and an iterative version</p>
<p></p>
<p></p>
<p><pre>(define (factorial n)
  (fact-iter 1 1 n))
(define (fact-iter product counter max-count)
  (if (&gt; counter max-count)
      product
      (fact-iter (* counter product)
                 (+ counter 1)
                 max-count)))
</pre></p>
<p></p>
<p>Show the environment structures created by evaluating <code>(factorial 6)</code>using each version of the <code>factorial</code> procedure.<a name="call_footnote_Temp_345" href="#footnote_Temp_345" id="call_footnote_Temp_345"><sup><small>14</small></sup></a></p>
<p><a name="%_sec_3.2.3" id="%_sec_3.2.3"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_3.2.3">3.2.3  Frames as the Repository of Local State</a></h3>
<p><a name="%_idx_3098" id="%_idx_3098"></a><a name="%_idx_3100" id="%_idx_3100"></a><a name="%_idx_3102" id="%_idx_3102"></a><a name="%_idx_3104" id="%_idx_3104"></a>We can turn to the environment model to see how procedures andassignment can be used to represent objects with local state.  As anexample, consider the “withdrawal processor” fromsection <a href="book-Z-H-20.html#%_sec_3.1.1">3.1.1</a> created by calling theprocedure</p>
<p></p>
<p></p>
<p><pre>(define (make-withdraw balance)
  (lambda (amount)
    (if (&gt;= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds")))
</pre></p>
<p></p>
<p>Let us describe the evaluation of</p>
<p></p>
<p></p>
<p><pre>(define W1 (make-withdraw 100))
</pre></p>
<p></p>
<p>followed by</p>
<p></p>
<p></p>
<p><pre>(W1 50)
<i>50</i>
</pre></p>
<p></p>
<p>Figure <a href="#%_fig_3.6">3.6</a> shows the result of defining the <code>make-withdraw</code> procedure in the global environment.  This produces aprocedure object that contains a pointer to the global environment.So far, this is no different from the examples we have already seen,except that the body of the procedure is itself a <code>lambda</code>expression.</p>
<p><a name="%_fig_3.6" id="%_fig_3.6"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch3-Z-G-7.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 3.6:</b>  Result of defining <code>make-withdraw</code>in the global environment.</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p>The interesting part of the computation happens when we apply theprocedure <code>make-withdraw</code> to an argument:</p>
<p></p>
<p></p>
<p><pre>(define W1 (make-withdraw 100))
</pre></p>
<p></p>
<p>We begin, as usual, by setting up an environment E1 in which theformal parameter <code>balance</code> is bound to the argument 100.  Withinthis environment, we evaluate the body of <code>make-withdraw</code>, namelythe <code>lambda</code> expression.  This constructs a new procedure object,whose code is as specified by the <code>lambda</code> and whose environmentis E1, the environment in which the <code>lambda</code> was evaluated toproduce the procedure.  The resulting procedure object is the valuereturned by the call to <code>make-withdraw</code>.  This is bound to <code>W1</code> in the global environment, since the <code>define</code> itself is beingevaluated in the global environment.  Figure <a href="#%_fig_3.7">3.7</a> shows theresulting environment structure.</p>
<p><a name="%_fig_3.7" id="%_fig_3.7"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch3-Z-G-8.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 3.7:</b>  Result of evaluating <code>(define W1 (make-withdraw 100))</code>.</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p>Now we can analyze what happens when <code>W1</code> is applied to anargument:</p>
<p></p>
<p></p>
<p><pre>(W1 50)
<i>50</i>
</pre></p>
<p></p>
<p>We begin by constructing a frame in which <code>amount</code>, the formalparameter of <code>W1</code>, is bound to the argument 50.  The crucial pointto observe is that this frame has as its enclosing environment not theglobal environment, but rather the environment E1, because this is theenvironment that is specified by the <code>W1</code> procedure object.Within this new environment, we evaluate the body of the procedure:</p>
<p></p>
<p></p>
<p><pre>(if (&gt;= balance amount)
    (begin (set! balance (- balance amount))
           balance)
    "Insufficient funds")
</pre></p>
<p></p>
<p>The resulting environment structure is shown infigure <a href="#%_fig_3.8">3.8</a>.  The expression being evaluated referencesboth <code>amount</code> and <code>balance</code>.  <code>Amount</code> will be found inthe first frame in the environment, while <code>balance</code> will be foundby following the enclosing-environment pointer to E1.</p>
<p><a name="%_fig_3.8" id="%_fig_3.8"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch3-Z-G-9.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 3.8:</b>  Environments created by applying the procedureobject <code>W1</code>.</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p>When the <code>set!</code> is executed, the binding of <code>balance</code> in E1 is changed.  At the completion of the call to <code>W1</code>,<code>balance</code> is 50, and the frame that contains <code>balance</code>is still pointed to by the procedure object <code>W1</code>.  The framethat binds <code>amount</code>(in which we executed the code that changed <code>balance</code>) is no longerrelevant, since the procedure call that constructed it has terminated,and there are no pointers to that frame from other parts of theenvironment.  The next time <code>W1</code> is called, this will build a newframe that binds <code>amount</code> and whose enclosing environment is E1.We see that E1 serves as the “place” that holds the local statevariable for the procedure object <code>W1</code>.  Figure <a href="#%_fig_3.9">3.9</a>shows the situation after the call to <code>W1</code>.</p>
<p><a name="%_fig_3.9" id="%_fig_3.9"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch3-Z-G-10.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 3.9:</b>  Environments after the call to <code>W1</code>.</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p>Observe what happens when we create a second “withdraw” object bymaking another call to <code>make-withdraw</code>:</p>
<p></p>
<p></p>
<p><pre>(define W2 (make-withdraw 100))
</pre></p>
<p></p>
<p>This produces the environment structure of figure <a href="#%_fig_3.10">3.10</a>, which showsthat <code>W2</code> is a procedure object, that is, a pair with some codeand an environment.  The environment E2 for <code>W2</code> was created bythe call to <code>make-withdraw</code>.  It contains a frame with its ownlocal binding for <code>balance</code>.  On the other hand, <code>W1</code> and <code>W2</code> have the same code: the code specified by the <code>lambda</code>expression in the body of <code>make-withdraw</code>.<a name="call_footnote_Temp_346" href="#footnote_Temp_346" id="call_footnote_Temp_346"><sup><small>15</small></sup></a> We see here why <code>W1</code> and <code>W2</code>behave as independent objects.  Calls to <code>W1</code> reference the statevariable <code>balance</code> stored in E1, whereas calls to <code>W2</code>reference the <code>balance</code> stored in E2. Thus, changes to the localstate of one object do not affect the other object.</p>
<p><a name="%_fig_3.10" id="%_fig_3.10"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch3-Z-G-11.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 3.10:</b>  Using <code>(define W2 (make-withdraw 100))</code>to create a second object.</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p></p>
<p><a name="%_thm_3.10" id="%_thm_3.10"></a><b>Exercise 3.10.</b>  In the <code>make-withdraw</code> procedure, the local variable <code>balance</code>is created as a parameter of <code>make-withdraw</code>.  We could alsocreate the local state variable explicitly, using <code>let</code>, asfollows:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3106" id="%_idx_3106"></a>(define (make-withdraw initial-amount)
  (let ((balance initial-amount))
    (lambda (amount)
      (if (&gt;= balance amount)
          (begin (set! balance (- balance amount))
                 balance)
          "Insufficient funds"))))
</pre></p>
<p></p>
<p><a name="%_idx_3108" id="%_idx_3108"></a><a name="%_idx_3110" id="%_idx_3110"></a>Recall from section <a href="book-Z-H-12.html#%_sec_1.3.2">1.3.2</a> that <code>let</code> is simplysyntactic sugar for a procedure call:</p>
<p></p>
<p></p>
<p><pre>(let ((&lt;<em>var</em>&gt; &lt;<em>exp</em>&gt;)) &lt;<em>body</em>&gt;)
</pre></p>
<p></p>
<p>is interpreted as an alternate syntax for</p>
<p></p>
<p></p>
<p><pre>((lambda (&lt;<em>var</em>&gt;) &lt;<em>body</em>&gt;) &lt;<em>exp</em>&gt;)
</pre></p>
<p></p>
<p>Use the environment model to analyze this alternateversion of <code>make-withdraw</code>, drawing figures like the ones above toillustrate the interactions</p>
<p></p>
<p></p>
<p><pre>(define W1 (make-withdraw 100))

(W1 50)

(define W2 (make-withdraw 100))
</pre></p>
<p></p>
<p>Show that the two versions of <code>make-withdraw</code> create objects withthe same behavior.  How do the environment structures differ for the twoversions?</p>
<p></p>
<p><a name="%_sec_3.2.4" id="%_sec_3.2.4"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_3.2.4">3.2.4  Internal Definitions</a></h3>
<p><a name="%_idx_3112" id="%_idx_3112"></a><a name="%_idx_3114" id="%_idx_3114"></a><a name="%_idx_3116" id="%_idx_3116"></a>Section <a href="book-Z-H-10.html#%_sec_1.1.8">1.1.8</a> introduced the idea that procedures can have internaldefinitions, thus leading to a block structure as in thefollowing procedure to compute square roots:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3118" id="%_idx_3118"></a>(define (sqrt x)
  (define (good-enough? guess)
    (&lt; (abs (- (square guess) x)) 0.001))
  (define (improve guess)
    (average guess (/ x guess)))
  (define (sqrt-iter guess)
    (if (good-enough? guess)
        guess
        (sqrt-iter (improve guess))))
  (sqrt-iter 1.0))
</pre></p>
<p></p>
<p>Now we can use the environment model to see why these internaldefinitions behave as desired.  Figure <a href="#%_fig_3.11">3.11</a> shows the point in theevaluation of the expression <code>(sqrt 2)</code> where the internalprocedure <code>good-enough?</code> has been called for the first time with<code>guess</code> equal to 1.</p>
<p><a name="%_fig_3.11" id="%_fig_3.11"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch3-Z-G-12.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 3.11:</b>  <code>Sqrt</code> procedure with internal definitions.</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p>Observe the structure of the environment.  <code>Sqrt</code> is a symbol inthe global environment that is bound to a procedure object whoseassociated environment is the global environment.  When <code>sqrt</code> wascalled, a new environment E1 was formed, subordinate to the globalenvironment, in which the parameter <code>x</code> is bound to 2.  The bodyof <code>sqrt</code> was then evaluated in E1.  Since the first expression inthe body of <code>sqrt</code> is</p>
<p></p>
<p></p>
<p><pre>(define (good-enough? guess)
  (&lt; (abs (- (square guess) x)) 0.001))
</pre></p>
<p></p>
<p>evaluating this expression defined the procedure <code>good-enough?</code>in the environment E1.  To be more precise, the symbol <code>good-enough?</code> was added to the first frame of E1, bound to aprocedure object whose associated environment is E1.  Similarly, <code>improve</code> and <code>sqrt-iter</code> were defined as procedures in E1.  Forconciseness, figure <a href="#%_fig_3.11">3.11</a> shows only the procedureobject for <code>good-enough?</code>.</p>
<p>After the local procedures were defined, theexpression <code>(sqrt-iter 1.0)</code> was evaluated,still in environment E1.  So theprocedure object bound to <code>sqrt-iter</code> in E1 was called with 1 asan argument.  This created an environment E2 in which <code>guess</code>,the parameter of <code>sqrt-iter</code>, is bound to 1.  <code>Sqrt-iter</code> inturn called <code>good-enough?</code> with the value of <code>guess</code> (fromE2) as the argument for <code>good-enough?</code>.  This set up anotherenvironment, E3, in which <code>guess</code> (the parameter of <code>good-enough?</code>) is bound to 1.  Although <code>sqrt-iter</code> and <code>good-enough?</code> both have a parameter named <code>guess</code>, these are twodistinct local variables located in different frames.  Also, E2 and E3both have E1 as their enclosing environment, because the <code>sqrt-iter</code> and <code>good-enough?</code> procedures both have E1 as theirenvironment part.  One consequence of this is that the symbol <code>x</code>that appears in the body of <code>good-enough?</code> will reference thebinding of <code>x</code> that appears in E1, namely the value of <code>x</code>with which the original <code>sqrt</code> procedure was called.The environment model thus explains the two key properties that makelocal procedure definitions a useful technique for modularizingprograms:</p>
<p></p>
<ul>
<li>The names of the local procedures do not interfere withnames external to the enclosing procedure, because the local procedurenames will be bound in the frame that the procedure creates when it isrun, rather than being bound in the global environment.<p></p>
</li>
<li>The local procedures can access the arguments of the enclosingprocedure, simply by using parameter names as free variables.This is because the body of the local procedure is evaluated in anenvironment that is subordinate to the evaluation environment for theenclosing procedure.</li>
</ul>
<p></p>
<p></p>
<p><a name="%_thm_3.11" id="%_thm_3.11"></a><b>Exercise 3.11.</b>  <a name="%_idx_3120" id="%_idx_3120"></a><a name="%_idx_3122" id="%_idx_3122"></a><a name="%_idx_3124" id="%_idx_3124"></a>In section <a href="#%_sec_3.2.3">3.2.3</a>we saw how the environment model described thebehavior of procedures with local state.  Now we have seen howinternal definitions work.  A typical message-passing procedurecontains both of these aspects.  Consider the bank account procedureof section <a href="book-Z-H-20.html#%_sec_3.1.1">3.1.1</a>:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3126" id="%_idx_3126"></a>(define (make-account balance)
  (define (withdraw amount)
    (if (&gt;= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (define (dispatch m)
    (cond ((eq? m 'withdraw) withdraw)
          ((eq? m 'deposit) deposit)
          (else (error "Unknown request -- MAKE-ACCOUNT"
                       m))))
  dispatch)
</pre></p>
<p></p>
<p>Show the environment structure generated by the sequence ofinteractions</p>
<p></p>
<p></p>
<p><pre>(define acc (make-account 50))

((acc 'deposit) 40)
<i>90</i>

((acc 'withdraw) 60)
<i>30</i>
</pre></p>
<p></p>
<p>Where is the local state for <code>acc</code> kept?  Suppose we defineanother account</p>
<p></p>
<p></p>
<p><pre>(define acc2 (make-account 100))
</pre></p>
<p></p>
<p>How are the local states for the two accounts kept distinct?  Whichparts of the environment structure are shared between <code>acc</code> and<code>acc2</code>?</p>
<p></p>
<p></p>
<div class="smallprint"><hr></div>
<p></p>
<div class="footnote">
<p><a name="footnote_Temp_342" href="#call_footnote_Temp_342" id="footnote_Temp_342"><sup><small>12</small></sup></a> Assignment introduces a subtlety into step 1 ofthe evaluation rule.  As shown inexercise <a href="book-Z-H-20.html#%_thm_3.8">3.8</a>, the presence of assignmentallows us to write expressions that will produce different valuesdepending on the order in which the subexpressions in a combination<a name="%_idx_3066" id="%_idx_3066"></a><a name="%_idx_3068" id="%_idx_3068"></a>are evaluated.  Thus, to be precise, we should specify an evaluationorder in step 1 (e.g., left to right or right to left).  However, thisorder should always be considered to be an implementation detail, andone should never write programs that depend on some particular order.For instance, a sophisticated compiler might optimize a program byvarying the order in which subexpressions are evaluated.</p>
<p><a name="footnote_Temp_343" href="#call_footnote_Temp_343" id="footnote_Temp_343"><sup><small>13</small></sup></a> If there is already a binding for thevariable in the current frame, then the binding is changed.  This isconvenient because it allows redefinition of symbols; however, it alsomeans that <code>define</code> can be used to change values, and this bringsup the issues of assignment without explicitly using <a name="%_idx_3080" id="%_idx_3080"></a><code>set!</code>.Because of this, some people prefer redefinitions of existing symbolsto signal errors or warnings.</p>
<p><a name="footnote_Temp_345" href="#call_footnote_Temp_345" id="footnote_Temp_345"><sup><small>14</small></sup></a> Theenvironment model will not clarify our claim insection <a href="book-Z-H-11.html#%_sec_1.2.1">1.2.1</a> that the interpreter canexecute a procedure such as <code>fact-iter</code> in a constant amount ofspace using tail recursion.  We will discuss tail recursion when we<a name="%_idx_3094" id="%_idx_3094"></a><a name="%_idx_3096" id="%_idx_3096"></a>deal with the control structure of the interpreter insection <a href="book-Z-H-34.html#%_sec_5.4">5.4</a>.</p>
<p><a name="footnote_Temp_346" href="#call_footnote_Temp_346" id="footnote_Temp_346"><sup><small>15</small></sup></a> Whether<code>W1</code> and <code>W2</code> share the same physical code stored in thecomputer, or whether they each keep a copy of the code, is a detail ofthe implementation.  For the interpreter we implement in chapter 4,the code is in fact shared.</p>
</div></body>
</html>
