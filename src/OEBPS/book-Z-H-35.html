<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<?xml version="1.0" encoding="utf-8"?><html xmlns="http://www.w3.org/1999/xhtml" xmlns:ops="http://www.idpf.org/2007/ops">
<!-- Generated from TeX source by tex2page, v 4o,
     (c) Dorai Sitaram, http://www.cs.rice.edu/~dorai/tex2page --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Type: text/html; charset=utf-8">
<title>Structure and Interpretation of Computer Programs</title>
<link rel="stylesheet" type="text/css" href="book-Z-C.css" title="default">
</head>
<body><a name="%_sec_5.5" id="%_sec_5.5"></a><h2><a href="book-Z-H-4.html#%_toc_%_sec_5.5">5.5  Compilation</a></h2>
<p><a name="%_idx_6194" id="%_idx_6194"></a>The explicit-control evaluator of section <a href="book-Z-H-34.html#%_sec_5.4">5.4</a> is aregister machine whose controller interprets Scheme programs.  In thissection we will see how to run Scheme programs on a register machinewhose controller is not a Scheme interpreter.</p>
<p><a name="%_idx_6196" id="%_idx_6196"></a><a name="%_idx_6198" id="%_idx_6198"></a>The explicit-control evaluator machine is universal – it can carry outany computational process that can be described in Scheme.  Theevaluator's controller orchestrates the use of its data paths toperform the desired computation.  Thus, the evaluator's data paths areuniversal: They are sufficient to perform any computation we desire,given an appropriate controller.<a name="call_footnote_Temp_794" href="#footnote_Temp_794" id="call_footnote_Temp_794"><sup><small>33</small></sup></a></p>
<p><a name="%_idx_6200" id="%_idx_6200"></a><a name="%_idx_6202" id="%_idx_6202"></a>Commercial general-purpose computers are register machines organizedaround a collection of registers and operations that constitutean efficient and convenient universal set of data paths.The controller for a general-purpose machine is an interpreter fora register-machine language like the one we have been using.  Thislanguage is called the <a name="%_idx_6204" id="%_idx_6204"></a><em>native language</em> of the machine, or simply<a name="%_idx_6206" id="%_idx_6206"></a><em>machine language</em>.  Programs written in machine language aresequences of instructions that use the machine's data paths.For example, the <a name="%_idx_6208" id="%_idx_6208"></a>explicit-control evaluator's instruction sequencecan be thought of as a machine-language program for a general-purposecomputer rather than as the controller for a specialized interpretermachine.</p>
<p><a name="%_idx_6210" id="%_idx_6210"></a><a name="%_idx_6212" id="%_idx_6212"></a>There are two common strategies for bridging the gap betweenhigher-level languages and register-machine languages.  Theexplicit-control evaluator illustrates thestrategy of interpretation.  An interpreter written in the nativelanguage of a machine configures the machine to execute programswritten in a language (called the <a name="%_idx_6214" id="%_idx_6214"></a><em>source language</em>) that maydiffer from the native language of the machine performing theevaluation.  The primitive procedures of the source language areimplemented as a library of subroutines written in the native languageof the given machine.  A program to be interpreted (called the <a name="%_idx_6216" id="%_idx_6216"></a><em>source program</em>) is represented as a data structure.  The interpretertraverses this data structure, analyzing the source program.  As itdoes so, it simulates the intended behavior of the source program bycalling appropriate primitive subroutines from the library.</p>
<p>In this section, we explore the alternative strategy of <em>compilation</em>.  A compiler for a given source language and machinetranslates a source program into an equivalent program (called the<a name="%_idx_6218" id="%_idx_6218"></a><em>object program</em>) written in the machine's native language.  Thecompiler that we implement in this section translates programs writtenin Scheme into sequences of instructions to be executed usingthe explicit-control evaluator machine's data paths.<a name="call_footnote_Temp_795" href="#footnote_Temp_795" id="call_footnote_Temp_795"><sup><small>34</small></sup></a></p>
<p>Compared with interpretation, compilation can provide a great increasein the efficiency of program execution, as we will explain below inthe overview of the compiler.  On the other hand, an interpreterprovides a more powerful environment for interactive programdevelopment and debugging, because the source program being executedis available at run time to be examined and modified.  In addition,because the entire library of primitives is present, new programs canbe constructed and added to the system during debugging.</p>
<p>In view of the complementary advantages of compilation andinterpretation, modern program-development environments pursue a mixedstrategy.  Lisp interpreters are generally organized so thatinterpreted procedures and compiled procedures can call each other.This enables a programmer to compile those parts of a program that areassumed to be debugged, thus gaining the efficiency advantage ofcompilation, while retaining the interpretive mode of execution forthose parts of the program that are in the flux of interactivedevelopment and debugging.  Insection <a href="#%_sec_5.5.7">5.5.7</a>, after we have implementedthe compiler, we will show how to interface it with our interpreter toproduce an integrated interpreter-compiler development system.</p>
<p><a name="%_sec_Temp_796" id="%_sec_Temp_796"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_796">An overview of the compiler</a></h4>
<p><a name="%_idx_6224" id="%_idx_6224"></a><a name="%_idx_6226" id="%_idx_6226"></a>Our compiler is much like our interpreter, both in its structure and inthe function it performs.  Accordingly, the mechanisms used by thecompiler for analyzing expressions will be similar to those used bythe interpreter.  Moreover, to make it easy to interface compiled andinterpreted code, we will design the compiler to generate code thatobeys the same conventions of <a name="%_idx_6228" id="%_idx_6228"></a>register usage as the interpreter: Theenvironment will be kept in the <code>env</code> register, argument listswill be accumulated in <code>argl</code>, a procedure to be applied will bein <code>proc</code>, procedures will return their answers in <code>val</code>,and the location to which a procedure should return will be kept in<code>continue</code>.In general, the compiler translates a source program into an objectprogram that performs essentially the same register operations aswould the interpreter in evaluating the same source program.</p>
<p>This description suggests a strategy for implementing a rudimentarycompiler: We traverse the expression in the same way theinterpreter does.  When we encounter a register instruction that theinterpreter would perform in evaluating the expression, we do notexecute the instruction but instead accumulate it into a sequence.  Theresulting sequence of instructions will be the object code.  Observethe <a name="%_idx_6230" id="%_idx_6230"></a><a name="%_idx_6232" id="%_idx_6232"></a>efficiency advantage of compilation over interpretation.  Eachtime the interpreter evaluates an expression – for example,<code>(f 84 96)</code> – it performs the work ofclassifying the expression (discovering that thisis a procedure application) and testing for the end of the operand list(discovering that there are two operands).  With acompiler, the expression is analyzed only once, when theinstruction sequence is generated at compile time.  The object codeproduced by the compiler contains only the instructions that evaluatethe operator and the two operands, assemble the argument list,and apply the procedure (in <code>proc</code>) to the arguments (in <code>argl</code>).</p>
<p><a name="%_idx_6234" id="%_idx_6234"></a>This is the same kind of optimization we implemented in theanalyzing evaluator of section <a href="book-Z-H-26.html#%_sec_4.1.7">4.1.7</a>.But there are further opportunities to gain efficiency in compiled code.As the interpreter runs, it follows a process that must be applicableto any expression in the language.  In contrast, a given segment ofcompiled code is meant to execute some particular expression.  Thiscan make a big difference, for example in the use of the stack tosave registers.  When the interpreter evaluates an expression, it mustbe prepared for any contingency.  Before evaluating a subexpression,the interpreter saves allregisters that will be needed later, becausethe subexpression might require an arbitrary evaluation.A compiler, on the other hand, can exploit the structure of theparticular expression it is processing to generate code that avoidsunnecessary stack operations.</p>
<p>As a case in point, consider the combination <code>(f 84 96)</code>.  Beforethe interpreter evaluates the operator of the combination, it preparesfor this evaluation by saving the registers containing the operandsand the environment, whose values will be needed later.  Theinterpreter then evaluates the operator to obtain the result in <code>val</code>, restores the saved registers, and finally moves the result from<code>val</code> to <code>proc</code>.  However, in the particular expression we aredealing with, the operator is the symbol <code>f</code>, whose evaluation isaccomplished by the machine operation <code>lookup-variable-value</code>,which does not alter any registers.  The compiler that we implement inthis section will take advantage of this fact and generate code thatevaluates the operator using the instruction</p>
<p></p>
<p><pre>(assign proc (op lookup-variable-value) (const f) (reg env))
</pre></p>
<p></p>
<p>This code not only avoids the unnecessary saves andrestores but also assigns the value of the lookup directly to<code>proc</code>, whereas the interpreter would obtain the result in <code>val</code>and then move this to <code>proc</code>.</p>
<p>A compiler can also optimize access to the environment.  Havinganalyzed the code, the compiler can in many cases know in which framea particular variable will be located and access that frame directly,rather than performing the <code>lookup-variable-value</code> search.  Wewill discuss how to implement such variable access insection <a href="#%_sec_5.5.6">5.5.6</a>.  Until then, however, we willfocus on the kind of register and stack optimizations described above.There are many other optimizations that can be performed by acompiler, such as coding primitive operations “in line” instead ofusing a general <code>apply</code> mechanism (seeexercise <a href="#%_thm_5.38">5.38</a>); but we will not emphasize these here.Our main goal in this section is to illustrate the compilation processin a simplified (but still interesting) context.</p>
<p><a name="%_sec_5.5.1" id="%_sec_5.5.1"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_5.5.1">5.5.1  Structure of the Compiler</a></h3>
<p><a name="%_idx_6236" id="%_idx_6236"></a><a name="%_idx_6238" id="%_idx_6238"></a>In section <a href="book-Z-H-26.html#%_sec_4.1.7">4.1.7</a> we modified our originalmetacircular interpreter to separate analysis from execution.  Weanalyzed each expression to produce an execution procedure that tookan environment as argument and performed the required operations.  Inour compiler, we will do essentially the same analysis.  Instead ofproducing execution procedures, however, we will generate sequences ofinstructions to be run by our register machine.</p>
<p>The procedure <code>compile</code> is the top-level dispatch in the compiler.It corresponds to the <code>eval</code> procedure ofsection <a href="book-Z-H-26.html#%_sec_4.1.1">4.1.1</a>, the <code>analyze</code> procedure ofsection <a href="book-Z-H-26.html#%_sec_4.1.7">4.1.7</a>, and the <code>eval-dispatch</code>entry point of the explicit-control-evaluator insection <a href="book-Z-H-34.html#%_sec_5.4.1">5.4.1</a>.The compiler, like the interpreters, uses the <a name="%_idx_6240" id="%_idx_6240"></a>expression-syntaxprocedures defined in section <a href="book-Z-H-26.html#%_sec_4.1.2">4.1.2</a>.<a name="call_footnote_Temp_797" href="#footnote_Temp_797" id="call_footnote_Temp_797"><sup><small>35</small></sup></a><code>Compile</code> performs a caseanalysis on the syntactic type of the expression to be compiled.  Foreach type of expression, it dispatches to a specialized <a name="%_idx_6242" id="%_idx_6242"></a><em>codegenerator</em>:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_6244" id="%_idx_6244"></a>(define (compile exp target linkage)
  (cond ((self-evaluating? exp)
         (compile-self-evaluating exp target linkage))
        ((quoted? exp) (compile-quoted exp target linkage))
        ((variable? exp)
         (compile-variable exp target linkage))
        ((assignment? exp)
         (compile-assignment exp target linkage))
        ((definition? exp)
         (compile-definition exp target linkage))
        ((if? exp) (compile-if exp target linkage))
        ((lambda? exp) (compile-lambda exp target linkage))
        ((begin? exp)
         (compile-sequence (begin-actions exp)
                           target
                           linkage))
        ((cond? exp) (compile (cond-&gt;if exp) target linkage))
        ((application? exp)
         (compile-application exp target linkage))
        (else
         (error "Unknown expression type -- COMPILE" exp))))
</pre></p>
<p></p>
<p></p>
<p><a name="%_sec_Temp_798" id="%_sec_Temp_798"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_798">Targets and linkages</a></h4>
<p><a name="%_idx_6246" id="%_idx_6246"></a><code>Compile</code> and the code generators that it calls take two argumentsin addition to the expression to compile.  There is a <a name="%_idx_6248" id="%_idx_6248"></a><em>target</em>,which specifies the register in which the compiled code is to returnthe value of the expression.  There is also a <a name="%_idx_6250" id="%_idx_6250"></a><em>linkagedescriptor</em>, which describes how the code resulting from thecompilation of the expression should proceed when it has finished itsexecution.  The linkage descriptor can require that the code do one ofthe following three things:</p>
<p></p>
<p></p>
<ul>
<li>continue at the next instruction in sequence (this is<a name="%_idx_6252" id="%_idx_6252"></a>specified by the linkage descriptor <code>next</code>),<p></p>
</li>
<li>return from the procedure being compiled (this is specified<a name="%_idx_6254" id="%_idx_6254"></a>by the linkage descriptor <code>return</code>), or<p></p>
</li>
<li>jump to a named entry point (this is specified by using thedesignated label as the linkage descriptor).</li>
</ul>
<p></p>
<p>For example, compiling the expression <code>5</code> (which isself-evaluating) with a target of the <code>val</code> register and alinkage of <code>next</code> should produce the instruction</p>
<p></p>
<p></p>
<p><pre>(assign val (const 5))
</pre></p>
<p></p>
<p>Compiling the same expression with a linkage of <code>return</code> shouldproduce the instructions</p>
<p></p>
<p></p>
<p><pre>(assign val (const 5))
(goto (reg continue))
</pre></p>
<p></p>
<p>In the first case, execution will continue with the next instructionin the sequence. In the second case, we will return from a procedurecall.  In both cases, the value of the expression will be placed intothe target <code>val</code> register.</p>
<p><a name="%_sec_Temp_799" id="%_sec_Temp_799"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_799">Instruction sequences and stack usage</a></h4>
<p></p>
<p><a name="%_idx_6256" id="%_idx_6256"></a><a name="%_idx_6258" id="%_idx_6258"></a>Each code generator returns an <em>instruction sequence</em> containingthe object code it has generated for the expression.  Code generationfor a compound expression is accomplished by combining the output fromsimpler code generators for component expressions, just asevaluation of a compound expression is accomplished by evaluating thecomponent expressions.</p>
<p>The simplest method for combining instruction sequences is a procedure<a name="%_idx_6260" id="%_idx_6260"></a>called <code>append-instruction-sequences</code>.  It takes as arguments anynumber of instruction sequences that are to be executed sequentially;it appends them and returns the combined sequence.  That is, if&lt;<em><em>s</em><em>e</em><em>q</em><sub>1</sub></em>&gt; and &lt;<em><em>s</em><em>e</em><em>q</em><sub>2</sub></em>&gt; are sequences of instructions, thenevaluating</p>
<p></p>
<p><pre>(append-instruction-sequences &lt;<em><em>s</em><em>e</em><em>q</em><sub>1</sub></em>&gt; &lt;<em><em>s</em><em>e</em><em>q</em><sub>2</sub></em>&gt;)
</pre></p>
<p></p>
<p>produces the sequence</p>
<p></p>
<p><pre>&lt;<em><em>s</em><em>e</em><em>q</em><sub>1</sub></em>&gt;
&lt;<em><em>s</em><em>e</em><em>q</em><sub>2</sub></em>&gt;
</pre></p>
<p></p>
<p></p>
<p><a name="%_idx_6262" id="%_idx_6262"></a>Whenever registers might need to be saved, the compiler's code generators use<a name="%_idx_6264" id="%_idx_6264"></a><code>preserving</code>, which is a more subtle method for combininginstruction sequences.  <code>Preserving</code> takes three arguments: a setof registers and two instruction sequences that are to be executedsequentially.  It appends the sequences in such a way that thecontents of each register in the set is preserved over the executionof the first sequence, if this is needed for the execution of thesecond sequence.  That is, if the first sequence modifies the registerand the second sequence actually needs the register's originalcontents, then <code>preserving</code> wraps a <code>save</code> and a <code>restore</code>of the register around the first sequence before appending thesequences.  Otherwise, <code>preserving</code> simply returns the appendedinstruction sequences.  Thus, for example,</p>
<p></p>
<p><pre>(preserving (list &lt;<em><em>r</em><em>e</em><em>g</em><sub>1</sub></em>&gt; &lt;<em><em>r</em><em>e</em><em>g</em><sub>2</sub></em>&gt;) &lt;<em><em>s</em><em>e</em><em>q</em><sub>1</sub></em>&gt; &lt;<em><em>s</em><em>e</em><em>q</em><sub>2</sub></em>&gt;)
</pre></p>
<p></p>
<p>produces one of the following four sequences of instructions, depending on how&lt;<em><em>s</em><em>e</em><em>q</em><sub>1</sub></em>&gt; and &lt;<em><em>s</em><em>e</em><em>q</em><sub>2</sub></em>&gt; use &lt;<em><em>r</em><em>e</em><em>g</em><sub>1</sub></em>&gt; and &lt;<em><em>r</em><em>e</em><em>g</em><sub>2</sub></em>&gt;:</p>
<p></p>
<p></p>
<p></p>
<p></p>
<div align="left"><img src="images/ch5-Z-G-9.gif" border="0"></div>
<p></p>
<p>By using <code>preserving</code> to combine instruction sequences thecompiler avoids unnecessary stack operations.  This also isolates thedetails of whether or not to generate <code>save</code> and <code>restore</code>instructions within the <code>preserving</code> procedure, separating themfrom the concerns that arise in writing each of the individual codegenerators.In fact no <code>save</code> or <code>restore</code> instructions are explicitlyproduced by the code generators.</p>
<p>In principle, we could represent an instruction sequence simply as alist of instructions.  <code>Append-instruction-sequences</code> could thencombine instruction sequences by performing an ordinary list <code>append</code>.  However, <code>preserving</code> would then be a complex operation,because it would have to analyze each instruction sequence todetermine how the sequence uses its registers.  <code>Preserving</code>would be inefficient as well as complex, because it would have toanalyze each of its instruction sequence arguments, even though thesesequences might themselves have been constructed by calls to <code>preserving</code>, in which case their parts would have already beenanalyzed.  To avoid such repetitious analysis we will associate with eachinstruction sequence some information about its register use.When we construct a basic instruction sequence wewill provide this information explicitly,and the procedures that combine instruction sequences will deriveregister-use information for the combined sequence from theinformation associated with the component sequences.</p>
<p>An instruction sequence will contain three pieces of information:</p>
<p></p>
<ul>
<li>the set of registers that must be initialized before theinstructions in the sequence are executed (these registers are said tobe <em>needed</em> by the sequence),<p></p>
</li>
<li>the set of registers whose values are modified by theinstructions in the sequence, and<p></p>
</li>
<li>the actual instructions (also called <em>statements</em>) inthe sequence.</li>
</ul>
<p></p>
<p>We will represent an instruction sequence as a list of its threeparts.  The constructor for instruction sequences is thus</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_6266" id="%_idx_6266"></a>(define (make-instruction-sequence needs modifies statements)
  (list needs modifies statements))
</pre></p>
<p></p>
<p></p>
<p>For example, the two-instruction sequence that looks up the value ofthe variable <code>x</code> in the current environment, assigns the resultto <code>val</code>, and then returns, requires registers <code>env</code> and <code>continue</code> to have been initialized, and modifies register <code>val</code>.This sequence would therefore be constructed as</p>
<p></p>
<p></p>
<p><pre>(make-instruction-sequence '(env continue) '(val)
 '((assign val
           (op lookup-variable-value) (const x) (reg env))
   (goto (reg continue))))
</pre></p>
<p></p>
<p></p>
<p>We sometimes need to construct an instruction sequence with no statements:</p>
<p></p>
<p><pre><a name="%_idx_6268" id="%_idx_6268"></a>(define (empty-instruction-sequence)
  (make-instruction-sequence '() '() '()))
</pre></p>
<p></p>
<p></p>
<p>The procedures for combining instruction sequences are shown insection <a href="#%_sec_5.5.4">5.5.4</a>.</p>
<p></p>
<p><a name="%_thm_5.31" id="%_thm_5.31"></a><b>Exercise 5.31.</b>  <a name="%_idx_6270" id="%_idx_6270"></a><a name="%_idx_6272" id="%_idx_6272"></a>In evaluating a procedure application, the explicit-control evaluatoralways saves and restoresthe <code>env</code> register around the evaluation of the operator, saves andrestores <code>env</code> around the evaluation of each operand (except thefinal one), saves and restores <code>argl</code> around the evaluation of eachoperand, and saves and restores <code>proc</code> around the evaluation of theoperand sequence.  For each of the following combinations, say whichof these <code>save</code> and <code>restore</code> operations are superfluous andthus could be eliminated by the compiler's <code>preserving</code> mechanism:</p>
<p></p>
<p></p>
<p><pre>(f 'x 'y)

((f) 'x 'y)

(f (g 'x) y)

(f (g 'x) 'y)
</pre></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_5.32" id="%_thm_5.32"></a><b>Exercise 5.32.</b>  <a name="%_idx_6274" id="%_idx_6274"></a><a name="%_idx_6276" id="%_idx_6276"></a>Using the <code>preserving</code> mechanism, the compiler will avoid savingand restoring <code>env</code> around the evaluation of the operator of acombination in the case where the operator is a symbol.  We could alsobuild such optimizations into the evaluator.  Indeed, theexplicit-control evaluator of section <a href="book-Z-H-34.html#%_sec_5.4">5.4</a> alreadyperforms a similar optimization, by treating combinations with nooperands as a special case.</p>
<p></p>
<p></p>
<p>a. Extend the explicit-control evaluator to recognize as a separate classof expressions combinations whose operator is a symbol, and to takeadvantage of this fact in evaluating such expressions.</p>
<p></p>
<p></p>
<p>b. Alyssa P. Hacker suggests that by extending the evaluator to recognizemore and more special cases we could incorporate all the compiler'soptimizations, and that this would eliminate the advantage of compilationaltogether.  What do you think of this idea?</p>
<p></p>
<p><a name="%_sec_5.5.2" id="%_sec_5.5.2"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_5.5.2">5.5.2  Compiling Expressions</a></h3>
<p>In this section and the next we implement the code generators to which the <code>compile</code> procedure dispatches.</p>
<p><a name="%_sec_Temp_802" id="%_sec_Temp_802"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_802">Compiling linkage code</a></h4>
<p><a name="%_idx_6278" id="%_idx_6278"></a>In general, the output of each code generator will end withinstructions – generated by the procedure <code>compile-linkage</code> – thatimplement the required linkage.  If the linkage is <code>return</code> thenwe must generate the instruction <code>(goto (reg continue))</code>.  Thisneeds the <code>continue</code> register and does not modify any registers.If the linkage is <code>next</code>, then we needn't include any additionalinstructions.  Otherwise, the linkage is a label, and we generate a<code>goto</code> to that label, an instruction that does not need or modifyany registers.<a name="call_footnote_Temp_803" href="#footnote_Temp_803" id="call_footnote_Temp_803"><sup><small>36</small></sup></a></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_6292" id="%_idx_6292"></a>(define (compile-linkage linkage)
  (cond ((eq? linkage 'return)
         (make-instruction-sequence '(continue) '()
          '((goto (reg continue)))))
        ((eq? linkage 'next)
         (empty-instruction-sequence))
        (else
         (make-instruction-sequence '() '()
          `((goto (label ,linkage)))))))
</pre></p>
<p></p>
<p>The linkage code is appended to an instruction sequence by <code>preserving</code>the <code>continue</code> register, since a <code>return</code> linkage willrequire the <code>continue</code> register:If the given instruction sequence modifies <code>continue</code> and thelinkage code needs it, <code>continue</code> will be saved and restored.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_6294" id="%_idx_6294"></a>(define (end-with-linkage linkage instruction-sequence)
  (preserving '(continue)
   instruction-sequence
   (compile-linkage linkage)))
</pre></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_sec_Temp_804" id="%_sec_Temp_804"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_804">Compiling simple expressions</a></h4>
<p><a name="%_idx_6296" id="%_idx_6296"></a><a name="%_idx_6298" id="%_idx_6298"></a><a name="%_idx_6300" id="%_idx_6300"></a>The code generators for self-evaluating expressions,quotations, and variables construct instructionsequences that assign the required value to the target registerand then proceed as specified by the linkage descriptor.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_6302" id="%_idx_6302"></a>(define (compile-self-evaluating exp target linkage)
  (end-with-linkage linkage
   (make-instruction-sequence '() (list target)
    `((assign ,target (const ,exp))))))
<a name="%_idx_6304" id="%_idx_6304"></a>(define (compile-quoted exp target linkage)
  (end-with-linkage linkage
   (make-instruction-sequence '() (list target)
    `((assign ,target (const ,(text-of-quotation exp)))))))
<a name="%_idx_6306" id="%_idx_6306"></a>(define (compile-variable exp target linkage)
  (end-with-linkage linkage
   (make-instruction-sequence '(env) (list target)
    `((assign ,target
              (op lookup-variable-value)
              (const ,exp)
              (reg env))))))
</pre></p>
<p></p>
<p>All these assignment instructions modify the target register,and the one that looks up a variable needs the <code>env</code> register.</p>
<p><a name="%_idx_6308" id="%_idx_6308"></a><a name="%_idx_6310" id="%_idx_6310"></a>Assignments and definitions are handled much as they are in theinterpreter.  We recursively generate code that computes the value tobe assigned to the variable, and append to it a two-instructionsequence that actually sets or defines the variable and assigns thevalue of the whole expression (the symbol <code>ok</code>) to the targetregister.  The recursive compilation has target <code>val</code> and linkage<code>next</code> so that the code will put its result into <code>val</code> andcontinue with the code that is appended after it.  The appending isdone preserving <code>env</code>, since the environment is needed for settingor defining the variable and the code for the variable value could bethe compilation of a complex expression that might modify theregisters in arbitrary ways.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_6312" id="%_idx_6312"></a>(define (compile-assignment exp target linkage)
  (let ((var (assignment-variable exp))
        (get-value-code
         (compile (assignment-value exp) 'val 'next)))
    (end-with-linkage linkage
     (preserving '(env)
      get-value-code
      (make-instruction-sequence '(env val) (list target)
       `((perform (op set-variable-value!)
                  (const ,var)
                  (reg val)
                  (reg env))
         (assign ,target (const ok))))))))
<a name="%_idx_6314" id="%_idx_6314"></a>(define (compile-definition exp target linkage)
  (let ((var (definition-variable exp))
        (get-value-code
         (compile (definition-value exp) 'val 'next)))
    (end-with-linkage linkage
     (preserving '(env)
      get-value-code
      (make-instruction-sequence '(env val) (list target)
       `((perform (op define-variable!)
                  (const ,var)
                  (reg val)
                  (reg env))
         (assign ,target (const ok))))))))
</pre></p>
<p></p>
<p>The appended two-instruction sequence requires <code>env</code> and <code>val</code>and modifies the target.  Note that although we preserve <code>env</code> forthis sequence, we do not preserve <code>val</code>, because the <code>get-value-code</code> is designed to explicitly place its result in <code>val</code> for use by this sequence.(In fact, if we did preserve <code>val</code>, we wouldhave a bug, because this would cause the previous contents of <code>val</code> to be restored right after the <code>get-value-code</code> is run.)</p>
<p><a name="%_sec_Temp_805" id="%_sec_Temp_805"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_805">Compiling conditional expressions</a></h4>
<p><a name="%_idx_6316" id="%_idx_6316"></a>The code for an <code>if</code> expressioncompiled with a given target and linkage has the form</p>
<p></p>
<p></p>
<p><pre> &lt;<em>compilation of predicate, target <code>val</code>, linkage <code>next</code></em>&gt;
 (test (op false?) (reg val))
 (branch (label false-branch))
true-branch
 &lt;<em>compilation of consequent with given target and given linkage or <code>after-if</code></em>&gt;
false-branch
 &lt;<em>compilation of alternative with given target and linkage</em>&gt;
after-if
</pre></p>
<p></p>
<p></p>
<p>To generate this code, we compile the predicate, consequent,and alternative, and combine the resulting code with instructionsto test the predicate result and with newly generated labelsto mark the true and false branches and the end of the conditional.<a name="call_footnote_Temp_806" href="#footnote_Temp_806" id="call_footnote_Temp_806"><sup><small>37</small></sup></a>In this arrangement of code, we must branch around the true branchif the test is false.  The only slight complication is in how thelinkage for the true branch should be handled.  If the linkage for theconditional is <code>return</code> or a label, then the true and falsebranches will both use this same linkage.  If the linkage is <code>next</code>, the true branch ends with a jump around the code for the falsebranch to the label at the end of the conditional.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_6324" id="%_idx_6324"></a>(define (compile-if exp target linkage)
  (let ((t-branch (make-label 'true-branch))
        (f-branch (make-label 'false-branch))                    
        (after-if (make-label 'after-if)))
    (let ((consequent-linkage
           (if (eq? linkage 'next) after-if linkage)))
      (let ((p-code (compile (if-predicate exp) 'val 'next))
            (c-code
             (compile
              (if-consequent exp) target consequent-linkage))
            (a-code
             (compile (if-alternative exp) target linkage)))
        (preserving '(env continue)
         p-code
         (append-instruction-sequences
          (make-instruction-sequence '(val) '()
           `((test (op false?) (reg val))
             (branch (label ,f-branch))))
          (parallel-instruction-sequences
           (append-instruction-sequences t-branch c-code)
           (append-instruction-sequences f-branch a-code))
          after-if))))))
</pre></p>
<p></p>
<p><code>Env</code> is preserved around the predicate code because it could be needed bythe true and false branches, and <code>continue</code> is preserved because it couldbe needed by the linkage code in those branches.  The code for the true andfalse branches (which are not executed sequentially) is appended using aspecial combiner <code>parallel-instruction-sequences</code> described insection <a href="#%_sec_5.5.4">5.5.4</a>.</p>
<p>Note that <code>cond</code> is a derived expression, so all that thecompiler needs to do handle it is to apply the <code>cond-&gt;if</code>transformer (from section <a href="book-Z-H-26.html#%_sec_4.1.2">4.1.2</a>) andcompile the resulting <code>if</code> expression.</p>
<p><a name="%_sec_Temp_807" id="%_sec_Temp_807"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_807">Compiling sequences</a></h4>
<p><a name="%_idx_6326" id="%_idx_6326"></a>The compilation of sequences (from procedure bodies or explicit <code>begin</code> expressions) parallels their evaluation.  Each expression of thesequence is compiled – the last expression with the linkage specifiedfor the sequence, and the other expressions with linkage <code>next</code>(to execute the rest of the sequence).The instruction sequences for the individual expressions are appendedto form a single instruction sequence, such that <code>env</code> (needed forthe rest of the sequence) and <code>continue</code> (possibly needed for thelinkage at the end of the sequence) are preserved.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_6328" id="%_idx_6328"></a>(define (compile-sequence seq target linkage)
  (if (last-exp? seq)
      (compile (first-exp seq) target linkage)
      (preserving '(env continue)
       (compile (first-exp seq) target 'next)
       (compile-sequence (rest-exps seq) target linkage))))
</pre></p>
<p></p>
<p></p>
<p><a name="%_sec_Temp_808" id="%_sec_Temp_808"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_808">Compiling <code>lambda</code> expressions</a></h4>
<p><a name="%_idx_6330" id="%_idx_6330"></a><code>Lambda</code> expressions construct procedures.The object code for a <code>lambda</code> expression must have the form</p>
<p></p>
<p></p>
<p><pre>&lt;<em>construct procedure object and assign it to target register</em>&gt;
&lt;<em>linkage</em>&gt;
</pre></p>
<p></p>
<p>When we compile the <code>lambda</code> expression, we also generate the code for theprocedure body.  Although the body won't be executed at the time of procedureconstruction, it is convenient to insert it into the object code right afterthe code for the <code>lambda</code>.  If the linkage for the <code>lambda</code> expressionis a label or <code>return</code>, this is fine.  But if the linkage is <code>next</code>,we will need to skip around the code for the procedure body by using a linkagethat jumps to a label that is inserted after the body.  The object code thushas the form</p>
<p></p>
<p></p>
<p><pre> &lt;<em>construct procedure object and assign it to target register</em>&gt;
 &lt;<em>code for given linkage</em>&gt;<em>or</em> <code>(goto (label after-lambda))</code>
 &lt;<em>compilation of procedure body</em>&gt;
after-lambda
</pre></p>
<p></p>
<p></p>
<p><code>Compile-lambda</code> generates the code for constructing the procedureobject followed by the code for the procedure body.The procedure object will be constructed at run time by combiningthe current environment (the environment at the point of definition)with the entry point to the compiled procedure body (a newly generatedlabel).<a name="call_footnote_Temp_809" href="#footnote_Temp_809" id="call_footnote_Temp_809"><sup><small>38</small></sup></a></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_6340" id="%_idx_6340"></a>(define (compile-lambda exp target linkage)
  (let ((proc-entry (make-label 'entry))
        (after-lambda (make-label 'after-lambda)))
    (let ((lambda-linkage
           (if (eq? linkage 'next) after-lambda linkage)))
      (append-instruction-sequences
       (tack-on-instruction-sequence
        (end-with-linkage lambda-linkage
         (make-instruction-sequence '(env) (list target)
          `((assign ,target
                    (op make-compiled-procedure)
                    (label ,proc-entry)
                    (reg env)))))
        (compile-lambda-body exp proc-entry))
       after-lambda))))
</pre></p>
<p></p>
<p><code>Compile-lambda</code> uses the special combiner <code>tack-on-instruction-sequence</code>(section <a href="#%_sec_5.5.4">5.5.4</a>) rather than <code>append-instruction-sequences</code> to append the procedure body to the <code>lambda</code>expression code, because the body is not part of the sequence of instructionsthat will be executed when the combined sequence is entered; rather, it is inthe sequence only because that was a convenient place to put it.</p>
<p><code>Compile-lambda-body</code> constructs the code for the body of theprocedure.  This code begins with a label for the entry point.  Nextcome instructions that will cause the run-time evaluation environmentto switch to the correct environment for evaluating the procedurebody – namely, the definition environment of the procedure, extendedto include the bindings of the formal parameters to the arguments withwhich the procedure is called.  After this comes the code for thesequence of expressions that makes up the procedure body.The sequence is compiled with linkage <code>return</code> and target <code>val</code>so that it will end by returning from the procedure with theprocedure result in <code>val</code>.</p>
<p></p>
<p></p>
<p><pre>(define (compile-lambda-body exp proc-entry)
  (let ((formals (lambda-parameters exp)))
    (append-instruction-sequences
     (make-instruction-sequence '(env proc argl) '(env)
      `(,proc-entry
        (assign env (op compiled-procedure-env) (reg proc))
        (assign env
                (op extend-environment)
                (const ,formals)
                (reg argl)
                (reg env))))
     (compile-sequence (lambda-body exp) 'val 'return))))
</pre></p>
<p></p>
<p></p>
<p><a name="%_sec_5.5.3" id="%_sec_5.5.3"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_5.5.3">5.5.3  Compiling Combinations</a></h3>
<p><a name="%_idx_6342" id="%_idx_6342"></a><a name="%_idx_6344" id="%_idx_6344"></a>The essence of the compilation process is the compilation of procedureapplications.The code for a combination compiled with a given target and linkagehas the form</p>
<p></p>
<p><pre>&lt;<em>compilation of operator, target <code>proc</code>, linkage <code>next</code></em>&gt;
&lt;<em>evaluate operands and construct argument list in <code>argl</code></em>&gt;
&lt;<em>compilation of procedure call with given target and linkage</em>&gt;
</pre></p>
<p></p>
<p>The registers <code>env</code>, <code>proc</code>, and <code>argl</code> may have to besaved and restored during evaluation of the operator and operands.Note that this is the only place in the compiler where a target otherthan <code>val</code> is specified.</p>
<p>The required code is generated by <code>compile-application</code>.  Thisrecursively compiles the operator, to produce code that puts theprocedure to be applied into <code>proc</code>, and compiles the operands, toproduce code that evaluates the individual operands of theapplication.  The instruction sequences for the operands are combined(by <code>construct-arglist</code>) with code that constructs the list ofarguments in <code>argl</code>, and the resulting argument-list code iscombined with the procedure code and the code that performs theprocedure call (produced by <code>compile-procedure-call</code>).  Inappending the code sequences, the <code>env</code> register must be preservedaround the evaluation of the operator (since evaluating the operatormight modify <code>env</code>, which will be needed to evaluate theoperands), and the <code>proc</code> register must be preserved around theconstruction of the argument list (since evaluating the operands mightmodify <code>proc</code>, which will be needed for the actual procedureapplication).  <code>Continue</code> must also be preserved throughout, sinceit is needed for the linkage in the procedure call.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_6346" id="%_idx_6346"></a>(define (compile-application exp target linkage)
  (let ((proc-code (compile (operator exp) 'proc 'next))
        (operand-codes
         (map (lambda (operand) (compile operand 'val 'next))
              (operands exp))))
    (preserving '(env continue)
     proc-code
     (preserving '(proc continue)
      (construct-arglist operand-codes)
      (compile-procedure-call target linkage)))))
</pre></p>
<p></p>
<p></p>
<p>The code to construct the argument list will evaluate each operand into<code>val</code> and then <code>cons</code> that value onto the argument list beingaccumulated in <code>argl</code>.Since we <code>cons</code> the arguments onto <code>argl</code> in sequence, we muststart with the last argument and end with the first, so that thearguments will appear in order from first to last in the resulting list.Rather than waste an instruction by initializing <code>argl</code> to the empty listto set up for this sequence of evaluations,we make the first code sequence construct the initial <code>argl</code>.The general form of the argument-list construction is thus as follows:</p>
<p></p>
<p></p>
<p><pre>&lt;<em>compilation of last operand, targeted to <code>val</code></em>&gt;
(assign argl (op list) (reg val))
&lt;<em>compilation of next operand, targeted to <code>val</code></em>&gt;
(assign argl (op cons) (reg val) (reg argl))
<code>...</code>&lt;<em>compilation of first operand, targeted to <code>val</code></em>&gt;
(assign argl (op cons) (reg val) (reg argl))
</pre></p>
<p></p>
<p><code>Argl</code> must be preserved around each operand evaluation exceptthe first (so that arguments accumulated so far won't be lost), and<code>env</code> must be preserved around each operand evaluationexcept the last (for use by subsequent operand evaluations).</p>
<p>Compiling this argument code is a bit tricky, because ofthe special treatment of the first operand to be evaluated and theneed to preserve <code>argl</code> and <code>env</code> in different places.The <code>construct-arglist</code> procedure takes as arguments the code thatevaluates the individual operands.  If there are no operands at all, it simplyemits the instruction</p>
<p></p>
<p></p>
<p><pre>(assign argl (const ()))
</pre></p>
<p></p>
<p>Otherwise, <code>construct-arglist</code> creates code that initializes <code>argl</code> with the last argument, and appends code that evaluatesthe rest of the arguments and adjoins them to <code>argl</code> insuccession.  In order to process the arguments from last tofirst, we must reverse the list of operand code sequences from the ordersupplied by <code>compile-application</code>.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_6348" id="%_idx_6348"></a>(define (construct-arglist operand-codes)
  (let ((operand-codes (reverse operand-codes)))
    (if (null? operand-codes)
        (make-instruction-sequence '() '(argl)
         '((assign argl (const ()))))
        (let ((code-to-get-last-arg
               (append-instruction-sequences
                (car operand-codes)
                (make-instruction-sequence '(val) '(argl)
                 '((assign argl (op list) (reg val)))))))
          (if (null? (cdr operand-codes))
              code-to-get-last-arg
              (preserving '(env)
               code-to-get-last-arg
               (code-to-get-rest-args
                (cdr operand-codes))))))))
(define (code-to-get-rest-args operand-codes)
  (let ((code-for-next-arg
         (preserving '(argl)
          (car operand-codes)
          (make-instruction-sequence '(val argl) '(argl)
           '((assign argl
              (op cons) (reg val) (reg argl)))))))
    (if (null? (cdr operand-codes))
        code-for-next-arg
        (preserving '(env)
         code-for-next-arg
         (code-to-get-rest-args (cdr operand-codes))))))
</pre></p>
<p></p>
<p></p>
<p><a name="%_sec_Temp_810" id="%_sec_Temp_810"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_810">Applying procedures</a></h4>
<p>After evaluating the elements of a combination, the compiled code mustapply the procedure in <code>proc</code> to the arguments in <code>argl</code>.  Thecode performs essentially the same dispatch as the <code>apply</code> procedure in themetacircular evaluator of section <a href="book-Z-H-26.html#%_sec_4.1.1">4.1.1</a> or the<code>apply-dispatch</code> entry point in the explicit-control evaluator ofsection <a href="book-Z-H-34.html#%_sec_5.4.1">5.4.1</a>.  It checks whether theprocedure to be applied is a primitive procedure or a compiledprocedure.  For a primitive procedure, it uses <code>apply-primitive-procedure</code>; we will see shortly how it handlescompiled procedures.  The procedure-application code has the followingform:</p>
<p></p>
<p></p>
<p><pre> (test (op primitive-procedure?) (reg proc))
 (branch (label primitive-branch))
compiled-branch
 &lt;<em>code to apply compiled procedure with given target and appropriate linkage</em>&gt;
primitive-branch
 (assign &lt;<em>target</em>&gt;
         (op apply-primitive-procedure)
         (reg proc)
         (reg argl))
 &lt;<em>linkage</em>&gt;
after-call
</pre></p>
<p></p>
<p>Observe that the compiled branch must skip around the primitivebranch.  Therefore, if the linkage for the original procedure call was<code>next</code>, the compound branch must use a linkage that jumps to alabel that is inserted after the primitive branch.  (This is similarto the linkage used for the true branch in <code>compile-if</code>.)</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_6350" id="%_idx_6350"></a>(define (compile-procedure-call target linkage)
  (let ((primitive-branch (make-label 'primitive-branch))
        (compiled-branch (make-label 'compiled-branch))
        (after-call (make-label 'after-call)))
    (let ((compiled-linkage
           (if (eq? linkage 'next) after-call linkage)))
      (append-instruction-sequences
       (make-instruction-sequence '(proc) '()
        `((test (op primitive-procedure?) (reg proc))
          (branch (label ,primitive-branch))))
       (parallel-instruction-sequences
        (append-instruction-sequences
         compiled-branch
         (compile-proc-appl target compiled-linkage))
        (append-instruction-sequences
         primitive-branch
         (end-with-linkage linkage
          (make-instruction-sequence '(proc argl)
                                     (list target)
           `((assign ,target
                     (op apply-primitive-procedure)
                     (reg proc)
                     (reg argl)))))))
       after-call))))
</pre></p>
<p></p>
<p>The primitive and compound branches, like the trueand false branches in <code>compile-if</code>, are appended using<code>parallel-instruction-sequences</code> rather than the ordinary <code>append-instruction-sequences</code>, because they willnot be executed sequentially.</p>
<p><a name="%_sec_Temp_811" id="%_sec_Temp_811"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_811">Applying compiled procedures</a></h4>
<p>The code that handles procedure application is the most subtle part ofthe compiler, even though the instruction sequences it generates arevery short.  A compiled procedure (as constructed by <code>compile-lambda</code>) has an entry point, which is a label that designateswhere the code for the procedure starts.  The code at this entry pointcomputes a result in <code>val</code> and returns by executing theinstruction <code>(goto (reg continue))</code>.  Thus, we might expect thecode for a compiled-procedure application (to be generated by <code>compile-proc-appl</code>) with a given target and linkage to look like thisif the linkage is a label</p>
<p></p>
<p><pre> (assign continue (label proc-return))
 (assign val (op compiled-procedure-entry) (reg proc))
 (goto (reg val))
proc-return
 (assign &lt;<em>target</em>&gt; (reg val))   <em>; included if target is not <code>val</code></em>
 (goto (label &lt;<em>linkage</em>&gt;))   <em>; linkage code</em>
</pre></p>
<p></p>
<p>or like this if the linkage is <code>return</code>.</p>
<p></p>
<p><pre> (save continue)
 (assign continue (label proc-return))
 (assign val (op compiled-procedure-entry) (reg proc))
 (goto (reg val))
proc-return
 (assign &lt;<em>target</em>&gt; (reg val))   <em>; included if target is not <code>val</code></em>
 (restore continue)
 (goto (reg continue))   <em>; linkage code</em>
</pre></p>
<p></p>
<p>This code sets up <code>continue</code> so that the procedure will return to alabel <code>proc-return</code> and jumps to the procedure's entry point.  The codeat <code>proc-return</code> transfers the procedure's result from <code>val</code>to the target register (if necessary) and then jumps tothe location specified by the linkage.(The linkage is always <code>return</code> or a label, because <code>compile-procedure-call</code> replaces a <code>next</code> linkage for thecompound-procedure branch by an <code>after-call</code> label.)</p>
<p>In fact, if the target is not <code>val</code>, that is exactly the code ourcompiler will generate.<a name="call_footnote_Temp_812" href="#footnote_Temp_812" id="call_footnote_Temp_812"><sup><small>39</small></sup></a>Usually, however, the target is <code>val</code> (the only time the compilerspecifies a different register is when targeting the evaluation of anoperator to <code>proc</code>), so the procedure result is put directly intothe target register and there is no need to return to a speciallocation that copies it.  Instead, we simplify the code bysetting up <code>continue</code> so that the procedure will “return”directly to the place specified by the caller's linkage:</p>
<p></p>
<p><pre>&lt;<em>set up <code>continue</code> for linkage</em>&gt;
(assign val (op compiled-procedure-entry) (reg proc))
(goto (reg val))
</pre></p>
<p></p>
<p>If the linkage is a label, we set up <code>continue</code> so that the procedure will return tothat label.  (That is, the <code>(goto (reg continue))</code> the procedureends with becomes equivalent to the <code>(goto (label &lt;<em>linkage</em>&gt;))</code> at<code>proc-return</code> above.)</p>
<p></p>
<p><pre>(assign continue (label &lt;<em>linkage</em>&gt;))
(assign val (op compiled-procedure-entry) (reg proc))
(goto (reg val))
</pre></p>
<p></p>
<p>If the linkage is <code>return</code>, we don't need to set up <code>continue</code>at all: It already holds the desired location.  (That is, the <code>(goto (reg continue))</code> the procedure ends with goes directly to theplace where the <code>(goto (reg continue))</code> at <code>proc-return</code> wouldhave gone.)</p>
<p></p>
<p><pre>(assign val (op compiled-procedure-entry) (reg proc))
(goto (reg val))
</pre></p>
<p></p>
<p><a name="%_idx_6352" id="%_idx_6352"></a><a name="%_idx_6354" id="%_idx_6354"></a>With this implementation of the <code>return</code> linkage, the compilergenerates tail-recursive code.  Calling a procedure as the final stepin a procedure body does a direct transfer, without saving anyinformation on the stack.</p>
<p>Suppose instead that we had handled the case of a procedure call witha linkage of <code>return</code> and a target of <code>val</code> as shown above fora non-<code>val</code> target.  This would destroy tail recursion.  Oursystem would still give the same value for any expression.  But eachtime we called a procedure, we would save <code>continue</code> and returnafter the call to undo the (useless) save.  These extra saves wouldaccumulate during a nest of procedure calls.<a name="call_footnote_Temp_813" href="#footnote_Temp_813" id="call_footnote_Temp_813"><sup><small>40</small></sup></a></p>
<p><code>Compile-proc-appl</code> generates the above procedure-application code byconsidering four cases, depending on whether the target for the callis <code>val</code> and whether the linkage is <code>return</code>.Observe that the instruction sequences aredeclared to modify all the registers, since executing the procedurebody can change the registers in arbitrary ways.<a name="call_footnote_Temp_814" href="#footnote_Temp_814" id="call_footnote_Temp_814"><sup><small>41</small></sup></a>Also note that the code sequence for the case with target <code>val</code>and linkage <code>return</code> is declared to need <code>continue</code>:  Eventhough <code>continue</code> is not explicitly used in the two-instructionsequence, we must be sure that <code>continue</code> will have the correctvalue when we enter the compiled procedure.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_6376" id="%_idx_6376"></a>(define (compile-proc-appl target linkage)
  (cond ((and (eq? target 'val) (not (eq? linkage 'return)))
         (make-instruction-sequence '(proc) all-regs
           `((assign continue (label ,linkage))
             (assign val (op compiled-procedure-entry)
                         (reg proc))
             (goto (reg val)))))
        ((and (not (eq? target 'val))
              (not (eq? linkage 'return)))
         (let ((proc-return (make-label 'proc-return)))
           (make-instruction-sequence '(proc) all-regs
            `((assign continue (label ,proc-return))
              (assign val (op compiled-procedure-entry)
                          (reg proc))
              (goto (reg val))
              ,proc-return
              (assign ,target (reg val))
              (goto (label ,linkage))))))
        ((and (eq? target 'val) (eq? linkage 'return))
         (make-instruction-sequence '(proc continue) all-regs
          '((assign val (op compiled-procedure-entry)
                        (reg proc))
            (goto (reg val)))))
        ((and (not (eq? target 'val)) (eq? linkage 'return))
         (error "return linkage, target not val -- COMPILE"
                target))))
</pre></p>
<p></p>
<p></p>
<p><a name="%_sec_5.5.4" id="%_sec_5.5.4"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_5.5.4">5.5.4  Combining Instruction Sequences</a></h3>
<p><a name="%_idx_6378" id="%_idx_6378"></a>This section describes the details on how instruction sequences arerepresented and combined.  Recall fromsection <a href="#%_sec_5.5.1">5.5.1</a> that an instruction sequenceis represented as a list of the registers needed, the registersmodified, and the actual instructions.  We will also consider a label(symbol) to be a degenerate case of an instruction sequence, which doesn'tneed or modify any registers.So to determine the registers neededand modified by instruction sequences we use the selectors</p>
<p></p>
<p><pre><a name="%_idx_6380" id="%_idx_6380"></a>(define (registers-needed s)
  (if (symbol? s) '() (car s)))
<a name="%_idx_6382" id="%_idx_6382"></a>(define (registers-modified s)
  (if (symbol? s) '() (cadr s)))
<a name="%_idx_6384" id="%_idx_6384"></a>(define (statements s)
  (if (symbol? s) (list s) (caddr s)))
</pre></p>
<p></p>
<p>and to determine whether a givensequence needs or modifies a given register we use the predicates</p>
<p></p>
<p><pre><a name="%_idx_6386" id="%_idx_6386"></a>(define (needs-register? seq reg)
  (memq reg (registers-needed seq)))
<a name="%_idx_6388" id="%_idx_6388"></a>(define (modifies-register? seq reg)
  (memq reg (registers-modified seq)))
</pre></p>
<p></p>
<p>In terms of these predicates and selectors, we can implement thevarious instruction sequence combiners used throughout the compiler.</p>
<p>The basic combiner is <code>append-instruction-sequences</code>.  This takes asarguments an arbitrary number of instruction sequences that are to be executedsequentially and returns an instruction sequence whose statements are thestatements of all the sequences appended together.  The subtle point is todetermine the registers that are needed and modified by the resultingsequence.  It modifies those registers that are modified by any of thesequences; it needs those registers that must be initialized before the firstsequence can be run (the registers needed by the first sequence), togetherwith those registers needed by any of the other sequences that are notinitialized (modified) by sequences preceding it.</p>
<p>The sequences are appended two at a time by <code>append-2-sequences</code>.  Thistakes two instruction sequences <code>seq1</code> and <code>seq2</code> and returns theinstruction sequence whose statements are the statements of <code>seq1</code>followed by the statements of <code>seq2</code>, whose modified registers are thoseregisters that are modified by either <code>seq1</code> or <code>seq2</code>, and whoseneeded registers are the registers needed by <code>seq1</code> together with thoseregisters needed by <code>seq2</code> that are not modified by <code>seq1</code>.  (In termsof set operations, the new set of needed registers is the union of the set ofregisters needed by <code>seq1</code> with the set difference of the registers neededby <code>seq2</code> and the registers modified by <code>seq1</code>.)  Thus, <code>append-instruction-sequences</code> is implemented as follows:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_6390" id="%_idx_6390"></a>(define (append-instruction-sequences . seqs)
  (define (append-2-sequences seq1 seq2)
    (make-instruction-sequence
     (list-union (registers-needed seq1)
                 (list-difference (registers-needed seq2)
                                  (registers-modified seq1)))
     (list-union (registers-modified seq1)
                 (registers-modified seq2))
     (append (statements seq1) (statements seq2))))
  (define (append-seq-list seqs)
    (if (null? seqs)
        (empty-instruction-sequence)
        (append-2-sequences (car seqs)
                            (append-seq-list (cdr seqs)))))
  (append-seq-list seqs))
</pre></p>
<p></p>
<p></p>
<p>This procedure uses some simple operations for manipulating setsrepresented as lists, similar to the (unordered) set representationdescribed in section <a href="book-Z-H-16.html#%_sec_2.3.3">2.3.3</a>:</p>
<p></p>
<p><pre><a name="%_idx_6392" id="%_idx_6392"></a>(define (list-union s1 s2)
  (cond ((null? s1) s2)
        ((memq (car s1) s2) (list-union (cdr s1) s2))
        (else (cons (car s1) (list-union (cdr s1) s2)))))
<a name="%_idx_6394" id="%_idx_6394"></a>(define (list-difference s1 s2)
  (cond ((null? s1) '())
        ((memq (car s1) s2) (list-difference (cdr s1) s2))
        (else (cons (car s1)
                    (list-difference (cdr s1) s2)))))
</pre></p>
<p></p>
<p></p>
<p><code>Preserving</code>, the second major instruction sequence combiner, takes a listof registers <code>regs</code> and two instruction sequences <code>seq1</code> and <code>seq2</code> that are to be executed sequentially.  It returns an instructionsequence whose statements are the statements of <code>seq1</code> followed by thestatements of <code>seq2</code>, with appropriate <code>save</code> and <code>restore</code>instructions around <code>seq1</code> to protect the registers in <code>regs</code> that aremodified by <code>seq1</code> but needed by <code>seq2</code>.  To accomplish this, <code>preserving</code> first creates a sequence that has the required <code>save</code>sfollowed by the statements of <code>seq1</code> followed by the required <code>restore</code>s.  This sequence needs the registers being saved and restored inaddition to the registers needed by <code>seq1</code>, and modifies the registersmodified by <code>seq1</code> except for the ones being saved and restored.  Thisaugmented sequence and <code>seq2</code> are then appended in the usual way.  Thefollowing procedure implements this strategy recursively, walking down thelist of registers to be preserved:<a name="call_footnote_Temp_815" href="#footnote_Temp_815" id="call_footnote_Temp_815"><sup><small>42</small></sup></a></p>
<p></p>
<p><pre><a name="%_idx_6398" id="%_idx_6398"></a>(define (preserving regs seq1 seq2)
  (if (null? regs)
      (append-instruction-sequences seq1 seq2)
      (let ((first-reg (car regs)))
        (if (and (needs-register? seq2 first-reg)
                 (modifies-register? seq1 first-reg))
            (preserving (cdr regs)
             (make-instruction-sequence
              (list-union (list first-reg)
                          (registers-needed seq1))
              (list-difference (registers-modified seq1)
                               (list first-reg))
              (append `((save ,first-reg))
                      (statements seq1)
                      `((restore ,first-reg))))
             seq2)
            (preserving (cdr regs) seq1 seq2)))))
</pre></p>
<p></p>
<p></p>
<p>Another sequence combiner, <code>tack-on-instruction-sequence</code>,is used by <code>compile-lambda</code> to append a procedure body to anothersequence.  Because the procedure body is not “in line” to beexecuted as part of the combined sequence, its register use has noimpact on the register use of the sequence in which it is embedded.We thus ignore the procedure body's sets of needed and modifiedregisters when we tack it onto the other sequence.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_6400" id="%_idx_6400"></a>(define (tack-on-instruction-sequence seq body-seq)
  (make-instruction-sequence
   (registers-needed seq)
   (registers-modified seq)
   (append (statements seq) (statements body-seq))))
</pre></p>
<p></p>
<p></p>
<p><code>Compile-if</code> and <code>compile-procedure-call</code> use a specialcombiner called <code>parallel-instruction-sequences</code> to append the twoalternative branches that follow a test.  The two branches will never beexecuted sequentially; for any particular evaluation of the test, onebranch or the other will be entered.  Because of this, the registersneeded by the second branch are still needed by the combined sequence,even if these are modified by the first branch.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_6402" id="%_idx_6402"></a>(define (parallel-instruction-sequences seq1 seq2)
  (make-instruction-sequence
   (list-union (registers-needed seq1)
               (registers-needed seq2))
   (list-union (registers-modified seq1)
               (registers-modified seq2))
   (append (statements seq1) (statements seq2))))
</pre></p>
<p></p>
<p></p>
<p><a name="%_sec_5.5.5" id="%_sec_5.5.5"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_5.5.5">5.5.5  An Example of Compiled Code</a></h3>
<p><a name="%_idx_6404" id="%_idx_6404"></a><a name="%_idx_6406" id="%_idx_6406"></a>Now that we have seen all the elements of the compiler, let us examinean example of compiled code to see how things fit together.  We willcompile the definition of a recursive <code>factorial</code> procedure bycalling <code>compile</code>:</p>
<p></p>
<p></p>
<p><pre>(compile
 '(define (factorial n)
    (if (= n 1)
        1
        (* (factorial (- n 1)) n)))
 'val
 'next)
</pre></p>
<p></p>
<p>We have specified that the value of the <code>define</code> expression shouldbe placed in the <code>val</code> register.  We don't care what the compiledcode does after executing the <code>define</code>, so our choice of <code>next</code> as the linkage descriptor is arbitrary.</p>
<p><code>Compile</code> determines that the expression is a definition, so it calls <code>compile-definition</code> to compile code to compute the value to be assigned(targeted to <code>val</code>), followed by code to install the definition, followedby code to put the value of the <code>define</code> (which is the symbol <code>ok</code>)into the target register, followed finally by the linkage code.  <code>Env</code> ispreserved around the computation of the value, because it is needed in orderto install the definition.  Because the linkage is <code>next</code>, there is nolinkage code in this case.  The skeleton of the compiled code is thus</p>
<p></p>
<p></p>
<p><pre>  &lt;<em>save <code>env</code> if modified by code to compute value</em>&gt;
  &lt;<em>compilation of definition value, target <code>val</code>, linkage <code>next</code></em>&gt;
  &lt;<em>restore <code>env</code> if saved above</em>&gt;
  (perform (op define-variable!)
           (const factorial)
           (reg val)
           (reg env))
  (assign val (const ok))
</pre></p>
<p></p>
<p></p>
<p>The expression that is to be compiled to produce the value for thevariable <code>factorial</code> is a <code>lambda</code> expression whose value isthe procedure that computes factorials.  <code>Compile</code> handles this bycalling <code>compile-lambda</code>, which compiles the procedure body,labels it as a new entry point, and generates the instruction thatwill combine the procedure body at the new entry point with therun-time environment and assign the result to <code>val</code>.  The sequencethen skips around the compiled procedure code, which is inserted atthis point.  The procedure code itself begins by extending theprocedure's definition environment by a frame that bindsthe formal parameter <code>n</code> to the procedure argument.  Then comes the actualprocedure body.  Since this code for the value of the variabledoesn't modify the <code>env</code> register, the optional <code>save</code>and <code>restore</code> shown above aren't generated.  (The procedure code at<code>entry2</code> isn't executed at this point, so its use of <code>env</code>is irrelevant.)Therefore, the skeleton for the compiled code becomes</p>
<p></p>
<p></p>
<p><pre>  (assign val (op make-compiled-procedure)
              (label entry2)
              (reg env))
  (goto (label after-lambda1))
entry2
  (assign env (op compiled-procedure-env) (reg proc))
  (assign env (op extend-environment)
              (const (n))
              (reg argl)
              (reg env))
  &lt;<em>compilation of procedure body</em>&gt;
after-lambda1
  (perform (op define-variable!)
           (const factorial)
           (reg val)
           (reg env))
  (assign val (const ok))
</pre></p>
<p></p>
<p></p>
<p>A procedure body is always compiled (by <code>compile-lambda-body</code>) asa sequence with target <code>val</code> and linkage <code>return</code>.  Thesequence in this case consists of a single <code>if</code> expression:</p>
<p></p>
<p></p>
<p><pre>(if (= n 1)
    1
    (* (factorial (- n 1)) n))
</pre></p>
<p></p>
<p><code>Compile-if</code> generates code that first computes the predicate (targeted to<code>val</code>), then checks the result and branches around the true branch if thepredicate is false.  <code>Env</code> and <code>continue</code> are preserved around thepredicate code, since they may be needed for the rest of the <code>if</code>expression.  Since the <code>if</code> expression is the final expression (and onlyexpression) in the sequence making up the procedure body, its target is <code>val</code> and its linkage is <code>return</code>, so the true and false branches are bothcompiled with target <code>val</code> and linkage <code>return</code>.(That is, the value of the conditional, which is the value computed byeither of its branches, is the value of the procedure.)</p>
<p></p>
<p></p>
<p><pre>  &lt;<em>save <code>continue</code>, <code>env</code> if modified by predicate and needed by branches</em>&gt;
  &lt;<em>compilation of predicate, target <code>val</code>, linkage <code>next</code></em>&gt;
  &lt;<em>restore <code>continue</code>, <code>env</code> if saved above</em>&gt;
  (test (op false?) (reg val))
  (branch (label false-branch4))
true-branch5
  &lt;<em>compilation of true branch, target <code>val</code>, linkage <code>return</code></em>&gt;
false-branch4
  &lt;<em>compilation of false branch, target <code>val</code>, linkage <code>return</code></em>&gt;
after-if3
</pre></p>
<p></p>
<p></p>
<p>The predicate <code>(= n 1)</code> is a procedure call.  Thislooks up the operator (the symbol <code>=</code>) and places this value in<code>proc</code>.  It then assembles the arguments <code>1</code> and the value of<code>n</code> into <code>argl</code>.  Then it tests whether <code>proc</code> contains aprimitive or a compound procedure, and dispatches to a primitive branchor a compound branch accordingly.  Both branches resume at the <code>after-call</code> label.  The requirements to preserve registersaround the evaluation of the operator and operands don't result inany saving of registers, because in this case those evaluations don'tmodify the registers in question.</p>
<p></p>
<p></p>
<p><pre>  (assign proc
          (op lookup-variable-value) (const =) (reg env))
  (assign val (const 1))
  (assign argl (op list) (reg val))
  (assign val (op lookup-variable-value) (const n) (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch17))
compiled-branch16
  (assign continue (label after-call15))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch17
  (assign val (op apply-primitive-procedure)
              (reg proc)
              (reg argl))
after-call15
</pre></p>
<p></p>
<p></p>
<p>The true branch, which is the constant 1, compiles (with target<code>val</code> and linkage <code>return</code>) to</p>
<p></p>
<p></p>
<p><pre>  (assign val (const 1))
  (goto (reg continue))
</pre></p>
<p></p>
<p>The code for the false branch is another a procedure call, where theprocedure is the value of the symbol <code>*</code>, and the arguments are<code>n</code> and the result of another procedure call (a call to <code>factorial</code>).Each of these calls sets up <code>proc</code> and <code>argl</code> and its own primitiveand compound branches.  Figure <a href="#%_fig_5.17">5.17</a>shows the complete compilation of thedefinition of the <code>factorial</code> procedure.Notice that the possible <code>save</code> and <code>restore</code> of<code>continue</code> and <code>env</code> around the predicate, shown above,are in fact generated, because these registers are modified by the procedurecall in the predicate and needed for the procedure call and the<code>return</code> linkage in the branches.</p>
<p><a name="%_thm_5.33" id="%_thm_5.33"></a><b>Exercise 5.33.</b>  Consider the following definition of a factorial procedure, which isslightly different from the one given above:</p>
<p></p>
<p><pre>(define (factorial-alt n)
  (if (= n 1)
      1
      (* n (factorial-alt (- n 1)))))
</pre></p>
<p></p>
<p>Compile this procedure and compare the resulting code with that produced for<code>factorial</code>.  Explain any differences you find.  Does eitherprogram execute more efficiently than the other?</p>
<p></p>
<p></p>
<p><a name="%_thm_5.34" id="%_thm_5.34"></a><b>Exercise 5.34.</b>  <a name="%_idx_6408" id="%_idx_6408"></a><a name="%_idx_6410" id="%_idx_6410"></a>Compile the iterative factorial procedure</p>
<p></p>
<p><pre>(define (factorial n)
  (define (iter product counter)
    (if (&gt; counter n)
        product
        (iter (* counter product)
              (+ counter 1))))
  (iter 1 1))
</pre></p>
<p></p>
<p>Annotate the resulting code, showing the essential difference betweenthe code for iterative and recursive versions of <code>factorial</code> thatmakes one process build up stack space and the other run in constantstack space.</p>
<p></p>
<p><a name="%_fig_5.17" id="%_fig_5.17"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td>
<p></p>
<p><pre><em>;; construct the procedure and skip over code for the procedure body</em>
  (assign val
          (op make-compiled-procedure) (label entry2) (reg env))
  (goto (label after-lambda1))

entry2     <em>; calls to <code>factorial</code> will enter here</em>
  (assign env (op compiled-procedure-env) (reg proc))
  (assign env
          (op extend-environment) (const (n)) (reg argl) (reg env))
<em>;; begin actual procedure body</em>
  (save continue)
  (save env)

<em>;; compute <code>(= n 1)</code></em>
  (assign proc (op lookup-variable-value) (const =) (reg env))
  (assign val (const 1))
  (assign argl (op list) (reg val))
  (assign val (op lookup-variable-value) (const n) (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch17))
compiled-branch16
  (assign continue (label after-call15))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch17
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))

after-call15   <em>; <code>val</code> now contains result of <code>(= n 1)</code></em>
  (restore env)
  (restore continue)
  (test (op false?) (reg val))
  (branch (label false-branch4))
true-branch5  <em>; return 1</em>
  (assign val (const 1))
  (goto (reg continue))

false-branch4
<em>;; compute and return <code>(* (factorial (- n 1)) n)</code></em>
  (assign proc (op lookup-variable-value) (const *) (reg env))
  (save continue)
  (save proc)   <em>; save <code>*</code></em> procedure
  (assign val (op lookup-variable-value) (const n) (reg env))
  (assign argl (op list) (reg val))
  (save argl)   <em>; save partial argument list for <code>*</code></em>

<em>;; compute <code>(factorial (- n 1))</code>, which is the other argument for <code>*</code></em>
  (assign proc
          (op lookup-variable-value) (const factorial) (reg env))
  (save proc)  <em>; save <code>factorial</code> procedure</em>
</pre></p>
<p></p>
<p></p>
<p></p>
<p></p>
</td></tr>
<caption align="bottom"><div align="left">
<b>Figure 5.17:</b>  Compilation of the definition of the <code>factorial</code>procedure (continued on next page).</div></caption>
<tr><td><a name="%_idx_6412" id="%_idx_6412"></a></td></tr>
</table></div>
<p></p>
<p><a name="%_fig_5.17" id="%_fig_5.17"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td>
<p></p>
<p><pre><em>;; compute <code>(- n 1)</code>, which is the argument for <code>factorial</code></em>
  (assign proc (op lookup-variable-value) (const -) (reg env))
  (assign val (const 1))
  (assign argl (op list) (reg val))
  (assign val (op lookup-variable-value) (const n) (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch8))
compiled-branch7
  (assign continue (label after-call6))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch8
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))

after-call6   <em>; <code>val</code> now contains result of <code>(- n 1)</code></em>
  (assign argl (op list) (reg val))
  (restore proc) <em>; restore <code>factorial</code></em>
<em>;; apply <code>factorial</code></em>
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch11))
compiled-branch10
  (assign continue (label after-call9))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch11
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))

after-call9      <em>; <code>val</code> now contains result of <code>(factorial (- n 1))</code></em>
  (restore argl) <em>; restore partial argument list for <code>*</code></em>
  (assign argl (op cons) (reg val) (reg argl))
  (restore proc) <em>; restore <code>*</code></em>
  (restore continue)
<em>;; apply <code>*</code></em> and return its value
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch14))
compiled-branch13
<em>;; note that a compound procedure here is called tail-recursively</em>
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch14
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
  (goto (reg continue))
after-call12
after-if3
after-lambda1
<em>;; assign the procedure to the variable <code>factorial</code></em>
  (perform
   (op define-variable!) (const factorial) (reg val) (reg env))
  (assign val (const ok))
</pre></p>
<p></p>
<p></p>
<p></p>
<p></p>
</td></tr>
<caption align="bottom"><div align="left">
<b>Figure 5.17:</b>  (continued)</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p></p>
<p><a name="%_thm_5.35" id="%_thm_5.35"></a><b>Exercise 5.35.</b>  What expression was compiled to produce the code shown infigure <a href="#%_fig_5.18">5.18</a>?<a name="%_fig_5.18" id="%_fig_5.18"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td>
<p></p>
<p><pre>  (assign val (op make-compiled-procedure) (label entry16)
                                           (reg env))
  (goto (label after-lambda15))
entry16
  (assign env (op compiled-procedure-env) (reg proc))
  (assign env
          (op extend-environment) (const (x)) (reg argl) (reg env))
  (assign proc (op lookup-variable-value) (const +) (reg env))
  (save continue)
  (save proc)
  (save env)
  (assign proc (op lookup-variable-value) (const g) (reg env))
  (save proc)
  (assign proc (op lookup-variable-value) (const +) (reg env))
  (assign val (const 2))
  (assign argl (op list) (reg val))
  (assign val (op lookup-variable-value) (const x) (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch19))
compiled-branch18
  (assign continue (label after-call17))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch19
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
after-call17
  (assign argl (op list) (reg val))
  (restore proc)
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch22))
compiled-branch21
  (assign continue (label after-call20))
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch22
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
</pre></p>
<p></p>
<p></p>
<p></p>
<p></p>
</td></tr>
<caption align="bottom"><div align="left">
<b>Figure 5.18:</b>  An example of compiler output (continued on next page).See exercise <a href="#%_thm_5.35">5.35</a>.</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p><a name="%_fig_5.18" id="%_fig_5.18"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td>
<p></p>
<p><pre>after-call20
  (assign argl (op list) (reg val))
  (restore env)
  (assign val (op lookup-variable-value) (const x) (reg env))
  (assign argl (op cons) (reg val) (reg argl))
  (restore proc)
  (restore continue)
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-branch25))
compiled-branch24
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
primitive-branch25
  (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
  (goto (reg continue))
after-call23
after-lambda15
  (perform (op define-variable!) (const f) (reg val) (reg env))
  (assign val (const ok))
</pre></p>
<p></p>
<p></p>
<p></p>
<p></p>
</td></tr>
<caption align="bottom"><div align="left">
<b>Figure 5.18:</b>  (continued)</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_5.36" id="%_thm_5.36"></a><b>Exercise 5.36.</b>  <a name="%_idx_6414" id="%_idx_6414"></a><a name="%_idx_6416" id="%_idx_6416"></a>What order of evaluation does our compiler produce for operands of acombination?  Is it left-to-right, right-to-left, or some other order?Where in the compiler is this order determined?  Modify the compilerso that it produces some other order of evaluation.  (See thediscussion of order of evaluation for the explicit-control evaluatorin section <a href="book-Z-H-34.html#%_sec_5.4.1">5.4.1</a>.)  How does changing the order ofoperand evaluation affect the efficiency of the code that constructsthe argument list?</p>
<p></p>
<p></p>
<p><a name="%_thm_5.37" id="%_thm_5.37"></a><b>Exercise 5.37.</b>  <a name="%_idx_6418" id="%_idx_6418"></a><a name="%_idx_6420" id="%_idx_6420"></a>One way to understand the compiler's <code>preserving</code> mechanism foroptimizing stack usage is to see what extra operations wouldbe generated if we did not use this idea.  Modify <code>preserving</code> sothat it always generates the <code>save</code> and <code>restore</code> operations.Compile some simple expressions and identify the unnecessary stackoperations that are generated.Compare the code to that generated with the <code>preserving</code> mechanism intact.</p>
<p></p>
<p></p>
<p><a name="%_thm_5.38" id="%_thm_5.38"></a><b>Exercise 5.38.</b>  <a name="%_idx_6422" id="%_idx_6422"></a><a name="%_idx_6424" id="%_idx_6424"></a>Our compiler is clever about avoiding unnecessary stack operations,but it is not clever at all when it comes to compiling calls to the primitiveprocedures of the language in terms of the primitive operationssupplied by the machine.  For example, consider how much code iscompiled to compute <code>(+ a 1)</code>: The code sets up an argument listin <code>argl</code>, puts the primitive addition procedure (which it findsby looking up the symbol <code>+</code> in the environment) into <code>proc</code>,and tests whether the procedure is primitive or compound.  Thecompiler always generates code to perform the test, as well as codefor primitive and compound branches (only one of which will be executed).We have not shown the part of the controller that implementsprimitives, but we presume that these instructions make use ofprimitive arithmetic operations in the machine's data paths.  Considerhow much less code would be generated if the compiler could <em>open-code</em> primitives – that is, if it could generate code to directlyuse these primitive machine operations.  The expression <code>(+ a 1)</code>might be compiled into something as simple as <a name="call_footnote_Temp_822" href="#footnote_Temp_822" id="call_footnote_Temp_822"><sup><small>43</small></sup></a></p>
<p></p>
<p><pre>(assign val (op lookup-variable-value) (const a) (reg env))
(assign val (op +) (reg val) (const 1))
</pre></p>
<p></p>
<p>In this exercise we will extend our compiler to support open coding ofselected primitives.  Special-purpose code will be generatedfor calls to these primitive procedures instead of the generalprocedure-application code.  In order to support this, we will augmentour machine with special argument registers <code>arg1</code> and <code>arg2</code>.The primitive arithmetic operations of the machine will take theirinputs from <code>arg1</code> and <code>arg2</code>. The results may be put into<code>val</code>, <code>arg1</code>, or <code>arg2</code>.</p>
<p>The compiler must be able to recognize the application of anopen-coded primitive in the source program.  We will augment thedispatch in the <code>compile</code> procedure to recognize the names ofthese primitives in addition to the <a name="%_idx_6426" id="%_idx_6426"></a>reserved words (the special forms)it currently recognizes.<a name="call_footnote_Temp_823" href="#footnote_Temp_823" id="call_footnote_Temp_823"><sup><small>44</small></sup></a> For each special form our compiler has a code generator.  Inthis exercise we will construct a family of code generators for theopen-coded primitives.</p>
<p>a.  The open-coded primitives, unlike the special forms, all need theiroperands evaluated.  Write a code generator <code>spread-arguments</code> for use byall the open-coding code generators.  <code>Spread-arguments</code> should take anoperand list and compile the given operands targeted to successive argumentregisters.  Note that an operand may contain a call to an open-codedprimitive, so argument registers will have to be preserved during operandevaluation.</p>
<p>b.  For each of the primitive procedures <code>=</code>, <code>*</code>, <code>-</code>, and<code>+</code>, write a code generator that takes a combination with thatoperator, together with a target and a linkage descriptor, andproduces code to spread the arguments into the registers and thenperform the operation targeted to the given target with the givenlinkage.  You need only handle expressions with two operands.  Make<code>compile</code> dispatch to these code generators.</p>
<p>c.  Try your new compiler on the <code>factorial</code> example.  Compare theresulting code with the result produced without open coding.</p>
<p>d.  Extend your code generators for <code>+</code> and <code>*</code> so that theycan handle expressions with arbitrary numbers of operands.  Anexpression with more than two operands will have to be compiled into asequence of operations, each with only two inputs.</p>
<p></p>
<p><a name="%_sec_5.5.6" id="%_sec_5.5.6"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_5.5.6">5.5.6  Lexical Addressing</a></h3>
<p><a name="%_idx_6428" id="%_idx_6428"></a><a name="%_idx_6430" id="%_idx_6430"></a>One of the most common optimizations performed by compilers is theoptimization of variable lookup.  Our compiler, as we have implementedit so far, generates code that uses the <code>lookup-variable-value</code>operation of the evaluator machine.  This searches for a variable bycomparing it with each variable that is currently bound, working frameby frame outward through the run-time environment.  This search can beexpensive if the frames are deeply nested or if there are manyvariables.  For example, consider the problem of looking up the valueof <code>x</code> while evaluating the expression <code>(* x y z)</code> in anapplication of the procedure that is returned by</p>
<p></p>
<p></p>
<p><pre>(let ((x 3) (y 4))
  (lambda (a b c d e)
    (let ((y (* a b x))
          (z (+ c d x)))
      (* x y z))))
</pre></p>
<p></p>
<p>Since a <code>let</code> expression is just syntactic sugar for a <code>lambda</code> combination, this expression is equivalent to</p>
<p></p>
<p></p>
<p><pre>((lambda (x y)
   (lambda (a b c d e)
     ((lambda (y z) (* x y z))
      (* a b x)
      (+ c d x))))
 3
 4)
</pre></p>
<p></p>
<p>Each time <code>lookup-variable-value</code> searches for <code>x</code>, it mustdetermine that the symbol <code>x</code> is not <code>eq?</code> to <code>y</code> or <code>z</code> (in the first frame), nor to <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>, or<code>e</code> (in the second frame).  We will assume, for the moment, thatour programs do not use <code>define</code> – that variables arebound only with <code>lambda</code>.  Because our language is <a name="%_idx_6432" id="%_idx_6432"></a>lexicallyscoped, the run-time environment for any expression will have astructure that parallels the lexical structure of the program in whichthe expression appears.<a name="call_footnote_Temp_824" href="#footnote_Temp_824" id="call_footnote_Temp_824"><sup><small>45</small></sup></a>Thus, the compiler can know, when it analyzes theabove expression, that each time the procedure is applied the variable<code>x</code> in <code>(* x y z)</code> will be found two frames out from thecurrent frame and will be the first variable in that frame.</p>
<p><a name="%_idx_6434" id="%_idx_6434"></a>We can exploit this fact by inventing a new kind of variable-lookupoperation, <code>lexical-address-lookup</code>, that takes as arguments anenvironment and a <em>lexical address</em> that consists of two numbers:a <em>frame number</em>, which specifies how many frames to pass over,and a <em>displacement number</em>, which specifies how many variables topass over in that frame.  <a name="%_idx_6436" id="%_idx_6436"></a><code>Lexical-address-lookup</code> will producethe value of the variable stored at that lexical address relative tothe current environment.  If we add the <code>lexical-address-lookup</code>operation to our machine, we can make the compiler generate code thatreferences variables using this operation, rather than <code>lookup-variable-value</code>.  Similarly, our compiled code can use a new<a name="%_idx_6438" id="%_idx_6438"></a><code>lexical-address-set!</code>  operation instead of <code>set-variable-value!</code>.</p>
<p>In order to generate such code, the compiler must be able to determinethe lexical address of a variable it is about to compile a referenceto.  The lexical address of a variable in a program depends on whereone is in the code.  For example, in the following program, theaddress of <code>x</code> in expression &lt;<em>e1</em>&gt; is (2,0) – two frames backand the first variable in the frame.  At that point <code>y</code> is ataddress (0,0) and <code>c</code> is at address (1,2).  In expression&lt;<em>e2</em>&gt;,  <code>x</code> is at (1,0),   <code>y</code> is at (1,1), and <code>c</code> is at (0,2).</p>
<p></p>
<p></p>
<p><pre>((lambda (x y)
   (lambda (a b c d e)
     ((lambda (y z) &lt;<em>e1</em>&gt;)
      &lt;<em>e2</em>&gt;
      (+ c d x))))
 3
 4)
</pre></p>
<p></p>
<p></p>
<p><a name="%_idx_6440" id="%_idx_6440"></a>One way for the compiler to produce code that uses lexical addressingis to maintain a data structure called a <em>compile-timeenvironment</em>.  This keeps track of which variables will be at whichpositions in which frames in the run-time environment when aparticular variable-access operation is executed.  The compile-timeenvironment is a list of frames, each containing a list of variables.(There will of course be no values bound to the variables, sincevalues are not computed at compile time.)  The compile-timeenvironment becomes an additional argument to <code>compile</code> and ispassed along to each code generator.  The top-level call to <code>compile</code> uses an empty compile-time environment.When a <code>lambda</code> body is compiled, <code>compile-lambda-body</code>extends the compile-time environment by a frame containing theprocedure's parameters, so that the sequence making up the bodyis compiled with that extended environment.At each point in the compilation, <code>compile-variable</code> and <code>compile-assignment</code> use the compile-timeenvironment in order to generate the appropriate lexical addresses.</p>
<p>Exercises <a href="#%_thm_5.39">5.39</a>through <a href="#%_thm_5.43">5.43</a> describe how to complete this sketch ofthe lexical-addressing strategy in order to incorporate lexical lookupinto the compiler.Exercise <a href="#%_thm_5.44">5.44</a> describes another use for thecompile-time environment.</p>
<p></p>
<p><a name="%_thm_5.39" id="%_thm_5.39"></a><b>Exercise 5.39.</b>  <a name="%_idx_6442" id="%_idx_6442"></a><a name="%_idx_6444" id="%_idx_6444"></a>Write a procedure <code>lexical-address-lookup</code> that implements the newlookup operation.  It should take two arguments – a lexical addressand a run-time environment – and return the value of the variablestored at the specified lexical address.  <code>Lexical-address-lookup</code>should signal an error if the value of the variable is the symbol <code>*unassigned*</code>.<a name="call_footnote_Temp_826" href="#footnote_Temp_826" id="call_footnote_Temp_826"><sup><small>46</small></sup></a> Also write a procedure <code>lexical-address-set!</code> thatimplements the operation that changes the value of the variable at aspecified lexical address.</p>
<p></p>
<p></p>
<p><a name="%_thm_5.40" id="%_thm_5.40"></a><b>Exercise 5.40.</b>  <a name="%_idx_6450" id="%_idx_6450"></a>Modify the compiler to maintain the compile-time environment asdescribed above.  That is, add a compile-time-environment argument to<code>compile</code> and the various code generators, and extend it in<code>compile-lambda-body</code>.</p>
<p></p>
<p></p>
<p><a name="%_thm_5.41" id="%_thm_5.41"></a><b>Exercise 5.41.</b>  <a name="%_idx_6452" id="%_idx_6452"></a>Write a procedure <code>find-variable</code> that takes as arguments avariable and a compile-time environment and returns the lexicaladdress of the variable with respect to that environment.  Forexample, in the program fragment that is shown above, the compile-timeenvironment during the compilation of expression &lt;<em>e1</em>&gt; is <code>((yz) (a b c d e) (x y))</code>.  <code>Find-variable</code> should produce</p>
<p></p>
<p></p>
<p><pre>(find-variable 'c '((y z) (a b c d e) (x y)))
<i>(1 2)</i>

(find-variable 'x '((y z) (a b c d e) (x y)))
<i>(2 0)</i>

(find-variable 'w '((y z) (a b c d e) (x y)))
<i>not-found</i>
</pre></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_5.42" id="%_thm_5.42"></a><b>Exercise 5.42.</b>  Using <code>find-variable</code> from exercise <a href="#%_thm_5.41">5.41</a>,rewrite <code>compile-variable</code> and <code>compile-assignment</code> to outputlexical-address instructions.  In cases where <code>find-variable</code>returns <code>not-found</code> (that is, where the variable is not in thecompile-time environment), you should have the code generators use theevaluator operations, as before, to search for the binding.(The only place a variable that is not found at compile time can be is inthe global environment, which is part of the run-time environment butis not part of the compile-time environment.<a name="call_footnote_Temp_830" href="#footnote_Temp_830" id="call_footnote_Temp_830"><sup><small>47</small></sup></a>Thus, if you wish, you may have the evaluator operations look directly inthe global environment, which can be obtained with the operation <code>(op get-global-environment)</code>, instead of having them search the whole run-timeenvironment found in <code>env</code>.)Test the modified compiler on a few simple cases, such as the nested<code>lambda</code> combination at the beginning of this section.</p>
<p></p>
<p></p>
<p><a name="%_thm_5.43" id="%_thm_5.43"></a><b>Exercise 5.43.</b>  <a name="%_idx_6454" id="%_idx_6454"></a><a name="%_idx_6456" id="%_idx_6456"></a>We argued in section <a href="book-Z-H-26.html#%_sec_4.1.6">4.1.6</a> that internal definitionsfor block structure should not be considered “real” <code>define</code>s.  Rather,a procedure body should be interpreted as if the internal variables beingdefined were installed as ordinary <code>lambda</code> variables initialized to theircorrect values using <code>set!</code>.  Section <a href="book-Z-H-26.html#%_sec_4.1.6">4.1.6</a> andexercise <a href="book-Z-H-26.html#%_thm_4.16">4.16</a> showed how to modify the metacircularinterpreter to accomplish this by scanning out internal definitions.  Modifythe compiler to perform the same transformation before it compiles a procedurebody.</p>
<p></p>
<p></p>
<p><a name="%_thm_5.44" id="%_thm_5.44"></a><b>Exercise 5.44.</b>  <a name="%_idx_6458" id="%_idx_6458"></a><a name="%_idx_6460" id="%_idx_6460"></a><a name="%_idx_6462" id="%_idx_6462"></a><a name="%_idx_6464" id="%_idx_6464"></a>In this section we have focused on the use of the compile-timeenvironment to produce lexical addresses.  But there are other usesfor compile-time environments.  For instance, inexercise <a href="#%_thm_5.38">5.38</a> we increased the efficiency of compiledcode by open-coding primitive procedures.  Our implementation treatedthe names of open-coded procedures as reserved words.  If a programwere to rebind such a name, the mechanism described inexercise <a href="#%_thm_5.38">5.38</a> would still open-code it as a primitive,ignoring the new binding.  For example, consider the procedure</p>
<p></p>
<p></p>
<p><pre>(lambda (+ * a b x y)
  (+ (* a x) (* b y)))
</pre></p>
<p></p>
<p>which computes a linear combination of <code>x</code> and <code>y</code>.  We mightcall it with arguments <code>+matrix</code>, <code>*matrix</code>, and fourmatrices, but the open-coding compiler would still open-code the <code>+</code> and the <code>*</code> in <code>(+ (* a x) (* b y))</code> as primitive <code>+</code>and <code>*</code>.  Modify the open-coding compiler to consult thecompile-time environment in order to compile the correct code forexpressions involving the names of primitive procedures.(The code will work correctly as long as the program does not <code>define</code> or <code>set!</code> these names.)</p>
<p></p>
<p><a name="%_sec_5.5.7" id="%_sec_5.5.7"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_5.5.7">5.5.7  Interfacing Compiled Code to the Evaluator</a></h3>
<p><a name="%_idx_6466" id="%_idx_6466"></a><a name="%_idx_6468" id="%_idx_6468"></a><a name="%_idx_6470" id="%_idx_6470"></a>We have not yet explained how to load compiled code into the evaluator machineor how to run it.  We will assume that the explicit-control-evaluator machinehas been defined as in section <a href="book-Z-H-34.html#%_sec_5.4.4">5.4.4</a>, with theadditional operations specified in footnote <a href="#footnote_Temp_809">38</a>.We will implementa procedure <a name="%_idx_6472" id="%_idx_6472"></a><code>compile-and-go</code> that compiles a Scheme expression, loads theresulting object code into the evaluator machine,and causes the machine to run the code in theevaluator global environment, print the result, andenter the evaluator's driver loop.  We will also modify the evaluator so thatinterpreted expressions can call compiled procedures as well as interpretedones.  We can then put a compiled procedure into the machine and use theevaluator to call it:</p>
<p></p>
<p></p>
<p><pre>(compile-and-go
 '(define (factorial n)
    (if (= n 1)
        1
        (* (factorial (- n 1)) n))))
<i> ;;; EC-Eval value:</i>
<i>ok</i>
<i> ;;; EC-Eval input:</i>
(factorial 5)
<i>;;; EC-Eval value:</i>
<i>120</i>
</pre></p>
<p></p>
<p></p>
<p>To allow the evaluator to handle compiled procedures (for example,to evaluate the call to <code>factorial</code> above),we need to change the code at <code>apply-dispatch</code>(section <a href="book-Z-H-34.html#%_sec_5.4.1">5.4.1</a>) so that it recognizescompiled procedures (as distinct from compound or primitiveprocedures) and transfers control directly to the entry point of thecompiled code:<a name="call_footnote_Temp_833" href="#footnote_Temp_833" id="call_footnote_Temp_833"><sup><small>48</small></sup></a></p>
<p></p>
<p><pre><a name="%_idx_6474" id="%_idx_6474"></a>apply-dispatch
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-apply))
  (test (op compound-procedure?) (reg proc))  
  (branch (label compound-apply))
  (test (op compiled-procedure?) (reg proc))  
  (branch (label compiled-apply))
  (goto (label unknown-procedure-type))
<a name="%_idx_6476" id="%_idx_6476"></a>compiled-apply
  (restore continue)
  (assign val (op compiled-procedure-entry) (reg proc))
  (goto (reg val))
</pre></p>
<p></p>
<p>Note the restore of <code>continue</code> at <code>compiled-apply</code>.  Recall that theevaluator was arranged so that at <code>apply-dispatch</code>, the continuation wouldbe at the top of the stack.  The compiled code entry point, on the other hand,expects the continuation to be in <code>continue</code>, so <code>continue</code> must berestored before the compiled code is executed.</p>
<p>To enable us to run some compiled code when we start the evaluatormachine, we add a <code>branch</code> instruction atthe beginning of the evaluator machine, which causes the machine togo to a new entry point if the <code>flag</code> register is set.<a name="call_footnote_Temp_834" href="#footnote_Temp_834" id="call_footnote_Temp_834"><sup><small>49</small></sup></a></p>
<p></p>
<p></p>
<p><pre>  (branch (label external-entry))      <em>; branches if <code>flag</code> is set</em>
read-eval-print-loop
  (perform (op initialize-stack))
  <code>...</code></pre></p>
<p></p>
<p><code>External-entry</code> assumes that the machine is started with<code>val</code> containing the location of an instruction sequence thatputs a result into <code>val</code> and ends with <code>(goto (regcontinue))</code>.  Starting at this entry point jumps to the location designatedby <code>val</code>, but first assigns <code>continue</code> so that execution will returnto <code>print-result</code>, which prints the value in <code>val</code> and then goes tothe beginning of the evaluator's read-eval-print loop.<a name="call_footnote_Temp_835" href="#footnote_Temp_835" id="call_footnote_Temp_835"><sup><small>50</small></sup></a></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_6482" id="%_idx_6482"></a>external-entry
  (perform (op initialize-stack))
  (assign env (op get-global-environment))
  (assign continue (label print-result))
  (goto (reg val))
</pre></p>
<p></p>
<p>Now we can use the following procedure to compile a procedure definition,execute the compiled code, and run the read-eval-print loop so we can try theprocedure.  Because we want the compiled code to return to the location in<code>continue</code> with its result in <code>val</code>, we compile the expression with atarget of <code>val</code> and a linkage of <code>return</code>.  In order to transform theobject code produced by the compiler into executable instructions for theevaluator register machine, we use the procedure <code>assemble</code> from theregister-machine simulator (section <a href="book-Z-H-32.html#%_sec_5.2.2">5.2.2</a>).  We then initializethe <code>val</code> register to point to the list of instructions, set the<code>flag</code> so that the evaluator will go to <code>external-entry</code>, and startthe evaluator.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_6484" id="%_idx_6484"></a>(define (compile-and-go expression)
  (let ((instructions
         (assemble (statements
                    (compile expression 'val 'return))
                   eceval)))
    (set! the-global-environment (setup-environment))
    (set-register-contents! eceval 'val instructions)
    (set-register-contents! eceval 'flag true)
    (start eceval)))
</pre></p>
<p></p>
<p></p>
<p><a name="%_idx_6486" id="%_idx_6486"></a>If we have set up stack monitoring, as at the end ofsection <a href="book-Z-H-34.html#%_sec_5.4.4">5.4.4</a>, we can examine thestack usage of compiled code:</p>
<p></p>
<p></p>
<p><pre>(compile-and-go
 '(define (factorial n)
    (if (= n 1)
        1
        (* (factorial (- n 1)) n))))

<i>(total-pushes = 0 maximum-depth = 0)</i>
<i> ;;; EC-Eval value:</i>
<i>ok</i>
<i> ;;; EC-Eval input:</i>
(factorial 5)
<i>(total-pushes = 31 maximum-depth = 14)</i>
<i>;;; EC-Eval value:</i>
<i>120</i>
</pre></p>
<p></p>
<p><a name="%_idx_6488" id="%_idx_6488"></a>Compare this example with the evaluation of <code>(factorial 5)</code> usingthe interpreted version of the same procedure, shown at the end ofsection <a href="book-Z-H-34.html#%_sec_5.4.4">5.4.4</a>.  The interpreted version required144 pushes and a maximum stack depth of 28.  This illustrates theoptimization that results from our compilation strategy.</p>
<p><a name="%_sec_Temp_836" id="%_sec_Temp_836"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_836">Interpretation and compilation</a></h4>
<p><a name="%_idx_6490" id="%_idx_6490"></a><a name="%_idx_6492" id="%_idx_6492"></a>With the programs in this section, we can now experiment with thealternative execution strategies of interpretation andcompilation.<a name="call_footnote_Temp_837" href="#footnote_Temp_837" id="call_footnote_Temp_837"><sup><small>51</small></sup></a>  An interpreter raisesthe machine to the level of the user program; a compiler lowers theuser program to the level of the machine language.  We can regard theScheme language (or any programming language) as a coherent family ofabstractions erected on the machine language.  Interpreters are goodfor interactive program development and debugging because the steps ofprogram execution are organized in terms of these abstractions, andare therefore more intelligible to the programmer.  Compiled code canexecute faster, because the steps of program execution are organizedin terms of the machine language, and the compiler is free to makeoptimizations that cut across the higher-levelabstractions.<a name="call_footnote_Temp_838" href="#footnote_Temp_838" id="call_footnote_Temp_838"><sup><small>52</small></sup></a></p>
<p>The alternatives of interpretation and compilation also lead to<a name="%_idx_6504" id="%_idx_6504"></a>different strategies for porting languages to new computers. Supposethat we wish to implement Lisp for a new machine.  One strategy isto begin with the explicit-control evaluator of section <a href="book-Z-H-34.html#%_sec_5.4">5.4</a>and translate its instructions to instructions for thenew machine.  A different strategy is to begin with the compiler andchange the code generators so that they generate code for the newmachine.  The second strategy allows us to run any Lisp program onthe new machine by first compiling it with the compiler running on ouroriginal Lisp system, and linking it with a compiled version of therun-time library.<a name="call_footnote_Temp_839" href="#footnote_Temp_839" id="call_footnote_Temp_839"><sup><small>53</small></sup></a>  Better yet, we can compile the compiler itself, and runthis on the new machine to compile other Lisp programs.<a name="call_footnote_Temp_840" href="#footnote_Temp_840" id="call_footnote_Temp_840"><sup><small>54</small></sup></a>  Or we cancompile one of the interpreters of section <a href="book-Z-H-26.html#%_sec_4.1">4.1</a> toproduce an interpreter that runs on the new machine.</p>
<p></p>
<p><a name="%_thm_5.45" id="%_thm_5.45"></a><b>Exercise 5.45.</b>  <a name="%_idx_6506" id="%_idx_6506"></a><a name="%_idx_6508" id="%_idx_6508"></a>By comparing the stack operations used by compiled code to the stackoperations used by the evaluator for the same computation, we candetermine the extent to which the compiler optimizes use of the stack,both in speed (reducing the total number of stack operations) and inspace (reducing the maximum stack depth).  Comparing this optimizedstack use to the performance of a special-purpose machine for the samecomputation gives some indication of the quality of the compiler.</p>
<p></p>
<p></p>
<p>a. Exercise <a href="book-Z-H-34.html#%_thm_5.27">5.27</a> asked you to determine, as a function of<em>n</em>, the number of pushes and the maximum stack depth needed by theevaluator to compute <em>n</em>! using the recursive factorial proceduregiven above.  Exercise <a href="book-Z-H-32.html#%_thm_5.14">5.14</a> asked you to do the samemeasurements for the special-purpose factorial machine shown infigure <a href="book-Z-H-31.html#%_fig_5.11">5.11</a>. Now perform the same analysis using thecompiled <code>factorial</code> procedure.</p>
<p>Take the ratio of the number of pushes in the compiled version to thenumber of pushes in the interpreted version, and do the same for themaximum stack depth.  Since the number of operations and the stackdepth used to compute <em>n</em>! are linear in <em>n</em>, these ratios shouldapproach constants as <em>n</em> becomes large.  What are these constants?Similarly, find the ratios of the stack usage in the special-purposemachine to the usage in the interpreted version.</p>
<p>Compare the ratios for special-purpose versus interpreted code to the ratiosfor compiled versus interpreted code.  You should find that thespecial-purpose machine does much better than the compiled code, sincethe hand-tailored controller code should be much better than what isproduced by our rudimentary general-purpose compiler.</p>
<p></p>
<p></p>
<p>b. Can you suggest improvements to the compiler that would help itgenerate code that would come closer in performance to thehand-tailored version?</p>
<p></p>
<p></p>
<p><a name="%_thm_5.46" id="%_thm_5.46"></a><b>Exercise 5.46.</b>  <a name="%_idx_6510" id="%_idx_6510"></a><a name="%_idx_6512" id="%_idx_6512"></a>Carry out an analysis like the one inexercise <a href="#%_thm_5.45">5.45</a> to determine the effectiveness ofcompiling the tree-recursive Fibonacci procedure</p>
<p></p>
<p></p>
<p><pre>(define (fib n)
  (if (&lt; n 2)
      n
      (+ (fib (- n 1)) (fib (- n 2)))))
</pre></p>
<p></p>
<p>compared to the effectiveness of using the special-purpose Fibonacci machine offigure <a href="book-Z-H-31.html#%_fig_5.12">5.12</a>.  (For measurement of the interpretedperformance, see exercise <a href="book-Z-H-34.html#%_thm_5.29">5.29</a>.)For Fibonacci, the time resource used is not linear in <em>n</em>; hence theratios of stack operations will not approach a limiting value that isindependent of <em>n</em>.</p>
<p></p>
<p></p>
<p><a name="%_thm_5.47" id="%_thm_5.47"></a><b>Exercise 5.47.</b>  This section described how to modify the explicit-control evaluator sothat interpreted code can call compiled procedures.  Show how tomodify the compiler so that compiled procedures can call not onlyprimitive procedures and compiled procedures, but interpretedprocedures as well.  This requires modifying <code>compile-procedure-call</code>to handle the case of compound (interpreted) procedures.Be sure to handle all the same <code>target</code> and <code>linkage</code> combinationsas in <code>compile-proc-appl</code>.  To do the actual procedure application,the code needs to jump to the evaluator's <code>compound-apply</code> entry point.This label cannot be directly referenced in object code(since the assembler requires that all labels referenced by thecode it is assembling be defined there), so we will add a registercalled <code>compapp</code> to the evaluator machine to hold thisentry point, and add an instruction to initialize it:</p>
<p></p>
<p><pre>  (assign compapp (label compound-apply))
  (branch (label external-entry))      <em>; branches if <code>flag</code> is set</em>
read-eval-print-loop
  <code>...</code></pre></p>
<p></p>
<p>To test your code, start by defining a procedure <code>f</code> that calls aprocedure <code>g</code>.  Use <code>compile-and-go</code> to compile the definitionof <code>f</code> and start the evaluator.  Now, typing at the evaluator,define <code>g</code> and try to call <code>f</code>.</p>
<p></p>
<p></p>
<p><a name="%_thm_5.48" id="%_thm_5.48"></a><b>Exercise 5.48.</b>  <a name="%_idx_6514" id="%_idx_6514"></a>The <code>compile-and-go</code> interface implemented in this section isawkward, since the compiler can be called only once (when theevaluator machine is started).  Augment the compiler-interpreterinterface by providing a <code>compile-and-run</code> primitive that can becalled from within the explicit-control evaluator as follows:</p>
<p></p>
<p></p>
<p><pre><i>;;; EC-Eval input:</i>
(compile-and-run
 '(define (factorial n)
    (if (= n 1)
        1
        (* (factorial (- n 1)) n))))
<i>;;; EC-Eval value:</i>
<i>ok</i>
<i>;;; EC-Eval input:</i>
(factorial 5)
<i>;;; EC-Eval value:</i>
<i>120</i>
</pre></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_5.49" id="%_thm_5.49"></a><b>Exercise 5.49.</b>  As an alternative to using the explicit-control evaluator'sread-eval-print loop, design a register machine that performs aread-compile-execute-print loop.  That is, the machine should run aloop that reads an expression, compiles it, assembles andexecutes the resulting code, and prints the result.  This is easy torun in our simulated setup, since we can arrange to call theprocedures <code>compile</code> and <code>assemble</code> as “register-machineoperations.”</p>
<p></p>
<p></p>
<p><a name="%_thm_5.50" id="%_thm_5.50"></a><b>Exercise 5.50.</b>  <a name="%_idx_6516" id="%_idx_6516"></a>Use the compiler to compile the metacircular evaluator ofsection <a href="book-Z-H-26.html#%_sec_4.1">4.1</a> and run this program using the register-machinesimulator.  (To compile more than one definition at a time, you canpackage the definitions in a <code>begin</code>.)  The resulting interpreterwill run very slowly because of the multiple levels of interpretation,but getting all the details to work is an instructive exercise.</p>
<p></p>
<p></p>
<p><a name="%_thm_5.51" id="%_thm_5.51"></a><b>Exercise 5.51.</b>  <a name="%_idx_6518" id="%_idx_6518"></a>Develop a rudimentary implementation of Scheme in C (or some otherlow-level language of your choice) by translating the explicit-controlevaluator of section <a href="book-Z-H-34.html#%_sec_5.4">5.4</a> into C.  In order to run this codeyou will need to alsoprovide appropriate storage-allocation routines and other run-timesupport.</p>
<p></p>
<p></p>
<p><a name="%_thm_5.52" id="%_thm_5.52"></a><b>Exercise 5.52.</b>  <a name="%_idx_6520" id="%_idx_6520"></a><a name="%_idx_6522" id="%_idx_6522"></a><a name="%_idx_6524" id="%_idx_6524"></a>As a counterpoint to exercise <a href="#%_thm_5.51">5.51</a>, modify the compilerso that it compiles Scheme procedures into sequences of Cinstructions.  Compile the metacircular evaluator ofsection <a href="book-Z-H-26.html#%_sec_4.1">4.1</a> to produce a Scheme interpreter written in C.</p>
<p></p>
<p></p>
<p></p>
<div class="smallprint"><hr></div>
<p></p>
<div class="footnote">
<p><a name="footnote_Temp_794" href="#call_footnote_Temp_794" id="footnote_Temp_794"><sup><small>33</small></sup></a> This is a theoretical statement.  We are not claimingthat the evaluator's data paths are a particularly convenient orefficient set of data paths for a general-purpose computer.  For example,they are not very good for implementing high-performance floating-pointcalculations or calculations that intensively manipulate bit vectors.</p>
<p><a name="footnote_Temp_795" href="#call_footnote_Temp_795" id="footnote_Temp_795"><sup><small>34</small></sup></a> Actually, the machine that runscompiled code can be simpler than the interpreter machine, because we<a name="%_idx_6220" id="%_idx_6220"></a>won't use the <code>exp</code> and <code>unev</code> registers.  The interpreterused these to hold pieces of unevaluated expressions.  With thecompiler, however, these expressions get built into thecompiled code that the register machine will run.  For the samereason, <a name="%_idx_6222" id="%_idx_6222"></a>we don't need the machine operations that deal with expressionsyntax.  But compiled code will use a few additional machineoperations (to represent compiled procedure objects) that didn'tappear in the explicit-control evaluator machine.</p>
<p><a name="footnote_Temp_797" href="#call_footnote_Temp_797" id="footnote_Temp_797"><sup><small>35</small></sup></a> Notice, however, that ourcompiler is a Scheme program, and the syntax procedures that it usesto manipulate expressions are the actual Scheme procedures used withthe metacircular evaluator.  For the explicit-control evaluator, incontrast, we assumed that equivalent syntax operations were availableas operations for the register machine.  (Of course, when we simulatedthe register machine in Scheme, we used the actual Scheme proceduresin our register machine simulation.)</p>
<p><a name="footnote_Temp_803" href="#call_footnote_Temp_803" id="footnote_Temp_803"><sup><small>36</small></sup></a> This procedure uses a feature of Lisp called <em><a name="%_idx_6280" id="%_idx_6280"></a><a name="%_idx_6282" id="%_idx_6282"></a><a name="%_idx_6284" id="%_idx_6284"></a><a name="%_idx_6286" id="%_idx_6286"></a><a name="%_idx_6288" id="%_idx_6288"></a><a name="%_idx_6290" id="%_idx_6290"></a>backquote</em> (or <em>quasiquote</em>) that is handy for constructing lists.Preceding a list with a backquote symbol is much like quoting it,except that anything in the list that is flagged with a comma is evaluated.</p>
<p>For example, if the value of <code>linkage</code> is the symbol<code>branch25</code>, then the expression<code>`((goto (label ,linkage)))</code>evaluates to the list<code>((goto (label branch25)))</code>.Similarly, if the value of <code>x</code> is the list <code>(a b c)</code>, then<code>`(1 2 ,(car x))</code>evaluates to the list<code>(1 2 a)</code>.</p>
<p><a name="footnote_Temp_806" href="#call_footnote_Temp_806" id="footnote_Temp_806"><sup><small>37</small></sup></a> We can't justuse the labels <code>true-branch</code>, <code>false-branch</code>, and<code>after-if</code> as shown above,because there might be more than one <code>if</code> in the program.<a name="%_idx_6318" id="%_idx_6318"></a>The compiler uses the procedure <code>make-label</code> to generate labels.<code>Make-label</code> takes a symbol as argument and returns a new symbolthat begins with the given symbol.  For example, successive calls to<code>(make-label 'a)</code> would return <code>a1</code>, <code>a2</code>, and so on.<code>Make-label</code> can be implemented similarly to the generation ofunique variable names in the query language, as follows:</p>
<p></p>
<p><pre>(define label-counter 0)

(define (new-label-number)
  (set! label-counter (+ 1 label-counter))
  label-counter)

<a name="%_idx_6320" id="%_idx_6320"></a><a name="%_idx_6322" id="%_idx_6322"></a>(define (make-label name)
  (string-&gt;symbol
    (string-append (symbol-&gt;string name)
                   (number-&gt;string (new-label-number)))))
</pre></p>
<p></p>
<p></p>
<p><a name="footnote_Temp_809" href="#call_footnote_Temp_809" id="footnote_Temp_809"><sup><small>38</small></sup></a> We need machine operations to implement a datastructure for representing compiled procedures, analogous to the structure forcompound procedures described in section <a href="book-Z-H-26.html#%_sec_4.1.3">4.1.3</a>:</p>
<p></p>
<p><pre><a name="%_idx_6332" id="%_idx_6332"></a>(define (make-compiled-procedure entry env)
  (list 'compiled-procedure entry env))

<a name="%_idx_6334" id="%_idx_6334"></a>(define (compiled-procedure? proc)
  (tagged-list? proc 'compiled-procedure))

<a name="%_idx_6336" id="%_idx_6336"></a>(define (compiled-procedure-entry c-proc) (cadr c-proc))

<a name="%_idx_6338" id="%_idx_6338"></a>(define (compiled-procedure-env c-proc) (caddr c-proc))
</pre></p>
<p></p>
<p></p>
<p><a name="footnote_Temp_812" href="#call_footnote_Temp_812" id="footnote_Temp_812"><sup><small>39</small></sup></a> Actually, we signal an error when the target is not <code>val</code>and the linkage is <code>return</code>, sincethe only place we request <code>return</code> linkages is in compilingprocedures, and our convention is that procedures return theirvalues in <code>val</code>.</p>
<p><a name="footnote_Temp_813" href="#call_footnote_Temp_813" id="footnote_Temp_813"><sup><small>40</small></sup></a> Making a<a name="%_idx_6356" id="%_idx_6356"></a>compiler generate tail-recursive code might seem like astraightforward idea.  But most compilers for common languages,including C and Pascal, do not do this, and therefore these languagescannot represent iterative processes in terms of procedure call alone.The difficulty with <a name="%_idx_6358" id="%_idx_6358"></a><a name="%_idx_6360" id="%_idx_6360"></a><a name="%_idx_6362" id="%_idx_6362"></a>tail recursion in these languages is that theirimplementations use the stack to store procedure arguments and localvariables as well as return addresses.  The Scheme implementationsdescribed in this book store arguments and variables in memory to begarbage-collected.  The reason for using the stack for variables andarguments is that it avoids the need for garbage collection inlanguages that would not otherwise require it, and is generallybelieved to be more efficient.  Sophisticated Lisp compilers can, infact, use the stack for arguments without destroying tail recursion.(See <a name="%_idx_6364" id="%_idx_6364"></a>Hanson 1990 for a description.)  There is also some debate aboutwhether stack allocation is actually more efficient than garbagecollection in the first place, but the details seem to hinge on finepoints of computer architecture.  (See <a name="%_idx_6366" id="%_idx_6366"></a>Appel 1987 and <a name="%_idx_6368" id="%_idx_6368"></a><a name="%_idx_6370" id="%_idx_6370"></a>Miller and Rozas1994 for opposing views on this issue.)</p>
<p><a name="footnote_Temp_814" href="#call_footnote_Temp_814" id="footnote_Temp_814"><sup><small>41</small></sup></a> The variable<a name="%_idx_6372" id="%_idx_6372"></a><code>all-regs</code> is bound to the list of names of all the registers:</p>
<p></p>
<p><pre><a name="%_idx_6374" id="%_idx_6374"></a>(define all-regs '(env proc val argl continue))
</pre></p>
<p></p>
<p></p>
<p><a name="footnote_Temp_815" href="#call_footnote_Temp_815" id="footnote_Temp_815"><sup><small>42</small></sup></a> Note that <code>preserving</code> calls <code>append</code> with three<a name="%_idx_6396" id="%_idx_6396"></a>arguments.  Though the definition of <code>append</code> shown in this bookaccepts only two arguments, Scheme standardly provides an <code>append</code>procedure that takes an arbitrary number of arguments.</p>
<p><a name="footnote_Temp_822" href="#call_footnote_Temp_822" id="footnote_Temp_822"><sup><small>43</small></sup></a> We have usedthe same symbol <code>+</code> here to denote both the source-languageprocedure and the machine operation.  In general there will not be aone-to-one correspondence between primitives of the source languageand primitives of the machine.</p>
<p><a name="footnote_Temp_823" href="#call_footnote_Temp_823" id="footnote_Temp_823"><sup><small>44</small></sup></a> Making the primitives into reservedwords is in general a bad idea, since a user cannot then rebind thesenames to different procedures.  Moreover, if we add reserved words toa compiler that is in use, existing programs that define procedureswith these names will stop working.  Seeexercise <a href="#%_thm_5.44">5.44</a> for ideas on how to avoid thisproblem.</p>
<p><a name="footnote_Temp_824" href="#call_footnote_Temp_824" id="footnote_Temp_824"><sup><small>45</small></sup></a> This is not true if we allowinternal definitions, unless we scan them out.See exercise <a href="#%_thm_5.43">5.43</a>.</p>
<p><a name="footnote_Temp_826" href="#call_footnote_Temp_826" id="footnote_Temp_826"><sup><small>46</small></sup></a> This is the modification to variable lookup<a name="%_idx_6446" id="%_idx_6446"></a><a name="%_idx_6448" id="%_idx_6448"></a>required if we implement the scanning method to eliminate internaldefinitions (exercise <a href="#%_thm_5.43">5.43</a>).  We will needto eliminate these definitions in order for lexical addressing towork.</p>
<p><a name="footnote_Temp_830" href="#call_footnote_Temp_830" id="footnote_Temp_830"><sup><small>47</small></sup></a> Lexical addresses cannot be used to access variables in the globalenvironment, because these names can be defined and redefinedinteractively at any time.  With internal definitions scanned out, asin exercise <a href="#%_thm_5.43">5.43</a>, the only definitions thecompiler sees are those at top level, which act on the globalenvironment.  Compilation of a definition does not cause the definedname to be entered in the compile-time environment.</p>
<p><a name="footnote_Temp_833" href="#call_footnote_Temp_833" id="footnote_Temp_833"><sup><small>48</small></sup></a> Of course, compiled procedures as well as interpretedprocedures are compound (nonprimitive).  For compatibility withthe terminology used in the explicit-control evaluator, in thissection we will use “compound” to mean interpreted (as opposedto compiled).</p>
<p><a name="footnote_Temp_834" href="#call_footnote_Temp_834" id="footnote_Temp_834"><sup><small>49</small></sup></a> Now that the evaluator machine startswith a <code>branch</code>, we must always initialize the <code>flag</code> registerbefore starting the evaluator machine.  To start the machine atits ordinary read-eval-print loop, we could use</p>
<p></p>
<p><pre><a name="%_idx_6478" id="%_idx_6478"></a>(define (start-eceval)
  (set! the-global-environment (setup-environment))
  (set-register-contents! eceval 'flag false)
  (start eceval))
</pre></p>
<p></p>
<p></p>
<p><a name="footnote_Temp_835" href="#call_footnote_Temp_835" id="footnote_Temp_835"><sup><small>50</small></sup></a> Since a compiled procedure is anobject that the system may try to print, we also modify the systemprint operation <code>user-print</code> (from section <a href="book-Z-H-26.html#%_sec_4.1.4">4.1.4</a>)so that it will not attempt to print thecomponents of a compiled procedure:</p>
<p></p>
<p><pre><a name="%_idx_6480" id="%_idx_6480"></a>(define (user-print object)
  (cond ((compound-procedure? object)
         (display (list 'compound-procedure
                        (procedure-parameters object)
                        (procedure-body object)
                        '&lt;procedure-env&gt;)))
        ((compiled-procedure? object)
         (display '&lt;compiled-procedure&gt;))
        (else (display object))))
</pre></p>
<p></p>
<p></p>
<p><a name="footnote_Temp_837" href="#call_footnote_Temp_837" id="footnote_Temp_837"><sup><small>51</small></sup></a> We can do even better by extending the compilerto allow compiled code to call interpreted procedures.  Seeexercise <a href="#%_thm_5.47">5.47</a>.</p>
<p><a name="footnote_Temp_838" href="#call_footnote_Temp_838" id="footnote_Temp_838"><sup><small>52</small></sup></a> Independent of the strategy of execution, we<a name="%_idx_6494" id="%_idx_6494"></a>incur significant overhead if we insist that errors encountered inexecution of a user program be detected and signaled, rather than beingallowed to kill the system or produce wrong answers.  For example, anout-of-bounds array reference can be detected by checking the validityof the reference before performing it.  The overhead of checking,however, can be many times the cost of the array reference itself, anda programmer should weigh speed against safety in determining whethersuch a check is desirable.  A good compiler should be able to producecode with such checks, should avoid redundant checks, and should allowprogrammers to control the extent and type of error checking in thecompiled code.</p>
<p><a name="%_idx_6496" id="%_idx_6496"></a>Compilers for popular languages, such as C and C++,put hardly any error-checking operations intorunning code, so as to make things run as fast as possible.  As aresult, it falls to programmers to explicitly provide error checking.Unfortunately, people often neglect to do this, even incritical applications where speed is not a constraint.  Their programslead fast and dangerous lives.  For example, the notorious <a name="%_idx_6498" id="%_idx_6498"></a>“Worm”that paralyzed the Internet in 1988 exploited the <a name="%_idx_6500" id="%_idx_6500"></a>UNIX<sup><em>T</em><em>M</em></sup>operating system's failure to check whether the input buffer has<a name="%_idx_6502" id="%_idx_6502"></a>overflowed in the finger daemon. (See Spafford 1989.)</p>
<p><a name="footnote_Temp_839" href="#call_footnote_Temp_839" id="footnote_Temp_839"><sup><small>53</small></sup></a> Of course, with either theinterpretation or the compilation strategy we must also implement forthe new machine storage allocation, input and output, and all thevarious operations that we took as “primitive” in our discussion ofthe evaluator and compiler.  One strategy for minimizing work here isto write as many of these operations as possible in Lisp and thencompile them for the new machine.  Ultimately, everything reduces to asmall kernel (such as garbage collection and the mechanism forapplying actual machine primitives) that is hand-coded for the newmachine.</p>
<p><a name="footnote_Temp_840" href="#call_footnote_Temp_840" id="footnote_Temp_840"><sup><small>54</small></sup></a>This strategy leads to amusing tests of correctness ofthe compiler, such as checkingwhether the compilation of a program on the new machine, using thecompiled compiler, is identical with thecompilation of the program on the original Lisp system.  Trackingdown the source of differences is fun but often frustrating, becausethe results are extremely sensitive to minuscule details.</p>
</div></body>
</html>
