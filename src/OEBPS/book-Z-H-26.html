<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<?xml version="1.0" encoding="utf-8"?><html xmlns="http://www.w3.org/1999/xhtml" xmlns:ops="http://www.idpf.org/2007/ops">
<!-- Generated from TeX source by tex2page, v 4o,
     (c) Dorai Sitaram, http://www.cs.rice.edu/~dorai/tex2page --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Type: text/html; charset=utf-8">
<title>Structure and Interpretation of Computer Programs</title>
<link rel="stylesheet" type="text/css" href="book-Z-C.css" title="default">
</head>
<body><a name="%_sec_4.1" id="%_sec_4.1"></a><h2><a href="book-Z-H-4.html#%_toc_%_sec_4.1">4.1  The Metacircular Evaluator</a></h2>
<p><a name="%_idx_4210" id="%_idx_4210"></a>Our evaluator for Lisp will be implemented as a Lisp program.  It mayseem circular to think about evaluating Lisp programs using anevaluator that is itself implemented in Lisp.  However, evaluation isa process, so it is appropriate to describe the evaluation processusing Lisp, which, after all, is our tool for describingprocesses.<a name="call_footnote_Temp_510" href="#footnote_Temp_510" id="call_footnote_Temp_510"><sup><small>3</small></sup></a>  An evaluator that is written in the same language<a name="%_idx_4212" id="%_idx_4212"></a><a name="%_idx_4214" id="%_idx_4214"></a>that it evaluates is said to be <em>metacircular</em>.</p>
<p><a name="%_idx_4216" id="%_idx_4216"></a><a name="%_idx_4218" id="%_idx_4218"></a>The metacircular evaluator is essentially a Scheme formulation of theenvironment model of evaluation described insection <a href="book-Z-H-21.html#%_sec_3.2">3.2</a>.  Recall that the model has twobasic parts:</p>
<p></p>
<blockquote><p>1. To evaluate a combination (a compound expression other than aspecial form), evaluate the subexpressions and then apply the value ofthe operator subexpression to the values of the operandsubexpressions.</p>
<p></p>
<p>2. To apply a compound procedure to a set of arguments, evaluate thebody of the procedure in a new environment.  To construct thisenvironment, extend the environment part of the procedure object by aframe in which the formal parameters of the procedure are bound to thearguments to which the procedure is applied.</p>
</blockquote>
<p><a name="%_idx_4220" id="%_idx_4220"></a>These two rules describe the essence of the evaluation process, abasic cycle in which expressions to be evaluated in environments arereduced to procedures to be applied to arguments, which in turn arereduced to new expressions to be evaluated in new environments, and soon, until we get down to symbols, whose values are lookedup in the environment, and to primitive procedures, which are applieddirectly (see figure <a href="#%_fig_4.1">4.1</a>).<a name="call_footnote_Temp_511" href="#footnote_Temp_511" id="call_footnote_Temp_511"><sup><small>4</small></sup></a>This evaluation cycle will be embodied by the interplay between the twocritical procedures in the evaluator, <code>eval</code> and <code>apply</code>,which are described in section <a href="#%_sec_4.1.1">4.1.1</a>(see figure <a href="#%_fig_4.1">4.1</a>).</p>
<p>The implementation of the evaluator will depend upon procedures thatdefine the <em>syntax</em> of the expressions to be evaluated.  We willuse <a name="%_idx_4224" id="%_idx_4224"></a>data abstraction to make the evaluator independent of therepresentation of the language.  For example, rather than committingto a choice that an assignment is to be represented by a listbeginning with the symbol <code>set!</code> we use an abstract predicate<code>assignment?</code> to test for an assignment, and we use abstractselectors <code>assignment-variable</code> and <code>assignment-value</code> toaccess the parts of an assignment.  Implementation of expressions willbe described in detail in section <a href="#%_sec_4.1.2">4.1.2</a>.There are also operations, described insection <a href="#%_sec_4.1.3">4.1.3</a>, that specify therepresentation of procedures and environments.  For example, <code>make-procedure</code> constructs compound procedures, <code>lookup-variable-value</code> accesses the values of variables, and <code>apply-primitive-procedure</code> applies a primitive procedure to a given listof arguments.</p>
<p><a name="%_sec_4.1.1" id="%_sec_4.1.1"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_4.1.1">4.1.1  The Core of the Evaluator</a></h3>
<p><a name="%_idx_4226" id="%_idx_4226"></a><a name="%_fig_4.1" id="%_fig_4.1"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch4-Z-G-1.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 4.1:</b>  The <code>eval</code>-<code>apply</code> cycle exposes the essenceof a computer language.</div></caption>
<tr><td><a name="%_idx_4228" id="%_idx_4228"></a></td></tr>
</table></div>
<p></p>
<p>The evaluation process can be described as the interplay between twoprocedures: <code>eval</code> and <code>apply</code>.</p>
<p><a name="%_sec_Temp_512" id="%_sec_Temp_512"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_512">Eval</a></h4>
<p><a name="%_idx_4230" id="%_idx_4230"></a><code>Eval</code> takes as arguments an expression and an environment.  Itclassifies the expression and directs its evaluation.  <code>Eval</code> isstructured as a case analysis of the syntactic type of the expressionto be evaluated.  In order to keep the procedure general, we expressthe determination of the type of an expression abstractly, making nocommitment to any particular <a name="%_idx_4232" id="%_idx_4232"></a>representation for the various types ofexpressions.  Each type of expression has a predicate that tests forit and an abstract means for selecting its parts.  This <a name="%_idx_4234" id="%_idx_4234"></a><a name="%_idx_4236" id="%_idx_4236"></a><em>abstractsyntax</em> makes it easy to see how we can change the syntax of thelanguage by using the same evaluator, but with a different collection ofsyntax procedures.</p>
<p><a name="%_sec_Temp_513" id="%_sec_Temp_513"></a></p>
<h5><a href="book-Z-H-4.html#%_toc_%_sec_Temp_513">Primitive expressions</a></h5>
<p></p>
<p></p>
<ul>
<li>
<a name="%_idx_4238" id="%_idx_4238"></a><a name="%_idx_4240" id="%_idx_4240"></a>For self-evaluating expressions, such as numbers, <code>eval</code> returnsthe expression itself.<p></p>
</li>
<li>
<code>Eval</code> must look up variables in the environment to find their values.</li>
</ul>
<p></p>
<p><a name="%_sec_Temp_514" id="%_sec_Temp_514"></a></p>
<h5><a href="book-Z-H-4.html#%_toc_%_sec_Temp_514">Special forms</a></h5>
<p></p>
<p></p>
<ul>
<p></p>
<li>For quoted expressions, <code>eval</code> returns the expression that wasquoted.<p></p>
</li>
<li>An assignment to (or a definition of) a variable must recursively call<code>eval</code> to compute the new value to be associated with thevariable.  The environment must be modified to change (or create) thebinding of the variable.<p></p>
</li>
<li>An <code>if</code> expression requires special processing of its parts, so as toevaluate the consequent if the predicate is true, and otherwise toevaluate the alternative.<p></p>
</li>
<li>A <code>lambda</code> expression must be transformed into anapplicable procedure by packaging together the parameters and bodyspecified by the <code>lambda</code> expression with the environment of theevaluation.<p></p>
</li>
<li>A <code>begin</code> expression requires evaluating its sequence ofexpressions in the order in which they appear.<p></p>
</li>
<li>A case analysis (<code>cond</code>) is transformed into a nest of <code>if</code>expressions and then evaluated.</li>
</ul>
<p></p>
<p><a name="%_sec_Temp_515" id="%_sec_Temp_515"></a></p>
<h5><a href="book-Z-H-4.html#%_toc_%_sec_Temp_515">Combinations</a></h5>
<p></p>
<p></p>
<ul><li>For a procedure application, <code>eval</code> must recursivelyevaluate the operator part and the operands of the combination.  Theresulting procedure and arguments are passed to <code>apply</code>, whichhandles the actual procedure application.</li></ul>
<p></p>
<p></p>
<p></p>
<p><a name="%_idx_4242" id="%_idx_4242"></a>Here is the definition of <code>eval</code>:</p>
<p></p>
<p></p>
<p><pre>(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp) 
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (eval (cond-&gt;if exp) env))
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type -- EVAL" exp))))
</pre></p>
<p></p>
<p></p>
<p><a name="%_idx_4244" id="%_idx_4244"></a><a name="%_idx_4246" id="%_idx_4246"></a>For clarity, <code>eval</code> has been implemented as a case analysis using<code>cond</code>.  The disadvantage of this is that our procedure handlesonly a few distinguishable types of expressions, and no new ones canbe defined without editing the definition of <code>eval</code>.  In most Lispimplementations, dispatching on the type of an expression is done in adata-directed style.  This allows a user to add new types ofexpressions that <code>eval</code> can distinguish, without modifying thedefinition of <code>eval</code> itself.(See exercise <a href="#%_thm_4.3">4.3</a>.)</p>
<p><a name="%_sec_Temp_516" id="%_sec_Temp_516"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_516">Apply</a></h4>
<p><code>Apply</code> takes two arguments, a procedure and a list of argumentsto which the procedure should be applied.  <code>Apply</code> classifiesprocedures into two kinds: It calls <a name="%_idx_4248" id="%_idx_4248"></a><code>apply-primitive-procedure</code> to apply primitives; it applies compoundprocedures by sequentially evaluating the expressions thatmake up the body of the procedure.  The environment for theevaluation of the body of a compound procedureis constructed by extending the base environment carried bythe procedure to include a frame that binds the parameters of theprocedure to the arguments to which the procedure is to be applied.Here is the definition of <code>apply</code>:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4250" id="%_idx_4250"></a>(define (apply procedure arguments)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure procedure arguments))
        ((compound-procedure? procedure)
         (eval-sequence
           (procedure-body procedure)
           (extend-environment
             (procedure-parameters procedure)
             arguments
             (procedure-environment procedure))))
        (else
         (error
          "Unknown procedure type -- APPLY" procedure))))
</pre></p>
<p></p>
<p></p>
<p><a name="%_sec_Temp_517" id="%_sec_Temp_517"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_517">Procedure arguments</a></h4>
<p>When <code>eval</code> processes aprocedure application, it uses <code>list-of-values</code> to produce thelist of arguments to which the procedure is to be applied. <code>List-of-values</code> takes as an argument the operands of the combination.It evaluates each operand and returns a list of the correspondingvalues:<a name="call_footnote_Temp_518" href="#footnote_Temp_518" id="call_footnote_Temp_518"><sup><small>5</small></sup></a></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4256" id="%_idx_4256"></a>(define (list-of-values exps env)
  (if (no-operands? exps)
      '()
      (cons (eval (first-operand exps) env)
            (list-of-values (rest-operands exps) env))))
</pre></p>
<p></p>
<p></p>
<p><a name="%_sec_Temp_519" id="%_sec_Temp_519"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_519">Conditionals</a></h4>
<p><code>Eval-if</code> evaluates the predicate part of an <code>if</code> expressionin the given environment.  Ifthe result is true, <code>eval-if</code> evaluates the consequent, otherwiseit evaluates the alternative:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4258" id="%_idx_4258"></a>(define (eval-if exp env)
  (if (true? (eval (if-predicate exp) env))
      (eval (if-consequent exp) env)
      (eval (if-alternative exp) env)))
</pre></p>
<p></p>
<p></p>
<p><a name="%_idx_4260" id="%_idx_4260"></a>The use of <code>true?</code> in <code>eval-if</code> highlights the issue of theconnection between an implemented language and an implementationlanguage.  The <code>if-predicate</code> is evaluated in the language beingimplemented and thus yields a value in that language.  The interpreterpredicate <code>true?</code> translates that value into a value that can betested by the <code>if</code> in the implementation language: Themetacircular representation of truth might not be the same as that ofthe underlying Scheme.<a name="call_footnote_Temp_520" href="#footnote_Temp_520" id="call_footnote_Temp_520"><sup><small>6</small></sup></a></p>
<p><a name="%_sec_Temp_521" id="%_sec_Temp_521"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_521">Sequences</a></h4>
<p><code>Eval-sequence</code> is used by <code>apply</code> to evaluate the sequence ofexpressions in a procedure body and by <code>eval</code> to evaluate thesequence of expressions in a <code>begin</code>expression.  It takes as arguments a sequence of expressions and anenvironment, and evaluates the expressions in the order in which theyoccur.  The value returned is the value of the final expression.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4264" id="%_idx_4264"></a>(define (eval-sequence exps env)
  (cond ((last-exp? exps) (eval (first-exp exps) env))
        (else (eval (first-exp exps) env)
              (eval-sequence (rest-exps exps) env))))
</pre></p>
<p></p>
<p></p>
<p><a name="%_sec_Temp_522" id="%_sec_Temp_522"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_522">Assignments and definitions</a></h4>
<p>The following procedure handles assignments to variables.  It calls<code>eval</code> to find the value to be assigned and transmits the variableand the resulting value to <code>set-variable-value!</code> to be installedin the designated environment.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4266" id="%_idx_4266"></a>(define (eval-assignment exp env)
  (set-variable-value! (assignment-variable exp)
                       (eval (assignment-value exp) env)
                       env)
  'ok)
</pre></p>
<p></p>
<p>Definitions of variables are handled in a similarmanner.<a name="call_footnote_Temp_523" href="#footnote_Temp_523" id="call_footnote_Temp_523"><sup><small>7</small></sup></a></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4268" id="%_idx_4268"></a>(define (eval-definition exp env)
  (define-variable! (definition-variable exp)
                    (eval (definition-value exp) env)
                    env)
  'ok)
</pre></p>
<p></p>
<p>We have chosen here to return the symbol <code>ok</code> as the valueof an assignment or a definition.<a name="call_footnote_Temp_524" href="#footnote_Temp_524" id="call_footnote_Temp_524"><sup><small>8</small></sup></a></p>
<p></p>
<p><a name="%_thm_4.1" id="%_thm_4.1"></a><b>Exercise 4.1.</b>  <a name="%_idx_4270" id="%_idx_4270"></a><a name="%_idx_4272" id="%_idx_4272"></a>Notice that we cannot tell whether the metacircular evaluatorevaluates operands from left to right or from right to left.  Its evaluationorder is inherited from the underlying Lisp:If the arguments to <code>cons</code> in <code>list-of-values</code>are evaluated from left to right, then <code>list-of-values</code> willevaluate operands from left to right; andif the arguments to <code>cons</code>are evaluated from right to left, then <code>list-of-values</code> willevaluate operands from right to left.</p>
<p>Write a version of <code>list-of-values</code> that evaluates operandsfrom left to right regardless of the order of evaluation in the underlyingLisp.  Also write a version of <code>list-of-values</code> that evaluates operandsfrom right to left.</p>
<p></p>
<p><a name="%_sec_4.1.2" id="%_sec_4.1.2"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_4.1.2">4.1.2  Representing Expressions</a></h3>
<p><a name="%_idx_4274" id="%_idx_4274"></a><a name="%_idx_4276" id="%_idx_4276"></a><a name="%_idx_4278" id="%_idx_4278"></a>The evaluator is reminiscent of the symbolic differentiation programdiscussed in section <a href="book-Z-H-16.html#%_sec_2.3.2">2.3.2</a>.  Bothprograms operate on symbolic expressions.  In both programs, theresult of operating on a compound expression is determined byoperating recursively on the pieces of the expression and combiningthe results in a way that depends on the type of the expression.  Inboth programs we used <a name="%_idx_4280" id="%_idx_4280"></a>data abstraction to decouple the general rulesof operation from the details of how expressions are represented.  Inthe differentiation program this meant that the same differentiationprocedure could deal with algebraic expressions in prefix form, ininfix form, or in some other form.  For the evaluator, this means thatthe syntax of the language being evaluated is determined solely by theprocedures that classify and extract pieces of expressions.</p>
<p></p>
<p></p>
<p>Here is the specification of the syntax of our language:</p>
<p></p>
<p></p>
<p>¤ The only self-evaluating items are numbers andstrings:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4282" id="%_idx_4282"></a>(define (self-evaluating? exp)
  (cond ((number? exp) true)
        ((string? exp) true)
        (else false)))
</pre></p>
<p></p>
<p>¤ Variables are represented by symbols:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4284" id="%_idx_4284"></a>(define (variable? exp) (symbol? exp))
</pre></p>
<p></p>
<p>¤ Quotations have the form <code>(quote&lt;<em>text-of-quotation</em>&gt;)</code>:<a name="call_footnote_Temp_526" href="#footnote_Temp_526" id="call_footnote_Temp_526"><sup><small>9</small></sup></a></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4286" id="%_idx_4286"></a>(define (quoted? exp)
  (tagged-list? exp 'quote))

<a name="%_idx_4288" id="%_idx_4288"></a>(define (text-of-quotation exp) (cadr exp))
</pre></p>
<p></p>
<p><code>Quoted?</code> is defined in terms of the procedure <code>tagged-list?</code>, which identifies lists beginning with a designatedsymbol:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4290" id="%_idx_4290"></a>(define (tagged-list? exp tag)
  (if (pair? exp)
      (eq? (car exp) tag)
      false))
</pre></p>
<p></p>
<p>¤ Assignments have the form <code>(set!&lt;<em>var</em>&gt; &lt;<em>value</em>&gt;)</code>:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4292" id="%_idx_4292"></a>(define (assignment? exp)
  (tagged-list? exp 'set!))
<a name="%_idx_4294" id="%_idx_4294"></a>(define (assignment-variable exp) (cadr exp))
<a name="%_idx_4296" id="%_idx_4296"></a>(define (assignment-value exp) (caddr exp))
</pre></p>
<p></p>
<p>¤ Definitions have the form</p>
<p></p>
<p></p>
<p><pre>(define &lt;<em>var</em>&gt; &lt;<em>value</em>&gt;)
</pre></p>
<p></p>
<p>or the form</p>
<p></p>
<p></p>
<p><pre>(define (&lt;<em>var</em>&gt; &lt;<em>parameter<sub>1</sub></em>&gt; <code>...</code> &lt;<em>parameter<sub><em>n</em></sub></em>&gt;)
  &lt;<em>body</em>&gt;)
</pre></p>
<p></p>
<p><a name="%_idx_4298" id="%_idx_4298"></a><a name="%_idx_4300" id="%_idx_4300"></a>The latter form (standard procedure definition) is syntactic sugar for</p>
<p></p>
<p></p>
<p><pre>(define &lt;<em>var</em>&gt;
  (lambda (&lt;<em>parameter<sub>1</sub></em>&gt; <code>...</code> &lt;<em>parameter<sub><em>n</em></sub></em>&gt;)
    &lt;<em>body</em>&gt;))
</pre></p>
<p></p>
<p>The corresponding syntax procedures are the following:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4302" id="%_idx_4302"></a>(define (definition? exp)
  (tagged-list? exp 'define))
<a name="%_idx_4304" id="%_idx_4304"></a>(define (definition-variable exp)
  (if (symbol? (cadr exp))
      (cadr exp)
      (caadr exp)))
<a name="%_idx_4306" id="%_idx_4306"></a>(define (definition-value exp)
  (if (symbol? (cadr exp))
      (caddr exp)
      (make-lambda (cdadr exp)   <em>; formal parameters</em>
                   (cddr exp)))) <em>; body</em>
</pre></p>
<p></p>
<p>¤ <code>Lambda</code> expressions are lists that begin with thesymbol <code>lambda</code>:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4308" id="%_idx_4308"></a>(define (lambda? exp) (tagged-list? exp 'lambda))
<a name="%_idx_4310" id="%_idx_4310"></a>(define (lambda-parameters exp) (cadr exp))
<a name="%_idx_4312" id="%_idx_4312"></a>(define (lambda-body exp) (cddr exp))
</pre></p>
<p></p>
<p>We also provide a constructor for <code>lambda</code> expressions,which is used by <code>definition-value</code>, above:</p>
<p></p>
<p><pre><a name="%_idx_4314" id="%_idx_4314"></a>(define (make-lambda parameters body)
  (cons 'lambda (cons parameters body)))
</pre></p>
<p></p>
<p>¤ Conditionals begin with <code>if</code> and have a predicate, aconsequent, and an (optional) alternative.  If the expression has noalternative part, we provide <code>false</code> as the alternative.<a name="call_footnote_Temp_527" href="#footnote_Temp_527" id="call_footnote_Temp_527"><sup><small>10</small></sup></a></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4316" id="%_idx_4316"></a>(define (if? exp) (tagged-list? exp 'if))
<a name="%_idx_4318" id="%_idx_4318"></a>(define (if-predicate exp) (cadr exp))
<a name="%_idx_4320" id="%_idx_4320"></a>(define (if-consequent exp) (caddr exp))
<a name="%_idx_4322" id="%_idx_4322"></a>(define (if-alternative exp)
  (if (not (null? (cdddr exp)))
      (cadddr exp)
      'false))
</pre></p>
<p></p>
<p>We also provide a constructor for <code>if</code> expressions,to be used by <code>cond-&gt;if</code> to transform <code>cond</code> expressionsinto <code>if</code> expressions:</p>
<p></p>
<p><pre><a name="%_idx_4324" id="%_idx_4324"></a>(define (make-if predicate consequent alternative)
  (list 'if predicate consequent alternative))
</pre></p>
<p></p>
<p>¤ <code>Begin</code> packages a sequence of expressions into a singleexpression.  We include syntax operations on <code>begin</code> expressionsto extract the actual sequence from the <code>begin</code> expression, aswell as selectors that return the first expression and the rest of theexpressions in the sequence.<a name="call_footnote_Temp_528" href="#footnote_Temp_528" id="call_footnote_Temp_528"><sup><small>11</small></sup></a></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4326" id="%_idx_4326"></a>(define (begin? exp) (tagged-list? exp 'begin))
<a name="%_idx_4328" id="%_idx_4328"></a>(define (begin-actions exp) (cdr exp))
<a name="%_idx_4330" id="%_idx_4330"></a>(define (last-exp? seq) (null? (cdr seq)))
<a name="%_idx_4332" id="%_idx_4332"></a>(define (first-exp seq) (car seq))
<a name="%_idx_4334" id="%_idx_4334"></a>(define (rest-exps seq) (cdr seq))
</pre></p>
<p></p>
<p>We also include a constructor <code>sequence-&gt;exp</code> (for use by<code>cond-&gt;if</code>) that transforms a sequence into a single expression,using <code>begin</code> if necessary:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4336" id="%_idx_4336"></a>(define (sequence-&gt;exp seq)
  (cond ((null? seq) seq)
        ((last-exp? seq) (first-exp seq))
        (else (make-begin seq))))
<a name="%_idx_4338" id="%_idx_4338"></a>(define (make-begin seq) (cons 'begin seq))
</pre></p>
<p></p>
<p>¤ A procedure application is any compound expressionthat is not one of the above expression types.  The <code>car</code> of theexpression is the operator, and the <code>cdr</code> is the list of operands:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4340" id="%_idx_4340"></a>(define (application? exp) (pair? exp))
<a name="%_idx_4342" id="%_idx_4342"></a>(define (operator exp) (car exp))
<a name="%_idx_4344" id="%_idx_4344"></a>(define (operands exp) (cdr exp))
<a name="%_idx_4346" id="%_idx_4346"></a>(define (no-operands? ops) (null? ops))
<a name="%_idx_4348" id="%_idx_4348"></a>(define (first-operand ops) (car ops))
<a name="%_idx_4350" id="%_idx_4350"></a>(define (rest-operands ops) (cdr ops))
</pre></p>
<p></p>
<p></p>
<p><a name="%_sec_Temp_529" id="%_sec_Temp_529"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_529">Derived expressions</a></h4>
<p><a name="%_idx_4352" id="%_idx_4352"></a><a name="%_idx_4354" id="%_idx_4354"></a><a name="%_idx_4356" id="%_idx_4356"></a><a name="%_idx_4358" id="%_idx_4358"></a>Some special forms in our language can be defined in terms ofexpressions involving other special forms, rather than beingimplemented directly.  One example is <code>cond</code>, which can beimplemented as a nest of <code>if</code> expressions.  For example,we can reduce the problem of evaluating the expression</p>
<p></p>
<p></p>
<p><pre>(cond ((&gt; x 0) x)
      ((= x 0) (display 'zero) 0)
      (else (- x)))
</pre></p>
<p></p>
<p>to the problem of evaluating the followingexpression involving <code>if</code> and <code>begin</code> expressions:</p>
<p></p>
<p></p>
<p><pre>(if (&gt; x 0)
    x
    (if (= x 0)
        (begin (display 'zero)
               0)
        (- x)))
</pre></p>
<p></p>
<p>Implementing the evaluation of <code>cond</code> in this waysimplifies the evaluator because it reduces the number of specialforms for which the evaluation process must be explicitly specified.</p>
<p>We include syntax procedures that extract the parts of a <code>cond</code>expression, and a procedure <code>cond-&gt;if</code> that transforms <code>cond</code>expressions into <code>if</code> expressions.  A case analysis begins with <code>cond</code> and has a list of predicate-action clauses.  A clause is an <code>else</code> clause if its predicate is the symbol <code>else</code>.<a name="call_footnote_Temp_530" href="#footnote_Temp_530" id="call_footnote_Temp_530"><sup><small>12</small></sup></a></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4360" id="%_idx_4360"></a>(define (cond? exp) (tagged-list? exp 'cond))
<a name="%_idx_4362" id="%_idx_4362"></a>(define (cond-clauses exp) (cdr exp))
<a name="%_idx_4364" id="%_idx_4364"></a>(define (cond-else-clause? clause)
  (eq? (cond-predicate clause) 'else))
<a name="%_idx_4366" id="%_idx_4366"></a>(define (cond-predicate clause) (car clause))
<a name="%_idx_4368" id="%_idx_4368"></a>(define (cond-actions clause) (cdr clause))
<a name="%_idx_4370" id="%_idx_4370"></a>(define (cond-&gt;if exp)
  (expand-clauses (cond-clauses exp)))

<a name="%_idx_4372" id="%_idx_4372"></a>(define (expand-clauses clauses)
  (if (null? clauses)
      'false                          <em>; no <code>else</code> clause</em>
      (let ((first (car clauses))
            (rest (cdr clauses)))
        (if (cond-else-clause? first)
            (if (null? rest)
                (sequence-&gt;exp (cond-actions first))
                (error "ELSE clause isn't last -- COND-&gt;IF"
                       clauses))
            (make-if (cond-predicate first)
                     (sequence-&gt;exp (cond-actions first))
                     (expand-clauses rest))))))
</pre></p>
<p></p>
<p></p>
<p>Expressions (such as <code>cond</code>) that we choose to implement as syntactictransformations are called <em>derived expressions</em>.<code>Let</code> expressions are also derived expressions(see exercise <a href="#%_thm_4.6">4.6</a>).<a name="call_footnote_Temp_531" href="#footnote_Temp_531" id="call_footnote_Temp_531"><sup><small>13</small></sup></a></p>
<p></p>
<p><a name="%_thm_4.2" id="%_thm_4.2"></a><b>Exercise 4.2.</b>  <a name="%_idx_4384" id="%_idx_4384"></a>Louis Reasoner plans to reorder the <code>cond</code> clausesin <code>eval</code> so that the clause for procedure applications appearsbefore the clause for assignments.  He argues that this will make theinterpreter more efficient:  Since programs usually contain moreapplications than assignments, definitions, and so on,his modified <code>eval</code> will usually check fewerclauses than the original <code>eval</code> before identifying the type of anexpression.</p>
<p></p>
<p></p>
<p>a. What is wrong with Louis's plan?  (Hint: What willLouis's evaluator do with the expression <code>(define x 3)</code>?)</p>
<p></p>
<p></p>
<p><a name="%_idx_4386" id="%_idx_4386"></a>b. Louis is upset that his plan didn't work.He is willing to go to any lengths to make his evaluatorrecognize procedure applications before it checks for most otherkinds of expressions.Help him by changing the syntax of the evaluated language so thatprocedure applications start with <code>call</code>.  For example, instead of<code>(factorial 3)</code> we will now have to write <code>(call factorial 3)</code>and instead of <code>(+ 1 2)</code> we will have to write <code>(call + 1 2)</code>.</p>
<p></p>
<p></p>
<p><a name="%_thm_4.3" id="%_thm_4.3"></a><b>Exercise 4.3.</b>  <a name="%_idx_4388" id="%_idx_4388"></a><a name="%_idx_4390" id="%_idx_4390"></a><a name="%_idx_4392" id="%_idx_4392"></a>Rewrite <code>eval</code> so that the dispatch is done in data-directedstyle.  Compare this with the data-directeddifferentiation procedure ofexercise <a href="book-Z-H-17.html#%_thm_2.73">2.73</a>.(You may use the <code>car</code> of a compound expression as thetype of the expression, as is appropriate for the syntax implementedin this section.).</p>
<p></p>
<p></p>
<p><a name="%_thm_4.4" id="%_thm_4.4"></a><b>Exercise 4.4.</b>  <a name="%_idx_4394" id="%_idx_4394"></a><a name="%_idx_4396" id="%_idx_4396"></a><a name="%_idx_4398" id="%_idx_4398"></a>Recall the definitions of the special forms <code>and</code> and <code>or</code>from chapter 1:</p>
<p></p>
<ul>
<li>
<code>and</code>: The expressions are evaluated fromleft to right.  If any expression evaluates tofalse, false is returned; any remaining expressions are notevaluated.  If all the expressions evaluate to true values, the valueof the last expression is returned.  If there are no expressions thentrue is returned.<p></p>
</li>
<li>
<code>or</code>: The expressions are evaluated from left to right.  If anyexpression evaluates to a true value, that value isreturned; any remaining expressions are not evaluated.  If allexpressions evaluate to false, or if there are no expressions,then false is returned.</li>
</ul>
<p>Install <code>and</code> and <code>or</code> as new special forms for the evaluatorby defining appropriate syntax procedures and evaluationprocedures <code>eval-and</code> and <code>eval-or</code>.  Alternatively, show howto implement <code>and</code> and <code>or</code> as derived expressions.</p>
<p></p>
<p></p>
<p><a name="%_thm_4.5" id="%_thm_4.5"></a><b>Exercise 4.5.</b>  <a name="%_idx_4400" id="%_idx_4400"></a><a name="%_idx_4402" id="%_idx_4402"></a><a name="%_idx_4404" id="%_idx_4404"></a>Scheme allows an additional syntax for <code>cond</code> clauses, <code>(&lt;<em>test</em>&gt; =&gt; &lt;<em>recipient</em>&gt;)</code>.  If &lt;<em>test</em>&gt;evaluates to a true value, then &lt;<em>recipient</em>&gt; is evaluated.  Itsvalue must be a procedure of one argument; this procedure is theninvoked on the value of the &lt;<em>test</em>&gt;, and the result is returned asthe value of the <code>cond</code> expression.  For example</p>
<p></p>
<p></p>
<p><pre>(cond ((assoc 'b '((a 1) (b 2))) =&gt; cadr)
      (else false))
</pre></p>
<p></p>
<p>returns 2.Modify the handling of <code>cond</code> so that it supports this extendedsyntax.</p>
<p></p>
<p></p>
<p><a name="%_thm_4.6" id="%_thm_4.6"></a><b>Exercise 4.6.</b>  <a name="%_idx_4406" id="%_idx_4406"></a><code>Let</code> expressions are derived expressions, because</p>
<p></p>
<p></p>
<p><pre>(let ((&lt;<em>var<sub>1</sub></em>&gt; &lt;<em>exp<sub>1</sub></em>&gt;) <code>...</code> (&lt;<em>var<sub><em>n</em></sub></em>&gt; &lt;<em>exp<sub><em>n</em></sub></em>&gt;))
  &lt;<em>body</em>&gt;)
</pre></p>
<p></p>
<p>is equivalent to</p>
<p></p>
<p></p>
<p><pre>((lambda (&lt;<em>var<sub>1</sub></em>&gt; <code>...</code> &lt;<em>var<sub><em>n</em></sub></em>&gt;)
   &lt;<em>body</em>&gt;)
 &lt;<em>exp<sub>1</sub></em>&gt;
 ⋮
 &lt;<em>exp<sub><em>n</em></sub></em>&gt;)
</pre></p>
<p></p>
<p>Implement a syntactic transformation <code>let-&gt;combination</code> thatreduces evaluating <code>let</code> expressions to evaluating combinations ofthe type shown above, and add the appropriate clause to <code>eval</code> tohandle <code>let</code> expressions.</p>
<p></p>
<p></p>
<p><a name="%_thm_4.7" id="%_thm_4.7"></a><b>Exercise 4.7.</b>  <a name="%_idx_4408" id="%_idx_4408"></a><a name="%_idx_4410" id="%_idx_4410"></a><a name="%_idx_4412" id="%_idx_4412"></a><code>Let*</code> is similar to <code>let</code>, except that the bindings of the <code>let</code> variables are performed sequentially from left to right, and eachbinding is made in an environment in which all of the precedingbindings are visible.  For example</p>
<p></p>
<p><pre>(let* ((x 3)
       (y (+ x 2))
       (z (+ x y 5)))
  (* x z))
</pre></p>
<p></p>
<p>returns 39.  Explain how a <code>let*</code> expression can be rewritten as aset of nested <code>let</code> expressions, and write a procedure <code>let*-&gt;nested-lets</code> that performs this transformation.  If wehave already implemented <code>let</code> (exercise <a href="#%_thm_4.6">4.6</a>)and we want toextend the evaluator to handle <code>let*</code>, is it sufficient to adda clause to <code>eval</code> whose action is</p>
<p></p>
<p><pre>(eval (let*-&gt;nested-lets exp) env)
</pre></p>
<p></p>
<p>or must weexplicitly expand <code>let*</code> in terms of non-derived expressions?</p>
<p></p>
<p></p>
<p><a name="%_thm_4.8" id="%_thm_4.8"></a><b>Exercise 4.8.</b>  <a name="%_idx_4414" id="%_idx_4414"></a><a name="%_idx_4416" id="%_idx_4416"></a><a name="%_idx_4418" id="%_idx_4418"></a><a name="%_idx_4420" id="%_idx_4420"></a>“Named <code>let</code>” is a variant of <code>let</code> that has the form</p>
<p></p>
<p><pre>(let &lt;<em>var</em>&gt; &lt;<em>bindings</em>&gt; &lt;<em>body</em>&gt;)
</pre></p>
<p></p>
<p>The &lt;<em>bindings</em>&gt; and &lt;<em>body</em>&gt; are just as in ordinary <code>let</code>, except that &lt;<em>var</em>&gt; is bound within &lt;<em>body</em>&gt; to aprocedure whose body is &lt;<em>body</em>&gt; and whose parameters are thevariables in the &lt;<em>bindings</em>&gt;.  Thus, one can repeatedly execute the&lt;<em>body</em>&gt; by invoking the procedure named &lt;<em>var</em>&gt;.  For example,the iterative Fibonacci procedure (section <a href="book-Z-H-11.html#%_sec_1.2.2">1.2.2</a>)can be rewritten using named <code>let</code> as follows:</p>
<p></p>
<p><pre><a name="%_idx_4422" id="%_idx_4422"></a>(define (fib n)
  (let fib-iter ((a 1)
                 (b 0)
                 (count n))
    (if (= count 0)
        b
        (fib-iter (+ a b) a (- count 1)))))
</pre></p>
<p></p>
<p>Modify <code>let-&gt;combination</code> of exercise <a href="#%_thm_4.6">4.6</a> toalso support named <code>let</code>.</p>
<p></p>
<p></p>
<p><a name="%_thm_4.9" id="%_thm_4.9"></a><b>Exercise 4.9.</b>  <a name="%_idx_4424" id="%_idx_4424"></a><a name="%_idx_4426" id="%_idx_4426"></a>Many languages support a variety of iteration constructs, such as <code>do</code>, <code>for</code>, <code>while</code>, and <code>until</code>.  In Scheme,iterative processes can be expressed in terms of ordinary procedurecalls, so special iteration constructs provide no essential gain incomputational power.  On the other hand, such constructs are oftenconvenient.  Design some iteration constructs, give examples of theiruse, and show how to implement them as derived expressions.</p>
<p></p>
<p></p>
<p><a name="%_thm_4.10" id="%_thm_4.10"></a><b>Exercise 4.10.</b>  <a name="%_idx_4428" id="%_idx_4428"></a><a name="%_idx_4430" id="%_idx_4430"></a>By using data abstraction, we were able to write an <code>eval</code>procedure that is independent of the particular syntax of the languageto be evaluated.  To illustrate this, design and implement a newsyntax for Scheme by modifying the procedures in this section, withoutchanging <code>eval</code> or <code>apply</code>.</p>
<p></p>
<p><a name="%_sec_4.1.3" id="%_sec_4.1.3"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_4.1.3">4.1.3  Evaluator Data Structures</a></h3>
<p></p>
<p>In addition to defining the external syntax of expressions, theevaluator implementation must also define the data structures that theevaluator manipulates internally, as part of the execution of aprogram, such as the representation of procedures and environments andthe representation of true and false.</p>
<p><a name="%_sec_Temp_541" id="%_sec_Temp_541"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_541">Testing of predicates</a></h4>
<p><a name="%_idx_4432" id="%_idx_4432"></a>For conditionals, we accept anything to be true that is notthe explicit <code>false</code> object.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4434" id="%_idx_4434"></a>(define (true? x)
  (not (eq? x false)))
<a name="%_idx_4436" id="%_idx_4436"></a>(define (false? x)
  (eq? x false))
</pre></p>
<p></p>
<p></p>
<p><a name="%_sec_Temp_542" id="%_sec_Temp_542"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_542">Representing procedures</a></h4>
<p><a name="%_idx_4438" id="%_idx_4438"></a>To handle primitives, we assume that we have available thefollowing procedures:</p>
<p></p>
<p></p>
<ul>
<li>
<a name="%_idx_4440" id="%_idx_4440"></a><code>(apply-primitive-procedure &lt;<em>proc</em>&gt; &lt;<em>args</em>&gt;)</code>
applies the given primitive procedure to the argument values in thelist &lt;<em>args</em>&gt; and returns the result of the application.<p></p>
</li>
<li>
<a name="%_idx_4442" id="%_idx_4442"></a><code>(primitive-procedure? &lt;<em>proc</em>&gt;)</code>
tests whether &lt;<em>proc</em>&gt; is a primitive procedure.</li>
</ul>
<p></p>
<p>These mechanisms for handling primitives are further described insection <a href="#%_sec_4.1.4">4.1.4</a>.</p>
<p>Compound procedures are constructed from parameters, procedurebodies, and environments using the constructor <code>make-procedure</code>:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4444" id="%_idx_4444"></a>(define (make-procedure parameters body env)
  (list 'procedure parameters body env))
<a name="%_idx_4446" id="%_idx_4446"></a>(define (compound-procedure? p)
  (tagged-list? p 'procedure))
<a name="%_idx_4448" id="%_idx_4448"></a>(define (procedure-parameters p) (cadr p))
<a name="%_idx_4450" id="%_idx_4450"></a>(define (procedure-body p) (caddr p))
<a name="%_idx_4452" id="%_idx_4452"></a>(define (procedure-environment p) (cadddr p))
</pre></p>
<p></p>
<p></p>
<p><a name="%_sec_Temp_543" id="%_sec_Temp_543"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_543">Operations on Environments</a></h4>
<p><a name="%_idx_4454" id="%_idx_4454"></a>The evaluator needs operations for manipulating environments.  Asexplained in section <a href="book-Z-H-21.html#%_sec_3.2">3.2</a>, an environment is asequence of frames, where each frame is a table of bindings thatassociate variables with their corresponding values.  We usethe following operations for manipulating environments:</p>
<p></p>
<p></p>
<ul>
<a name="%_idx_4456" id="%_idx_4456"></a><li>
<code>(lookup-variable-value &lt;<em>var</em>&gt; &lt;<em>env</em>&gt;)</code>
returns the value that is bound to the symbol &lt;<em>var</em>&gt; in theenvironment &lt;<em>env</em>&gt;, or signals an error if the variable is unbound.<p></p>
</li>
<li>
<a name="%_idx_4458" id="%_idx_4458"></a><code>(extend-environment &lt;<em>variables</em>&gt; &lt;<em>values</em>&gt; &lt;<em>base-env</em>&gt;)</code>
returns a new environment, consisting of a new frame in which thesymbols in the list &lt;<em>variables</em>&gt; are bound to the correspondingelements in the list &lt;<em>values</em>&gt;, where the enclosing environment isthe environment &lt;<em>base-env</em>&gt;.<p></p>
</li>
<li>
<a name="%_idx_4460" id="%_idx_4460"></a><code>(define-variable! &lt;<em>var</em>&gt; &lt;<em>value</em>&gt; &lt;<em>env</em>&gt;)</code>
adds to the first frame in the environment &lt;<em>env</em>&gt; a new binding thatassociates the variable &lt;<em>var</em>&gt; with the value &lt;<em>value</em>&gt;.<p></p>
</li>
<li>
<a name="%_idx_4462" id="%_idx_4462"></a><code>(set-variable-value! &lt;<em>var</em>&gt; &lt;<em>value</em>&gt; &lt;<em>env</em>&gt;)</code>
changes the binding of the variable &lt;<em>var</em>&gt; in the environment &lt;<em>env</em>&gt;so that the variable is now bound to the value &lt;<em>value</em>&gt;, or signalsan error if the variable is unbound.</li>
</ul>
<p></p>
<p><a name="%_idx_4464" id="%_idx_4464"></a>To implement these operations we represent an environment as a list offrames.  The enclosing environment of an environment is the <code>cdr</code> ofthe list.  The empty environment is simply the empty list.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4466" id="%_idx_4466"></a>(define (enclosing-environment env) (cdr env))
<a name="%_idx_4468" id="%_idx_4468"></a>(define (first-frame env) (car env))
(define the-empty-environment '())
</pre></p>
<p></p>
<p>Each frame of an environment is represented as a pair of lists: a listof the variables bound in that frame and a list of the associated values.<a name="call_footnote_Temp_544" href="#footnote_Temp_544" id="call_footnote_Temp_544"><sup><small>14</small></sup></a></p>
<p></p>
<p><pre><a name="%_idx_4470" id="%_idx_4470"></a>(define (make-frame variables values)
  (cons variables values))
<a name="%_idx_4472" id="%_idx_4472"></a>(define (frame-variables frame) (car frame))
<a name="%_idx_4474" id="%_idx_4474"></a>(define (frame-values frame) (cdr frame))
<a name="%_idx_4476" id="%_idx_4476"></a>(define (add-binding-to-frame! var val frame)
  (set-car! frame (cons var (car frame)))
  (set-cdr! frame (cons val (cdr frame))))
</pre></p>
<p></p>
<p></p>
<p>To extend an environment by a new frame that associates variables withvalues, we make a frame consisting of the list of variables and thelist of values, and we adjoin this to the environment.  We signalan error if the number of variables does not match the number of values.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4478" id="%_idx_4478"></a>(define (extend-environment vars vals base-env)
  (if (= (length vars) (length vals))
      (cons (make-frame vars vals) base-env)
      (if (&lt; (length vars) (length vals))
          (error "Too many arguments supplied" vars vals)
          (error "Too few arguments supplied" vars vals))))
</pre></p>
<p></p>
<p></p>
<p>To look up a variable in an environment, we scan the list of variablesin the first frame.  If we find the desired variable, we returnthe corresponding element in the list of values.  If we do not findthe variable in the current frame, we search the enclosing environment,and so on.  If we reach the empty environment, we signal an “unboundvariable” error.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4480" id="%_idx_4480"></a>(define (lookup-variable-value var env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (car vals))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))
</pre></p>
<p></p>
<p></p>
<p>To set a variable to a new value in a specified environment, we scanfor the variable, just as in <code>lookup-variable-value</code>, and changethe corresponding value when we find it.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4482" id="%_idx_4482"></a>(define (set-variable-value! var val env)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable -- SET!" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env))
</pre></p>
<p></p>
<p></p>
<p>To define a variable, we search the first frame for a binding forthe variable, and change the binding if it exists(just as in <code>set-variable-value!</code>).  If no such bindingexists, we adjoin one to the first frame.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4484" id="%_idx_4484"></a>(define (define-variable! var val env)
  (let ((frame (first-frame env)))
    (define (scan vars vals)
      (cond ((null? vars)
             (add-binding-to-frame! var val frame))
            ((eq? var (car vars))
             (set-car! vals val))
            (else (scan (cdr vars) (cdr vals)))))
    (scan (frame-variables frame)
          (frame-values frame))))
</pre></p>
<p></p>
<p></p>
<p><a name="%_idx_4486" id="%_idx_4486"></a>The method described here is only one of many plausible ways torepresent environments.  Since we used data abstraction to isolate therest of the evaluator from the detailed choice of representation, wecould change the environment representation if we wanted to.  (Seeexercise <a href="#%_thm_4.11">4.11</a>.)  In aproduction-quality Lisp system, the speed of the evaluator'senvironment operations – especially that of variable lookup – has amajor impact on the performance of the system.  The representationdescribed here, although conceptually simple, is not efficient andwould not ordinarily be used in a production system.<a name="call_footnote_Temp_545" href="#footnote_Temp_545" id="call_footnote_Temp_545"><sup><small>15</small></sup></a></p>
<p></p>
<p><a name="%_thm_4.11" id="%_thm_4.11"></a><b>Exercise 4.11.</b>  Instead of representing a frame as a pair of lists, we can represent aframe as a list of bindings, where each binding is a name-value pair.Rewrite the environment operations to use this alternativerepresentation.</p>
<p></p>
<p></p>
<p><a name="%_thm_4.12" id="%_thm_4.12"></a><b>Exercise 4.12.</b>  The procedures <code>set-variable-value!</code>, <code>define-variable!</code>,and <code>lookup-variable-value</code> can be expressed in terms ofmore abstract procedures for traversing the environment structure.Define abstractions that capture the common patterns and redefinethe three procedures in terms of these abstractions.</p>
<p></p>
<p></p>
<p><a name="%_thm_4.13" id="%_thm_4.13"></a><b>Exercise 4.13.</b>  Scheme allows us to create new bindings for variables by means of <code>define</code>, but provides no way to get rid of bindings.  Implement forthe evaluator a special form <code>make-unbound!</code> that removes thebinding of a given symbol from the environment in which the<code>make-unbound!</code> expression is evaluated.This problem is not completely specified.  For example,should we remove only the binding in the first frame of theenvironment?  Complete the specification and justify any choices youmake.</p>
<p></p>
<p><a name="%_sec_4.1.4" id="%_sec_4.1.4"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_4.1.4">4.1.4  Running the Evaluator as a Program</a></h3>
<p><a name="%_idx_4492" id="%_idx_4492"></a>Given the evaluator, we have in our hands a description(expressed in Lisp) of the processby which Lisp expressions are evaluated.  One advantage of expressing theevaluator as a program is that we can run the program.  This gives us,running within Lisp, a working model of how Lisp itself evaluatesexpressions.  This can serve as a framework for experimenting withevaluation rules, as we shall do later in this chapter.</p>
<p><a name="%_idx_4494" id="%_idx_4494"></a>Our evaluator program reduces expressions ultimately to theapplication of primitive procedures.  Therefore, all that we need torun the evaluator is to create a mechanism that calls on the underlyingLisp system to model the application of primitive procedures.</p>
<p>There must be a binding for each primitive procedure name, so that when<code>eval</code> evaluates the operator of an application of a primitive, itwill find an object to pass to <code>apply</code>.  We thus set up a <a name="%_idx_4496" id="%_idx_4496"></a><a name="%_idx_4498" id="%_idx_4498"></a>globalenvironment that associates unique objects with the names of theprimitive procedures that can appearin the expressions we will be evaluating.  Theglobal environment also includes bindings for the symbols <a name="%_idx_4500" id="%_idx_4500"></a><code>true</code> and<code>false</code>, so that they can be used as variables in expressionsto be evaluated.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4502" id="%_idx_4502"></a>(define (setup-environment)
  (let ((initial-env
         (extend-environment (primitive-procedure-names)
                             (primitive-procedure-objects)
                             the-empty-environment)))
    (define-variable! 'true true initial-env)
    (define-variable! 'false false initial-env)
    initial-env))
<a name="%_idx_4504" id="%_idx_4504"></a>(define the-global-environment (setup-environment))
</pre></p>
<p></p>
<p></p>
<p>It does not matter how we represent the primitive procedure objects,so long as <code>apply</code> can identify and apply them by using theprocedures <code>primitive-procedure?</code> and <code>apply-primitive-procedure</code>.  We have chosen to represent a primitiveprocedure as a list beginning with the symbol <code>primitive</code> andcontaining a procedure in the underlying Lisp that implements that primitive.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4506" id="%_idx_4506"></a>(define (primitive-procedure? proc)
  (tagged-list? proc 'primitive))

<a name="%_idx_4508" id="%_idx_4508"></a>(define (primitive-implementation proc) (cadr proc))
</pre></p>
<p></p>
<p></p>
<p><code>Setup-environment</code> will get the primitive names and implementationprocedures from a list:<a name="call_footnote_Temp_549" href="#footnote_Temp_549" id="call_footnote_Temp_549"><sup><small>16</small></sup></a></p>
<p></p>
<p></p>
<p><pre>(define primitive-procedures
  (list (list 'car car)
        (list 'cdr cdr)
        (list 'cons cons)
        (list 'null? null?)
        &lt;<em>more primitives</em>&gt;
        ))
<a name="%_idx_4510" id="%_idx_4510"></a>(define (primitive-procedure-names)
  (map car
       primitive-procedures))

(define (primitive-procedure-objects)
<a name="%_idx_4512" id="%_idx_4512"></a>  (map (lambda (proc) (list 'primitive (cadr proc)))
       primitive-procedures))
</pre></p>
<p></p>
<p></p>
<p>To apply a primitive procedure, we simply apply the implementationprocedure to the arguments, using the underlying Lisp system:<a name="call_footnote_Temp_550" href="#footnote_Temp_550" id="call_footnote_Temp_550"><sup><small>17</small></sup></a></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4514" id="%_idx_4514"></a>(define (apply-primitive-procedure proc args)
  (apply-in-underlying-scheme
   (primitive-implementation proc) args))
</pre></p>
<p></p>
<p></p>
<p><a name="%_idx_4516" id="%_idx_4516"></a><a name="%_idx_4518" id="%_idx_4518"></a>For convenience in running the metacircular evaluator, we provide a <em>driver loop</em> that models the read-eval-print loop of the underlyingLisp system.  It prints a <a name="%_idx_4520" id="%_idx_4520"></a><em>prompt</em>, reads an input expression,evaluates this expression in the global environment, and prints theresult.  We precede each printed result by an <em>output prompt</em> soas to distinguish the value of the expression from otheroutput that may be printed.<a name="call_footnote_Temp_551" href="#footnote_Temp_551" id="call_footnote_Temp_551"><sup><small>18</small></sup></a></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4530" id="%_idx_4530"></a>(define input-prompt ";;; M-Eval input:")
(define output-prompt ";;; M-Eval value:")
<a name="%_idx_4532" id="%_idx_4532"></a>(define (driver-loop)
  (prompt-for-input input-prompt)
  (let ((input (read)))
    (let ((output (eval input the-global-environment)))
      (announce-output output-prompt)
      (user-print output)))
  (driver-loop))
<a name="%_idx_4534" id="%_idx_4534"></a>(define (prompt-for-input string)
  (newline) (newline) (display string) (newline))

<a name="%_idx_4536" id="%_idx_4536"></a>(define (announce-output string)
  (newline) (display string) (newline))
</pre></p>
<p></p>
<p>We use a special printing procedure, <code>user-print</code>, to avoid printing theenvironment part of a compound procedure, which may be a very long list(or may even contain cycles).</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4538" id="%_idx_4538"></a>(define (user-print object)
  (if (compound-procedure? object)
      (display (list 'compound-procedure
                     (procedure-parameters object)
                     (procedure-body object)
                     '&lt;procedure-env&gt;))
      (display object)))
</pre></p>
<p></p>
<p></p>
<p>Now all we need to do to run the evaluator is to initialize theglobal environment and start the driver loop.  Here is a sampleinteraction:</p>
<p></p>
<p></p>
<p><pre>(define the-global-environment (setup-environment))
(driver-loop)
<i>;;; M-Eval input:</i>
(define (append x y)
  (if (null? x)
      y
      (cons (car x)
            (append (cdr x) y))))
<i>;;; M-Eval value:</i>
<i>ok</i>
<i>;;; M-Eval input:</i>
(append '(a b c) '(d e f))
<i>;;; M-Eval value:</i>
<i>(a b c d e f)</i>
</pre></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_4.14" id="%_thm_4.14"></a><b>Exercise 4.14.</b>  Eva Lu Ator and Louis Reasoner are each experimenting with themetacircular evaluator.  Eva types in the definition of <code>map</code>, andruns some test programs that use it.  They work fine.  Louis, in contrast,has installed the system version of <code>map</code> as a primitive for themetacircular evaluator.  When he tries it, things go terriblywrong.  Explain why Louis's <code>map</code> fails even though Eva's works.</p>
<p></p>
<p><a name="%_sec_4.1.5" id="%_sec_4.1.5"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_4.1.5">4.1.5  Data as Programs</a></h3>
<p><a name="%_idx_4540" id="%_idx_4540"></a><a name="%_idx_4542" id="%_idx_4542"></a>In thinking about a Lisp program that evaluates Lisp expressions, ananalogy might be helpful.  One operational view of the meaning of aprogram is that a <a name="%_idx_4544" id="%_idx_4544"></a>program is a description of an abstract (perhapsinfinitely large) machine.  For example, consider the familiarprogram to compute factorials:</p>
<p></p>
<p></p>
<p><pre>(define (factorial n)
  (if (= n 1)
      1
      (* (factorial (- n 1)) n)))
</pre></p>
<p></p>
<p><a name="%_idx_4546" id="%_idx_4546"></a>We may regard this program as the description of a machine containingparts that decrement, multiply, and test for equality, together with atwo-position switch and another factorial machine. (The factorialmachine is infinite because it contains another factorial machinewithin it.)  Figure <a href="#%_fig_4.2">4.2</a> is a flow diagram for thefactorial machine, showing how the parts are wired together.</p>
<p><a name="%_fig_4.2" id="%_fig_4.2"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch4-Z-G-2.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 4.2:</b>  The factorial program, viewed as an abstract machine.</div></caption>
<tr><td></td></tr>
</table></div>
<p>              </p>
<p><a name="%_idx_4548" id="%_idx_4548"></a>In a similar way, we can regard the evaluator as a very specialmachine that takes as input a description of a machine.  Given thisinput, the evaluator configures itself to emulate the machinedescribed.  For example, if we feed our evaluator the definition of<code>factorial</code>, as shown in figure <a href="#%_fig_4.3">4.3</a>, theevaluator will be able to compute factorials.</p>
<p><a name="%_fig_4.3" id="%_fig_4.3"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch4-Z-G-3.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 4.3:</b>  The evaluator emulating a factorial machine.</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p><a name="%_idx_4550" id="%_idx_4550"></a><a name="%_idx_4552" id="%_idx_4552"></a>From this perspective, our evaluator is seen to be a <em>universal machine</em>.It mimics other machines when these are described as Lisp programs.<a name="call_footnote_Temp_553" href="#footnote_Temp_553" id="call_footnote_Temp_553"><sup><small>19</small></sup></a>This is striking. Try to imagine an analogous evaluator for electricalcircuits.  This would be a circuit that takes as input a signalencoding the plans for some other circuit, such as a filter.  Giventhis input, the circuit evaluator would then behave like a filter withthe same description.  Such a universal electrical circuit isalmost unimaginably complex.  It is remarkable that the programevaluator is a rather simple program.<a name="call_footnote_Temp_554" href="#footnote_Temp_554" id="call_footnote_Temp_554"><sup><small>20</small></sup></a></p>
<p>Another striking aspect of the evaluator is that it acts as a bridgebetween the data objects that are manipulated by our programminglanguage and the programming language itself.  Imagine that theevaluator program (implemented in Lisp) is running, and that a user istyping expressions to the evaluator and observing the results.  Fromthe perspective of the user, an input expression such as <code>(* x x)</code>is an expression in the programming language, which the evaluatorshould execute.  From the perspective of the evaluator, however, theexpression is simply a list (in this case, a list of three symbols:<code>*</code>, <code>x</code>, and <code>x</code>) that is to be manipulated according toa well-defined set of rules.</p>
<p>That the user's programs are the evaluator's data need not be a sourceof confusion.  In fact, it is sometimes convenient to ignore thisdistinction, and to give the user the ability to explicitly evaluate adata object as a Lisp expression, by making <code>eval</code> available foruse in programs.  Many Lisp dialects provide a <a name="%_idx_4572" id="%_idx_4572"></a><a name="%_idx_4574" id="%_idx_4574"></a>primitive <code>eval</code>procedure that takes as arguments an expression and an environment andevaluates the expression relative to the environment.<a name="call_footnote_Temp_555" href="#footnote_Temp_555" id="call_footnote_Temp_555"><sup><small>21</small></sup></a>Thus,</p>
<p></p>
<p></p>
<p><pre>(eval '(* 5 5) user-initial-environment)
</pre></p>
<p></p>
<p>and</p>
<p></p>
<p><pre>(eval (cons '* (list 5 5)) user-initial-environment)
</pre></p>
<p></p>
<p>will both return 25.<a name="call_footnote_Temp_556" href="#footnote_Temp_556" id="call_footnote_Temp_556"><sup><small>22</small></sup></a></p>
<p></p>
<p><a name="%_thm_4.15" id="%_thm_4.15"></a><b>Exercise 4.15.</b>  <a name="%_idx_4588" id="%_idx_4588"></a>Given a one-argument procedure <code>p</code> and an object <code>a</code>, <code>p</code>is said to “halt” on <code>a</code> if evaluating the expression <code>(pa)</code> returns a value (as opposed to terminating with an error messageor running forever).  Show that it is impossible to write a procedure<code>halts?</code> that correctly determines whether <code>p</code> halts on <code>a</code> for any procedure <code>p</code> and object <code>a</code>.  Use the followingreasoning: If you had such a procedure <code>halts?</code>, you couldimplement the following program:</p>
<p></p>
<p><pre>(define (run-forever) (run-forever))

(define (try p)
  (if (halts? p p)
      (run-forever)
      'halted))
</pre></p>
<p></p>
<p>Now consider evaluating the expression <code>(try try)</code> and show thatany possible outcome (either halting or running forever) violates theintended behavior of <code>halts?</code>.<a name="call_footnote_Temp_558" href="#footnote_Temp_558" id="call_footnote_Temp_558"><sup><small>23</small></sup></a></p>
<p></p>
<p><a name="%_sec_4.1.6" id="%_sec_4.1.6"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_4.1.6">4.1.6  Internal Definitions</a></h3>
<p><a name="%_idx_4598" id="%_idx_4598"></a><a name="%_idx_4600" id="%_idx_4600"></a><a name="%_idx_4602" id="%_idx_4602"></a>Our environment model of evaluation and our metacircular evaluator executedefinitions in sequence, extending the environment frame onedefinition at a time.  This is particularly convenient for interactiveprogram development, in which the programmer needs to freely mix theapplication of procedures with the definition of new procedures.However, if we think carefully about the internal definitionsused to implement block structure (introduced insection <a href="book-Z-H-10.html#%_sec_1.1.8">1.1.8</a>), we will find that name-by-name extensionof the environment may not be the best way to define local variables.</p>
<p>Consider a procedure with internal definitions, such as</p>
<p></p>
<p></p>
<p><pre>(define (f x)
  (define (even? n)
    (if (= n 0)
        true
        (odd? (- n 1))))
  (define (odd? n)
    (if (= n 0)
        false
        (even? (- n 1))))
  &lt;<em>rest of body of <code>f</code></em>&gt;)
</pre></p>
<p></p>
<p>Our intention here is that the name <code>odd?</code> in the body of theprocedure <code>even?</code> should refer to the procedure <code>odd?</code> that isdefined after <code>even?</code>.  The scope of the name <code>odd?</code> is theentire body of <code>f</code>, not just the portion of the body of <code>f</code>starting at the point where the <code>define</code> for <code>odd?</code> occurs.Indeed, when we consider that <code>odd?</code> is itself defined in terms of<code>even?</code> – so that <code>even?</code> and <code>odd?</code> are mutuallyrecursive procedures – we see that the only satisfactoryinterpretation of the two <code>define</code>s is to regard them as if thenames <code>even?</code> and <code>odd?</code> were being added to the environmentsimultaneously.More generally, in block structure, the scope of a local name is theentire procedure body in which the <code>define</code> is evaluated.</p>
<p>As it happens, our interpreter will evaluate calls to <code>f</code>correctly, but for an “accidental” reason: Since the definitions ofthe internal procedures come first, no calls to these procedures willbe evaluated until all of them have been defined.  Hence, <code>odd?</code>will have been defined by the time <code>even?</code> is executed.  In fact,our sequential evaluation mechanism will give the same result as amechanism that directly implements simultaneous definition for anyprocedure in which the <a name="%_idx_4604" id="%_idx_4604"></a>internal definitions come first in a body andevaluation of the value expressions for the defined variables doesn'tactually use any of the defined variables.(For an example of a procedure that doesn't obey these restrictions,so that sequential definition isn't equivalent to simultaneous definition,see exercise <a href="#%_thm_4.19">4.19</a>.)<a name="call_footnote_Temp_559" href="#footnote_Temp_559" id="call_footnote_Temp_559"><sup><small>24</small></sup></a></p>
<p>There is, however, a simple way to treat definitions so thatinternally defined names have truly simultaneous scope – just createall local variables that will be in the current environment beforeevaluating any of the value expressions.  One way to do this is by asyntax transformation on <code>lambda</code> expressions.  Before evaluatingthe body of a <code>lambda</code> expression, we <a name="%_idx_4606" id="%_idx_4606"></a><a name="%_idx_4608" id="%_idx_4608"></a>“scan out” and eliminateall the internal definitions in the body.  The internally definedvariables will be created with a <code>let</code> and then set to theirvalues by assignment.  For example, the procedure</p>
<p></p>
<p></p>
<p><pre>(lambda &lt;<em>vars</em>&gt;
  (define u &lt;<em>e1</em>&gt;)
  (define v &lt;<em>e2</em>&gt;)
  &lt;<em>e3</em>&gt;)
</pre></p>
<p></p>
<p>would be transformed into</p>
<p></p>
<p></p>
<p><pre>(lambda &lt;<em>vars</em>&gt;
  (let ((u '*unassigned*)
        (v '*unassigned*))
    (set! u &lt;<em>e1</em>&gt;)
    (set! v &lt;<em>e2</em>&gt;)
    &lt;<em>e3</em>&gt;))
</pre></p>
<p></p>
<p>where <code>*unassigned*</code> is a special symbol that causes looking up avariable to signal an error if an attempt is made to use the value ofthe not-yet-assigned variable.</p>
<p>An alternative strategy for scanning out internal definitions is shownin exercise <a href="#%_thm_4.18">4.18</a>.  Unlike the transformationshown above, this enforces the restriction that the defined variables'values can be evaluated without using any of the variables' values.<a name="call_footnote_Temp_560" href="#footnote_Temp_560" id="call_footnote_Temp_560"><sup><small>25</small></sup></a></p>
<p></p>
<p><a name="%_thm_4.16" id="%_thm_4.16"></a><b>Exercise 4.16.</b>  In this exercise we implement the method just described forinterpreting internal definitions.We assume that the evaluator supports <code>let</code>(see exercise <a href="#%_thm_4.6">4.6</a>).</p>
<p><a name="%_idx_4612" id="%_idx_4612"></a>a.  Change <code>lookup-variable-value</code>(section <a href="#%_sec_4.1.3">4.1.3</a>) to signal an error ifthe value it finds is the symbol <code>*unassigned*</code>.</p>
<p><a name="%_idx_4614" id="%_idx_4614"></a>b.  Write a procedure <code>scan-out-defines</code> that takes aprocedure body and returns an equivalent one that has no internaldefinitions, by making the transformation described above.</p>
<p>c.  Install <code>scan-out-defines</code> in the interpreter, either in <code>make-procedure</code> or in <code>procedure-body</code> (seesection <a href="#%_sec_4.1.3">4.1.3</a>).  Which place is better?Why?</p>
<p></p>
<p></p>
<p><a name="%_thm_4.17" id="%_thm_4.17"></a><b>Exercise 4.17.</b>  Draw diagrams of the environment in effect when evaluating theexpression &lt;<em>e3</em>&gt; in the procedure in the text, comparing how thiswill be structured when definitions are interpreted sequentially withhow it will be structured if definitions are scanned out as described.Why is there an extra frame in the transformed program?  Explain whythis difference in environment structure can never make a differencein the behavior of a correct program.  Design a way to make theinterpreter implement the “simultaneous” scope rule for internaldefinitions without constructing the extra frame.</p>
<p></p>
<p></p>
<p><a name="%_thm_4.18" id="%_thm_4.18"></a><b>Exercise 4.18.</b>  Consider an alternative strategy for scanning out definitions thattranslates the example in the text to</p>
<p></p>
<p><pre>(lambda &lt;<em>vars</em>&gt;
  (let ((u '*unassigned*)
        (v '*unassigned*))
    (let ((a &lt;<em>e1</em>&gt;)
          (b &lt;<em>e2</em>&gt;))
      (set! u a)
      (set! v b))
    &lt;<em>e3</em>&gt;))
</pre></p>
<p></p>
<p>Here <code>a</code> and <code>b</code> are meant to represent new variable names,created by the interpreter, that do not appear in the user'sprogram.Consider the <code>solve</code> procedure fromsection <a href="book-Z-H-24.html#%_sec_3.5.4">3.5.4</a>:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4616" id="%_idx_4616"></a>(define (solve f y0 dt)
  (define y (integral (delay dy) y0 dt))
  (define dy (stream-map f y))
  y)
</pre></p>
<p></p>
<p>Will this procedure work if internal definitions are scanned out asshown in this exercise?  What if they are scanned out as shown in thetext?  Explain.</p>
<p></p>
<p></p>
<p><a name="%_thm_4.19" id="%_thm_4.19"></a><b>Exercise 4.19.</b>  Ben Bitdiddle, Alyssa P. Hacker, and Eva Lu Ator are arguing aboutthe desired result of evaluating the expression</p>
<p></p>
<p></p>
<p><pre>(let ((a 1))
  (define (f x)
    (define b (+ a x))
    (define a 5)
    (+ a b))
  (f 10))
</pre></p>
<p></p>
<p>Ben asserts that the result should be obtained using the sequentialrule for <code>define</code>: <code>b</code> is defined to be 11, then <code>a</code> isdefined to be 5, so the result is 16.  Alyssa objects that mutualrecursion requires the simultaneous scope rule for internal proceduredefinitions, and that it is unreasonable to treat procedure namesdifferently from other names.  Thus, she argues for the mechanismimplemented in exercise <a href="#%_thm_4.16">4.16</a>.  This would lead to<code>a</code> being unassigned at the time that the value for <code>b</code> is tobe computed.  Hence, in Alyssa's view the procedure should produce anerror.  Eva has a third opinion.  She says that if the definitions of<code>a</code> and <code>b</code> are truly meant to be simultaneous, then the value5 for <code>a</code> should be used in evaluating <code>b</code>.  Hence, in Eva'sview <code>a</code> should be 5, <code>b</code> should be 15, and the result shouldbe 20.  Which (if any) of these viewpoints do you support?  Can youdevise a way to implement internal definitions so that they behave asEva prefers?<a name="call_footnote_Temp_565" href="#footnote_Temp_565" id="call_footnote_Temp_565"><sup><small>26</small></sup></a></p>
<p></p>
<p></p>
<p><a name="%_thm_4.20" id="%_thm_4.20"></a><b>Exercise 4.20.</b>  <a name="%_idx_4618" id="%_idx_4618"></a><a name="%_idx_4620" id="%_idx_4620"></a>Because internal definitions look sequential but are actuallysimultaneous, some people prefer to avoid them entirely, and use thespecial form <code>letrec</code> instead.  <code>Letrec</code> looks like <code>let</code>,so it is not surprising that the variables it binds are boundsimultaneously and have the same scope as each other.  The sampleprocedure <code>f</code> above can be written without internal definitions,but with exactly the same meaning, as</p>
<p></p>
<p></p>
<p><pre>(define (f x)
  (letrec ((even?
            (lambda (n)
              (if (= n 0)
                  true
                  (odd? (- n 1)))))
           (odd?
            (lambda (n)
              (if (= n 0)
                  false
                  (even? (- n 1))))))
    &lt;<em>rest of body of <code>f</code></em>&gt;))
</pre></p>
<p></p>
<p><code>Letrec</code> expressions, which have the form</p>
<p></p>
<p><pre>(letrec ((&lt;<em>var<sub>1</sub></em>&gt; &lt;<em>exp<sub>1</sub></em>&gt;) <code>...</code> (&lt;<em>var<sub><em>n</em></sub></em>&gt; &lt;<em>exp<sub><em>n</em></sub></em>&gt;))
  &lt;<em>body</em>&gt;)
</pre></p>
<p></p>
<p>are a variation on <code>let</code> in which the expressions&lt;<em>exp<sub><em>k</em></sub></em>&gt; that provide the initial values for the variables &lt;<em>var<sub><em>k</em></sub></em>&gt;are evaluated in an environment that includes all the <code>letrec</code>bindings.  This permits recursion in the bindings, such as the mutualrecursion of <code>even?</code> and <code>odd?</code> in the example above, or<a name="%_idx_4622" id="%_idx_4622"></a>the evaluation of 10 factorial with</p>
<p></p>
<p></p>
<p><pre>(letrec ((fact
          (lambda (n)
            (if (= n 1)
                1
                (* n (fact (- n 1)))))))
  (fact 10))
</pre></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p>a. Implement <code>letrec</code> as a derived expression, by transforminga <code>letrec</code> expression into a <code>let</code> expression as shown inthe text above or in exercise <a href="#%_thm_4.18">4.18</a>.That is, the <code>letrec</code> variables should be created with a <code>let</code>and then be assigned their values with <code>set!</code>.</p>
<p></p>
<p></p>
<p>b. Louis Reasoner is confused by all this fuss about internaldefinitions.  The way he sees it, if you don't like to use <code>define</code> inside a procedure, you can just use <code>let</code>.  Illustratewhat is loose about his reasoning by drawing an environment diagramthat shows the environment in which the &lt;<em>rest of body of <code>f</code></em>&gt;is evaluated during evaluation of the expression <code>(f 5)</code>, with<code>f</code> defined as in this exercise.  Drawan environment diagram for the same evaluation, but with <code>let</code> inplace of <code>letrec</code> in the definition of <code>f</code>.</p>
<p></p>
<p></p>
<p><a name="%_thm_4.21" id="%_thm_4.21"></a><b>Exercise 4.21.</b>  <a name="%_idx_4624" id="%_idx_4624"></a>Amazingly, Louis's intuition in exercise <a href="#%_thm_4.20">4.20</a>is correct.  It is indeed possible to specify recursive procedureswithout using <code>letrec</code> (or even <code>define</code>), although the methodfor accomplishing this is much more subtle than Louis imagined.  Thefollowing expression computes 10 factorial by applying a recursive<a name="%_idx_4626" id="%_idx_4626"></a>factorial procedure:<a name="call_footnote_Temp_568" href="#footnote_Temp_568" id="call_footnote_Temp_568"><sup><small>27</small></sup></a></p>
<p></p>
<p><pre>((lambda (n)
   ((lambda (fact)
      (fact fact n))
    (lambda (ft k)
      (if (= k 1)
          1
          (* k (ft ft (- k 1)))))))
 10)
</pre></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p>a. Check (by evaluating the expression) that this really does computefactorials.  Devise an analogous expression for computing Fibonacci numbers.</p>
<p></p>
<p></p>
<p>b. Consider the following procedure, which includes mutually recursiveinternal definitions:</p>
<p></p>
<p><pre>(define (f x)
  (define (even? n)
    (if (= n 0)
        true
        (odd? (- n 1))))
  (define (odd? n)
    (if (= n 0)
        false
        (even? (- n 1))))
  (even? x))
</pre></p>
<p></p>
<p>Fill in the missing expressions to complete an alternative definitionof <code>f</code>, which uses neither internal definitions nor <code>letrec</code>:</p>
<p></p>
<p><pre>(define (f x)
  ((lambda (even? odd?)
     (even? even? odd? x))
   (lambda (ev? od? n)
     (if (= n 0) true (od? &lt;??&gt; &lt;??&gt; &lt;??&gt;)))
   (lambda (ev? od? n)
     (if (= n 0) false (ev? &lt;??&gt; &lt;??&gt; &lt;??&gt;)))))
</pre></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_sec_4.1.7" id="%_sec_4.1.7"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_4.1.7">4.1.7  Separating Syntactic Analysis from Execution</a></h3>
<p><a name="%_idx_4634" id="%_idx_4634"></a><a name="%_idx_4636" id="%_idx_4636"></a><a name="%_idx_4638" id="%_idx_4638"></a><a name="%_idx_4640" id="%_idx_4640"></a><a name="%_idx_4642" id="%_idx_4642"></a>The evaluator implemented above is simple, but it is veryinefficient, because the syntactic analysis of expressions is interleavedwith their execution.  Thus if a program is executed many times, itssyntax is analyzed many times.  Consider, for example, evaluating <code>(factorial 4)</code> using the following definition of <code>factorial</code>:</p>
<p></p>
<p></p>
<p><pre>(define (factorial n)
  (if (= n 1)
      1
      (* (factorial (- n 1)) n)))
</pre></p>
<p></p>
<p></p>
<p>Each time <code>factorial</code> is called, the evaluator must determine thatthe body is an <code>if</code> expression and extract the predicate.Only then can it evaluate thepredicate and dispatch on its value.  Each time it evaluates theexpression <code>(* (factorial (- n 1)) n)</code>,or the subexpressions <code>(factorial (- n 1))</code> and <code>(- n 1)</code>,the evaluator must performthe case analysis in <code>eval</code> to determine that the expression is anapplication, and must extract its operator and operands.  Thisanalysis is expensive.  Performing it repeatedly is wasteful.</p>
<p>We can transform the evaluator to be significantly more efficient byarranging things so that syntactic analysis is performed onlyonce.<a name="call_footnote_Temp_569" href="#footnote_Temp_569" id="call_footnote_Temp_569"><sup><small>28</small></sup></a> We split <code>eval</code>, which takes anexpression and an environment, into two parts.  The procedure <code>analyze</code> takes only the expression.  It performs the syntacticanalysis and returns a new procedure, the <a name="%_idx_4652" id="%_idx_4652"></a><em>execution procedure</em>, thatencapsulates the work to be done in executing the analyzedexpression.  The execution procedure takes an environment as itsargument and completes the evaluation.  This saves work because <code>analyze</code> will be called only once on an expression, while theexecution procedure may be called many times.</p>
<p>With the separation into analysis and execution, <code>eval</code> now becomes</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4654" id="%_idx_4654"></a>(define (eval exp env)
  ((analyze exp) env))
</pre></p>
<p></p>
<p></p>
<p>The result of calling <code>analyze</code> is the execution procedure tobe applied to the environment.  The <code>analyze</code> procedure isthe same case analysis as performed by the original <code>eval</code> ofsection <a href="#%_sec_4.1.1">4.1.1</a>, except that the procedures towhich we dispatch perform only analysis, not full evaluation:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4656" id="%_idx_4656"></a>(define (analyze exp)
  (cond ((self-evaluating? exp) 
         (analyze-self-evaluating exp))
        ((quoted? exp) (analyze-quoted exp))
        ((variable? exp) (analyze-variable exp))
        ((assignment? exp) (analyze-assignment exp))
        ((definition? exp) (analyze-definition exp))
        ((if? exp) (analyze-if exp))
        ((lambda? exp) (analyze-lambda exp))
        ((begin? exp) (analyze-sequence (begin-actions exp)))
        ((cond? exp) (analyze (cond-&gt;if exp)))
        ((application? exp) (analyze-application exp))
        (else
         (error "Unknown expression type -- ANALYZE" exp))))
</pre></p>
<p></p>
<p></p>
<p>Here is the simplest syntactic analysis procedure, which handlesself-evaluating expressions.  It returns an execution procedure thatignores its environment argument and just returns the expression:</p>
<p><a name="%_idx_4658" id="%_idx_4658"></a></p>
<p></p>
<p><pre>(define (analyze-self-evaluating exp)
  (lambda (env) exp))
</pre></p>
<p></p>
<p></p>
<p>For a quoted expression, we can gain a little efficiency byextracting the text of the quotation only once, in the analysis phase,rather than in the execution phase.</p>
<p></p>
<p></p>
<p><pre>(define (analyze-quoted exp)
  (let ((qval (text-of-quotation exp)))
    (lambda (env) qval)))
</pre></p>
<p></p>
<p></p>
<p>Looking up a variable value must still be done in the execution phase,since this depends upon knowing the environment.<a name="call_footnote_Temp_570" href="#footnote_Temp_570" id="call_footnote_Temp_570"><sup><small>29</small></sup></a></p>
<p></p>
<p></p>
<p><pre>(define (analyze-variable exp)
  (lambda (env) (lookup-variable-value exp env)))
</pre></p>
<p></p>
<p></p>
<p><code>Analyze-assignment</code> also must defer actually setting the variableuntil the execution, when the environment has been supplied.  However,the fact that the <code>assignment-value</code> expression can beanalyzed (recursively) during analysis is a major gain in efficiency,because the <code>assignment-value</code> expression will now be analyzedonly once.  The same holds true for definitions.</p>
<p></p>
<p></p>
<p><pre>(define (analyze-assignment exp)
  (let ((var (assignment-variable exp))
        (vproc (analyze (assignment-value exp))))
    (lambda (env)
      (set-variable-value! var (vproc env) env)
      'ok)))
(define (analyze-definition exp)
  (let ((var (definition-variable exp))
        (vproc (analyze (definition-value exp))))
    (lambda (env)
      (define-variable! var (vproc env) env)
      'ok)))
</pre></p>
<p></p>
<p></p>
<p>For <code>if</code> expressions, we extract and analyze the predicate,consequent, and alternative at analysis time.</p>
<p></p>
<p></p>
<p><pre>(define (analyze-if exp)
  (let ((pproc (analyze (if-predicate exp)))
        (cproc (analyze (if-consequent exp)))
        (aproc (analyze (if-alternative exp))))
    (lambda (env)
      (if (true? (pproc env))
          (cproc env)
          (aproc env)))))
</pre></p>
<p></p>
<p></p>
<p>Analyzing a <code>lambda</code> expression also achieves a majorgain in efficiency: We analyze the <code>lambda</code> body only once, even thoughprocedures resulting from evaluation of the <code>lambda</code>may be applied many times.</p>
<p></p>
<p></p>
<p><pre>(define (analyze-lambda exp)
  (let ((vars (lambda-parameters exp))
        (bproc (analyze-sequence (lambda-body exp))))
    (lambda (env) (make-procedure vars bproc env))))
</pre></p>
<p></p>
<p></p>
<p>Analysis of a sequence of expressions (as in a <code>begin</code> or the bodyof a <code>lambda</code> expression) is more involved.<a name="call_footnote_Temp_571" href="#footnote_Temp_571" id="call_footnote_Temp_571"><sup><small>30</small></sup></a>Each expressionin the sequence is analyzed, yielding an executionprocedure.  These execution procedures are combined to produce anexecutionprocedure that takes an environment as argument and sequentially callseach individual execution procedure with the environment as argument.</p>
<p></p>
<p></p>
<p><pre>(define (analyze-sequence exps)
  (define (sequentially proc1 proc2)
    (lambda (env) (proc1 env) (proc2 env)))
  (define (loop first-proc rest-procs)
    (if (null? rest-procs)
        first-proc
        (loop (sequentially first-proc (car rest-procs))
              (cdr rest-procs))))
  (let ((procs (map analyze exps)))
    (if (null? procs)
        (error "Empty sequence -- ANALYZE"))
    (loop (car procs) (cdr procs))))
</pre></p>
<p></p>
<p></p>
<p>To analyze an application, we analyze the operator and operands andconstruct an execution procedure thatcalls the operator execution procedure (to obtain theactual procedure to be applied) and the operand executionprocedures (to obtain the actual arguments).  We then pass these to <code>execute-application</code>, which is the analog of <code>apply</code> insection <a href="#%_sec_4.1.1">4.1.1</a>.<code>Execute-application</code> differs from <code>apply</code> in that the procedure body for a compound procedure has alreadybeen analyzed, so there is no need to do further analysis.  Instead,we just call the execution procedure for the body on the extendedenvironment.</p>
<p></p>
<p><pre>(define (analyze-application exp)
  (let ((fproc (analyze (operator exp)))
        (aprocs (map analyze (operands exp))))
    (lambda (env)
      (execute-application (fproc env)
                           (map (lambda (aproc) (aproc env))
                                aprocs)))))
<a name="%_idx_4660" id="%_idx_4660"></a>(define (execute-application proc args)
  (cond ((primitive-procedure? proc)
         (apply-primitive-procedure proc args))
        ((compound-procedure? proc)
         ((procedure-body proc)
          (extend-environment (procedure-parameters proc)
                              args
                              (procedure-environment proc))))
        (else
         (error
          "Unknown procedure type -- EXECUTE-APPLICATION"
          proc))))
</pre></p>
<p></p>
<p></p>
<p>Our new evaluator uses the same data structures, syntaxprocedures, and run-time support procedures as insections <a href="#%_sec_4.1.2">4.1.2</a>, <a href="#%_sec_4.1.3">4.1.3</a>, and <a href="#%_sec_4.1.4">4.1.4</a>.</p>
<p></p>
<p><a name="%_thm_4.22" id="%_thm_4.22"></a><b>Exercise 4.22.</b>  <a name="%_idx_4662" id="%_idx_4662"></a>Extend the evaluator in this section to support the special form <code>let</code>.(See exercise <a href="#%_thm_4.6">4.6</a>.)</p>
<p></p>
<p></p>
<p><a name="%_thm_4.23" id="%_thm_4.23"></a><b>Exercise 4.23.</b>  <a name="%_idx_4664" id="%_idx_4664"></a>Alyssa P. Hacker doesn't understand why <code>analyze-sequence</code> needs to beso complicated.  All the other analysis proceduresare straightforward transformations of the corresponding evaluationprocedures (or <code>eval</code> clauses) in section <a href="#%_sec_4.1.1">4.1.1</a>.She expected <code>analyze-sequence</code> to look like this:</p>
<p></p>
<p></p>
<p><pre>(define (analyze-sequence exps)
  (define (execute-sequence procs env)
    (cond ((null? (cdr procs)) ((car procs) env))
          (else ((car procs) env)
                (execute-sequence (cdr procs) env))))
  (let ((procs (map analyze exps)))
    (if (null? procs)
        (error "Empty sequence -- ANALYZE"))
    (lambda (env) (execute-sequence procs env))))
</pre></p>
<p></p>
<p>Eva Lu Ator explains to Alyssa that the version in the text does moreof the work of evaluating a sequence at analysis time.  Alyssa'ssequence-execution procedure, rather than having the calls to theindividual execution procedures built in, loops through the proceduresin order to call them: In effect, although the individual expressionsin the sequence have been analyzed, the sequence itself has not been.</p>
<p>Compare the two versions of <code>analyze-sequence</code>.  For example,consider the common case (typical of procedure bodies) where thesequence has just one expression.  What work will the executionprocedure produced by Alyssa's program do?  What about the executionprocedure produced by the program in the text above?  How do the twoversions compare for a sequence with two expressions?</p>
<p></p>
<p></p>
<p><a name="%_thm_4.24" id="%_thm_4.24"></a><b>Exercise 4.24.</b>  Design and carry out some experiments tocompare the speed of the original metacircular evaluatorwith the version in this section.  Use your results to estimate the fractionof time that is spent in analysis versus execution for variousprocedures.</p>
<p></p>
<p></p>
<p></p>
<div class="smallprint"><hr></div>
<p></p>
<div class="footnote">
<p><a name="footnote_Temp_510" href="#call_footnote_Temp_510" id="footnote_Temp_510"><sup><small>3</small></sup></a> Even so, there will remain important aspects ofthe evaluation process that are not elucidated by our evaluator.  Themost important of these are the detailed mechanisms by whichprocedures call other procedures and return values to their callers.We will address these issues in chapter 5, where we take a closer lookat the evaluation process by implementing the evaluator as a simpleregister machine.</p>
<p><a name="footnote_Temp_511" href="#call_footnote_Temp_511" id="footnote_Temp_511"><sup><small>4</small></sup></a> If we grant ourselves the ability to apply primitives,<a name="%_idx_4222" id="%_idx_4222"></a>then what remains for us to implement in the evaluator?  The job ofthe evaluator is not to specify the primitives of the language, but ratherto provide the connective tissue – the means of combination and themeans of abstraction – that binds a collection of primitives to form alanguage.  Specifically:</p>
<p></p>
<ul>
<li>The evaluator enables us to deal with nested expressions.  Forexample, although simply applying primitiveswould suffice for evaluatingthe expression <code>(+ 1 6)</code>, it is not adequate for handling <code>(+ 1 (* 23))</code>.  As far as the primitive procedure <code>+</code> is concerned,its arguments must be numbers, and it would choke if we passed it theexpression <code>(* 2 3)</code> as an argument.  One important role of theevaluator is to choreograph procedure composition so that <code>(* 23)</code> is reduced to 6 before being passed as an argument to <code>+</code>.<p></p>
</li>
<li>The evaluator allows us to use variables.  For example, theprimitive procedure for addition has no way to deal with expressions suchas <code>(+ x 1)</code>.  We need an evaluator to keep track of variables andobtain their values before invoking the primitiveprocedures.<p></p>
</li>
<li>The evaluator allows us to define compound procedures.  Thisinvolves keeping track of procedure definitions, knowing how to usethese definitions in evaluating expressions, and providing a mechanismthat enables procedures to accept arguments.<p></p>
</li>
<li>The evaluator provides the special forms, which must beevaluated differently from procedure calls.</li>
</ul>
<p></p>
<p><a name="footnote_Temp_518" href="#call_footnote_Temp_518" id="footnote_Temp_518"><sup><small>5</small></sup></a> We could have simplified the <code>application?</code> clause in <code>eval</code> by using <code>map</code>(and stipulating that <code>operands</code> returns a list) rather thanwriting an explicit <code>list-of-values</code> procedure.  We chose not touse <code>map</code> here to emphasize the fact that the <a name="%_idx_4252" id="%_idx_4252"></a><a name="%_idx_4254" id="%_idx_4254"></a>evaluator can beimplemented without any use of higher-order procedures(and thus could be written in a language that doesn't havehigher-order procedures), even thoughthe language that it supports will include higher-order procedures.</p>
<p><a name="footnote_Temp_520" href="#call_footnote_Temp_520" id="footnote_Temp_520"><sup><small>6</small></sup></a> In this case, the language being implemented and theimplementation language are the same.  Contemplation of the meaning of<a name="%_idx_4262" id="%_idx_4262"></a><code>true?</code> here yields expansion of consciousness without the abuseof substance.</p>
<p><a name="footnote_Temp_523" href="#call_footnote_Temp_523" id="footnote_Temp_523"><sup><small>7</small></sup></a> This implementation of <code>define</code> ignores a subtleissue in the handling of internal definitions, although it workscorrectly in most cases.  We will see what the problem is and how tosolve it in section <a href="#%_sec_4.1.6">4.1.6</a>.</p>
<p><a name="footnote_Temp_524" href="#call_footnote_Temp_524" id="footnote_Temp_524"><sup><small>8</small></sup></a> As we said when weintroduced <code>define</code> and <code>set!</code>, these valuesare implementation-dependent in Scheme – that is, the implementorcan choose what value to return.</p>
<p><a name="footnote_Temp_526" href="#call_footnote_Temp_526" id="footnote_Temp_526"><sup><small>9</small></sup></a> As mentioned insection <a href="book-Z-H-16.html#%_sec_2.3.1">2.3.1</a>, the evaluator sees a quoted expression asa list beginning with <code>quote</code>, even if theexpression is typed with the quotation mark.  For example, theexpression <code>'a</code> would be seen by the evaluator as <code>(quote a)</code>.See exercise <a href="book-Z-H-16.html#%_thm_2.55">2.55</a>.</p>
<p><a name="footnote_Temp_527" href="#call_footnote_Temp_527" id="footnote_Temp_527"><sup><small>10</small></sup></a> The value of an <code>if</code> expression when the predicateis false and there is no alternativeis unspecified in Scheme; we have chosen here to make it false.We will support the use of the variables <code>true</code> and <code>false</code>in expressions to be evaluated by binding them in the globalenvironment.  See section <a href="#%_sec_4.1.4">4.1.4</a>.</p>
<p><a name="footnote_Temp_528" href="#call_footnote_Temp_528" id="footnote_Temp_528"><sup><small>11</small></sup></a> These selectors for a list of expressions – and thecorresponding ones for a list of operands – are not intended as a dataabstraction.  They are introduced as mnemonic names for the basic listoperations in order to make it easier to understand the explicit-controlevaluator in section <a href="book-Z-H-34.html#%_sec_5.4">5.4</a>.</p>
<p><a name="footnote_Temp_530" href="#call_footnote_Temp_530" id="footnote_Temp_530"><sup><small>12</small></sup></a> The value of a <code>cond</code> expression when all the predicatesare false and there is no <code>else</code> clauseis unspecified in Scheme; we have chosen here to make it false.</p>
<p><a name="footnote_Temp_531" href="#call_footnote_Temp_531" id="footnote_Temp_531"><sup><small>13</small></sup></a> Practical Lisp systems provide amechanism that allows a user to add new derived expressions andspecify their implementation as syntactic transformations withoutmodifying the evaluator.  Such a user-defined transformation is called a<a name="%_idx_4374" id="%_idx_4374"></a><em>macro</em>.Although it is easy to add an elementary mechanism for defining macros,the resulting language has subtle name-conflict problems.There has been much research on mechanisms for macro definitionthat do not cause these difficulties.  See,<a name="%_idx_4376" id="%_idx_4376"></a><a name="%_idx_4378" id="%_idx_4378"></a><a name="%_idx_4380" id="%_idx_4380"></a><a name="%_idx_4382" id="%_idx_4382"></a>for example, Kohlbecker 1986, Clinger and Rees 1991, and Hanson 1991.</p>
<p><a name="footnote_Temp_544" href="#call_footnote_Temp_544" id="footnote_Temp_544"><sup><small>14</small></sup></a> Frames are not really a data abstraction in the following code:<code>Set-variable-value!</code> and <code>define-variable!</code> use <code>set-car!</code>to directly modify the values in a frame.  The purpose of the frameprocedures is to make the environment-manipulation procedures easy to read.</p>
<p><a name="footnote_Temp_545" href="#call_footnote_Temp_545" id="footnote_Temp_545"><sup><small>15</small></sup></a> The drawback of this representation (as well as the variant inexercise <a href="#%_thm_4.11">4.11</a>) is that the evaluatormay have to search through many frames in order to find the bindingfor a given variable.<a name="%_idx_4488" id="%_idx_4488"></a><a name="%_idx_4490" id="%_idx_4490"></a>(Such an approach is referred to as <em>deep binding</em>.)One way to avoidthis inefficiency is to make use of a strategy called <em>lexicaladdressing</em>, which will be discussed insection <a href="book-Z-H-35.html#%_sec_5.5.6">5.5.6</a>.</p>
<p><a name="footnote_Temp_549" href="#call_footnote_Temp_549" id="footnote_Temp_549"><sup><small>16</small></sup></a> Any procedure defined in the underlying Lisp can be used asa primitive for the metacircular evaluator.  The name of aprimitive installed in the evaluator need not be the same as the nameof its implementation in the underlying Lisp; the names are the samehere because the metacircular evaluator implements Scheme itself.Thus, for example, we could put <code>(list 'first car)</code> or <code>(list'square (lambda (x) (* x x)))</code> in the list of <code>primitive-procedures</code>.</p>
<p><a name="footnote_Temp_550" href="#call_footnote_Temp_550" id="footnote_Temp_550"><sup><small>17</small></sup></a> <code>Apply-in-underlying-scheme</code> is the <code>apply</code> procedurewe have used in earlier chapters.  The metacircular evaluator's <code>apply</code> procedure (section <a href="#%_sec_4.1.1">4.1.1</a>) models theworking of this primitive.  Having two different things called <code>apply</code> leads to a technical problem in running the metacircularevaluator, because defining the metacircular evaluator's <code>apply</code>will mask the definition of the primitive.  One way around this is torename the metacircular <code>apply</code> to avoid conflict with the name ofthe primitive procedure.  We have assumed instead that we have saved areference to the underlying <code>apply</code> by doing</p>
<p></p>
<p><pre>(define apply-in-underlying-scheme apply)
</pre></p>
<p></p>
<p>before defining the metacircular <code>apply</code>.  This allows us toaccess the original version of <code>apply</code> under a different name.</p>
<p><a name="footnote_Temp_551" href="#call_footnote_Temp_551" id="footnote_Temp_551"><sup><small>18</small></sup></a> The primitive procedure <a name="%_idx_4522" id="%_idx_4522"></a><a name="%_idx_4524" id="%_idx_4524"></a><code>read</code> waits for input from the user,and returns the next complete expression that is typed.For example, if the user types <code>(+ 23 x)</code>, <code>read</code> returnsa three-element list containing the symbol <code>+</code>, the number 23,and the symbol <code>x</code>.<a name="%_idx_4526" id="%_idx_4526"></a><a name="%_idx_4528" id="%_idx_4528"></a>If the user types <code>'x</code>, <code>read</code> returns a two-element listcontaining the symbol <code>quote</code> and the symbol <code>x</code>.</p>
<p><a name="footnote_Temp_553" href="#call_footnote_Temp_553" id="footnote_Temp_553"><sup><small>19</small></sup></a> The fact that the machines are described in Lisp isinessential.  If we give our evaluator a Lisp programthat behaves as an evaluator forsome other language, say C, the Lisp evaluator will emulate the Cevaluator, which in turn can emulate any machine described as a Cprogram.  Similarly, writing a Lisp evaluator in C produces a Cprogram that can execute any Lisp program.  The deep idea here is thatany evaluator can emulate any other.  Thus, the notion of “what canin principle be computed” (ignoring practicalities of time andmemory required) is independent of the language or the computer, andinstead reflects an underlying notion of <a name="%_idx_4554" id="%_idx_4554"></a><em>computability</em>.  Thiswas first demonstrated in a clear way by <a name="%_idx_4556" id="%_idx_4556"></a>Alan M. Turing (1912-1954),whose 1936 paper laid the foundations for theoretical <a name="%_idx_4558" id="%_idx_4558"></a>computerscience.  In the paper, Turing presented a simple computationalmodel – now known as a <a name="%_idx_4560" id="%_idx_4560"></a><em>Turing machine</em> – and argued that any“effective process” can be formulated as a program for such amachine.  (This argument is known as the <a name="%_idx_4562" id="%_idx_4562"></a><em>Church-Turing thesis</em>.)Turing then implemented a universal machine, i.e., a Turing machinethat behaves as an evaluator for Turing-machine programs.  He usedthis framework to demonstrate that there are well-posed problems thatcannot be computed by Turing machines (seeexercise <a href="#%_thm_4.15">4.15</a>), and so by implication cannot beformulated as “effective processes.”  Turing went on to makefundamental contributions to practical computer science as well.  Forexample, he invented the idea of <a name="%_idx_4564" id="%_idx_4564"></a>structuring programs usinggeneral-purpose subroutines.  See <a name="%_idx_4566" id="%_idx_4566"></a>Hodges 1983 for a biography ofTuring.</p>
<p><a name="footnote_Temp_554" href="#call_footnote_Temp_554" id="footnote_Temp_554"><sup><small>20</small></sup></a> Some people find itcounterintuitive that an evaluator, which is implemented by arelatively simple procedure, can emulate programs that are morecomplex than the evaluator itself.  The existence of a universalevaluator machine is a deep and wonderful property of computation.<a name="%_idx_4568" id="%_idx_4568"></a><em>Recursion theory</em>, a branch of mathematical logic, is concernedwith logical limits of computation.  <a name="%_idx_4570" id="%_idx_4570"></a>Douglas Hofstadter's beautifulbook <em>Gödel, Escher, Bach</em> (1979) explores some of these ideas.</p>
<p><a name="footnote_Temp_555" href="#call_footnote_Temp_555" id="footnote_Temp_555"><sup><small>21</small></sup></a> Warning:<a name="%_idx_4576" id="%_idx_4576"></a>This <code>eval</code> primitive is notidentical to the <code>eval</code> procedure we implemented insection <a href="#%_sec_4.1.1">4.1.1</a>, because it uses <em>actual</em>Scheme environments rather than the sample environment structures webuilt in section <a href="#%_sec_4.1.3">4.1.3</a>.  These actualenvironments cannot be manipulated by the user as ordinary lists; theymust be accessed via <code>eval</code> or other special operations.<a name="%_idx_4578" id="%_idx_4578"></a>Similarly, the <code>apply</code> primitive we saw earlier is not identicalto the metacircular <code>apply</code>, because it uses actual Scheme proceduresrather than the procedure objects we constructed insections <a href="#%_sec_4.1.3">4.1.3</a> and <a href="#%_sec_4.1.4">4.1.4</a>.</p>
<p><a name="footnote_Temp_556" href="#call_footnote_Temp_556" id="footnote_Temp_556"><sup><small>22</small></sup></a> The MIT<a name="%_idx_4580" id="%_idx_4580"></a><a name="%_idx_4582" id="%_idx_4582"></a><a name="%_idx_4584" id="%_idx_4584"></a><a name="%_idx_4586" id="%_idx_4586"></a>implementation of Scheme includes <code>eval</code>, as well as a symbol <code>user-initial-environment</code> that is bound to the initial environment inwhich the user's input expressions are evaluated.</p>
<p><a name="footnote_Temp_558" href="#call_footnote_Temp_558" id="footnote_Temp_558"><sup><small>23</small></sup></a> Although we stipulated that <code>halts?</code> is given a procedure object,notice that this reasoning still applies even if <code>halts?</code> can gainaccess to the procedure's text and its environment.<a name="%_idx_4590" id="%_idx_4590"></a><a name="%_idx_4592" id="%_idx_4592"></a><a name="%_idx_4594" id="%_idx_4594"></a><a name="%_idx_4596" id="%_idx_4596"></a>This is Turing's celebrated <em>Halting Theorem</em>, which gavethe first clear example of a <em>non-computable</em> problem, i.e., awell-posed task that cannot be carried out as a computationalprocedure.</p>
<p><a name="footnote_Temp_559" href="#call_footnote_Temp_559" id="footnote_Temp_559"><sup><small>24</small></sup></a> Wanting programs to not depend on this evaluationmechanism is the reason for the “management is notresponsible” remark in footnote <a href="book-Z-H-10.html#footnote_Temp_45">28</a> of chapter 1.By insisting that internal definitions come first and do not use eachother while the definitions are being evaluated, the IEEE standardfor Scheme leaves implementors some choice in the mechanism used toevaluate these definitions.  The choice of one evaluation rule ratherthan another here may seem like a small issue, affecting only theinterpretation of “badly formed” programs.  However, we will see insection <a href="book-Z-H-35.html#%_sec_5.5.6">5.5.6</a> that moving to a model ofsimultaneous scoping for internal definitions avoids some nastydifficulties that would otherwise arise in implementing a compiler.</p>
<p><a name="footnote_Temp_560" href="#call_footnote_Temp_560" id="footnote_Temp_560"><sup><small>25</small></sup></a> The IEEE standard for Schemeallows for different implementation strategies by specifying that itis up to the programmer to obey this restriction, not up to theimplementation to enforce it.  Some Scheme implementations, including<a name="%_idx_4610" id="%_idx_4610"></a>MIT Scheme, use the transformation shown above.  Thus, some programsthat don't obey this restriction will in fact run in such implementations.</p>
<p><a name="footnote_Temp_565" href="#call_footnote_Temp_565" id="footnote_Temp_565"><sup><small>26</small></sup></a> The MIT implementors of Scheme support Alyssa onthe following grounds: Eva is in principle correct – the definitionsshould be regarded as simultaneous.  But it seems difficult toimplement a general, efficient mechanism that does what Eva requires.In the absence of such a mechanism, it is better to generate an errorin the difficult cases of simultaneous definitions (Alyssa's notion)than to produce an incorrect answer (as Ben would have it).</p>
<p><a name="footnote_Temp_568" href="#call_footnote_Temp_568" id="footnote_Temp_568"><sup><small>27</small></sup></a> This example illustrates a programming trick forformulating recursive procedures without using <code>define</code>.  The<a name="%_idx_4628" id="%_idx_4628"></a>most general trick of this sort is the <em>Y</em> <em>operator</em>, which canbe used to give a “pure λ-calculus” implementation of<a name="%_idx_4630" id="%_idx_4630"></a><a name="%_idx_4632" id="%_idx_4632"></a>recursion.  (See Stoy 1977 for details on the lambda calculus, andGabriel 1988 for an exposition of the <em>Y</em> operator in Scheme.)</p>
<p><a name="footnote_Temp_569" href="#call_footnote_Temp_569" id="footnote_Temp_569"><sup><small>28</small></sup></a> This technique is an integral part of the compilationprocess, which we shall discuss in chapter 5.  Jonathan Rees wrote a Scheme<a name="%_idx_4644" id="%_idx_4644"></a><a name="%_idx_4646" id="%_idx_4646"></a><a name="%_idx_4648" id="%_idx_4648"></a><a name="%_idx_4650" id="%_idx_4650"></a>interpreter like this in about 1982 for the T project (Rees and Adams1982).  Marc Feeley (1986) (see also Feeley and Lapalme 1987)independently invented this techniquein his master's thesis.</p>
<p><a name="footnote_Temp_570" href="#call_footnote_Temp_570" id="footnote_Temp_570"><sup><small>29</small></sup></a> There is,however, an important part of the variable search that <em>can</em> bedone as part of the syntactic analysis.  As we will show insection <a href="book-Z-H-35.html#%_sec_5.5.6">5.5.6</a>, one can determine the positionin the environment structure where the value of the variable will befound, thus obviating the need to scan the environment for the entrythat matches the variable.</p>
<p><a name="footnote_Temp_571" href="#call_footnote_Temp_571" id="footnote_Temp_571"><sup><small>30</small></sup></a> See exercise <a href="#%_thm_4.23">4.23</a> for some insightinto the processing of sequences.</p>
</div></body>
</html>
