<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<?xml version="1.0" encoding="utf-8"?><html xmlns="http://www.w3.org/1999/xhtml" xmlns:ops="http://www.idpf.org/2007/ops">
<!-- Generated from TeX source by tex2page, v 4o,
     (c) Dorai Sitaram, http://www.cs.rice.edu/~dorai/tex2page --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Type: text/html; charset=utf-8">
<title>Structure and Interpretation of Computer Programs</title>
<link rel="stylesheet" type="text/css" href="book-Z-C.css" title="default">
</head>
<body><a name="%_sec_1.3" id="%_sec_1.3"></a><h2><a href="book-Z-H-4.html#%_toc_%_sec_1.3">1.3  Formulating Abstractions with Higher-Order Procedures</a></h2>
<p></p>
<p>We have seen that procedures are, in effect, abstractions that describecompound operations on numbers independent of the particular numbers.For example, when we</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_962" id="%_idx_962"></a>(define (cube x) (* x x x))
</pre></p>
<p></p>
<p>we are not talking about the cube of a particular number, but ratherabout a method for obtaining the cube of any number.  Of course wecould get along without ever defining this procedure, byalways writing expressions such as</p>
<p></p>
<p></p>
<p><pre>(* 3 3 3)
(* x x x)
(* y y y)        
</pre></p>
<p></p>
<p>and never mentioning <code>cube</code> explicitly.  This would place us at aserious disadvantage, forcing us to work always at the level of theparticular operations that happen to be primitives in the language(multiplication, in this case) rather than in terms of higher-leveloperations.  Our programs would be able to compute cubes, but ourlanguage would lack the ability to express the concept of cubing.  Oneof the things we should demand from a powerful programming language isthe ability to build abstractions by assigning names to commonpatterns and then to work in terms of the abstractions directly.Procedures provide this ability.  This is why all but the mostprimitive programming languages include mechanisms for definingprocedures.</p>
<p>Yet even in numerical processing we will be severely limited in ourability to create abstractions if we are restricted to procedureswhose parameters must be numbers.  Often the same programming patternwill be used with a number of different procedures.  To express suchpatterns as concepts, we will need to construct procedures that canaccept procedures as arguments or return procedures as values.Procedures that manipulate procedures are called <a name="%_idx_964" id="%_idx_964"></a><em>higher-orderprocedures</em>.  This section shows how higher-order procedures can serveas powerful abstraction mechanisms, vastly increasing the expressivepower of our language.</p>
<p><a name="%_sec_1.3.1" id="%_sec_1.3.1"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_1.3.1">1.3.1  Procedures as Arguments</a></h3>
<p><a name="%_idx_966" id="%_idx_966"></a><a name="%_idx_968" id="%_idx_968"></a>Consider the following three procedures.  The first computes the sumof the integers from <code>a</code> through <code>b</code>:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_970" id="%_idx_970"></a>(define (sum-integers a b)
  (if (&gt; a b)
      0
      (+ a (sum-integers (+ a 1) b))))
</pre></p>
<p></p>
<p>The second computes the sum of the cubes of the integers in the given range:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_972" id="%_idx_972"></a>(define (sum-cubes a b)
  (if (&gt; a b)
      0
      (+ (cube a) (sum-cubes (+ a 1) b))))
</pre></p>
<p></p>
<p>The third computes the sum of a sequence of terms in theseries</p>
<p></p>
<div align="left"><img src="images/ch1-Z-G-26.gif" border="0"></div>
<p>which converges to π/8 (very slowly):<a name="call_footnote_Temp_90" href="#footnote_Temp_90" id="call_footnote_Temp_90"><sup><small>49</small></sup></a></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_978" id="%_idx_978"></a>(define (pi-sum a b)
  (if (&gt; a b)
      0
      (+ (/ 1.0 (* a (+ a 2))) (pi-sum (+ a 4) b))))
</pre></p>
<p></p>
<p></p>
<p>These three procedures clearly share a common underlying pattern.They are for the most part identical, differing only in the name ofthe procedure, the function of <code>a</code> used to compute the term to be added,and the function that provides the next value of <code>a</code>.  We could generateeach of the procedures by filling in slots in the same template:</p>
<p></p>
<p></p>
<p><pre>(define (&lt;<em>name</em>&gt; a b)
  (if (&gt; a b)
      0
      (+ (&lt;<em>term</em>&gt; a)
         (&lt;<em>name</em>&gt; (&lt;<em>next</em>&gt; a) b))))
</pre></p>
<p></p>
<p></p>
<p><a name="%_idx_980" id="%_idx_980"></a>The presence of such a common pattern is strong evidence that there isa useful abstraction waiting to be brought to the surface.  Indeed,mathematicians long ago identified the abstraction of<a name="%_idx_982" id="%_idx_982"></a><a name="%_idx_984" id="%_idx_984"></a><em>summation of a series</em> and invented “sigma<a name="%_idx_986" id="%_idx_986"></a><a name="%_idx_988" id="%_idx_988"></a>notation,” for example</p>
<p></p>
<p></p>
<div align="left"><img src="images/ch1-Z-G-27.gif" border="0"></div>
<p></p>
<p>to express this concept.  The power of sigma notation is that itallows mathematicians to deal with the concept of summationitself rather than only with particular sums – for example, toformulate general results about sums that are independent of theparticular series being summed.</p>
<p>Similarly, as program designers, we would like our language tobe powerful enough so that we can write a procedure that expresses theconcept of summation itself rather than only proceduresthat compute particular sums.  We can do so readily in ourprocedural language by taking the common template shown above andtransforming the “slots” into formal parameters:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_990" id="%_idx_990"></a>(define (sum term a next b)
  (if (&gt; a b)
      0
      (+ (term a)
         (sum term (next a) next b))))
</pre></p>
<p></p>
<p>Notice that <code>sum</code> takes as its arguments the lower and upper bounds<code>a</code> and <code>b</code> together with the procedures <code>term</code> and <code>next</code>.We can use <code>sum</code> just as we would any procedure.  For example, we canuse it (along with a procedure <code>inc</code> that increments its argument by 1)to define <code>sum-cubes</code>:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_992" id="%_idx_992"></a>(define (inc n) (+ n 1))
<a name="%_idx_994" id="%_idx_994"></a>(define (sum-cubes a b)
  (sum cube a inc b))
</pre></p>
<p></p>
<p>Using this, we can compute the sum of the cubes of the integers from 1to 10:</p>
<p></p>
<p></p>
<p><pre>(sum-cubes 1 10)
<i>3025</i>
</pre></p>
<p></p>
<p>With the aid of an identity procedure to compute the term, we can define<code>sum-integers</code> in terms of <code>sum</code>:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_996" id="%_idx_996"></a>(define (identity x) x)

<a name="%_idx_998" id="%_idx_998"></a>(define (sum-integers a b)
  (sum identity a inc b))
</pre></p>
<p></p>
<p>Then we can add up the integers from 1 to 10:</p>
<p></p>
<p></p>
<p><pre>(sum-integers 1 10)
<i>55</i>
</pre></p>
<p></p>
<p>We can also define <code>pi-sum</code> in the same way:<a name="call_footnote_Temp_91" href="#footnote_Temp_91" id="call_footnote_Temp_91"><sup><small>50</small></sup></a></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_1000" id="%_idx_1000"></a>(define (pi-sum a b)
  (define (pi-term x)
    (/ 1.0 (* x (+ x 2))))
  (define (pi-next x)
    (+ x 4))
  (sum pi-term a pi-next b))
</pre></p>
<p></p>
<p>Using these procedures, we can compute an approximation toπ:</p>
<p></p>
<p></p>
<p><pre>(* 8 (pi-sum 1 1000))
<i>3.139592655589783</i>
</pre></p>
<p></p>
<p></p>
<p>Once we have <code>sum</code>, we can use it as a building block informulating further concepts.  For instance, the <a name="%_idx_1002" id="%_idx_1002"></a>definite integral of afunction <em>f</em> between the limits <em>a</em> and <em>b</em> can be approximatednumerically using the formula</p>
<p></p>
<p></p>
<div align="left"><img src="images/ch1-Z-G-28.gif" border="0"></div>
<p>for small values of <em>d</em><em>x</em>.  We can express this directly as aprocedure:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_1004" id="%_idx_1004"></a>(define (integral f a b dx)
  (define (add-dx x) (+ x dx))
  (* (sum f (+ a (/ dx 2.0)) add-dx b)
     dx))
(integral cube 0 1 0.01)
<i>.24998750000000042</i>
(integral cube 0 1 0.001)
<i>.249999875000001</i>
</pre></p>
<p></p>
<p>(The exact value of the integral of <code>cube</code> between 0 and 1 is 1/4.)</p>
<p></p>
<p><a name="%_thm_1.29" id="%_thm_1.29"></a><b>Exercise 1.29.</b>  <a name="%_idx_1006" id="%_idx_1006"></a>Simpson's Rule is a more accurate method of numerical integration thanthe method illustrated above.  Using Simpson's Rule, the integral of afunction <em>f</em> between <em>a</em> and <em>b</em> is approximated as</p>
<p></p>
<div align="left"><img src="images/ch1-Z-G-29.gif" border="0"></div>
<p></p>
<p>where <em>h</em> = (<em>b</em> - <em>a</em>)/<em>n</em>, for some even integer <em>n</em>, and <em>y</em><sub><em>k</em></sub>  = <em>f</em>(<em>a</em> + <em>k</em><em>h</em>).(Increasing <em>n</em> increases the accuracy of the approximation.)  Definea procedure that takes as arguments <em>f</em>, <em>a</em>, <em>b</em>, and <em>n</em> and returnsthe value of the integral, computed using Simpson's Rule.Use your procedure to integrate <code>cube</code> between 0 and 1(with <em>n</em> = 100 and <em>n</em> = 1000), and compare the results to those of the<code>integral</code> procedure shown above.</p>
<p></p>
<p></p>
<p><a name="%_thm_1.30" id="%_thm_1.30"></a><b>Exercise 1.30.</b>  <a name="%_idx_1008" id="%_idx_1008"></a>The <code>sum</code> procedure above generates a linear recursion.  Theprocedure can be rewritten so that the sum is performed iteratively.Show how to do this by filling in the missing expressions in thefollowing definition:</p>
<p></p>
<p></p>
<p><pre>(define (sum term a next b)
  (define (iter a result)
    (if &lt;<em>??</em>&gt;
        &lt;<em>??</em>&gt;
        (iter &lt;<em>??</em>&gt; &lt;<em>??</em>&gt;)))
  (iter &lt;<em>??</em>&gt; &lt;<em>??</em>&gt;))
</pre></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_1.31" id="%_thm_1.31"></a><b>Exercise 1.31.</b>  <a name="%_idx_1010" id="%_idx_1010"></a>
a.  The <code>sum</code> procedure is only the simplest of a vast number ofsimilar abstractions that can be captured as higher-order procedures.<a name="call_footnote_Temp_95" href="#footnote_Temp_95" id="call_footnote_Temp_95"><sup><small>51</small></sup></a>  Write an analogous procedurecalled <code>product</code> that returns the product of the values of afunction at points over a given range.Show how to define <a name="%_idx_1012" id="%_idx_1012"></a><code>factorial</code> in terms of<code>product</code>.  Also use <code>product</code> to compute approximations to<a name="%_idx_1014" id="%_idx_1014"></a>π using the formula<a name="call_footnote_Temp_96" href="#footnote_Temp_96" id="call_footnote_Temp_96"><sup><small>52</small></sup></a></p>
<p></p>
<div align="left"><img src="images/ch1-Z-G-30.gif" border="0"></div>
<p></p>
<p>b.  If your <code>product</code>procedure generates a recursive process, write one that generatesan iterative process.If it generates an iterative process, write one that generatesa recursive process.</p>
<p></p>
<p></p>
<p><a name="%_thm_1.32" id="%_thm_1.32"></a><b>Exercise 1.32.</b>  <a name="%_idx_1018" id="%_idx_1018"></a><a name="%_idx_1020" id="%_idx_1020"></a><a name="%_idx_1022" id="%_idx_1022"></a>a. Show that <code>sum</code> and <code>product</code>(exercise <a href="#%_thm_1.31">1.31</a>) are both special cases of a still moregeneral notion called <code>accumulate</code> that combines a collection ofterms, using some general accumulation function:</p>
<p></p>
<p></p>
<p><pre>(accumulate combiner null-value term a next b)
</pre></p>
<p></p>
<p><code>Accumulate</code> takes as arguments the same term and rangespecifications as <code>sum</code> and <code>product</code>, together with a <code>combiner</code>procedure (of two arguments) that specifies how the currentterm is to be combined with the accumulation of the preceding termsand a <code>null-value</code> that specifies what base value to usewhen the terms run out.  Write <code>accumulate</code>and show how <code>sum</code> and <code>product</code> can bothbe defined as simple calls to <code>accumulate</code>.</p>
<p></p>
<p></p>
<p>b. If your <code>accumulate</code>procedure generates a recursive process, write one that generatesan iterative process.If it generates an iterative process, write one that generatesa recursive process.</p>
<p></p>
<p></p>
<p><a name="%_thm_1.33" id="%_thm_1.33"></a><b>Exercise 1.33.</b>  <a name="%_idx_1024" id="%_idx_1024"></a>You can obtain an even more general version of <code>accumulate</code>(exercise <a href="#%_thm_1.32">1.32</a>) by introducing the notion of a <a name="%_idx_1026" id="%_idx_1026"></a><em>filter</em> on the terms to be combined.  That is, combine only thoseterms derived from values in the range that satisfy a specifiedcondition.  The resulting <code>filtered-accumulate</code> abstraction takesthe same arguments as accumulate, together with an additionalpredicate of one argument that specifies the filter.  Write <code>filtered-accumulate</code> as a procedure.  Show how to express thefollowing using <code>filtered-accumulate</code>:</p>
<p></p>
<p></p>
<p>a. the sum of the squares of the prime numbers in the interval <em>a</em> to<em>b</em> (assuming that you have a <code>prime?</code> predicate already written)</p>
<p></p>
<p></p>
<p>b. the product of all the positive integers less than <em>n</em><a name="%_idx_1028" id="%_idx_1028"></a>that are relatively prime to <em>n</em> (i.e., all positive integers<em>i</em> &lt; <em>n</em> such that  <em>G</em><em>C</em><em>D</em>(<em>i</em>,<em>n</em>) = 1).</p>
<p></p>
<p><a name="%_sec_1.3.2" id="%_sec_1.3.2"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_1.3.2">1.3.2  Constructing Procedures Using <code>Lambda</code></a></h3>
<p></p>
<p>In using <code>sum</code> as in section <a href="#%_sec_1.3.1">1.3.1</a>,it seems terribly awkward to have to define trivial procedures such as<code>pi-term</code> and <code>pi-next</code> just so we can use them as arguments toour higher-order procedure.  Rather than define <code>pi-next</code> and <code>pi-term</code>, it would be more convenientto have a way to directly specify “the procedure that returns itsinput incremented by 4” and “the procedure that returns thereciprocal of its input times its input plus 2.”  We can do this byintroducing the special form <code>lambda</code>, which creates procedures.Using <code>lambda</code> we can describe what we want as</p>
<p></p>
<p></p>
<p><pre>(lambda (x) (+ x 4))
</pre></p>
<p></p>
<p>and </p>
<p></p>
<p></p>
<p><pre>(lambda (x) (/ 1.0 (* x (+ x 2))))
</pre></p>
<p></p>
<p>Then our <code>pi-sum</code> procedure can be expressed without defining anyauxiliary procedures as</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_1030" id="%_idx_1030"></a>(define (pi-sum a b)
  (sum (lambda (x) (/ 1.0 (* x (+ x 2))))
       a
       (lambda (x) (+ x 4))
       b))
</pre></p>
<p></p>
<p></p>
<p>Again using <code>lambda</code>, we can write the <code>integral</code> procedurewithout having to define the auxiliary procedure <code>add-dx</code>:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_1032" id="%_idx_1032"></a>(define (integral f a b dx)
  (* (sum f
          (+ a (/ dx 2.0))
          (lambda (x) (+ x dx))
          b)
     dx))
</pre></p>
<p></p>
<p></p>
<p><a name="%_idx_1034" id="%_idx_1034"></a><a name="%_idx_1036" id="%_idx_1036"></a><a name="%_idx_1038" id="%_idx_1038"></a><a name="%_idx_1040" id="%_idx_1040"></a><a name="%_idx_1042" id="%_idx_1042"></a>In general, <code>lambda</code> is used to create procedures in the same way as<code>define</code>, except that <a name="%_idx_1044" id="%_idx_1044"></a>no name is specified for the procedure:</p>
<p></p>
<p></p>
<p><pre>(lambda (&lt;<em>formal-parameters</em>&gt;) &lt;<em>body</em>&gt;)
</pre></p>
<p></p>
<p>The resulting procedure is just as much a procedure as one that iscreated using <code>define</code>.  The only difference is that it has notbeen associated with any name in the environment.  In fact,</p>
<p><a name="%_idx_1046" id="%_idx_1046"></a></p>
<p></p>
<p><pre>(define (plus4 x) (+ x 4))
</pre></p>
<p></p>
<p>is equivalent to</p>
<p></p>
<p></p>
<p><pre>(define plus4 (lambda (x) (+ x 4)))
</pre></p>
<p></p>
<p>We can read a <code>lambda</code> expression as follows:</p>
<p></p>
<p><pre>    (lambda             (x)             (+    x     4))
        ↑                 ↑               ↑    ↑    ↑
 the procedure   of an argument <code>x</code>  that adds  <code>x</code> and 4
</pre></p>
<p></p>
<p><a name="%_idx_1048" id="%_idx_1048"></a><a name="%_idx_1050" id="%_idx_1050"></a><a name="%_idx_1052" id="%_idx_1052"></a>Like any expression that has a procedure as its value, a<code>lambda</code> expression can be used as the operator in a combination such as</p>
<p></p>
<p></p>
<p><pre>((lambda (x y z) (+ x y (square z))) 1 2 3)
<i>12</i>
</pre></p>
<p></p>
<p>or, more generally, in any context where we would normally use aprocedure name.<a name="call_footnote_Temp_99" href="#footnote_Temp_99" id="call_footnote_Temp_99"><sup><small>53</small></sup></a></p>
<p><a name="%_sec_Temp_100" id="%_sec_Temp_100"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_100">Using <code>let</code> to create local variables</a></h4>
<p><a name="%_idx_1058" id="%_idx_1058"></a><a name="%_idx_1060" id="%_idx_1060"></a>Another use of <code>lambda</code> is in creating local variables.We often need local variables in our procedures other than those that havebeen bound as formal parameters.  For example, suppose we wish tocompute the function</p><p><em>ƒ</em>(<em>r</em>, <em>y</em>) = <em>r</em>(1 + <em>ry</em>)<sup>2</sup> + <em>y</em>(1 - <em>y</em>) + (1 + <em>ry</em>)(1 - <em>y</em>)</p><p>which we could also express as</p><p>    <code>      <em>a</em> = 1 + <em>ry</em></code>
<code>      <em>b</em> = 1 - <em>y</em></code>
<code><em>ƒ</em>(<em>r</em>, <em>y</em>) = <em>ra</em><sup>2</sup> + <em>yb</em> + <em>ab</em></code></p><p>In writing a procedure to compute <em>f</em>, we would like to include aslocal variables not only <em>x</em> and <em>y</em>  but also the names ofintermediate quantities like <em>a</em> and <em>b</em>.  One way toaccomplish this is touse an auxiliary procedure to bind the local variables:</p>
<p></p>
<p></p>
<p><pre>(define (f x y)
  (define (f-helper a b)
    (+ (* x (square a))
       (* y b)
       (* a b)))
  (f-helper (+ 1 (* x y)) 
            (- 1 y)))
</pre></p>
<p></p>
<p></p>
<p>Of course, we could use a <code>lambda</code> expression to specify ananonymous procedure for binding our local variables.  The body of<code>f</code> then becomes a single call to that procedure:</p>
<p></p>
<p></p>
<p><pre>(define (f x y)
  ((lambda (a b)
     (+ (* x (square a))
        (* y b)
        (* a b)))
   (+ 1 (* x y))
   (- 1 y)))
</pre></p>
<p></p>
<p>This construct is so useful that there is a special form called<code>let</code> to make its use more convenient.  Using <code>let</code>, the <code>f</code>procedure could be written as</p>
<p></p>
<p></p>
<p><pre>(define (f x y)
  (let ((a (+ 1 (* x y)))
        (b (- 1 y)))
    (+ (* x (square a))
       (* y b)
       (* a b))))
</pre></p>
<p></p>
<p><a name="%_idx_1062" id="%_idx_1062"></a><a name="%_idx_1064" id="%_idx_1064"></a>The general form of a <code>let</code> expression is</p>
<p></p>
<p></p>
<p><pre>(let ((&lt;<em>var<sub>1</sub></em>&gt; &lt;<em>exp<sub>1</sub></em>&gt;)
      (&lt;<em>var<sub>2</sub></em>&gt; &lt;<em>exp<sub>2</sub></em>&gt;)
      ⋮
      (&lt;<em>var<sub><em>n</em></sub></em>&gt; &lt;<em>exp<sub><em>n</em></sub></em>&gt;))
   &lt;<em>body</em>&gt;)
</pre></p>
<p></p>
<p>which can be thought of as saying</p>
<p></p>
<table border="0">
<tr>
<td valign="top">let </td>
<td valign="top">&lt;<em>var<sub>1</sub></em>&gt; have the value &lt;<em>exp<sub>1</sub></em>&gt; and</td>
</tr>
<tr>
<td valign="top"></td>
<td valign="top">&lt;<em>var<sub>2</sub></em>&gt; have the value &lt;<em>exp<sub>2</sub></em>&gt; and</td>
</tr>
<tr>
<td valign="top"></td>
<td valign="top">⋮</td>
</tr>
<tr>
<td valign="top"></td>
<td valign="top">&lt;<em>var<sub><em>n</em></sub></em>&gt; have the value &lt;<em>exp<sub><em>n</em></sub></em>&gt;</td>
</tr>
<tr>
<td valign="top">in  </td>
<td valign="top">&lt;<em>body</em>&gt;</td>
</tr>
</table>
<p>The first part of the <code>let</code> expression is a list ofname-expression pairs.  When the <code>let</code> is evaluated, each name isassociated with the value of the corresponding expression.  The bodyof the <code>let</code> is evaluated withthese names bound as local variables.  The way this happens is that the <code>let</code> expression is interpreted as an alternate syntax for</p>
<p></p>
<p></p>
<p><pre>((lambda (&lt;<em>var<sub>1</sub></em>&gt; <code>...</code>&lt;<em>var<sub><em>n</em></sub></em>&gt;)
    &lt;<em>body</em>&gt;)
 &lt;<em>exp<sub>1</sub></em>&gt;
 ⋮
 &lt;<em>exp<sub><em>n</em></sub></em>&gt;)
</pre></p>
<p></p>
<p>No new mechanism is required in the interpreter in order toprovide local variables.  A <a name="%_idx_1066" id="%_idx_1066"></a><a name="%_idx_1068" id="%_idx_1068"></a><code>let</code> expression is simply syntactic sugar forthe underlying <code>lambda</code> application.</p>
<p><a name="%_idx_1070" id="%_idx_1070"></a><a name="%_idx_1072" id="%_idx_1072"></a>We can see from this equivalence thatthe scope of a variable specified by a <code>let</code> expression is the body ofthe <code>let</code>.This implies that:</p>
<p></p>
<p></p>
<ul>
<li>
<code>Let</code> allows one tobind variables as locally as possible to where theyare to be used.  For example, if the value of <code>x</code> is 5,the value of the expression<p></p>
<p></p>
<p><pre>(+ (let ((x 3))
     (+ x (* x 10)))
   x)
</pre></p>
<p></p>
<p></p>
<p>is 38.  Here, the <code>x</code> in the body of the <code>let</code> is 3,so the value of the <code>let</code> expression is 33.  On the other hand, the<code>x</code> that is the second argument to the outermost <code>+</code> is still 5.</p>
<p></p>
</li>
<li>The variables' values are computed outside the <code>let</code>.This matters when the expressions thatprovide the values for the local variables depend uponvariables having the same names as the local variables themselves.For example, if the value of <code>x</code> is 2, the expression<p></p>
<p></p>
<p><pre>(let ((x 3)
      (y (+ x 2)))
  (* x y))
</pre></p>
<p></p>
<p>will have the value 12 because, inside the body of the <code>let</code>,<code>x</code> will be 3 and <code>y</code> will be 4 (which is theouter <code>x</code> plus 2).</p>
</li>
</ul>
<p></p>
<p><a name="%_idx_1074" id="%_idx_1074"></a><a name="%_idx_1076" id="%_idx_1076"></a>Sometimes we can use internal definitions to get the same effect aswith <code>let</code>.  For example, we could have defined the procedure <code>f</code> above as</p>
<p></p>
<p><pre>(define (f x y)
  (define a (+ 1 (* x y)))
  (define b (- 1 y))
  (+ (* x (square a))
     (* y b)
     (* a b)))
</pre></p>
<p></p>
<p>We prefer, however, to use <code>let</code> in situations like thisand to use internal <code>define</code> only for internal procedures.<a name="call_footnote_Temp_101" href="#footnote_Temp_101" id="call_footnote_Temp_101"><sup><small>54</small></sup></a></p>
<p></p>
<p><a name="%_thm_1.34" id="%_thm_1.34"></a><b>Exercise 1.34.</b>  Suppose we define the procedure</p>
<p></p>
<p></p>
<p><pre>(define (f g)
  (g 2))
</pre></p>
<p></p>
<p>Then we have</p>
<p></p>
<p></p>
<p><pre>(f square)
<i>4</i>

(f (lambda (z) (* z (+ z 1))))
<i>6</i>
</pre></p>
<p></p>
<p>What happens if we (perversely) ask the interpreter to evaluate thecombination <code>(f f)</code>?  Explain.</p>
<p></p>
<p><a name="%_sec_1.3.3" id="%_sec_1.3.3"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_1.3.3">1.3.3  Procedures as General Methods</a></h3>
<p><a name="%_idx_1078" id="%_idx_1078"></a><a name="%_idx_1080" id="%_idx_1080"></a>We introduced compound procedures insection <a href="book-Z-H-10.html#%_sec_1.1.4">1.1.4</a> as a mechanism for abstractingpatterns of numerical operations so as to make them independent of theparticular numbers involved.  With higher-order procedures, such asthe <code>integral</code> procedure ofsection <a href="#%_sec_1.3.1">1.3.1</a>, we began to see a morepowerful kind of abstraction: procedures used to express generalmethods of computation, independent of the particular functionsinvolved.  In this section we discuss two more elaborateexamples – general methods for finding zeros and fixed points offunctions – and show how these methods can be expressed directly asprocedures.</p>
<p><a name="%_sec_Temp_103" id="%_sec_Temp_103"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_103">Finding roots of equations by the half-interval method</a></h4>
<p><a name="%_idx_1082" id="%_idx_1082"></a>The <em>half-interval method</em> is a simple but powerful technique forfinding roots of an equation <em>f</em>(<em>x</em>) = 0, where <em>f</em> is a continuousfunction.  The idea is that, if we are given points <em>a</em> and <em>b</em> suchthat <em>f</em>(<em>a</em>) &lt; 0 &lt; <em>f</em>(<em>b</em>), then <em>f</em> must have at least one zero between<em>a</em> and <em>b</em>.  To locate a zero, let <em>x</em> be the average of <em>a</em> and <em>b</em>and compute <em>f</em>(<em>x</em>).  If <em>f</em>(<em>x</em>) &gt; 0, then <em>f</em> must have a zero between<em>a</em> and <em>x</em>.  If <em>f</em>(<em>x</em>) &lt; 0, then <em>f</em> must have a zero between <em>x</em> and<em>b</em>.  Continuing in this way, we can identify smaller and smallerintervals on which <em>f</em> must have a zero.  When we reach a point wherethe interval is small enough, the process stops.  Since the intervalof uncertainty is reduced by half at each step of the process, thenumber of steps required grows as θ(<code>log</code>( <em>L</em>/<em>T</em>)), where <em>L</em> is thelength of the original interval and <em>T</em> is the error tolerance(that is, the size of the interval we will consider “small enough”).Here is a procedure that implements this strategy:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_1084" id="%_idx_1084"></a>(define (search f neg-point pos-point)
  (let ((midpoint (average neg-point pos-point)))
    (if (close-enough? neg-point pos-point)
        midpoint
        (let ((test-value (f midpoint)))
          (cond ((positive? test-value)
                 (search f neg-point midpoint))
                ((negative? test-value)
                 (search f midpoint pos-point))
                (else midpoint))))))
</pre></p>
<p></p>
<p></p>
<p>We assume that we are initially given the function <em>f</em> together withpoints at which its values are negative and positive.  We firstcompute the midpoint of the two given points.  Next we check to see ifthe given interval is small enough, and if so we simply return themidpoint as our answer.  Otherwise, we compute as a test value thevalue of <em>f</em> at the midpoint.  If the test value is positive, thenwe continue the process with a new interval running from the originalnegative point to the midpoint.  If the test value is negative, wecontinue with the interval from the midpoint to the positive point.Finally, there is the possibility that the test value is 0, in whichcase the midpoint is itself the root we are searching for.</p>
<p>To test whether the endpoints are “close enough” we can use aprocedure similar to the one used in section <a href="book-Z-H-10.html#%_sec_1.1.7">1.1.7</a> forcomputing square roots:<a name="call_footnote_Temp_104" href="#footnote_Temp_104" id="call_footnote_Temp_104"><sup><small>55</small></sup></a></p>
<p></p>
<p></p>
<p><pre>(define (close-enough? x y)
  (&lt; (abs (- x y)) 0.001))
</pre></p>
<p></p>
<p></p>
<p><code>Search</code> is awkward to use directly, becausewe can accidentally give it points at which <em>f</em>'svalues do not have the required sign, in which case we get a wrong answer.Instead we will use <code>search</code> via the following procedure, whichchecks to see which of the endpoints has a negative function value andwhich has a positive value, and calls the <code>search</code> procedureaccordingly.  If the function has the same sign on the two givenpoints, the half-interval method cannot be used, in which case theprocedure signals an error.<a name="call_footnote_Temp_105" href="#footnote_Temp_105" id="call_footnote_Temp_105"><sup><small>56</small></sup></a></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_1092" id="%_idx_1092"></a>(define (half-interval-method f a b)
  (let ((a-value (f a))
        (b-value (f b)))
    (cond ((and (negative? a-value) (positive? b-value))
           (search f a b))
          ((and (negative? b-value) (positive? a-value))
           (search f b a))
          (else
           (error "Values are not of opposite sign" a b)))))
</pre></p>
<p></p>
<p></p>
<p><a name="%_idx_1094" id="%_idx_1094"></a>The following example uses the half-interval method to approximate πas the root between 2 and 4 of <code>sin</code>  <em>x</em>  =  0:</p>
<p></p>
<p></p>
<p><pre>(half-interval-method sin 2.0 4.0)
<i>3.14111328125</i>
</pre></p>
<p></p>
<p></p>
<p>Here is another example, using the half-interval methodto search for a root of the equation <em>x</em><sup>3</sup>  -  2<em>x</em>  -  3  =  0between 1 and 2:</p>
<p></p>
<p></p>
<p><pre>(half-interval-method (lambda (x) (- (* x x x) (* 2 x) 3))
                      1.0
                      2.0)
<i>1.89306640625</i>
</pre></p>
<p></p>
<p></p>
<p><a name="%_sec_Temp_106" id="%_sec_Temp_106"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_106">Finding fixed points of functions</a></h4>
<p><a name="%_idx_1096" id="%_idx_1096"></a><a name="%_idx_1098" id="%_idx_1098"></a>A number <em>x</em> is called a <em>fixed point</em> of a function <em>f</em> if <em>x</em>satisfies the equation <em>f</em>(<em>x</em>) = <em>x</em>.  For some functions <em>f</em> we can locatea fixed point by beginning with an initial guess and applying <em>f</em>repeatedly,</p><p><em>ƒ</em>(<em>r</em>), <em>ƒ</em>(<em>ƒ</em>(<em>r</em>)), <em>ƒ</em>(<em>ƒ</em>(<em>ƒ</em>(<em>r</em>))), …</p><p>until the value does not change very much.  Using this idea, we candevise a procedure <code>fixed-point</code> that takes as inputs a functionand an initial guess and produces an approximation to a fixed point ofthe function.  We apply the function repeatedly until we find twosuccessive values whose difference is less than some prescribedtolerance:</p>
<p></p>
<p></p>
<p><pre>(define tolerance 0.00001)
<a name="%_idx_1100" id="%_idx_1100"></a>(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (&lt; (abs (- v1 v2)) tolerance))
  (define (try guess)
    (let ((next (f guess)))
      (if (close-enough? guess next)
          next
          (try next))))
  (try first-guess))
</pre></p>
<p></p>
<p><a name="%_idx_1102" id="%_idx_1102"></a><a name="%_idx_1104" id="%_idx_1104"></a>For example, we can use this method to approximate the fixed point ofthe cosine function, starting with 1 as an initial approximation:<a name="call_footnote_Temp_107" href="#footnote_Temp_107" id="call_footnote_Temp_107"><sup><small>57</small></sup></a></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_1112" id="%_idx_1112"></a><a name="%_idx_1114" id="%_idx_1114"></a>(fixed-point cos 1.0)
<i>.7390822985224023</i>
</pre></p>
<p></p>
<p>Similarly, we can find a solution to the equation<em>y</em> = <code>sin</code> <em>y</em>  +  <code>cos</code> <em>y</em>:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_1116" id="%_idx_1116"></a><a name="%_idx_1118" id="%_idx_1118"></a>(fixed-point (lambda (y) (+ (sin y) (cos y)))
             1.0)
<i>1.2587315962971173</i>
</pre></p>
<p></p>
<p></p>
<p>The fixed-point process is reminiscent of the process we used forfinding square roots in section <a href="book-Z-H-10.html#%_sec_1.1.7">1.1.7</a>.  Both are based on theidea of repeatedly improving a guess until the result satisfies somecriterion.  In fact, we can readily formulate the <a name="%_idx_1120" id="%_idx_1120"></a>square-rootcomputation as a fixed-point search.  Computing the square root ofsome number <em>x</em> requires finding a <em>y</em> such that <em>y</em><sup>2</sup>  =  <em>x</em>.  Puttingthis equation into the equivalent form <em>y</em>  =  <em>x</em>/<em>y</em>, we recognize that weare looking for a fixed point of the function<a name="call_footnote_Temp_108" href="#footnote_Temp_108" id="call_footnote_Temp_108"><sup><small>58</small></sup></a> <em>y</em>  ⟼  <em>x</em>/<em>y</em>, and wecan therefore try to compute square roots as</p>
<p></p>
<p></p>
<p><pre>(define (sqrt x)
  (fixed-point (lambda (y) (/ x y))
               1.0))
</pre></p>
<p></p>
<p></p>
<p>Unfortunately, this fixed-point search does not converge.  Consider aninitial guess <em>y</em><sub>1</sub>.  The next guess is <em>y</em><sub>2</sub>  =  <em>x</em>/<em>y</em><sub>1</sub> and the nextguess is <em>y</em><sub>3</sub>  =  <em>x</em>/<em>y</em><sub>2</sub>  =  <em>x</em>/(<em>x</em>/<em>y</em><sub>1</sub>)  =  <em>y</em><sub>1</sub>.  This results in an infiniteloop in which the two guesses <em>y</em><sub>1</sub> and <em>y</em><sub>2</sub> repeat over and over,oscillating about the answer.</p>
<p>One way to control such oscillations is to prevent the guesses fromchanging so much.Since the answer is always between our guess <em>y</em>and <em>x</em>/<em>y</em>, we can make a new guess that is not as far from <em>y</em> as <em>x</em>/<em>y</em>by averaging <em>y</em> with <em>x</em>/<em>y</em>, so that the next guess after<em>y</em> is (1/2)(<em>y</em> + <em>x</em>/<em>y</em>) instead of <em>x</em>/<em>y</em>.The process of making such a sequence of guesses is simply the processof looking for a fixed point of <em>y</em>  ⟼  (1/2)(<em>y</em> + <em>x</em>/<em>y</em>):</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_1126" id="%_idx_1126"></a>(define (sqrt x)
  (fixed-point (lambda (y) (average y (/ x y)))
               1.0))
</pre></p>
<p></p>
<p>(Note that <em>y</em> = (1/2)(<em>y</em> + <em>x</em>/<em>y</em>) is a simple transformation of theequation <em>y</em> = <em>x</em>/<em>y</em>; to derive it, add <em>y</em> to both sides of the equationand divide by 2.)</p>
<p>With this modification, the square-root procedure works.  In fact, ifwe unravel the definitions, we can see that the sequence ofapproximations to the square root generated here is precisely thesame as the one generated by our original square-root procedure ofsection <a href="book-Z-H-10.html#%_sec_1.1.7">1.1.7</a>.  This approach of averagingsuccessive approximations to a solution, a technique we that we call<a name="%_idx_1128" id="%_idx_1128"></a><em>average damping</em>, often aids the convergence of fixed-pointsearches.</p>
<p></p>
<p><a name="%_thm_1.35" id="%_thm_1.35"></a><b>Exercise 1.35.</b>  <a name="%_idx_1130" id="%_idx_1130"></a><a name="%_idx_1132" id="%_idx_1132"></a>Show that the golden ratio <em>φ</em> (section <a href="book-Z-H-11.html#%_sec_1.2.2">1.2.2</a>)is a fixed point of the transformation <em>x</em>  ⟼  1  +  1/<em>x</em>, and usethis fact to compute <em>φ</em> by means of the <code>fixed-point</code>procedure.</p>
<p></p>
<p></p>
<p><a name="%_thm_1.36" id="%_thm_1.36"></a><b>Exercise 1.36.</b>  Modify <code>fixed-point</code> so that it prints the sequence ofapproximations it generates, usingthe <code>newline</code> and <code>display</code> primitives shown inexercise <a href="book-Z-H-11.html#%_thm_1.22">1.22</a>.  Then find a solution to <em>x</em><sup><em>x</em></sup>  =1000 by finding a fixed point of <em>x</em>  ⟼  <code>log</code>(1000)/<code>log</code>(<em>x</em>).  (UseScheme's <a name="%_idx_1134" id="%_idx_1134"></a><a name="%_idx_1136" id="%_idx_1136"></a>primitive <code>log</code> procedure, which computes naturallogarithms.)  Compare the number of steps this takes with and withoutaverage damping.  (Note that you cannot start <code>fixed-point</code> with aguess of 1, as this would cause division by <code>log</code>(1) = 0.)</p>
<p></p>
<p></p>
<p><a name="%_thm_1.37" id="%_thm_1.37"></a><b>Exercise 1.37.</b>  <a name="%_idx_1138" id="%_idx_1138"></a>a. An infinite <em>continued fraction</em> is an expression of the form</p>
<p></p>
<div align="left"><img src="images/ch1-Z-G-34.svg" border="0"></div>
<p><a name="%_idx_1140" id="%_idx_1140"></a><a name="%_idx_1142" id="%_idx_1142"></a>As an example, one can show that the infinite continued fractionexpansion with the <em>N</em><sub><em>i</em></sub> and the <em>D</em><sub><em>i</em></sub> all equal to 1 produces1/<em>φ</em>, where <em>φ</em> is the golden ratio (described insection <a href="book-Z-H-11.html#%_sec_1.2.2">1.2.2</a>).One way to approximate aninfinite continued fraction is to truncate the expansion after a givennumber of terms.  Such a truncation – a so-called <em><em>k</em>-term finitecontinued fraction</em> – has the form</p>
<p></p>
<div align="left"><img src="images/ch1-Z-G-35.gif" border="0"></div>
<p>Suppose that <code>n</code> and <code>d</code> are procedures of one argument (theterm index <em>i</em>) that return the <em>N</em><sub><em>i</em></sub> and <em>D</em><sub><em>i</em></sub> of the terms of thecontinued fraction.  Define a procedure <code>cont-frac</code>such that evaluating <code>(cont-frac n d k)</code>computes the value of the <em>k</em>-term finitecontinued fraction.  Check your procedure by approximating 1/<em>φ</em> using</p>
<p></p>
<p><pre>(cont-frac (lambda (i) 1.0)
           (lambda (i) 1.0)
           k)
</pre></p>
<p></p>
<p>for successive values of <code>k</code>.  How large must you make <code>k</code>in order to get an approximation that is accurate to 4 decimal places?</p>
<p></p>
<p></p>
<p>b. If your <code>cont-frac</code>procedure generates a recursive process, write one that generatesan iterative process.If it generates an iterative process, write one that generatesa recursive process.</p>
<p></p>
<p></p>
<p><a name="%_thm_1.38" id="%_thm_1.38"></a><b>Exercise 1.38.</b>  <a name="%_idx_1144" id="%_idx_1144"></a>In 1737, the Swiss mathematician Leonhard Euler published a memoir<em>De Fractionibus Continuis</em>, which included a <a name="%_idx_1146" id="%_idx_1146"></a><a name="%_idx_1148" id="%_idx_1148"></a>continued fractionexpansion for <em>e</em> - 2, where <em>e</em> is the base of the natural logarithms.In this fraction, the <em>N</em><sub><em>i</em></sub> are all 1, and the <em>D</em><sub><em>i</em></sub> are successively1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8, <code>...</code>.  Write a program that usesyour <code>cont-frac</code> procedure fromexercise <a href="#%_thm_1.37">1.37</a> to approximate <em>e</em>, based onEuler's expansion.</p>
<p></p>
<p></p>
<p><a name="%_thm_1.39" id="%_thm_1.39"></a><b>Exercise 1.39.</b>  <a name="%_idx_1150" id="%_idx_1150"></a><a name="%_idx_1152" id="%_idx_1152"></a><a name="%_idx_1154" id="%_idx_1154"></a>A continued fraction representation of the tangent function waspublished in 1770 by the German mathematician J.H. Lambert:</p>
<p></p>
<div align="left"><img src="images/ch1-Z-G-36.gif" border="0"></div>
<p>where <em>x</em> is in radians.Define a procedure <code>(tan-cf x k)</code> that computes an approximationto the tangent function based on Lambert'sformula.  <code>K</code> specifies the number of terms to compute, as inexercise <a href="#%_thm_1.37">1.37</a>.</p>
<p></p>
<p><a name="%_sec_1.3.4" id="%_sec_1.3.4"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_1.3.4">1.3.4  Procedures as Returned Values</a></h3>
<p><a name="%_idx_1156" id="%_idx_1156"></a><a name="%_idx_1158" id="%_idx_1158"></a>The above examples demonstrate howthe ability to pass procedures as arguments significantly enhancesthe expressive power of our programming language.  We can achieve evenmore expressive power by creating procedures whose returned values arethemselves procedures.</p>
<p>We can illustrate this idea by looking again at the fixed-pointexample described at the end ofsection <a href="#%_sec_1.3.3">1.3.3</a>.  We formulated a new versionof the square-root procedure as a fixed-point search, starting withthe observation that √<em>x</em> is a fixed-point of the function<em>y</em> ⟼  <em>x</em>/<em>y</em>.  Then we used average damping to make theapproximations converge.  Average damping is a useful generaltechnique in itself.  Namely, given a function <em>f</em>, we consider thefunction whose value at <em>x</em> is equal to the average of <em>x</em> and <em>f</em>(<em>x</em>).</p>
<p>We can express the idea of average damping by means of thefollowing procedure:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_1160" id="%_idx_1160"></a>(define (average-damp f)
  (lambda (x) (average x (f x))))
</pre></p>
<p></p>
<p><code>Average-damp</code> is a procedure that takes as its argument aprocedure <code>f</code> and returns as its value a procedure (produced bythe <code>lambda</code>) that, when applied to a number <code>x</code>, produces theaverage of <code>x</code> and <code>(f x)</code>.  For example, applying <code>average-damp</code> to the <code>square</code> procedure produces a procedure whosevalue at some number <em>x</em> is the average of <em>x</em> and <em>x</em><sup>2</sup>.  Applyingthis resulting procedure to 10 returns the average of 10 and 100, or55:<a name="call_footnote_Temp_114" href="#footnote_Temp_114" id="call_footnote_Temp_114"><sup><small>59</small></sup></a></p>
<p></p>
<p></p>
<p><pre>((average-damp square) 10)
<i>55</i>
</pre></p>
<p></p>
<p></p>
<p><a name="%_idx_1168" id="%_idx_1168"></a>Using <code>average-damp</code>, we can reformulate the square-root procedureas follows:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_1170" id="%_idx_1170"></a>(define (sqrt x)
  (fixed-point (average-damp (lambda (y) (/ x y)))
               1.0))
</pre></p>
<p></p>
<p>Notice how this formulation makes explicit the three ideas in themethod: fixed-point search, average damping, and the function<em>y</em> ⟼  <em>x</em>/<em>y</em>.  It is instructive to compare this formulation of thesquare-root method with the original version given insection <a href="book-Z-H-10.html#%_sec_1.1.7">1.1.7</a>.  Bear in mind that these procedures expressthe same process, and notice how much clearer the idea becomes when weexpress the process in terms of these abstractions.  In general, thereare many ways to formulate a process as a procedure.  Experiencedprogrammers know how to choose procedural formulations that areparticularly perspicuous, and where useful elements of the process areexposed as separate entities that can be reused in other applications.As a simple example of reuse, notice that the cube root of <em>x</em> is afixed point of the function <em>y</em> ⟼  <em>x</em>/<em>y</em><sup>2</sup>, so we can immediatelygeneralize our square-root procedure to one that extracts <a name="%_idx_1172" id="%_idx_1172"></a><a name="%_idx_1174" id="%_idx_1174"></a>cuberoots:<a name="call_footnote_Temp_115" href="#footnote_Temp_115" id="call_footnote_Temp_115"><sup><small>60</small></sup></a></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_1176" id="%_idx_1176"></a>(define (cube-root x)
  (fixed-point (average-damp (lambda (y) (/ x (square y))))
               1.0))
</pre></p>
<p></p>
<p></p>
<p><a name="%_sec_Temp_116" id="%_sec_Temp_116"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_116">Newton's method</a></h4>
<p><a name="%_idx_1178" id="%_idx_1178"></a>When we first introduced the square-root procedure, insection <a href="book-Z-H-10.html#%_sec_1.1.7">1.1.7</a>, we mentioned that this was a special case of<em>Newton's method</em>.If <em>x</em> ⟼  <em>g</em>(<em>x</em>) is a differentiable function, then a solution ofthe equation <em>g</em>(<em>x</em>) = 0 is a fixed point of the function <em>x</em> ⟼  <em>f</em>(<em>x</em>)where</p>
<p></p>
<div align="left"><img src="images/ch1-Z-G-37.gif" border="0"></div>
<p>and<em>D</em><em>g</em>(<em>x</em>) is the derivative of <em>g</em> evaluated at <em>x</em>.  <a name="%_idx_1180" id="%_idx_1180"></a>Newton'smethod is the use of the fixed-point method we saw above toapproximate a solution of the equation by finding a fixed point ofthe function <em>f</em>.<a name="call_footnote_Temp_117" href="#footnote_Temp_117" id="call_footnote_Temp_117"><sup><small>61</small></sup></a>For many functions <em>g</em> and for sufficiently good initial guesses for<em>x</em>, Newton's method converges very rapidly to a solution of<em>g</em>(<em>x</em>) = 0.<a name="call_footnote_Temp_118" href="#footnote_Temp_118" id="call_footnote_Temp_118"><sup><small>62</small></sup></a></p>
<p><a name="%_idx_1186" id="%_idx_1186"></a><a name="%_idx_1188" id="%_idx_1188"></a><a name="%_idx_1190" id="%_idx_1190"></a>In order to implement Newton's method as a procedure, we must firstexpress the idea of derivative.  Note that “derivative,” likeaverage damping, is something that transforms a function into anotherfunction.  For instance, the derivative of the function <em>x</em> ⟼<em>x</em><sup>3</sup> is the function <em>x</em>  ⟼  3<em>x</em><sup>2</sup>.  In general, if <em>g</em> is afunction and <em>d</em><em>x</em> is a small number, then the derivative <em>D</em><em>g</em> of <em>g</em> isthe function whose value at any number <em>x</em> is given (in the limit ofsmall <em>d</em><em>x</em>) by</p>
<p></p>
<div align="left"><img src="images/ch1-Z-G-38.gif" border="0"></div>
<p>Thus, we can express the idea of derivative (taking <em>d</em><em>x</em> to be, say,0.00001) as the procedure</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_1192" id="%_idx_1192"></a>(define (deriv g)
  (lambda (x)
    (/ (- (g (+ x dx)) (g x))
       dx)))
</pre></p>
<p></p>
<p>along with the definition</p>
<p></p>
<p></p>
<p><pre>(define dx 0.00001)
</pre></p>
<p></p>
<p></p>
<p>Like <code>average-damp</code>, <code>deriv</code> is a procedure that takes aprocedure as argument and returns a procedure as value.  For example,to approximate the derivative of <em>x</em>  ⟼  <em>x</em><sup>3</sup> at 5 (whose exactvalue is 75) we can evaluate</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_1194" id="%_idx_1194"></a>(define (cube x) (* x x x))
((deriv cube) 5)
<i>75.00014999664018</i>
</pre></p>
<p></p>
<p></p>
<p>With the aid of <code>deriv</code>, we can express Newton's method as afixed-point process:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_1196" id="%_idx_1196"></a>(define (newton-transform g)
  (lambda (x)
    (- x (/ (g x) ((deriv g) x)))))
<a name="%_idx_1198" id="%_idx_1198"></a>(define (newtons-method g guess)
  (fixed-point (newton-transform g) guess))
</pre></p>
<p></p>
<p>The <code>newton-transform</code> procedure expresses the formula at thebeginning of this section, and <code>newtons-method</code> is readily definedin terms of this.  It takes as arguments a procedure that computes thefunction for which we want to find a zero, together with an initialguess.  For instance, to find the <a name="%_idx_1200" id="%_idx_1200"></a>square root of <em>x</em>, we can useNewton's method to find a zero of the function <em>y</em> ⟼  <em>y</em><sup>2</sup> - <em>x</em> starting withan initial guess of 1.<a name="call_footnote_Temp_119" href="#footnote_Temp_119" id="call_footnote_Temp_119"><sup><small>63</small></sup></a>This provides yet another form of the square-rootprocedure:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_1202" id="%_idx_1202"></a>(define (sqrt x)
  (newtons-method (lambda (y) (- (square y) x))
                  1.0))
</pre></p>
<p></p>
<p></p>
<p><a name="%_sec_Temp_120" id="%_sec_Temp_120"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_120">Abstractions and first-class procedures</a></h4>
<p>We've seen two ways to express the square-rootcomputation as an instance of a more general method, once as a fixed-pointsearch and once using Newton's method.  Since Newton's methodwas itself expressed as a fixed-point process,we actually saw two ways to compute square roots as fixed points.Each method begins with a function and finds a <a name="%_idx_1204" id="%_idx_1204"></a>fixedpoint of some transformation of the function.  We can express thisgeneral idea itself as a procedure:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_1206" id="%_idx_1206"></a>(define (fixed-point-of-transform g transform guess)
  (fixed-point (transform g) guess))
</pre></p>
<p></p>
<p>This very general procedure takes as its arguments a procedure <code>g</code>that computes some function, a procedure that transforms <code>g</code>, andan initial guess.  The returned result is a fixed point of thetransformed function.</p>
<p><a name="%_idx_1208" id="%_idx_1208"></a>Using this abstraction, we can recast the first square-rootcomputation from this section (where we look fora fixed point of the average-damped version of <em>y</em>  ⟼  <em>x</em>/<em>y</em>)as an instance of this general method:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_1210" id="%_idx_1210"></a>(define (sqrt x)
  (fixed-point-of-transform (lambda (y) (/ x y))
                            average-damp
                            1.0))
</pre></p>
<p></p>
<p><a name="%_idx_1212" id="%_idx_1212"></a>Similarly, we can express the second square-root computation from this section(an instanceof Newton's method that finds a fixed point of theNewton transform of <em>y</em> ⟼  <em>y</em><sup>2</sup> - <em>x</em>) as</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_1214" id="%_idx_1214"></a><a name="%_idx_1216" id="%_idx_1216"></a>(define (sqrt x)
  (fixed-point-of-transform (lambda (y) (- (square y) x))
                            newton-transform
                            1.0))
</pre></p>
<p></p>
<p></p>
<p>We began section <a href="#%_sec_1.3">1.3</a> with the observationthat compound proceduresare a crucial abstraction mechanism, because they permit us toexpress general methods of computing as explicit elements in ourprogramming language.  Now we've seen how higher-orderprocedures permit us to manipulate these general methodsto create further abstractions.</p>
<p>As programmers, we should be alert to opportunities to identify theunderlying abstractions in our programs and to build upon them andgeneralize them to create more powerful abstractions.  This is not tosay that one should always write programs in the most abstract waypossible; expert programmers know how to choose the level ofabstraction appropriate to their task.  But it is important to be ableto think in terms of these abstractions, so that we can be ready toapply them in new contexts.  The significance of higher-orderprocedures is that they enable us to represent these abstractionsexplicitly as elements in our programming language, so that they canbe handled just like other computational elements.</p>
<p>In general, programming languages impose restrictions on the ways inwhich computational elements can be manipulated.  Elements with thefewest restrictions are said to have <a name="%_idx_1218" id="%_idx_1218"></a><em>first-class</em> status.  Someof the “rights and privileges” of first-class elements are:<a name="call_footnote_Temp_121" href="#footnote_Temp_121" id="call_footnote_Temp_121"><sup><small>64</small></sup></a></p>
<p></p>
<ul>
<li>They may be named by variables.</li>
<li>They may be passed as arguments to procedures.</li>
<li>They may be returned as the results of procedures.</li>
<li>They may be included in data structures.<a name="call_footnote_Temp_122" href="#footnote_Temp_122" id="call_footnote_Temp_122"><sup><small>65</small></sup></a></li>
</ul>
<p><a name="%_idx_1222" id="%_idx_1222"></a><a name="%_idx_1224" id="%_idx_1224"></a>Lisp, unlike other common programming languages, awards proceduresfull first-class status.  This poses challenges for efficientimplementation, but the resulting gain in expressive power isenormous.<a name="call_footnote_Temp_123" href="#footnote_Temp_123" id="call_footnote_Temp_123"><sup><small>66</small></sup></a></p>
<p></p>
<p><a name="%_thm_1.40" id="%_thm_1.40"></a><b>Exercise 1.40.</b>  Define a procedure <code>cubic</code> that can be used together with the <code>newtons-method</code> procedure in expressions of the form</p>
<p></p>
<p></p>
<p><pre>(newtons-method (cubic a b c) 1)
</pre></p>
<p></p>
<p>to approximate zeros of the cubic <em>x</em><sup>3</sup>  + <em>a</em><em>x</em><sup>2</sup>  + <em>b</em><em>x</em>  + <em>c</em>.</p>
<p></p>
<p></p>
<p><a name="%_thm_1.41" id="%_thm_1.41"></a><b>Exercise 1.41.</b>  Define a procedure <code>double</code> that takes a procedure of oneargument as argument andreturns a procedure that applies the original procedure twice.  Forexample, if <code>inc</code> is a procedure that adds 1 to its argument,then <code>(double inc)</code> should be a procedure that adds 2.  Whatvalue is returned by</p>
<p></p>
<p></p>
<p><pre>(((double (double double)) inc) 5)
</pre></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_1.42" id="%_thm_1.42"></a><b>Exercise 1.42.</b>  <a name="%_idx_1226" id="%_idx_1226"></a><a name="%_idx_1228" id="%_idx_1228"></a>Let <em>f</em> and <em>g</em> be two one-argument functions.  The <em>composition</em><em>f</em> after <em>g</em> is defined to be the function <em>x</em> ⟼  <em>f</em>(<em>g</em>(<em>x</em>)).Define a procedure <code>compose</code> that implements composition.  Forexample, if <code>inc</code> is a procedure that adds 1 to its argument,</p>
<p></p>
<p><pre>((compose square inc) 6)
<i>49</i>
</pre></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_1.43" id="%_thm_1.43"></a><b>Exercise 1.43.</b>  <a name="%_idx_1230" id="%_idx_1230"></a>If <em>f</em> is a numerical function and <em>n</em> is a positive integer, then wecan form the <em>n</em>th repeated application of <em>f</em>, which is defined to bethe function whose value at <em>x</em> is <em>f</em>(<em>f</em>(<code>...</code>(<em>f</em>(<em>x</em>))<code>...</code>)).  Forexample, if <em>f</em> is the function <em>x</em>  ⟼  <em>x</em> + 1,then the <em>n</em>th repeated application of <em>f</em> isthe function <em>x</em>  ⟼  <em>x</em> + <em>n</em>.  If <em>f</em> is the operation ofsquaring a number, then the <em>n</em>th repeated application of <em>f</em> is thefunction that raises its argument to the 2<sup><em>n</em></sup>th power.  Write aprocedure that takes as inputs a procedure that computes <em>f</em> and apositive integer <em>n</em> and returns the procedure that computes the <em>n</em>threpeated application of <em>f</em>.  Your procedure should be able to be usedas follows:</p>
<p></p>
<p></p>
<p><pre>((repeated square 2) 5)
<i>625</i>
</pre></p>
<p></p>
<p>Hint: You may find it convenient to use <code>compose</code> fromexercise <a href="#%_thm_1.42">1.42</a>.</p>
<p></p>
<p></p>
<p><a name="%_thm_1.44" id="%_thm_1.44"></a><b>Exercise 1.44.</b>  <a name="%_idx_1232" id="%_idx_1232"></a><a name="%_idx_1234" id="%_idx_1234"></a><a name="%_idx_1236" id="%_idx_1236"></a>The idea of <em>smoothing</em> a function is an important concept insignal processing.  If <em>f</em> is a function and <em>d</em><em>x</em> is some small number,then the smoothed version of <em>f</em> is the function whose value at apoint <em>x</em> is the average of <em>f</em>(<em>x</em> - <em>d</em><em>x</em>), <em>f</em>(<em>x</em>), and <em>f</em>(<em>x</em> + <em>d</em><em>x</em>).  Write aprocedure <code>smooth</code> that takes as input a procedure that computes<em>f</em> and returns a procedure that computes the smoothed <em>f</em>.  It issometimes valuable to repeatedly smooth a function (that is, smooththe smoothed function, and so on) to obtained the <em><em>n</em>-foldsmoothed function</em>.  Show how to generate the <em>n</em>-fold smoothedfunction of any given function using <code>smooth</code> and <code>repeated</code>from exercise <a href="#%_thm_1.43">1.43</a>.</p>
<p></p>
<p></p>
<p><a name="%_thm_1.45" id="%_thm_1.45"></a><b>Exercise 1.45.</b>  We saw in section <a href="#%_sec_1.3.3">1.3.3</a>that attempting to compute square roots by naively finding afixed point of <em>y</em> ⟼  <em>x</em>/<em>y</em> does not converge, and that this can befixed by average damping.  The same method works for finding cuberoots as fixed points of the average-damped <em>y</em> ⟼  <em>x</em>/<em>y</em><sup>2</sup>.Unfortunately, the process does not work for <a name="%_idx_1238" id="%_idx_1238"></a><a name="%_idx_1240" id="%_idx_1240"></a>fourth roots – a singleaverage damp is not enough to make a fixed-point search for <em>y</em> ⟼<em>x</em>/<em>y</em><sup>3</sup> converge.  On the other hand, if we average damp twice (i.e.,use the average damp of the average damp of <em>y</em> ⟼  <em>x</em>/<em>y</em><sup>3</sup>) thefixed-point search does converge.  Do some experiments to determinehow many average damps are required to compute <a name="%_idx_1242" id="%_idx_1242"></a><a name="%_idx_1244" id="%_idx_1244"></a><em>n</em>th roots as afixed-point search based upon repeated average damping of <em>y</em> ⟼<em>x</em>/<em>y</em><sup><em>n</em>-1</sup>.  Use this to implement a simple procedure for computing<em>n</em>th roots using <code>fixed-point</code>, <code>average-damp</code>, and the <code>repeated</code> procedure of exercise <a href="#%_thm_1.43">1.43</a>.Assume that any arithmetic operations you need are available as primitives.</p>
<p></p>
<p></p>
<p><a name="%_thm_1.46" id="%_thm_1.46"></a><b>Exercise 1.46.</b>  <a name="%_idx_1246" id="%_idx_1246"></a><a name="%_idx_1248" id="%_idx_1248"></a><a name="%_idx_1250" id="%_idx_1250"></a><a name="%_idx_1252" id="%_idx_1252"></a>Several of the numerical methods described in this chapter are instancesof an extremely general computational strategy known as <em>iterativeimprovement</em>.  Iterative improvement says that, to compute something,we start with an initial guess for the answer, test if the guess isgood enough, and otherwise improve the guess and continue the processusing the improved guess as the new guess.  Write a procedure <code>iterative-improve</code> that takes two procedures as arguments: a methodfor telling whether a guess is good enough and a method for improvinga guess.  <code>Iterative-improve</code> should return as its value aprocedure that takes a guess as argument and keeps improving the guessuntil it is good enough.  Rewrite the <code>sqrt</code> procedure ofsection <a href="book-Z-H-10.html#%_sec_1.1.7">1.1.7</a> and the <code>fixed-point</code> procedure ofsection <a href="#%_sec_1.3.3">1.3.3</a> in terms of <code>iterative-improve</code>.</p>
<p></p>
<p></p>
<p></p>
<div class="smallprint"><hr></div>
<p></p>
<div class="footnote">
<p><a name="footnote_Temp_90" href="#call_footnote_Temp_90" id="footnote_Temp_90"><sup><small>49</small></sup></a> This series,<a name="%_idx_974" id="%_idx_974"></a><a name="%_idx_976" id="%_idx_976"></a>usually written in the equivalent form (π/4)  =  1 - (1/3) + (1/5) - (1/7) + <code>···</code>, is due to Leibniz.  We'll see howto use this as the basis for some fancy numerical tricks insection <a href="book-Z-H-24.html#%_sec_3.5.3">3.5.3</a>.</p>
<p><a name="footnote_Temp_91" href="#call_footnote_Temp_91" id="footnote_Temp_91"><sup><small>50</small></sup></a> Noticethat we have used block structure (section <a href="book-Z-H-10.html#%_sec_1.1.8">1.1.8</a>) toembed the definitions of <code>pi-next</code> and <code>pi-term</code> within <code>pi-sum</code>, since these procedures are unlikely to be useful for anyother purpose.  We will see how to get rid of them altogether insection <a href="#%_sec_1.3.2">1.3.2</a>.</p>
<p><a name="footnote_Temp_95" href="#call_footnote_Temp_95" id="footnote_Temp_95"><sup><small>51</small></sup></a> The intent ofexercises <a href="#%_thm_1.31">1.31</a>-<a href="#%_thm_1.33">1.33</a> is todemonstrate the expressive power that is attained by using anappropriate abstraction to consolidate many seemingly disparateoperations.  However, though accumulation and filtering are elegantideas, our hands are somewhat tied in using them at this point sincewe do not yet have data structures to provide suitable means ofcombination for these abstractions.  We will return to these ideas insection <a href="book-Z-H-15.html#%_sec_2.2.3">2.2.3</a> when we show howto use <em>sequences</em> as interfaces for combining filters andaccumulators to build even more powerful abstractions.  We will seethere how these methods really come into their own as a powerful andelegant approach to designing programs.</p>
<p><a name="footnote_Temp_96" href="#call_footnote_Temp_96" id="footnote_Temp_96"><sup><small>52</small></sup></a> This formula was discovered by the seventeenth-century<a name="%_idx_1016" id="%_idx_1016"></a>English mathematician John Wallis.</p>
<p><a name="footnote_Temp_99" href="#call_footnote_Temp_99" id="footnote_Temp_99"><sup><small>53</small></sup></a> It would be clearer and less intimidating topeople learning Lisp if a name more obvious than <code>lambda</code>, such as<code>make-procedure</code>, were used.  But the convention is firmlyentrenched.  The notation is adopted from the <a name="%_idx_1054" id="%_idx_1054"></a>λ calculus, a<a name="%_idx_1056" id="%_idx_1056"></a>mathematical formalism introduced by the mathematical logician AlonzoChurch (1941).  Church developed the λ calculus to provide arigorous foundation for studying the notions of function and functionapplication.  The λ calculus has become a basic tool formathematical investigations of the semantics of programminglanguages.</p>
<p><a name="footnote_Temp_101" href="#call_footnote_Temp_101" id="footnote_Temp_101"><sup><small>54</small></sup></a> Understanding internal definitions well enough to be sure aprogram means what we intend it to mean requires a more elaboratemodel of the evaluation process than we have presented in thischapter.  The subtleties do not arise with internal definitions ofprocedures, however.  We will return to this issue insection <a href="book-Z-H-26.html#%_sec_4.1.6">4.1.6</a>, after we learn more aboutevaluation.</p>
<p><a name="footnote_Temp_104" href="#call_footnote_Temp_104" id="footnote_Temp_104"><sup><small>55</small></sup></a> We have used 0.001 as a representative “small” number to indicate atolerance for the acceptable error in a calculation.  The appropriatetolerance for a real calculation depends upon the problem to be solvedand the limitations of the computer and the algorithm.  This is often<a name="%_idx_1086" id="%_idx_1086"></a>a very subtle consideration, requiring help from a numerical analystor some other kind of magician.</p>
<p><a name="footnote_Temp_105" href="#call_footnote_Temp_105" id="footnote_Temp_105"><sup><small>56</small></sup></a> This<a name="%_idx_1088" id="%_idx_1088"></a><a name="%_idx_1090" id="%_idx_1090"></a>can be accomplished using <code>error</code>, which takes asarguments a number of items that are printed as errormessages.</p>
<p><a name="footnote_Temp_107" href="#call_footnote_Temp_107" id="footnote_Temp_107"><sup><small>57</small></sup></a> Try this during a boring lecture: Set your calculator to<a name="%_idx_1106" id="%_idx_1106"></a><a name="%_idx_1108" id="%_idx_1108"></a><a name="%_idx_1110" id="%_idx_1110"></a>radians mode and then repeatedly press the <code>cos</code> button until youobtain the fixed point.</p>
<p><a name="footnote_Temp_108" href="#call_footnote_Temp_108" id="footnote_Temp_108"><sup><small>58</small></sup></a>  ⟼<a name="%_idx_1122" id="%_idx_1122"></a><a name="%_idx_1124" id="%_idx_1124"></a>(pronounced “maps to”) isthe mathematician's way of writing <code>lambda</code>.<em>y</em>  ⟼  <em>x</em>/<em>y</em> means <code>(lambda(y) (/ x y))</code>, that is, thefunction whose value at <em>y</em> is <em>x</em>/<em>y</em>.</p>
<p><a name="footnote_Temp_114" href="#call_footnote_Temp_114" id="footnote_Temp_114"><sup><small>59</small></sup></a> Observe that this is a combination whose operator is itself<a name="%_idx_1162" id="%_idx_1162"></a><a name="%_idx_1164" id="%_idx_1164"></a><a name="%_idx_1166" id="%_idx_1166"></a>a combination.  Exercise <a href="book-Z-H-10.html#%_thm_1.4">1.4</a> already demonstratedthe ability to form such combinations, but that was only a toyexample.  Here we begin to see the real need for suchcombinations – when applying a procedure that is obtained as the valuereturned by a higher-order procedure.</p>
<p><a name="footnote_Temp_115" href="#call_footnote_Temp_115" id="footnote_Temp_115"><sup><small>60</small></sup></a> See exercise <a href="#%_thm_1.45">1.45</a> for a furthergeneralization.</p>
<p><a name="footnote_Temp_117" href="#call_footnote_Temp_117" id="footnote_Temp_117"><sup><small>61</small></sup></a> Elementary calculus books usually describe Newton'smethod in terms of the sequence of approximations<em>x</em><sub><em>n</em>+1</sub> = <em>x</em><sub><em>n</em></sub> - <em>g</em>(<em>x</em><sub><em>n</em></sub>)/<em>D</em><em>g</em>(<em>x</em><sub><em>n</em></sub>).  Having language for talking aboutprocesses and using the idea of fixed points simplifies the descriptionof the method.</p>
<p><a name="footnote_Temp_118" href="#call_footnote_Temp_118" id="footnote_Temp_118"><sup><small>62</small></sup></a> Newton's method does not always converge to an answer, butit can be shown that in favorable cases each iteration doubles thenumber-of-digits accuracy of the approximation to the solution.In such cases, <a name="%_idx_1182" id="%_idx_1182"></a><a name="%_idx_1184" id="%_idx_1184"></a>Newton's method will converge much morerapidly than the half-interval method.</p>
<p><a name="footnote_Temp_119" href="#call_footnote_Temp_119" id="footnote_Temp_119"><sup><small>63</small></sup></a> For finding square roots, Newton's method converges rapidly to thecorrect solution from any starting point.</p>
<p><a name="footnote_Temp_121" href="#call_footnote_Temp_121" id="footnote_Temp_121"><sup><small>64</small></sup></a> The notion of first-class status of programming-language<a name="%_idx_1220" id="%_idx_1220"></a>elements is due to the British computer scientist ChristopherStrachey (1916-1975).</p>
<p><a name="footnote_Temp_122" href="#call_footnote_Temp_122" id="footnote_Temp_122"><sup><small>65</small></sup></a> We'll seeexamples of this after we introduce data structures in chapter 2.</p>
<p><a name="footnote_Temp_123" href="#call_footnote_Temp_123" id="footnote_Temp_123"><sup><small>66</small></sup></a> The major implementation cost of first-classprocedures is that allowing procedures to be returned as valuesrequires reserving storage for a procedure's free variables even whilethe procedure is not executing.  In the Scheme implementation we willstudy in section <a href="book-Z-H-26.html#%_sec_4.1">4.1</a>, these variables are stored in theprocedure's environment.</p>
</div></body>
</html>
