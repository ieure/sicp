<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<?xml version="1.0" encoding="utf-8"?><html xmlns="http://www.w3.org/1999/xhtml" xmlns:ops="http://www.idpf.org/2007/ops">
<!-- Generated from TeX source by tex2page, v 4o,
     (c) Dorai Sitaram, http://www.cs.rice.edu/~dorai/tex2page --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Type: text/html; charset=utf-8">
<title>Structure and Interpretation of Computer Programs</title>
<link rel="stylesheet" type="text/css" href="book-Z-C.css" title="default">
</head>
<body><a name="%_sec_4.2" id="%_sec_4.2"></a><h2><a href="book-Z-H-4.html#%_toc_%_sec_4.2">4.2  Variations on a Scheme – Lazy Evaluation</a></h2>
<p><a name="%_idx_4666" id="%_idx_4666"></a><a name="%_idx_4668" id="%_idx_4668"></a><a name="%_idx_4670" id="%_idx_4670"></a><a name="%_idx_4672" id="%_idx_4672"></a>Now that we have an evaluator expressed as a Lisp program, we canexperiment with alternative choices in language design simply bymodifying the evaluator.  Indeed, new languages are often invented byfirst writing an evaluator that embeds the new language within anexisting high-level language.  For example, if we wish to discuss someaspect of a proposed modification to Lisp with another member of theLisp community, we can supply an evaluator that embodiesthe change.  The recipient can then experiment with the newevaluator and send back comments as further modifications.  Not onlydoes the high-level implementation base make it easier to test anddebug the evaluator; in addition, the embedding enables the designerto snarf<a name="call_footnote_Temp_575" href="#footnote_Temp_575" id="call_footnote_Temp_575"><sup><small>31</small></sup></a> featuresfrom the underlying language, just as our embedded Lisp evaluatoruses primitives and control structure from the underlying Lisp.  Onlylater (if ever) need the designer go to the trouble of building acomplete implementation in a low-level language or in hardware.  Inthis section and the next we explore some variations on Scheme thatprovide significant additional expressive power.</p>
<p><a name="%_sec_4.2.1" id="%_sec_4.2.1"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_4.2.1">4.2.1  Normal Order and Applicative Order</a></h3>
<p></p>
<p><a name="%_idx_4680" id="%_idx_4680"></a><a name="%_idx_4682" id="%_idx_4682"></a>In section <a href="book-Z-H-10.html#%_sec_1.1">1.1</a>, where we began our discussionof models of evaluation, we noted that Scheme is an <em>applicative-order</em> language, namely, that all the arguments to Schemeprocedures are evaluated when the procedure is applied.  Incontrast, <em>normal-order</em> languages delay evaluation of procedure argumentsuntil the actual argument values are needed.Delaying evaluation of procedure arguments until thelast possible moment (e.g., until they are required by a primitiveoperation) is called <a name="%_idx_4684" id="%_idx_4684"></a><em>lazy evaluation</em>.<a name="call_footnote_Temp_576" href="#footnote_Temp_576" id="call_footnote_Temp_576"><sup><small>32</small></sup></a>Consider the procedure</p>
<p></p>
<p></p>
<p><pre>(define (try a b)
  (if (= a 0) 1 b))
</pre></p>
<p></p>
<p>Evaluating <code>(try 0 (/ 1 0))</code> generates an error in Scheme.  Withlazy evaluation, there would be no error.  Evaluating the expressionwould return 1, because the argument <code>(/ 1 0)</code> wouldnever be evaluated.</p>
<p>An example that exploits lazy evaluation is thedefinition of a procedure <code>unless</code></p>
<p></p>
<p></p>
<p><pre>(define (unless condition usual-value exceptional-value)
  (if condition exceptional-value usual-value))
</pre></p>
<p></p>
<p>that can be used in expressions such as</p>
<p></p>
<p></p>
<p><pre>(unless (= b 0)
        (/ a b)
        (begin (display "exception: returning 0")
               0))
</pre></p>
<p></p>
<p>This won't work in an applicative-order language because both theusual value and the exceptional value will be evaluated before<code>unless</code> is called (compare exercise <a href="book-Z-H-10.html#%_thm_1.6">1.6</a>).  Anadvantage of lazy evaluation is that some procedures, such as <code>unless</code>, can do useful computation even if evaluation of some of theirarguments would produce errors or would not terminate.</p>
<p>If the body of a procedure is entered before an argument has beenevaluated we say that the procedure is <a name="%_idx_4686" id="%_idx_4686"></a><em>non-strict</em> in thatargument.  If the argument is evaluated before the body of theprocedure is entered we say that the procedure is <a name="%_idx_4688" id="%_idx_4688"></a><em>strict</em> in thatargument.<a name="call_footnote_Temp_577" href="#footnote_Temp_577" id="call_footnote_Temp_577"><sup><small>33</small></sup></a>In a purely applicative-order language, all procedures are strict ineach argument.  In a purely normal-order language, all compoundprocedures are non-strict in each argument, and primitive procedures may beeither strict or non-strict.  There are also languages (seeexercise <a href="#%_thm_4.31">4.31</a>) that give programmersdetailed control over the strictness of the procedures they define.</p>
<p>A striking example of a procedure that can usefully be made non-strictis <code>cons</code> (or, in general, almost any constructor for datastructures).  One can do useful computation, combining elements toform data structures and operating on the resulting data structures,even if the values of the elements are not known.  It makes perfectsense, for instance, to compute the length of a list without knowingthe values of the individual elements in the list.  We will exploitthis idea in section <a href="#%_sec_4.2.3">4.2.3</a> to implement thestreams of chapter 3 as lists formed of non-strict <code>cons</code>pairs.</p>
<p></p>
<p><a name="%_thm_4.25" id="%_thm_4.25"></a><b>Exercise 4.25.</b>  Suppose that (in ordinary applicative-order Scheme) we define <code>unless</code>as shown above and then define <code>factorial</code> in terms of <code>unless</code> as</p>
<p></p>
<p></p>
<p><pre>(define (factorial n)
  (unless (= n 1)
          (* n (factorial (- n 1)))
          1))
</pre></p>
<p></p>
<p>What happens if we attempt to evaluate <code>(factorial 5)</code>?  Will ourdefinitions work in a normal-order language?</p>
<p></p>
<p></p>
<p><a name="%_thm_4.26" id="%_thm_4.26"></a><b>Exercise 4.26.</b>  <a name="%_idx_4692" id="%_idx_4692"></a><a name="%_idx_4694" id="%_idx_4694"></a>Ben Bitdiddle and Alyssa P. Hacker disagree over the importance oflazy evaluation for implementing things such as <code>unless</code>.  Benpoints out that it's possible to implement <code>unless</code> in applicativeorder as a special form.Alyssa counters that, if one did that, <code>unless</code> would be merelysyntax, not a procedure that could be used in conjunction withhigher-order procedures.  Fill in the details on both sides of theargument.  Show how to implement <code>unless</code> as a derived expression(like <code>cond</code> or <code>let</code>),and give an example of a situation where it might be useful to have<code>unless</code> available as a procedure, rather than as a special form.</p>
<p></p>
<p><a name="%_sec_4.2.2" id="%_sec_4.2.2"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_4.2.2">4.2.2  An Interpreter with Lazy Evaluation</a></h3>
<p>In this section we will implement a normal-order language that isthe same as Scheme except that compound procedures are non-strictin each argument.  Primitive procedures will still be strict.It is not difficult to modify the evaluator ofsection <a href="book-Z-H-26.html#%_sec_4.1.1">4.1.1</a> so that the language it interprets behavesthis way.  Almost all the required changes center around procedureapplication.</p>
<p>The basic idea is that, when applying a procedure, the interpretermust determine which arguments are to beevaluated and which are to bedelayed.  The delayed arguments are notevaluated; instead, they are transformed into objects called <a name="%_idx_4696" id="%_idx_4696"></a><em>thunk</em>s.<a name="call_footnote_Temp_580" href="#footnote_Temp_580" id="call_footnote_Temp_580"><sup><small>34</small></sup></a>The thunk must contain the information required to produce the valueof the argument when it is needed, as if it had been evaluated atthe time of the application.  Thus, the thunk must contain theargument expression and the environment inwhich the procedure application is being evaluated.</p>
<p><a name="%_idx_4704" id="%_idx_4704"></a><a name="%_idx_4706" id="%_idx_4706"></a>The process of evaluating the expression in a thunk is called <em>forcing</em>.<a name="call_footnote_Temp_581" href="#footnote_Temp_581" id="call_footnote_Temp_581"><sup><small>35</small></sup></a>In general, a thunk will be forced only when its value is needed:when it is passed to a primitive procedure thatwill use the value of the thunk; when it is thevalue of a predicate of a conditional; and when itis the value of an operator that is about to be applied as a procedure.One design choice we have available is whether or not to <a name="%_idx_4710" id="%_idx_4710"></a><em>memoize</em> thunks, as we did with delayed objects insection <a href="book-Z-H-24.html#%_sec_3.5.1">3.5.1</a>.  With memoization, the first time athunk is forced, it stores the value that is computed.  Subsequentforcings simply return the stored value without repeating thecomputation.  We'll make our interpreter memoize, because this ismore efficient for many applications.  There are trickyconsiderations here, however.<a name="call_footnote_Temp_582" href="#footnote_Temp_582" id="call_footnote_Temp_582"><sup><small>36</small></sup></a></p>
<p><a name="%_sec_Temp_583" id="%_sec_Temp_583"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_583">Modifying the evaluator</a></h4>
<p>The main difference between the lazy evaluator and the one insection <a href="book-Z-H-26.html#%_sec_4.1">4.1</a> is in the handling of procedureapplications in <code>eval</code> and <code>apply</code>.</p>
<p><a name="%_idx_4720" id="%_idx_4720"></a>The <code>application?</code> clause of <code>eval</code> becomes</p>
<p></p>
<p></p>
<p><pre>((application? exp)
 (apply (actual-value (operator exp) env)
        (operands exp)
        env))
</pre></p>
<p></p>
<p>This is almost the same as the <code>application?</code> clause of <code>eval</code>in section <a href="book-Z-H-26.html#%_sec_4.1.1">4.1.1</a>.  For lazy evaluation, however,we call <code>apply</code> with the operand expressions, rather than thearguments produced by evaluating them.  Since we will need the environment toconstruct thunks if the arguments are to be delayed, we must pass this as well.We still evaluate theoperator, because <code>apply</code> needs the actual procedure to be appliedin order to dispatch on its type (primitive versus compound) and apply it.</p>
<p>Whenever we need the actual value of an expression, we use</p>
<p></p>
<p><pre><a name="%_idx_4722" id="%_idx_4722"></a>(define (actual-value exp env)
  (force-it (eval exp env)))
</pre></p>
<p></p>
<p>instead of just <code>eval</code>, so that if the expression's valueis a thunk, it will be forced.</p>
<p>Our new version of <code>apply</code> is also almost the same as theversion in section <a href="book-Z-H-26.html#%_sec_4.1.1">4.1.1</a>.  The difference isthat <code>eval</code> has passed in unevaluated operand expressions:For primitive procedures (which are strict), we evaluate all thearguments before applying the primitive;for compound procedures (which are non-strict) we delay all thearguments before applying the procedure.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4724" id="%_idx_4724"></a>(define (apply procedure arguments env)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure
          procedure
          (list-of-arg-values arguments env)))  <em>; changed</em>
        ((compound-procedure? procedure)
         (eval-sequence
          (procedure-body procedure)
          (extend-environment
           (procedure-parameters procedure)
           (list-of-delayed-args arguments env) <em>; changed</em>
           (procedure-environment procedure))))
        (else
         (error
          "Unknown procedure type -- APPLY" procedure))))
</pre></p>
<p></p>
<p>The procedures that process the arguments are just like <code>list-of-values</code> from section <a href="book-Z-H-26.html#%_sec_4.1.1">4.1.1</a>, except that<code>list-of-delayed-args</code> delays the arguments instead of evaluatingthem, and <code>list-of-arg-values</code> uses <code>actual-value</code> insteadof <code>eval</code>:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4726" id="%_idx_4726"></a>(define (list-of-arg-values exps env)
  (if (no-operands? exps)
      '()
      (cons (actual-value (first-operand exps) env)
            (list-of-arg-values (rest-operands exps)
                                env))))
<a name="%_idx_4728" id="%_idx_4728"></a>(define (list-of-delayed-args exps env)
  (if (no-operands? exps)
      '()
      (cons (delay-it (first-operand exps) env)
            (list-of-delayed-args (rest-operands exps)
                                  env))))
</pre></p>
<p></p>
<p></p>
<p>The other place we must change the evaluator is in the handling of<code>if</code>, where we must use <code>actual-value</code> insteadof <code>eval</code> to get the value of the predicate expressionbefore testing whether it is true or false:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4730" id="%_idx_4730"></a>(define (eval-if exp env)
  (if (true? (actual-value (if-predicate exp) env))
      (eval (if-consequent exp) env)
      (eval (if-alternative exp) env)))
</pre></p>
<p></p>
<p></p>
<p><a name="%_idx_4732" id="%_idx_4732"></a>Finally, we must change the <code>driver-loop</code>procedure (section <a href="book-Z-H-26.html#%_sec_4.1.4">4.1.4</a>) to use <code>actual-value</code> insteadof <code>eval</code>, so that if a delayed valueis propagated back to the read-eval-print loop, it will be forcedbefore being printed.  We also change the prompts to indicate thatthis is the lazy evaluator:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4734" id="%_idx_4734"></a>(define input-prompt ";;; L-Eval input:")
(define output-prompt ";;; L-Eval value:")
<a name="%_idx_4736" id="%_idx_4736"></a>(define (driver-loop)
  (prompt-for-input input-prompt)
  (let ((input (read)))
    (let ((output
           (actual-value input the-global-environment)))
      (announce-output output-prompt)
      (user-print output)))
  (driver-loop))
</pre></p>
<p></p>
<p></p>
<p>With these changes made, we can start the evaluator and test it.  Thesuccessful evaluation of the <code>try</code> expression discussed insection <a href="#%_sec_4.2.1">4.2.1</a> indicates that the interpreter isperforming lazy evaluation:</p>
<p></p>
<p></p>
<p><pre>(define the-global-environment (setup-environment))
(driver-loop)
<i>;;; L-Eval input:</i>
(define (try a b)
  (if (= a 0) 1 b))
<i>;;; L-Eval value:</i>
<i>ok</i>
<i>;;; L-Eval input:</i>
(try 0 (/ 1 0))
<i>;;; L-Eval value:</i>
<i>1</i>
</pre></p>
<p></p>
<p></p>
<p><a name="%_sec_Temp_584" id="%_sec_Temp_584"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_584">Representing thunks</a></h4>
<p><a name="%_idx_4738" id="%_idx_4738"></a>Our evaluator must arrange to create thunks when procedures areapplied to arguments and to force these thunks later.  A thunk mustpackage an expression together with the environment, so that theargument can be produced later.To force the thunk, we simply extract the expression and environmentfrom the thunk and evaluate the expression in the environment.We use <code>actual-value</code> rather than <code>eval</code> so that in case thevalue of the expression is itself a thunk, we will force that, and soon, until we reach something that is not a thunk:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4740" id="%_idx_4740"></a>(define (force-it obj)
  (if (thunk? obj)
      (actual-value (thunk-exp obj) (thunk-env obj))
      obj))
</pre></p>
<p></p>
<p></p>
<p>One easy way to package an expression with an environment is to make alist containing the expression and the environment.Thus, we create a thunk as follows:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4742" id="%_idx_4742"></a>(define (delay-it exp env)
  (list 'thunk exp env))

(define (thunk? obj)
  (tagged-list? obj 'thunk))

(define (thunk-exp thunk) (cadr thunk))

(define (thunk-env thunk) (caddr thunk))
</pre></p>
<p></p>
<p></p>
<p>Actually, what we want for our interpreter is not quite this, butrather thunks that have been memoized.When a thunk is forced, we will turn it into an evaluated thunkby replacing the stored expression with its value andchanging the <code>thunk</code> tag so that it can be recognized asalready evaluated.<a name="call_footnote_Temp_585" href="#footnote_Temp_585" id="call_footnote_Temp_585"><sup><small>37</small></sup></a></p>
<p></p>
<p></p>
<p><pre>(define (evaluated-thunk? obj)
  (tagged-list? obj 'evaluated-thunk))

(define (thunk-value evaluated-thunk) (cadr evaluated-thunk))
<a name="%_idx_4748" id="%_idx_4748"></a>(define (force-it obj)
  (cond ((thunk? obj)
         (let ((result (actual-value
                        (thunk-exp obj)
                        (thunk-env obj))))
           (set-car! obj 'evaluated-thunk)
           (set-car! (cdr obj) result)  <em>; replace <code>exp</code> with its value</em>
           (set-cdr! (cdr obj) '())     <em>; forget unneeded <code>env</code></em>
           result))
        ((evaluated-thunk? obj)
         (thunk-value obj))
        (else obj)))
</pre></p>
<p></p>
<p>Notice that the same <code>delay-it</code> procedure works both with andwithout memoization.</p>
<p></p>
<p><a name="%_thm_4.27" id="%_thm_4.27"></a><b>Exercise 4.27.</b>  Suppose we type in the following definitions to the lazy evaluator:</p>
<p></p>
<p><pre>(define count 0)
(define (id x)
  (set! count (+ count 1))
  x)
</pre></p>
<p></p>
<p>Give the missing values in the following sequence ofinteractions, and explain your answers.<a name="call_footnote_Temp_587" href="#footnote_Temp_587" id="call_footnote_Temp_587"><sup><small>38</small></sup></a></p>
<p></p>
<p><pre>(define w (id (id 10)))
<i>;;; L-Eval input:</i>
count
<i>;;; L-Eval value:</i>
&lt;<em>response</em>&gt;
<i>;;; L-Eval input:</i>
w
<i>;;; L-Eval value:</i>
&lt;<em>response</em>&gt;
<i>;;; L-Eval input:</i>
count
<i>;;; L-Eval value:</i>
&lt;<em>response</em>&gt;
</pre></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_4.28" id="%_thm_4.28"></a><b>Exercise 4.28.</b>  <code>Eval</code> uses <code>actual-value</code> rather than <code>eval</code>to evaluate the operator before passing it to <code>apply</code>,in order to force the value of the operator.Give an example that demonstrates the need for this forcing.</p>
<p></p>
<p></p>
<p><a name="%_thm_4.29" id="%_thm_4.29"></a><b>Exercise 4.29.</b>  Exhibit a program that you would expect to run much more slowlywithout memoization than with memoization.  Also, consider thefollowing interaction, where the <code>id</code> procedure is defined as inexercise <a href="#%_thm_4.27">4.27</a> and <code>count</code> starts at 0:</p>
<p></p>
<p><pre>(define (square x)
  (* x x))
<i>;;; L-Eval input:</i>
(square (id 10))
<i>;;; L-Eval value:</i>
&lt;<em>response</em>&gt;
<i>;;; L-Eval input:</i>
count
<i>;;; L-Eval value:</i>
&lt;<em>response</em>&gt;
</pre></p>
<p></p>
<p>Give the responses both when the evaluator memoizes and when it does not.</p>
<p></p>
<p></p>
<p><a name="%_thm_4.30" id="%_thm_4.30"></a><b>Exercise 4.30.</b>  Cy D. Fect, a reformed C programmer, is worried that some side effectsmay never take place, because the lazy evaluator doesn't force theexpressions in a sequence.Since the value of an expression in a sequence other than the last oneis not used (the expression is there only for its effect, such asassigning to a variable or printing), there can be no subsequent useof this value (e.g., as an argument to a primitive procedure) thatwill cause it to be forced.  Cy thus thinks that when evaluatingsequences, we must force all expressions in the sequence except thefinal one.  He proposes to modify <code>eval-sequence</code> fromsection <a href="book-Z-H-26.html#%_sec_4.1.1">4.1.1</a> to use <code>actual-value</code> ratherthan <code>eval</code>:</p>
<p></p>
<p></p>
<p><pre>(define (eval-sequence exps env)
  (cond ((last-exp? exps) (eval (first-exp exps) env))
        (else (actual-value (first-exp exps) env)
              (eval-sequence (rest-exps exps) env))))
</pre></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p>a. Ben Bitdiddle thinks Cy is wrong.He shows Cy the <code>for-each</code> procedure described inexercise <a href="book-Z-H-15.html#%_thm_2.23">2.23</a>, which gives an important example ofa sequence with side effects:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4750" id="%_idx_4750"></a>(define (for-each proc items)
  (if (null? items)
      'done
      (begin (proc (car items))
             (for-each proc (cdr items)))))
</pre></p>
<p></p>
<p>He claims that the evaluator in the text (with the original <code>eval-sequence</code>) handles this correctly:</p>
<p></p>
<p></p>
<p><pre><i>;;; L-Eval input:</i>
(for-each (lambda (x) (newline) (display x))
          (list 57 321 88))
<i>57</i>
<i>321</i>
<i>88</i>
<i>;;; L-Eval value:</i>
<i>done</i>
</pre></p>
<p></p>
<p>Explain why Ben is right about the behavior of <code>for-each</code>.</p>
<p></p>
<p></p>
<p>b. Cy agrees that Ben is right about the <code>for-each</code> example,but says that that's not the kind of program he was thinking aboutwhen he proposed his change to <code>eval-sequence</code>.He defines the following two procedures in the lazy evaluator:</p>
<p></p>
<p></p>
<p><pre>(define (p1 x)
  (set! x (cons x '(2)))
  x)

(define (p2 x)
  (define (p e)
    e
    x)
  (p (set! x (cons x '(2)))))
</pre></p>
<p></p>
<p>What are the values of <code>(p1 1)</code> and <code>(p2 1)</code> with theoriginal <code>eval-sequence</code>?What would the values be with Cy's proposed change to <code>eval-sequence</code>?</p>
<p></p>
<p></p>
<p>c. Cy also points out that changing <code>eval-sequence</code> as he proposesdoes not affect the behavior of the example in part a.Explain why this is true.</p>
<p></p>
<p></p>
<p>d. How do you think sequences ought to be treated in the lazy evaluator?Do you like Cy's approach, the approach in the text, or some other approach?</p>
<p></p>
<p></p>
<p><a name="%_thm_4.31" id="%_thm_4.31"></a><b>Exercise 4.31.</b>  <a name="%_idx_4752" id="%_idx_4752"></a>The approach taken in this section is somewhat unpleasant, because itmakes an incompatible change to Scheme.  It might be nicer toimplement lazy evaluation as an <em>upward-compatible extension</em>,that is, so that ordinary Scheme programs will work as before.  We cando this by extending the syntax of procedure declarations to let the usercontrol whether or not arguments are to be delayed.  While we're atit, we may as well also give the user the choice between delaying withand without memoization.  For example, the definition</p>
<p></p>
<p><pre>(define (f a (b lazy) c (d lazy-memo))
  <code>...</code>)
</pre></p>
<p></p>
<p>would define <code>f</code> to be a procedure of four arguments, where thefirst and third arguments are evaluated when the procedure is called,the second argument is delayed, and the fourth argument is bothdelayed and memoized.  Thus, ordinary procedure definitions willproduce the same behavior as ordinary Scheme, while adding the <code>lazy-memo</code> declaration to each parameter of every compound procedurewill produce the behavior of the lazy evaluator defined in thissection. Design and implement the changes required to produce such anextension to Scheme.  You will have to implement new syntax proceduresto handle the new syntax for <code>define</code>.  You must also arrange for<code>eval</code> or <code>apply</code> to determine when arguments are to be delayed, and toforce or delay arguments accordingly, and you must arrange for forcingto memoize or not, as appropriate.</p>
<p></p>
<p><a name="%_sec_4.2.3" id="%_sec_4.2.3"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_4.2.3">4.2.3  Streams as Lazy Lists</a></h3>
<p><a name="%_idx_4754" id="%_idx_4754"></a><a name="%_idx_4756" id="%_idx_4756"></a><a name="%_idx_4758" id="%_idx_4758"></a><a name="%_idx_4760" id="%_idx_4760"></a><a name="%_idx_4762" id="%_idx_4762"></a><a name="%_idx_4764" id="%_idx_4764"></a><a name="%_idx_4766" id="%_idx_4766"></a><a name="%_idx_4768" id="%_idx_4768"></a><a name="%_idx_4770" id="%_idx_4770"></a>In section <a href="book-Z-H-24.html#%_sec_3.5.1">3.5.1</a>, we showed how to implement streamsas delayed lists.  We introduced special forms <code>delay</code> and <code>cons-stream</code>, which allowed us to construct a “promise” to computethe <code>cdr</code> of a stream, without actually fulfilling that promiseuntil later.  We could use this general technique of introducingspecial forms whenever we need more control over the evaluation process,but this is awkward.  For one thing, a special form is not afirst-class object like a procedure, so we cannot use it together withhigher-order procedures.<a name="call_footnote_Temp_592" href="#footnote_Temp_592" id="call_footnote_Temp_592"><sup><small>39</small></sup></a>  Additionally,we were forced to create streams as a new kind of data objectsimilar but not identical to lists, and this required us toreimplement many ordinary list operations (<code>map</code>, <code>append</code>, andso on) for use with streams.</p>
<p>With lazy evaluation, streams and lists can be identical, so there isno need for special forms or for separate list and stream operations.All we need to do is to arrange matters so that <code>cons</code> isnon-strict.  One way to accomplish this is to extend the lazyevaluator to allow for non-strict primitives, and to implement <code>cons</code> as one of these.  An easier way is to recall(section <a href="book-Z-H-14.html#%_sec_2.1.3">2.1.3</a>) that there is no fundamental need toimplement <code>cons</code> as a primitive at all.  Instead, we can represent<a name="%_idx_4772" id="%_idx_4772"></a>pairs as procedures:<a name="call_footnote_Temp_593" href="#footnote_Temp_593" id="call_footnote_Temp_593"><sup><small>40</small></sup></a></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4774" id="%_idx_4774"></a>(define (cons x y)
  (lambda (m) (m x y)))
<a name="%_idx_4776" id="%_idx_4776"></a>(define (car z)
  (z (lambda (p q) p)))
<a name="%_idx_4778" id="%_idx_4778"></a>(define (cdr z)
  (z (lambda (p q) q)))
</pre></p>
<p></p>
<p></p>
<p>In terms of these basic operations, the standard definitions of thelist operations will work with infinite lists (streams) as well asfinite ones, and the stream operations can be implemented as list operations.Here are some examples:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4780" id="%_idx_4780"></a>(define (list-ref items n)
  (if (= n 0)
      (car items)
      (list-ref (cdr items) (- n 1))))
<a name="%_idx_4782" id="%_idx_4782"></a>(define (map proc items)
  (if (null? items)
      '()
      (cons (proc (car items))
            (map proc (cdr items)))))
<a name="%_idx_4784" id="%_idx_4784"></a>(define (scale-list items factor)
  (map (lambda (x) (* x factor))
       items))
<a name="%_idx_4786" id="%_idx_4786"></a>(define (add-lists list1 list2)
  (cond ((null? list1) list2)
        ((null? list2) list1)
        (else (cons (+ (car list1) (car list2))
                    (add-lists (cdr list1) (cdr list2))))))
<a name="%_idx_4788" id="%_idx_4788"></a>(define ones (cons 1 ones))
<a name="%_idx_4790" id="%_idx_4790"></a>(define integers (cons 1 (add-lists ones integers)))
<i>;;; L-Eval input:</i>
(list-ref integers 17)
<i>;;; L-Eval value:</i>
<i>18</i>
</pre></p>
<p></p>
<p></p>
<p>Note that these lazy lists are even lazier than the streams ofchapter 3:  The <code>car</code> of the list, as well as the <code>cdr</code>, isdelayed.<a name="call_footnote_Temp_594" href="#footnote_Temp_594" id="call_footnote_Temp_594"><sup><small>41</small></sup></a>In fact, even accessing the <code>car</code> or <code>cdr</code> of a lazypair need not force the value of a list element.  The value will beforced only when it is really needed – e.g., for use as theargument of a primitive, or to be printed as an answer.</p>
<p>Lazy pairs also help with the problem that arose with streams insection <a href="book-Z-H-24.html#%_sec_3.5.4">3.5.4</a>, where we found thatformulating stream models of systems with loops may require us tosprinkle our programs with <a name="%_idx_4798" id="%_idx_4798"></a><a name="%_idx_4800" id="%_idx_4800"></a>explicit <code>delay</code> operations, beyond theones supplied by <code>cons-stream</code>.  With lazy evaluation, allarguments to procedures are delayed uniformly.  For instance, we canimplement procedures to integrate lists and solve differentialequations as we originally intended insection <a href="book-Z-H-24.html#%_sec_3.5.4">3.5.4</a>:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4802" id="%_idx_4802"></a>(define (integral integrand initial-value dt)
  (define int
    (cons initial-value
          (add-lists (scale-list integrand dt)
                    int)))
  int)
<a name="%_idx_4804" id="%_idx_4804"></a>(define (solve f y0 dt)
  (define y (integral dy y0 dt))
  (define dy (map f y))
  y)
<i>;;; L-Eval input:</i>
(list-ref (solve (lambda (x) x) 1 0.001) 1000)
<i>;;; L-Eval value:</i>
<i>2.716924</i></pre></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_4.32" id="%_thm_4.32"></a><b>Exercise 4.32.</b>  Give some examples that illustrate the difference between the streamsof chapter 3 and the “lazier” lazy lists described in this section.How can you take advantage of this extra laziness?</p>
<p></p>
<p></p>
<p><a name="%_thm_4.33" id="%_thm_4.33"></a><b>Exercise 4.33.</b>  Ben Bitdiddle tests the lazy list implementation given above byevaluating the expression</p>
<p></p>
<p><pre>(car '(a b c))
</pre></p>
<p></p>
<p>To his surprise, this produces an error.  After some thought, herealizes that the “lists” obtained by reading in quoted expressionsare different from the lists manipulated by the new definitions of<code>cons</code>, <code>car</code>, and <code>cdr</code>.  Modify the evaluator'streatment of quoted expressions so that quoted lists typed at thedriver loop will produce true lazy lists.</p>
<p></p>
<p></p>
<p><a name="%_thm_4.34" id="%_thm_4.34"></a><b>Exercise 4.34.</b>  Modify the driver loop for the evaluator so that lazy pairs and listswill print in some reasonable way.  (What are you going to do aboutinfinite lists?)  You may also need to modify the representation oflazy pairs so that the evaluator can identify them in orderto print them.</p>
<p></p>
<p></p>
<p></p>
<div class="smallprint"><hr></div>
<p></p>
<div class="footnote">
<p><a name="footnote_Temp_575" href="#call_footnote_Temp_575" id="footnote_Temp_575"><sup><small>31</small></sup></a> Snarf: “To grab, especially a large document or<a name="%_idx_4674" id="%_idx_4674"></a><a name="%_idx_4676" id="%_idx_4676"></a><a name="%_idx_4678" id="%_idx_4678"></a>file for the purpose of using it either with or without the owner'spermission.”  Snarf down: “To snarf, sometimes with the connotationof absorbing, processing, or understanding.”  (These definitions weresnarfed from Steele et al. 1983.  See also Raymond 1993.)</p>
<p><a name="footnote_Temp_576" href="#call_footnote_Temp_576" id="footnote_Temp_576"><sup><small>32</small></sup></a> The difference between the “lazy” terminology andthe “normal-order” terminology is somewhat fuzzy.  Generally, “lazy”refers to the mechanisms of particular evaluators, while “normal-order”refers to the semantics of languages, independent of any particularevaluation strategy.  But this is not a hard-and-fast distinction, andthe two terminologies are often used interchangeably.</p>
<p><a name="footnote_Temp_577" href="#call_footnote_Temp_577" id="footnote_Temp_577"><sup><small>33</small></sup></a> The “strict” versus “non-strict” terminology means essentially thesame thing as “applicative-order” versus “normal-order,” except thatit refers to individual procedures and arguments rather than to thelanguage as a whole.  At a conference on programming languages youmight hear someone say, “The normal-order language <a name="%_idx_4690" id="%_idx_4690"></a>Hassle has certainstrict primitives.  Other procedures take their arguments by lazyevaluation.”</p>
<p><a name="footnote_Temp_580" href="#call_footnote_Temp_580" id="footnote_Temp_580"><sup><small>34</small></sup></a> The word <em>thunk</em> was invented by an informal<a name="%_idx_4698" id="%_idx_4698"></a><a name="%_idx_4700" id="%_idx_4700"></a><a name="%_idx_4702" id="%_idx_4702"></a>working group that was discussing the implementation of call-by-namein Algol 60.  They observed that most of the analysis of (“thinkingabout”) the expression could be done at compile time; thus, at runtime, the expression would already have been “thunk” about (Ingermanet al. 1960).</p>
<p><a name="footnote_Temp_581" href="#call_footnote_Temp_581" id="footnote_Temp_581"><sup><small>35</small></sup></a> This is analogous to the use of <code>force</code><a name="%_idx_4708" id="%_idx_4708"></a>on the delayed objects that were introduced in chapter 3 to representstreams.  The critical difference between what we aredoing here and what we did in chapter 3 is that we are buildingdelaying and forcing into the evaluator, and thus making this uniformand automatic throughout the language.</p>
<p><a name="footnote_Temp_582" href="#call_footnote_Temp_582" id="footnote_Temp_582"><sup><small>36</small></sup></a> Lazy evaluation combined with memoization is sometimes<a name="%_idx_4712" id="%_idx_4712"></a>referred to as <em>call-by-need</em> argument passing, in contrast to<em>call-by-name</em> argument passing.  <a name="%_idx_4714" id="%_idx_4714"></a><a name="%_idx_4716" id="%_idx_4716"></a>(Call-by-name, introduced inAlgol 60, is similar to non-memoized lazy evaluation.)As language designers, we can build our evaluator to memoize,not to memoize, or leave this an option for programmers(exercise <a href="#%_thm_4.31">4.31</a>).  As you might expectfrom chapter 3, these choices raise issues that become both subtle andconfusing in the presence of assignments.  (Seeexercises <a href="#%_thm_4.27">4.27</a> and <a href="#%_thm_4.29">4.29</a>.)<a name="%_idx_4718" id="%_idx_4718"></a>An excellent article by Clinger (1982) attempts to clarify themultiple dimensions of confusion that arise here.</p>
<p><a name="footnote_Temp_585" href="#call_footnote_Temp_585" id="footnote_Temp_585"><sup><small>37</small></sup></a> Notice that we also erase the <code>env</code> from the thunk once theexpression's value has been computed.  This makes no difference in thevalues returned by the interpreter.  It does help save space,however, because removing the reference from the thunk to the <code>env</code>once it is no longer needed allows this structure to be<a name="%_idx_4744" id="%_idx_4744"></a><a name="%_idx_4746" id="%_idx_4746"></a><em>garbage-collected</em> and itsspace recycled, as we will discuss in section <a href="book-Z-H-33.html#%_sec_5.3">5.3</a>.</p>
<p>Similarly, we could have allowed unneeded environments in the memoizeddelayed objects of section <a href="book-Z-H-24.html#%_sec_3.5.1">3.5.1</a> to be garbage-collected,by having <code>memo-proc</code> do something like <code>(set! proc '())</code>to discard the procedure <code>proc</code> (which includes the environmentin which the <code>delay</code> was evaluated) after storing its value.</p>
<p><a name="footnote_Temp_587" href="#call_footnote_Temp_587" id="footnote_Temp_587"><sup><small>38</small></sup></a> This exercisedemonstrates that the interaction between lazy evaluation and sideeffects can be very confusing.  This is just what you might expectfrom the discussion in chapter 3.</p>
<p><a name="footnote_Temp_592" href="#call_footnote_Temp_592" id="footnote_Temp_592"><sup><small>39</small></sup></a> This is precisely the issue with the <code>unless</code> procedure,as in exercise <a href="#%_thm_4.26">4.26</a>.</p>
<p><a name="footnote_Temp_593" href="#call_footnote_Temp_593" id="footnote_Temp_593"><sup><small>40</small></sup></a> This is the procedural representation described inexercise <a href="book-Z-H-14.html#%_thm_2.4">2.4</a>.  Essentially any procedural representation(e.g., a message-passing implementation) would do as well.  Noticethat we can install these definitions in the lazy evaluator simply bytyping them at the driver loop.  If we had originally included <code>cons</code>, <code>car</code>, and <code>cdr</code> as primitives in the globalenvironment, they will be redefined.  (Also seeexercises <a href="#%_thm_4.33">4.33</a> and <a href="#%_thm_4.34">4.34</a>.)</p>
<p><a name="footnote_Temp_594" href="#call_footnote_Temp_594" id="footnote_Temp_594"><sup><small>41</small></sup></a> This permits us to create delayed versions of more general kinds of<a name="%_idx_4792" id="%_idx_4792"></a>list structures, not just sequences.  Hughes 1990 discusses some<a name="%_idx_4794" id="%_idx_4794"></a><a name="%_idx_4796" id="%_idx_4796"></a>applications of “lazy trees.”</p>
</div></body>
</html>
