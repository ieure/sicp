<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<?xml version="1.0" encoding="utf-8"?><html xmlns="http://www.w3.org/1999/xhtml" xmlns:ops="http://www.idpf.org/2007/ops">
<!-- Generated from TeX source by tex2page, v 4o,
     (c) Dorai Sitaram, http://www.cs.rice.edu/~dorai/tex2page --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Type: text/html; charset=utf-8">
<title>Structure and Interpretation of Computer Programs</title>
<link rel="stylesheet" type="text/css" href="book-Z-C.css" title="default">
</head>
<body><a name="%_sec_3.5" id="%_sec_3.5"></a><h2><a href="book-Z-H-4.html#%_toc_%_sec_3.5">3.5  Streams</a></h2>
<p><a name="%_idx_3726" id="%_idx_3726"></a>We've gained a good understanding of assignment as a tool in modeling,as well as an appreciation of the complex problems that assignmentraises. It is time to ask whether we could have gone about things in adifferent way, so as to avoid some of these problems.  In thissection, we explore an alternative approach to modeling state, basedon data structures called <em>streams</em>.  As we shall see, streams canmitigate some of the complexity of modeling state.</p>
<p>Let's step back and review where this complexity comes from.  In anattempt to model real-world phenomena, we made some apparentlyreasonable decisions: We modeled real-world objects with local stateby computational objects with local variables.  We identified timevariation in the real world with time variation in the computer.  Weimplemented the time variation of the states of the model objects inthe computer with assignments to the local variables of the modelobjects.</p>
<p>Is there another approach?  Can we avoid identifying time in thecomputer with time in the modeled world?  Must we make the modelchange with time in order to model phenomena in a changing world?Think about the issue in terms of mathematical functions.  We candescribe the time-varying behavior of a quantity <em>x</em> as a function oftime <em>x</em>(<em>t</em>).  If we concentrate on <em>x</em> instant by instant, we think ofit as a changing quantity.  Yet if we concentrate on the entiretime history of values, we do not emphasize change – the functionitself does not change.<a name="call_footnote_Temp_442" href="#footnote_Temp_442" id="call_footnote_Temp_442"><sup><small>52</small></sup></a></p>
<p>If time is measured in discrete steps, then we can model a time function asa (possibly infinite) sequence.  In this section, we will see how tomodel change in terms of sequences that represent the time historiesof the systems being modeled.  To accomplish this, we introduce newdata structures called <em>streams</em>.  From an abstract point of view,a stream is simply a sequence.  However, we will find that thestraightforward implementation of streams as lists (as insection <a href="book-Z-H-15.html#%_sec_2.2.1">2.2.1</a>) doesn't fully revealthe power of stream processing.  As an alternative, we introduce thetechnique of <a name="%_idx_3730" id="%_idx_3730"></a><em>delayed evaluation</em>, which enables us to representvery large (even infinite) sequences as streams.</p>
<p>Stream processing lets us model systems that have state without everusing assignment or mutable data.  This has important implications,both theoretical and practical, because we can build models that avoidthe drawbacks inherent in introducing assignment.  On the other hand,the stream framework raises difficulties of its own, and the questionof which modeling technique leads to more modular and more easilymaintained systems remains open.</p>
<p><a name="%_sec_3.5.1" id="%_sec_3.5.1"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_3.5.1">3.5.1  Streams Are Delayed Lists</a></h3>
<p><a name="%_idx_3732" id="%_idx_3732"></a>As we saw in section <a href="book-Z-H-15.html#%_sec_2.2.3">2.2.3</a>,sequences can serve as standard interfaces for combining programmodules.  We formulated powerful abstractions for manipulatingsequences, such as <code>map</code>, <code>filter</code>, and <code>accumulate</code>, thatcapture a wide variety of operations in a manner that is both succinctand elegant.</p>
<p>Unfortunately, if we represent sequences as lists, this elegance isbought at the price of severe inefficiency with respect to both thetime and space required by our computations.When we represent manipulations on sequences as transformationsof lists, our programs must construct and copy data structures (whichmay be huge) at every step of a process.</p>
<p>To see why this is true, let us compare two programs for computing thesum of all the prime numbers in an interval.  The first program iswritten in standard iterative style:<a name="call_footnote_Temp_443" href="#footnote_Temp_443" id="call_footnote_Temp_443"><sup><small>53</small></sup></a></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3734" id="%_idx_3734"></a>(define (sum-primes a b)
  (define (iter count accum)
    (cond ((&gt; count b) accum)
          ((prime? count) (iter (+ count 1) (+ count accum)))
          (else (iter (+ count 1) accum))))
  (iter a 0))
</pre></p>
<p></p>
<p>The second program performs the same computation using the sequenceoperations of section <a href="book-Z-H-15.html#%_sec_2.2.3">2.2.3</a>:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3736" id="%_idx_3736"></a>(define (sum-primes a b)
  (accumulate +
              0
              (filter prime? (enumerate-interval a b))))
</pre></p>
<p></p>
<p></p>
<p>In carrying out the computation, the first program needs to store onlythe sum being accumulated.  In contrast, the filter in the secondprogram cannot do any testing until <code>enumerate-interval</code> hasconstructed a complete list of the numbers in the interval.  Thefilter generates another list, which in turn is passed to <code>accumulate</code> before being collapsed to form a sum.  Such largeintermediate storage is not needed by the first program, which we canthink of as enumerating the interval incrementally, adding each primeto the sum as it is generated.</p>
<p>The inefficiency in using lists becomes painfully apparent if we usethe sequence paradigm to compute the second prime in the interval from10,000 to 1,000,000 by evaluating the expression</p>
<p></p>
<p></p>
<p><pre>(car (cdr (filter prime?
                  (enumerate-interval 10000 1000000))))
</pre></p>
<p></p>
<p>This expression does find the second prime, but the computationaloverhead is outrageous.  We construct a list of almost a millionintegers, filter this list by testing each element for primality, andthen ignore almost all of the result.  In a more traditionalprogramming style, we would interleave the enumeration and thefiltering, and stop when we reached the second prime.</p>
<p>Streams are a clever idea that allows one to use sequencemanipulations without incurring the costs of manipulating sequences aslists.  With streams we can achieve the best of both worlds: We canformulate programs elegantly as sequence manipulations, while attaining theefficiency of incremental computation.  The basic idea is to arrangeto construct a stream only partially, and to pass the partialconstruction to the program that consumes the stream.  If the consumerattempts to access a part of the stream that has not yet beenconstructed, the stream will automatically construct just enough moreof itself to produce the required part, thus preserving the illusionthat the entire stream exists.  In other words, although we will writeprograms as if we were processing complete sequences, we design ourstream implementation to automatically and transparently interleavethe construction of the stream with its use.</p>
<p>On the surface, streams are just lists with different names for theprocedures that manipulate them.  There is a constructor,<a name="%_idx_3738" id="%_idx_3738"></a><code>cons-stream</code>, and two selectors, <a name="%_idx_3740" id="%_idx_3740"></a><code>stream-car</code> and <a name="%_idx_3742" id="%_idx_3742"></a><code>stream-cdr</code>, which satisfy the constraints</p><p>    <code>(stream-car (cons-stream x y)) = x</code>
<code>(stream-cdr (cons-stream x y)) = y</code></p><p>There is a distinguishable object, <a name="%_idx_3744" id="%_idx_3744"></a><a name="%_idx_3746" id="%_idx_3746"></a><a name="%_idx_3748" id="%_idx_3748"></a><code>the-empty-stream</code>, whichcannot be the result of any <code>cons-stream</code> operation, and which canbe identified with the predicate <a name="%_idx_3750" id="%_idx_3750"></a><code>stream-null?</code>.<a name="call_footnote_Temp_444" href="#footnote_Temp_444" id="call_footnote_Temp_444"><sup><small>54</small></sup></a>Thus we can make and use streams, in just the same way as we can makeand use lists, to represent aggregate data arranged in a sequence.  Inparticular, we can build stream analogs of the list operations fromchapter 2, such as <code>list-ref</code>, <code>map</code>, and <code>for-each</code>:<a name="call_footnote_Temp_445" href="#footnote_Temp_445" id="call_footnote_Temp_445"><sup><small>55</small></sup></a></p>
<p></p>
<p><pre><a name="%_idx_3758" id="%_idx_3758"></a>(define (stream-ref s n)
  (if (= n 0)
      (stream-car s)
      (stream-ref (stream-cdr s) (- n 1))))
<a name="%_idx_3760" id="%_idx_3760"></a>(define (stream-map proc s)
  (if (stream-null? s)
      the-empty-stream
      (cons-stream (proc (stream-car s))
                   (stream-map proc (stream-cdr s)))))
<a name="%_idx_3762" id="%_idx_3762"></a>(define (stream-for-each proc s)
  (if (stream-null? s)
      'done
      (begin (proc (stream-car s))
             (stream-for-each proc (stream-cdr s)))))
</pre></p>
<p></p>
<p><code>Stream-for-each</code> is useful for viewing streams:</p>
<p></p>
<p><pre><a name="%_idx_3764" id="%_idx_3764"></a>(define (display-stream s)
  (stream-for-each display-line s))

<a name="%_idx_3766" id="%_idx_3766"></a>(define (display-line x)
  (newline)
  (display x))
</pre></p>
<p></p>
<p></p>
<p>To make the stream implementation automatically and transparentlyinterleave the construction of a stream with its use, we will arrangefor the <code>cdr</code> of a stream to be evaluated when it is accessed bythe <code>stream-cdr</code> procedure rather than when the stream isconstructed by <code>cons-stream</code>.  This implementation choice isreminiscent of our discussion of rational numbers insection <a href="book-Z-H-14.html#%_sec_2.1.2">2.1.2</a>, where we saw that we canchoose to implement rational numbers so that the reduction ofnumerator and denominator to lowest terms is performed either atconstruction time or at selection time.  The two rational-numberimplementations produce the same data abstraction, but the choice hasan effect on efficiency.  There is a similar relationship betweenstreams and ordinary lists.  As a data abstraction, streams are thesame as lists.  The difference is the time at which the elements areevaluated.  With ordinary lists, both the <code>car</code> and the <code>cdr</code>are evaluated at construction time.  With streams, the <code>cdr</code> isevaluated at selection time.</p>
<p><a name="%_idx_3768" id="%_idx_3768"></a><a name="%_idx_3770" id="%_idx_3770"></a>Our implementation of streams will be based on a special form called<code>delay</code>.  Evaluating <code>(delay &lt;<em>exp</em>&gt;)</code> does notevaluate the expression &lt;<em>exp</em>&gt;, but rather returns a so-called <a name="%_idx_3772" id="%_idx_3772"></a><em>delayed object</em>, which we can think of as a “promise” to evaluate&lt;<em>exp</em>&gt; at some future time.  As a companion to <code>delay</code>, there isa procedure called <a name="%_idx_3774" id="%_idx_3774"></a><code>force</code> that takes a delayed object asargument and performs the evaluation – in effect, forcing the<code>delay</code> to fulfill its promise.  We will see below how <code>delay</code>and <code>force</code> can be implemented, but first let us use these toconstruct streams.</p>
<p><a name="%_idx_3776" id="%_idx_3776"></a><a name="%_idx_3778" id="%_idx_3778"></a><code>Cons-stream</code> is a special form defined so that</p>
<p></p>
<p></p>
<p><pre>(cons-stream &lt;<em>a</em>&gt; &lt;<em>b</em>&gt;)
</pre></p>
<p></p>
<p>is equivalent to</p>
<p></p>
<p></p>
<p><pre>(cons &lt;<em>a</em>&gt; (delay &lt;<em>b</em>&gt;))
</pre></p>
<p></p>
<p>What this means is that we will construct streams using pairs.  However,rather than placing the value of the rest of the streaminto the <code>cdr</code> of thepair we will put there a promise to compute the rest if it is everrequested.  <code>Stream-car</code> and <code>stream-cdr</code> can now be defined asprocedures:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3780" id="%_idx_3780"></a>(define (stream-car stream) (car stream))

<a name="%_idx_3782" id="%_idx_3782"></a>(define (stream-cdr stream) (force (cdr stream)))
</pre></p>
<p></p>
<p><code>Stream-car</code> selects the <code>car</code> of the pair; <code>stream-cdr</code>selects the <code>cdr</code> of the pair and evaluates the delayed expressionfound there to obtain the rest of the stream.<a name="call_footnote_Temp_446" href="#footnote_Temp_446" id="call_footnote_Temp_446"><sup><small>56</small></sup></a><a name="%_sec_Temp_447" id="%_sec_Temp_447"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_447">The stream implementation in action</a></h4>
<p>To see how this implementation behaves, let us analyze the“outrageous” prime computation we saw above, reformulated in termsof streams:</p>
<p></p>
<p></p>
<p><pre>(stream-car
 (stream-cdr
  (stream-filter prime?
                 (stream-enumerate-interval 10000 1000000))))
</pre></p>
<p></p>
<p>We will see that it does indeed work efficiently.</p>
<p>We begin by calling <code>stream-enumerate-interval</code> withthe arguments 10,000 and 1,000,000.  <code>Stream-enumerate-interval</code>is the stream analog of <code>enumerate-interval</code>(section <a href="book-Z-H-15.html#%_sec_2.2.3">2.2.3</a>):</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3788" id="%_idx_3788"></a>(define (stream-enumerate-interval low high)
  (if (&gt; low high)
      the-empty-stream
      (cons-stream
       low
       (stream-enumerate-interval (+ low 1) high))))
</pre></p>
<p></p>
<p>and thus the result returned by <code>stream-enumerate-interval</code>,formed by the <code>cons-stream</code>, is<a name="call_footnote_Temp_448" href="#footnote_Temp_448" id="call_footnote_Temp_448"><sup><small>57</small></sup></a></p>
<p></p>
<p></p>
<p><pre>(cons 10000
      (delay (stream-enumerate-interval 10001 1000000)))
</pre></p>
<p></p>
<p>That is, <code>stream-enumerate-interval</code>returns a stream represented as a pair whose <code>car</code>is 10,000 and whose <code>cdr</code> is a promise to enumerate more of theinterval if so requested.  This stream is now filtered for primes,using the stream analog of the <code>filter</code> procedure(section <a href="book-Z-H-15.html#%_sec_2.2.3">2.2.3</a>):</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3790" id="%_idx_3790"></a>(define (stream-filter pred stream)
  (cond ((stream-null? stream) the-empty-stream)
        ((pred (stream-car stream))
         (cons-stream (stream-car stream)
                      (stream-filter pred
                                     (stream-cdr stream))))
        (else (stream-filter pred (stream-cdr stream)))))
</pre></p>
<p></p>
<p><code>Stream-filter</code> tests the <code>stream-car</code> of the stream (the <code>car</code> of the pair, which is 10,000).  Since this is not prime,<code>stream-filter</code> examines the <code>stream-cdr</code> of its inputstream.  The call to <code>stream-cdr</code> forces evaluation of the delayed<code>stream-enumerate-interval</code>, which now returns</p>
<p></p>
<p></p>
<p><pre>(cons 10001
      (delay (stream-enumerate-interval 10002 1000000)))
</pre></p>
<p></p>
<p><code>Stream-filter</code> now looks at the <code>stream-car</code> of this stream,10,001, sees that this is not prime either, forces another <code>stream-cdr</code>, and so on, until <code>stream-enumerate-interval</code> yieldsthe prime 10,007, whereupon <code>stream-filter</code>, according to itsdefinition, returns</p>
<p></p>
<p></p>
<p><pre>(cons-stream (stream-car stream)
             (stream-filter pred (stream-cdr stream)))
</pre></p>
<p></p>
<p>which in this case is</p>
<p></p>
<p></p>
<p><pre>(cons 10007
      (delay
        (stream-filter
         prime?
         (cons 10008
               (delay
                 (stream-enumerate-interval 10009
                                            1000000))))))
</pre></p>
<p></p>
<p>This result is now passed to <code>stream-cdr</code> in ouroriginal expression.  This forces the delayed <code>stream-filter</code>, which in turn keeps forcing the delayed <code>stream-enumerate-interval</code> until it finds the next prime, which is10,009.  Finally, the result passed to <code>stream-car</code> in ouroriginal expression is</p>
<p></p>
<p></p>
<p><pre>(cons 10009
      (delay
        (stream-filter
         prime?
         (cons 10010
               (delay
                 (stream-enumerate-interval 10011
                                            1000000))))))
</pre></p>
<p></p>
<p><code>Stream-car</code> returns 10,009, and the computation is complete.  Only asmany integers were tested for primality as were necessary to find thesecond prime, and the interval was enumerated only as far as wasnecessary to feed the prime filter.</p>
<p>In general, we can think of delayed evaluation as <a name="%_idx_3792" id="%_idx_3792"></a>“demand-driven”programming, whereby each stage in the stream process is activatedonly enough to satisfy the next stage.  What we have done is to<a name="%_idx_3794" id="%_idx_3794"></a>decouple the actual order of events in the computation from theapparent structure of our procedures.  We write procedures as if thestreams existed “all at once” when, in reality, the computation isperformed incrementally, as in traditional programming styles.</p>
<p><a name="%_sec_Temp_449" id="%_sec_Temp_449"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_449">Implementing <code>delay</code> and <code>force</code></a></h4>
<p><a name="%_idx_3796" id="%_idx_3796"></a>Although <code>delay</code> and <code>force</code> may seem like mysteriousoperations, their implementation is really quite straightforward.<code>Delay</code> must package an expression so that it can be evaluatedlater on demand, and we can accomplish this simply by treating theexpression as the body of a procedure.  <code>Delay</code> can be a specialform such that</p>
<p></p>
<p></p>
<p><pre>(delay &lt;<em>exp</em>&gt;)
</pre></p>
<p></p>
<p>is syntactic sugar for</p>
<p></p>
<p></p>
<p><pre>(lambda () &lt;<em>exp</em>&gt;)
</pre></p>
<p></p>
<p><code>Force</code> simply calls the procedure (of noarguments) produced by <code>delay</code>, so we can implement <code>force</code> asa procedure:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3798" id="%_idx_3798"></a>(define (force delayed-object)
  (delayed-object))
</pre></p>
<p></p>
<p></p>
<p><a name="%_idx_3800" id="%_idx_3800"></a><a name="%_idx_3802" id="%_idx_3802"></a>This implementation suffices for <code>delay</code> and <code>force</code> to workas advertised, but there is an important optimization that we caninclude.  In many applications, we end up forcing the same delayed objectmany times.  This can lead to serious inefficiency in recursiveprograms involving streams.  (Seeexercise <a href="#%_thm_3.57">3.57</a>.)  The solution is to builddelayed objects so that the first time they are forced, they store thevalue that is computed.  Subsequent forcings will simply return thestored value without repeating the computation.  In other words, weimplement <code>delay</code> as a special-purpose memoized procedure similarto the one described in exercise <a href="book-Z-H-22.html#%_thm_3.27">3.27</a>.  One way toaccomplish this is to use the following procedure, which takes asargument a procedure (of no arguments) and returns a memoized versionof the procedure.  The first time the memoized procedure is run, itsaves the computed result.  On subsequent evaluations, it simplyreturns the result.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3804" id="%_idx_3804"></a>(define (memo-proc proc)
  (let ((already-run? false) (result false))
    (lambda ()
      (if (not already-run?)
          (begin (set! result (proc))
                 (set! already-run? true)
                 result)
          result))))
</pre></p>
<p></p>
<p><code>Delay</code> is then defined so that <code>(delay &lt;<em>exp</em>&gt;)</code> isequivalent to</p>
<p></p>
<p></p>
<p><pre>(memo-proc (lambda () &lt;<em>exp</em>&gt;))
</pre></p>
<p></p>
<p>and <code>force</code> is as defined previously.<a name="call_footnote_Temp_450" href="#footnote_Temp_450" id="call_footnote_Temp_450"><sup><small>58</small></sup></a></p>
<p></p>
<p><a name="%_thm_3.50" id="%_thm_3.50"></a><b>Exercise 3.50.</b>  Complete the following definition, whichgeneralizes <code>stream-map</code> to allow procedures thattake multiple arguments, analogous to <code>map</code> insection <a href="book-Z-H-15.html#%_sec_2.2.3">2.2.3</a>, footnote <a href="book-Z-H-15.html#footnote_Temp_166">12</a>.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3824" id="%_idx_3824"></a>(define (stream-map proc . argstreams)
  (if (&lt;<em>??</em>&gt; (car argstreams))
      the-empty-stream
      (&lt;<em>??</em>&gt;
       (apply proc (map &lt;<em>??</em>&gt; argstreams))
       (apply stream-map
              (cons proc (map &lt;<em>??</em>&gt; argstreams))))))
</pre></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_3.51" id="%_thm_3.51"></a><b>Exercise 3.51.</b>  <a name="%_idx_3826" id="%_idx_3826"></a>In order to take a closer look at delayed evaluation, we will use thefollowing procedure, which simply returns its argument after printing it:</p>
<p></p>
<p></p>
<p><pre>(define (show x)
  (display-line x)
  x)
</pre></p>
<p></p>
<p>What does the interpreter print in response to evaluating eachexpression in the following sequence?<a name="call_footnote_Temp_453" href="#footnote_Temp_453" id="call_footnote_Temp_453"><sup><small>59</small></sup></a></p>
<p></p>
<p></p>
<p><pre>(define x (stream-map show (stream-enumerate-interval 0 10)))
(stream-ref x 5)
(stream-ref x 7)
</pre></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_3.52" id="%_thm_3.52"></a><b>Exercise 3.52.</b>  <a name="%_idx_3830" id="%_idx_3830"></a>Consider the sequence of expressions</p>
<p></p>
<p></p>
<p><pre>(define sum 0)
(define (accum x)
  (set! sum (+ x sum))
  sum)
(define seq (stream-map accum (stream-enumerate-interval 1 20)))
(define y (stream-filter even? seq))
(define z (stream-filter (lambda (x) (= (remainder x 5) 0))
                         seq))
(stream-ref y 7)
(display-stream z)
</pre></p>
<p></p>
<p>What is the value of <code>sum</code> after each of the above expressions isevaluated?  What is the printed response to evaluating the <code>stream-ref</code> and <code>display-stream</code> expressions?  Would these responsesdiffer if we had implemented <code>(delay &lt;<em>exp</em>&gt;)</code> simply as<code>(lambda () &lt;<em>exp</em>&gt;)</code> without using the optimization provided by<code>memo-proc</code> ?  Explain.</p>
<p></p>
<p><a name="%_sec_3.5.2" id="%_sec_3.5.2"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_3.5.2">3.5.2  Infinite Streams</a></h3>
<p><a name="%_idx_3832" id="%_idx_3832"></a>We have seen how to support the illusion of manipulating streamsas complete entities even though, in actuality, we compute onlyas much of the stream as we need to access.  We can exploit thistechnique to represent sequences efficiently as streams, even if thesequences are very long.  What is more striking, we can use streams torepresent sequences that are infinitely long.  For instance, considerthe following definition of the stream of positive integers:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3834" id="%_idx_3834"></a>(define (integers-starting-from n)
  (cons-stream n (integers-starting-from (+ n 1))))

<a name="%_idx_3836" id="%_idx_3836"></a>(define integers (integers-starting-from 1))
</pre></p>
<p></p>
<p>This makes sense because <code>integers</code> will be a pair whose <code>car</code>is 1 and whose <code>cdr</code> is a promise to produce the integersbeginning with 2.  This is an infinitely long stream, but in any giventime we can examine only a finite portion of it.  Thus, our programswill never know that the entire infinite stream is not there.</p>
<p>Using <code>integers</code> we can define other infinite streams, such asthe stream of integers that are not divisible by 7:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3838" id="%_idx_3838"></a>(define (divisible? x y) (= (remainder x y) 0))
(define no-sevens
  (stream-filter (lambda (x) (not (divisible? x 7)))
                 integers))
</pre></p>
<p></p>
<p>Then we can find integers not divisible by 7 simply by accessingelements of this stream:</p>
<p></p>
<p></p>
<p><pre>(stream-ref no-sevens 100)
<i>117</i>
</pre></p>
<p></p>
<p></p>
<p>In analogy with <code>integers</code>, we can define the infinite stream ofFibonacci numbers:</p>
<p></p>
<p></p>
<p><pre>(define (fibgen a b)
  (cons-stream a (fibgen b (+ a b))))
<a name="%_idx_3840" id="%_idx_3840"></a>(define fibs (fibgen 0 1))
</pre></p>
<p></p>
<p><code>Fibs</code> is a pair whose <code>car</code> is 0 and whose <code>cdr</code> is apromise to evaluate <code>(fibgen 1 1)</code>.  When we evaluate this delayed<code>(fibgen 1 1)</code>, itwill produce a pair whose <code>car</code> is 1 and whose <code>cdr</code> is apromise to evaluate <code>(fibgen 1 2)</code>, and so on.</p>
<p><a name="%_idx_3842" id="%_idx_3842"></a>For a look at a more exciting infinite stream, we can generalize the<code>no-sevens</code> example to construct the infinite stream of primenumbers, using a method known as the <a name="%_idx_3844" id="%_idx_3844"></a><em>sieve ofEratosthenes</em>.<a name="call_footnote_Temp_455" href="#footnote_Temp_455" id="call_footnote_Temp_455"><sup><small>60</small></sup></a> Westart with the integers beginning with 2, which is the first prime.To get the rest of the primes, we start by filtering the multiples of2 from the rest of the integers.  This leaves a stream beginning with3, which is the next prime.  Now we filter the multiples of 3 from therest of this stream.  This leaves a stream beginning with 5, which isthe next prime, and so on.  In other words, we construct the primes bya sieving process, described as follows: To sieve a stream <code>S</code>,form a stream whose first element is the first element of <code>S</code> andthe rest of which is obtained by filtering all multiples of the first elementof <code>S</code> out of the rest of <code>S</code> and sieving the result. Thisprocess is readily described in terms of stream operations:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3852" id="%_idx_3852"></a>(define (sieve stream)
  (cons-stream
   (stream-car stream)
   (sieve (stream-filter
           (lambda (x)
             (not (divisible? x (stream-car stream))))
           (stream-cdr stream)))))

<a name="%_idx_3854" id="%_idx_3854"></a>(define primes (sieve (integers-starting-from 2)))
</pre></p>
<p></p>
<p>Now to find a particular prime we need only ask for it:</p>
<p></p>
<p></p>
<p><pre>(stream-ref primes 50)
<i>233</i>
</pre></p>
<p></p>
<p></p>
<p>It is interesting to contemplate the signal-processing system set upby <code>sieve</code>, shown in the <a name="%_idx_3856" id="%_idx_3856"></a>“Henderson diagram” infigure <a href="#%_fig_3.31">3.31</a>.<a name="call_footnote_Temp_456" href="#footnote_Temp_456" id="call_footnote_Temp_456"><sup><small>61</small></sup></a>The input stream feeds into an“un<code>cons</code>er” that separates the first element of the stream from therest of the stream.The first element is used to construct a divisibility filter, throughwhich the rest is passed, and the output of the filter is fed toanother sieve box.  Then the original first element is <code>cons</code>ed onto theoutput of the internal sieve to form the output stream.  Thus, notonly is the stream infinite, but the signal processor is alsoinfinite, because the sieve contains a sieve within it.</p>
<p><a name="%_fig_3.31" id="%_fig_3.31"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch3-Z-G-35.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 3.31:</b>  The prime sieve viewed as a signal-processing system.</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p><a name="%_sec_Temp_457" id="%_sec_Temp_457"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_457">Defining streams implicitly</a></h4>
<p><a name="%_idx_3860" id="%_idx_3860"></a>The <code>integers</code> and <code>fibs</code> streams above were defined byspecifying “generating” procedures that explicitly compute thestream elements one by one. An alternative way to specify streams isto take advantage of delayed evaluation to define streams implicitly.For example, the following expression defines the stream <code>ones</code> tobe an infinite stream of ones:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3862" id="%_idx_3862"></a>(define ones (cons-stream 1 ones))
</pre></p>
<p></p>
<p>This works much like the definition of a recursive procedure: <code>ones</code> is a pair whose <code>car</code> is 1 and whose <code>cdr</code> is a promiseto evaluate <code>ones</code>.  Evaluating the <code>cdr</code> gives us again a 1and a promise to evaluate <code>ones</code>, and so on.</p>
<p>We can do more interesting things by manipulating streams withoperations such as <code>add-streams</code>, which produces the elementwisesum of two given streams:<a name="call_footnote_Temp_458" href="#footnote_Temp_458" id="call_footnote_Temp_458"><sup><small>62</small></sup></a></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3864" id="%_idx_3864"></a>(define (add-streams s1 s2)
  (stream-map + s1 s2))
</pre></p>
<p></p>
<p>Now we can define the integers as follows:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3866" id="%_idx_3866"></a>(define integers (cons-stream 1 (add-streams ones integers)))
</pre></p>
<p></p>
<p>This defines <code>integers</code> to be a stream whose first element is 1and the rest of which is the sum of <code>ones</code> and <code>integers</code>.  Thus, thesecond element of <code>integers</code> is 1 plus the first element of <code>integers</code>,or 2; the third element of <code>integers</code> is 1 plus the secondelement of <code>integers</code>, or 3; and so on.  This definition worksbecause, at any point, enough of the <code>integers</code> stream has beengenerated so that we can feed it back into the definition to producethe next integer.</p>
<p>We can define the Fibonacci numbers in the same style:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3868" id="%_idx_3868"></a>(define fibs
  (cons-stream 0
               (cons-stream 1
                            (add-streams (stream-cdr fibs)
                                         fibs))))
</pre></p>
<p></p>
<p>This definition says that <code>fibs</code> is a stream beginning with 0 and1, such that the rest of the stream can be generated by adding <code>fibs</code>to itself shifted by one place:</p>
<p></p>
<table border="0">
<tr>
<td valign="top"></td>
<td valign="top"></td>
<td valign="top">1 </td>
<td valign="top">1 </td>
<td valign="top">2 </td>
<td valign="top">3 </td>
<td valign="top">5 </td>
<td valign="top">8 </td>
<td valign="top">13 </td>
<td valign="top">21 </td>
<td valign="top">
<code>...</code> = <code>(stream-cdr fibs)</code>
</td>
</tr>
<tr>
<td valign="top"></td>
<td valign="top"></td>
<td valign="top">0 </td>
<td valign="top">1 </td>
<td valign="top">1 </td>
<td valign="top">2 </td>
<td valign="top">3 </td>
<td valign="top">5 </td>
<td valign="top"> 8 </td>
<td valign="top">13 </td>
<td valign="top">
<code>...</code> = <code>fibs</code>
</td>
</tr>
<tr>
<td valign="top">0 </td>
<td valign="top">1 </td>
<td valign="top">1 </td>
<td valign="top">2 </td>
<td valign="top">3 </td>
<td valign="top">5 </td>
<td valign="top">8 </td>
<td valign="top">13 </td>
<td valign="top">21 </td>
<td valign="top">34 </td>
<td valign="top">
<code>...</code> = <code>fibs</code>
</td>
</tr>
<tr><td valign="top"></td></tr>
</table>
<p><code>Scale-stream</code> is another useful procedure in formulating such stream definitions.This multiplies each item in a stream by a givenconstant:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3870" id="%_idx_3870"></a>(define (scale-stream stream factor)
  (stream-map (lambda (x) (* x factor)) stream))
</pre></p>
<p></p>
<p>For example,</p>
<p></p>
<p></p>
<p><pre>(define double (cons-stream 1 (scale-stream double 2)))
</pre></p>
<p></p>
<p>produces the stream of powers of 2: 1, 2, 4, 8, 16, 32, <code>...</code>.</p>
<p>An alternate definition of the stream of primes can be given bystarting with the integers and filtering them by testing forprimality.  We will need the first prime, 2, to get started:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3872" id="%_idx_3872"></a>(define primes
  (cons-stream
   2
   (stream-filter prime? (integers-starting-from 3))))
</pre></p>
<p></p>
<p>This definition is not so straightforward as it appears, because wewill test whether a number <em>n</em> is prime by checking whether <em>n</em> isdivisible by a prime (not by just any integer) less than or equal to√<em>n</em>:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3874" id="%_idx_3874"></a>(define (prime? n)
  (define (iter ps)
    (cond ((&gt; (square (stream-car ps)) n) true)
          ((divisible? n (stream-car ps)) false)
          (else (iter (stream-cdr ps)))))
  (iter primes))
</pre></p>
<p></p>
<p>This is a recursive definition, since <code>primes</code> is defined in termsof the <code>prime?</code> predicate, which itself uses the <code>primes</code>stream.  The reason this procedure works is that, at any point, enoughof the <code>primes</code> stream has been generated to test the primality ofthe numbers we need to check next.  That is, for every <em>n</em> we test forprimality, either <em>n</em> is not prime (in which case there is a primealready generated that divides it) or <em>n</em> is prime (in which casethere is a prime already generated – i.e., a prime less than<em>n</em> – that is greater than √<em>n</em>).<a name="call_footnote_Temp_459" href="#footnote_Temp_459" id="call_footnote_Temp_459"><sup><small>63</small></sup></a></p>
<p><a name="%_thm_3.53" id="%_thm_3.53"></a><b>Exercise 3.53.</b>  Without running the program, describe the elements of thestream defined by</p>
<p></p>
<p><pre>(define s (cons-stream 1 (add-streams s s)))
</pre></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_3.54" id="%_thm_3.54"></a><b>Exercise 3.54.</b>  Define a procedure <a name="%_idx_3886" id="%_idx_3886"></a><a name="%_idx_3888" id="%_idx_3888"></a><a name="%_idx_3890" id="%_idx_3890"></a><code>mul-streams</code>, analogous to <code>add-streams</code>,that produces the elementwise product of its two input streams.Use this together with the stream of <code>integers</code> to complete thefollowing definition of the stream whose <em>n</em>th element (counting from 0)is <em>n</em> + 1 factorial:</p>
<p></p>
<p><pre>(define factorials (cons-stream 1 (mul-streams &lt;<em>??</em>&gt; &lt;<em>??</em>&gt;)))
</pre></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_3.55" id="%_thm_3.55"></a><b>Exercise 3.55.</b>  Define a procedure <a name="%_idx_3892" id="%_idx_3892"></a><code>partial-sums</code> that takes as argument astream <em>S</em> and returns the stream whoseelements are <em>S</em><sub>0</sub>, <em>S</em><sub>0</sub> + <em>S</em><sub>1</sub>, <em>S</em><sub>0</sub> + <em>S</em><sub>1</sub> + <em>S</em><sub>2</sub>, <code>...</code>.  For example, <code>(partial-sums integers)</code> should be the stream1, 3, 6, 10, 15, <code>...</code>.</p>
<p></p>
<p></p>
<p><a name="%_thm_3.56" id="%_thm_3.56"></a><b>Exercise 3.56.</b>  A famous problem, first raised by <a name="%_idx_3894" id="%_idx_3894"></a>R. Hamming, is to enumerate, inascending order with no repetitions, all positive integers with noprime factors other than 2, 3, or 5.  One obvious way to do this is tosimply test each integer in turn to see whether it has any factorsother than 2, 3, and 5.  But this is very inefficient, since, as theintegers get larger, fewer and fewer of them fit the requirement.  Asan alternative, let us call the required stream of numbers <code>S</code> andnotice the following facts about it.</p>
<p></p>
<ul>
<li>
<code>S</code> begins with 1.<p></p>
</li>
<li>The elements of <code>(scale-stream S 2)</code> are alsoelements of <code>S</code>.<p></p>
</li>
<li>The same is true for <code>(scale-stream S 3)</code>and <code>(scale-stream 5 S)</code>.<p></p>
</li>
<li>These are all the elements of <code>S</code>.</li>
</ul>
<p></p>
<p><a name="%_idx_3896" id="%_idx_3896"></a>Now all we have to do is combine elements from these sources.For this we define a procedure <code>merge</code> that combines two orderedstreams into one ordered result stream, eliminating repetitions:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3898" id="%_idx_3898"></a>(define (merge s1 s2)
  (cond ((stream-null? s1) s2)
        ((stream-null? s2) s1)
        (else
         (let ((s1car (stream-car s1))
               (s2car (stream-car s2)))
           (cond ((&lt; s1car s2car)
                  (cons-stream s1car (merge (stream-cdr s1) s2)))
                 ((&gt; s1car s2car)
                  (cons-stream s2car (merge s1 (stream-cdr s2))))
                 (else
                  (cons-stream s1car
                               (merge (stream-cdr s1)
                                      (stream-cdr s2)))))))))
</pre></p>
<p></p>
<p>Then the required stream may be constructed with <code>merge</code>, asfollows:</p>
<p></p>
<p></p>
<p><pre>(define S (cons-stream 1 (merge &lt;<em>??</em>&gt; &lt;<em>??</em>&gt;)))
</pre></p>
<p></p>
<p>Fill in the missing expressions in the places marked &lt;<em>??</em>&gt; above.</p>
<p></p>
<p></p>
<p><a name="%_thm_3.57" id="%_thm_3.57"></a><b>Exercise 3.57.</b>  <a name="%_idx_3900" id="%_idx_3900"></a>How many additions are performed when we compute the <em>n</em>th Fibonaccinumber using the definition of <code>fibs</code> based on the <code>add-streams</code> procedure?  Show that the number of additions would beexponentially greater if we had implemented<code>(delay &lt;<em>exp</em>&gt;)</code> simply as <code>(lambda () &lt;<em>exp</em>&gt;)</code>,without using the optimization provided by the <code>memo-proc</code>procedure described in section <a href="#%_sec_3.5.1">3.5.1</a>.<a name="call_footnote_Temp_465" href="#footnote_Temp_465" id="call_footnote_Temp_465"><sup><small>64</small></sup></a></p>
<p></p>
<p></p>
<p><a name="%_thm_3.58" id="%_thm_3.58"></a><b>Exercise 3.58.</b>  Give an interpretation of the stream computed by the followingprocedure:</p>
<p></p>
<p></p>
<p><pre>(define (expand num den radix)
  (cons-stream
   (quotient (* num radix) den)
   (expand (remainder (* num radix) den) den radix)))
</pre></p>
<p></p>
<p><a name="%_idx_3906" id="%_idx_3906"></a><a name="%_idx_3908" id="%_idx_3908"></a>(<code>Quotient</code> is a primitive that returns the integer quotient oftwo integers.)  What are the successive elements produced by <code>(expand 1 7 10)</code> ?  What is produced by <code>(expand 3 8 10)</code> ?</p>
<p></p>
<p></p>
<p><a name="%_thm_3.59" id="%_thm_3.59"></a><b>Exercise 3.59.</b>  <a name="%_idx_3910" id="%_idx_3910"></a><a name="%_idx_3912" id="%_idx_3912"></a>In section <a href="book-Z-H-18.html#%_sec_2.5.3">2.5.3</a> we saw how to implement apolynomial arithmetic system representing polynomials as lists ofterms.  In a similar way, we can work with <em>power series</em>, such as</p>
<p><a name="%_idx_3914" id="%_idx_3914"></a></p>
<p></p>
<div align="left"><img src="images/ch3-Z-G-36.gif" border="0"></div>
<p></p>
<p><a name="%_idx_3916" id="%_idx_3916"></a></p>
<p></p>
<div align="left"><img src="images/ch3-Z-G-37.gif" border="0"></div>
<p></p>
<p><a name="%_idx_3918" id="%_idx_3918"></a></p>
<p></p>
<div align="left"><img src="images/ch3-Z-G-38.gif" border="0"></div>
<p></p>
<p>represented as infinite streams.We will represent the series<em>a</em><sub>0</sub>  +  <em>a</em><sub>1</sub><em>x</em>  +  <em>a</em><sub>2</sub><em>x</em><sup>2</sup>  +  <em>a</em><sub>3</sub><em>x</em><sup>3</sup>  +  <code>···</code>as the stream whose elements are the coefficients <em>a</em><sub>0</sub>, <em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, <em>a</em><sub>3</sub>, <code>...</code>.</p>
<p></p>
<p></p>
<p><a name="%_idx_3920" id="%_idx_3920"></a><a name="%_idx_3922" id="%_idx_3922"></a>a. The integral of the series <em>a</em><sub>0</sub>  +  <em>a</em><sub>1</sub><em>x</em>  +  <em>a</em><sub>2</sub><em>x</em><sup>2</sup>  +  <em>a</em><sub>3</sub><em>x</em><sup>3</sup>  +  <code>···</code>is the series</p>
<p></p>
<div align="left"><img src="images/ch3-Z-G-39.gif" border="0"></div>
<p>where <em>c</em> is any constant.Define a procedure <a name="%_idx_3924" id="%_idx_3924"></a><code>integrate-series</code> that takes as input a stream<em>a</em><sub>0</sub>, <em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, <code>...</code> representing a power series and returns the stream<em>a</em><sub>0</sub>, (1/2)<em>a</em><sub>1</sub>, (1/3)<em>a</em><sub>2</sub>, <code>...</code> of coefficients ofthe non-constant terms of the integral of the series.(Since the result has no constant term, it doesn't represent a powerseries; when we use <code>integrate-series</code>, we will <code>cons</code> onthe appropriate constant.) </p>
<p></p>
<p></p>
<p>b. The function <em>x</em> ⟼  <em>e</em><sup><em>x</em></sup> is its ownderivative.  This implies that <em>e</em><sup><em>x</em></sup> and the integral of <em>e</em><sup><em>x</em></sup> are thesame series, except for the constant term, which is <em>e</em><sup>0</sup>  = 1.Accordingly, we can generate the series for<em>e</em><sup><em>x</em></sup> as</p>
<p></p>
<p><pre>(define exp-series
  (cons-stream 1 (integrate-series exp-series)))
</pre></p>
<p></p>
<p>Show how to generate the series for sine and cosine, starting from the factsthat the derivative of sine is cosine and the derivative of cosine isthe negative of sine:</p>
<p></p>
<p><pre>(define cosine-series
  (cons-stream 1 &lt;<em>??</em>&gt;))
(define sine-series
  (cons-stream 0 &lt;<em>??</em>&gt;))
</pre></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_3.60" id="%_thm_3.60"></a><b>Exercise 3.60.</b>  <a name="%_idx_3926" id="%_idx_3926"></a><a name="%_idx_3928" id="%_idx_3928"></a><a name="%_idx_3930" id="%_idx_3930"></a><a name="%_idx_3932" id="%_idx_3932"></a>With power series represented as streams of coefficients as inexercise <a href="#%_thm_3.59">3.59</a>, adding series is implemented by <code>add-streams</code>.  Complete the definition of the following procedure formultiplying series:</p>
<p></p>
<p><pre>(define (mul-series s1 s2)
  (cons-stream &lt;<em>??</em>&gt; (add-streams &lt;<em>??</em>&gt; &lt;<em>??</em>&gt;)))
</pre></p>
<p></p>
<p>You can test your procedure by verifying that<em>s</em><em>i</em><em>n</em><sup>2</sup><em>x</em>  +  <em>c</em><em>o</em><em>s</em><sup>2</sup><em>x</em>  =  1, using the series from exercise <a href="#%_thm_3.59">3.59</a>.</p>
<p></p>
<p></p>
<p><a name="%_thm_3.61" id="%_thm_3.61"></a><b>Exercise 3.61.</b>  Let <em>S</em> be a power series (exercise <a href="#%_thm_3.59">3.59</a>)whose constant term is 1.  Suppose we wantto find the power series 1/<em>S</em>, that is, the series <em>X</em> such that<em>S</em> ·  <em>X</em> =  1.  Write <em>S</em> = 1 + <em>S</em><sub><em>R</em></sub> where <em>S</em><sub><em>R</em></sub> is the part of <em>S</em> afterthe constant term.  Then we can solve for <em>X</em> as follows:</p>
<p></p>
<div align="left"><img src="images/ch3-Z-G-40.gif" border="0"></div>
<p>In other words, <em>X</em> is the power series whose constant term is 1 andwhose higher-order terms are given by the negative of <em>S</em><sub><em>R</em></sub> times <em>X</em>.Use this idea to write a procedure <code>invert-unit-series</code> that computes 1/<em>S</em> for a power series <em>S</em> withconstant term 1.You will need to use <code>mul-series</code> from exercise <a href="#%_thm_3.60">3.60</a>.</p>
<p></p>
<p></p>
<p><a name="%_thm_3.62" id="%_thm_3.62"></a><b>Exercise 3.62.</b>  <a name="%_idx_3934" id="%_idx_3934"></a><a name="%_idx_3936" id="%_idx_3936"></a><a name="%_idx_3938" id="%_idx_3938"></a>Use the results of exercises <a href="#%_thm_3.60">3.60</a>and <a href="#%_thm_3.61">3.61</a> to define a procedure <code>div-series</code>that divides two power series.  <code>Div-series</code> should work for anytwo series, provided that the denominator series begins with anonzero constant term.  (If the denominator has a zero constant term,then <code>div-series</code> should signal an error.)Show how to use <code>div-series</code>together with the result of exercise <a href="#%_thm_3.59">3.59</a> to generate<a name="%_idx_3940" id="%_idx_3940"></a>the power series for tangent.</p>
<p><a name="%_sec_3.5.3" id="%_sec_3.5.3"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_3.5.3">3.5.3  Exploiting the Stream Paradigm</a></h3>
<p></p>
<p>Streams with delayed evaluation can be a powerful modeling tool,providing many of the benefits of local state and assignment.Moreover, they avoid some of the theoretical tangles that accompanythe introduction of assignment into a programming language.</p>
<p><a name="%_idx_3942" id="%_idx_3942"></a>The stream approach can be illuminating because it allows us to buildsystems with different module boundaries than systems organized aroundassignment to state variables.  For example, we can think of an entiretime series (or signal) as a focus of interest, rather than the valuesof the state variables at individual moments.  This makes itconvenient to combine and compare components of state from differentmoments.</p>
<p><a name="%_sec_Temp_471" id="%_sec_Temp_471"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_471">Formulating iterations as stream processes</a></h4>
<p><a name="%_idx_3944" id="%_idx_3944"></a>In section <a href="book-Z-H-11.html#%_sec_1.2.1">1.2.1</a>, we introduced iterativeprocesses, which proceed by updating state variables.  We know nowthat we can represent state as a “timeless” stream of values ratherthan as a set of variables to be updated.  Let's adopt thisperspective in revisiting the square-root procedure fromsection <a href="book-Z-H-10.html#%_sec_1.1.7">1.1.7</a>.  Recall that the idea is to generate asequence of better and better guesses for the square root of <em>x</em> byapplying over and over again the procedure that improves guesses:</p>
<p></p>
<p></p>
<p><pre>(define (sqrt-improve guess x)
  (average guess (/ x guess)))
</pre></p>
<p></p>
<p></p>
<p><a name="%_idx_3946" id="%_idx_3946"></a>In our original <code>sqrt</code> procedure, we made these guesses be thesuccessive values of a state variable. Instead we can generate theinfinite stream of guesses, starting with an initial guess of 1:<a name="call_footnote_Temp_472" href="#footnote_Temp_472" id="call_footnote_Temp_472"><sup><small>65</small></sup></a></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3948" id="%_idx_3948"></a>(define (sqrt-stream x)
  (define guesses
    (cons-stream 1.0
                 (stream-map (lambda (guess)
                               (sqrt-improve guess x))
                             guesses)))
  guesses)
(display-stream (sqrt-stream 2))
<i>1.</i>
<i>1.5</i>
<i>1.4166666666666665</i>
<i>1.4142156862745097</i>
<i>1.4142135623746899</i>
<code>...</code></pre></p>
<p></p>
<p>We can generate more and more terms of the stream to get better andbetter guesses.  If we like, we can write a procedure that keepsgenerating terms until the answer is good enough.  (Seeexercise <a href="#%_thm_3.64">3.64</a>.)</p>
<p><a name="%_idx_3950" id="%_idx_3950"></a><a name="%_idx_3952" id="%_idx_3952"></a><a name="%_idx_3954" id="%_idx_3954"></a><a name="%_idx_3956" id="%_idx_3956"></a><a name="%_idx_3958" id="%_idx_3958"></a><a name="%_idx_3960" id="%_idx_3960"></a>Another iteration that we can treat in the same way is to generate anapproximation to π, based upon the alternating series that we sawin section <a href="book-Z-H-12.html#%_sec_1.3.1">1.3.1</a>:</p>
<p></p>
<p></p>
<div align="left"><img src="images/ch3-Z-G-41.gif" border="0"></div>
<p></p>
<p>We first generate the stream of summands of the series (the reciprocalsof the odd integers, with alternating signs).  Then we take the streamof sums of more and more terms (using the <code>partial-sums</code> procedureof exercise <a href="#%_thm_3.55">3.55</a>) and scale the result by 4:</p>
<p></p>
<p><pre>(define (pi-summands n)
  (cons-stream (/ 1.0 n)
               (stream-map - (pi-summands (+ n 2)))))
<a name="%_idx_3962" id="%_idx_3962"></a>(define pi-stream
  (scale-stream (partial-sums (pi-summands 1)) 4))
(display-stream pi-stream)
<i>4.</i>
<i>2.666666666666667</i>
<i>3.466666666666667</i>
<i>2.8952380952380956</i>
<i>3.3396825396825403</i>
<i>2.9760461760461765</i>
<i>3.2837384837384844</i>
<i>3.017071817071818</i>
<code>...</code></pre></p>
<p></p>
<p>This gives us a stream of better and better approximations to π,although the approximations converge rather slowly.  Eight terms ofthe sequence bound the value of π between 3.284 and 3.017.</p>
<p><a name="%_idx_3964" id="%_idx_3964"></a>So far, our use of the stream of states approach is not much differentfrom updating state variables.  But streams give us an opportunity todo some interesting tricks.  For example, we can transform a streamwith a <a name="%_idx_3966" id="%_idx_3966"></a><em>sequence accelerator</em> that converts a sequence ofapproximations to a new sequence that converges to the same value asthe original, only faster.</p>
<p>One such accelerator, due to the eighteenth-century Swiss mathematician<a name="%_idx_3968" id="%_idx_3968"></a>Leonhard Euler, works well with sequences that are partial sums ofalternating series (series of terms with alternating signs).In Euler's technique, if <em>S</em><sub><em>n</em></sub> is the <em>n</em>th termof the original sum sequence, then the accelerated sequence has terms</p>
<p></p>
<div align="left"><img src="images/ch3-Z-G-42.gif" border="0"></div>
<p>Thus, if the original sequence is represented as a stream of values,the transformed sequence is given by</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3970" id="%_idx_3970"></a>(define (euler-transform s)
  (let ((s0 (stream-ref s 0))           <em>; <em>S</em><sub><em>n</em>-1</sub></em>
        (s1 (stream-ref s 1))           <em>; <em>S</em><sub><em>n</em></sub></em>
        (s2 (stream-ref s 2)))          <em>; <em>S</em><sub><em>n</em>+1</sub></em>
    (cons-stream (- s2 (/ (square (- s2 s1))
                          (+ s0 (* -2 s1) s2)))
                 (euler-transform (stream-cdr s)))))
</pre></p>
<p></p>
<p></p>
<p>We can demonstrate Euler acceleration with our sequence ofapproximations to π:</p>
<p></p>
<p></p>
<p><pre>(display-stream (euler-transform pi-stream))
<i>3.166666666666667</i>
<i>3.1333333333333337</i>
<i>3.1452380952380956</i>
<i>3.13968253968254</i>
<i>3.1427128427128435</i>
<i>3.1408813408813416</i>
<i>3.142071817071818</i>
<i>3.1412548236077655</i>
<code>...</code></pre></p>
<p></p>
<p></p>
<p>Even better, we can accelerate the accelerated sequence, andrecursively accelerate that, and so on.  Namely, we create a stream ofstreams (a structure we'll call a <a name="%_idx_3972" id="%_idx_3972"></a><em>tableau</em>) in which each streamis the transform of the preceding one:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3974" id="%_idx_3974"></a>(define (make-tableau transform s)
  (cons-stream s
               (make-tableau transform
                             (transform s))))
</pre></p>
<p></p>
<p>The tableau has the form</p>
<p></p>
<p></p>
<div align="left"><img src="images/ch3-Z-G-43.gif" border="0"></div>
<p>Finally, we form a sequence by taking the first term in each row ofthe tableau:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3976" id="%_idx_3976"></a>(define (accelerated-sequence transform s)
  (stream-map stream-car
              (make-tableau transform s)))
</pre></p>
<p></p>
<p></p>
<p>We can demonstrate this kind of “super-acceleration” of the πsequence:</p>
<p></p>
<p></p>
<p><pre>(display-stream (accelerated-sequence euler-transform
                                      pi-stream))
<i>4.</i>
<i>3.166666666666667</i>
<i>3.142105263157895</i>
<i>3.141599357319005</i>
<i>3.1415927140337785</i>
<i>3.1415926539752927</i>
<i>3.1415926535911765</i>
<i>3.141592653589778</i>
<code>...</code></pre></p>
<p></p>
<p>The result is impressive.  Taking eight terms of the sequence yieldsthe correct value of π to 14 decimal places.  If we had used onlythe original π sequence, we would need to compute on the order of10<sup>13</sup> terms (i.e., expanding the series far enough so that theindividual terms are less then 10<sup>-13</sup>) to get that much accuracy!We could have implemented these acceleration techniques withoutusing streams.  But the stream formulation is particularly elegant andconvenient because the entire sequence of states is available to us as adata structure that can be manipulated with a uniform set ofoperations.</p>
<p></p>
<p><a name="%_thm_3.63" id="%_thm_3.63"></a><b>Exercise 3.63.</b>  Louis Reasoner asks why the <code>sqrt-stream</code> procedure was notwritten in the following more straightforward way, withoutthe local variable <code>guesses</code>:</p>
<p></p>
<p><pre>(define (sqrt-stream x)
  (cons-stream 1.0
               (stream-map (lambda (guess)
                             (sqrt-improve guess x))
                           (sqrt-stream x))))
</pre></p>
<p></p>
<p>Alyssa P. Hacker replies that this version of the procedure isconsiderably less efficient because it performs redundant computation.Explain Alyssa's answer.  Would the two versions still differ inefficiency if our implementation of <code>delay</code> used only <code>(lambda() &lt;<em>exp</em>&gt;)</code> without using the optimization provided by <code>memo-proc</code> (section <a href="#%_sec_3.5.1">3.5.1</a>)?</p>
<p></p>
<p></p>
<p><a name="%_thm_3.64" id="%_thm_3.64"></a><b>Exercise 3.64.</b>  Write a procedure <a name="%_idx_3978" id="%_idx_3978"></a><code>stream-limit</code> that takes as arguments a streamand a number (the tolerance).  It should examine the stream until itfinds two successive elements that differ in absolute value by lessthan the tolerance, and return the second of the two elements.  Usingthis, we could compute square roots up to a given tolerance by</p>
<p></p>
<p><pre><a name="%_idx_3980" id="%_idx_3980"></a>(define (sqrt x tolerance)
  (stream-limit (sqrt-stream x) tolerance))
</pre></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_3.65" id="%_thm_3.65"></a><b>Exercise 3.65.</b>  <a name="%_idx_3982" id="%_idx_3982"></a>Use the series</p>
<p></p>
<div align="left"><img src="images/ch3-Z-G-44.gif" border="0"></div>
<p>to compute three sequences of approximations to the natural logarithm of 2,in the same way we did above for π.How rapidly do these sequences converge?</p>
<p><a name="%_sec_Temp_476" id="%_sec_Temp_476"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_476">Infinite streams of pairs</a></h4>
<p><a name="%_idx_3984" id="%_idx_3984"></a><a name="%_idx_3986" id="%_idx_3986"></a><a name="%_idx_3988" id="%_idx_3988"></a>In section <a href="book-Z-H-15.html#%_sec_2.2.3">2.2.3</a>, we saw how the sequence paradigmhandles traditional nested loops as processes defined on sequences ofpairs.  If we generalize this technique to infinite streams, then wecan write programs that are not easily represented as loops, becausethe “looping” must range over an infinite set.</p>
<p><a name="%_idx_3990" id="%_idx_3990"></a>For example, suppose we want to generalize the <code>prime-sum-pairs</code>procedure of section <a href="book-Z-H-15.html#%_sec_2.2.3">2.2.3</a> to produce the streamof pairs of <em>all</em> integers (<em>i</em>,<em>j</em>) with <em>i</em> <u>&lt;</u> <em>j</em> such that <em>i</em> + <em>j</em>is prime.  If <code>int-pairs</code> is the sequence of all pairs of integers (<em>i</em>,<em>j</em>)with <em>i</em> <u>&lt;</u> <em>j</em>, then our required stream is simply<a name="call_footnote_Temp_477" href="#footnote_Temp_477" id="call_footnote_Temp_477"><sup><small>66</small></sup></a></p>
<p></p>
<p></p>
<p><pre>(stream-filter (lambda (pair)
                 (prime? (+ (car pair) (cadr pair))))
               int-pairs)
</pre></p>
<p></p>
<p></p>
<p>Our problem, then, is to produce the stream <code>int-pairs</code>.  Moregenerally, suppose we have two streams <em>S</em>  =  (<em>S</em><sub><em>i</em></sub>) and <em>T</em>  =  (<em>T</em><sub><em>j</em></sub>),and imagine the infinite rectangular array</p>
<p></p>
<div align="left"><img src="images/ch3-Z-G-45.gif" border="0"></div>
<p>We wish to generate a stream that contains all the pairs in the arraythat lie on or above the diagonal, i.e., the pairs</p>
<p></p>
<div align="left"><img src="images/ch3-Z-G-46.gif" border="0"></div>
<p>(If we take both <em>S</em> and <em>T</em> to be the stream of integers, then thiswill be our desired stream <code>int-pairs</code>.)  </p>
<p>Call the general stream of pairs <code>(pairs S T)</code>, and consider it tobe composed of three parts: the pair (<em>S</em><sub>0</sub>,<em>T</em><sub>0</sub>), therest of the pairs in the first row, and the remaining pairs:<a name="call_footnote_Temp_478" href="#footnote_Temp_478" id="call_footnote_Temp_478"><sup><small>67</small></sup></a></p>
<p></p>
<div align="left"><img src="images/ch3-Z-G-47.gif" border="0"></div>
<p>Observe that the third piece in this decomposition (pairs that are not in thefirst row) is (recursively) the pairs formed from <code>(stream-cdr S)</code>and <code>(stream-cdr T)</code>.  Also note that the second piece (the restof the first row) is</p>
<p></p>
<p><pre>(stream-map (lambda (x) (list (stream-car s) x))
            (stream-cdr t))
</pre></p>
<p></p>
<p>Thus we can form our stream of pairs as follows:</p>
<p></p>
<p><pre>(define (pairs s t)
  (cons-stream
   (list (stream-car s) (stream-car t))
   (&lt;<em>combine-in-some-way</em>&gt;
       (stream-map (lambda (x) (list (stream-car s) x))
                   (stream-cdr t))
       (pairs (stream-cdr s) (stream-cdr t)))))
</pre></p>
<p></p>
<p></p>
<p><a name="%_idx_3992" id="%_idx_3992"></a>In order to complete the procedure, we must choose some way to combinethe two inner streams.  One idea is to use the stream analog of the<code>append</code> procedure from section <a href="book-Z-H-15.html#%_sec_2.2.1">2.2.1</a>:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3994" id="%_idx_3994"></a>(define (stream-append s1 s2)
  (if (stream-null? s1)
      s2
      (cons-stream (stream-car s1)
                   (stream-append (stream-cdr s1) s2))))
</pre></p>
<p></p>
<p>This is unsuitable for infinite streams, however,because it takes all the elements from the first stream beforeincorporating the second stream.In particular, if we try to generate all pairs of positive integers using</p>
<p></p>
<p></p>
<p><pre>(pairs integers integers)
</pre></p>
<p></p>
<p>our stream of results will first try to run through all pairs with thefirst integer equal to 1, and hence will never produce pairs with anyother value of the first integer.</p>
<p>To handle infinite streams, we need to devise an order of combinationthat ensures that every element will eventually be reached if we letour program run long enough.  An elegant way to accomplish this iswith the following <code>interleave</code> procedure:<a name="call_footnote_Temp_479" href="#footnote_Temp_479" id="call_footnote_Temp_479"><sup><small>68</small></sup></a></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4000" id="%_idx_4000"></a>(define (interleave s1 s2)
  (if (stream-null? s1)
      s2
      (cons-stream (stream-car s1)
                   (interleave s2 (stream-cdr s1)))))
</pre></p>
<p></p>
<p>Since <code>interleave</code> takes elements alternately from the two streams,every element of the second stream will eventually find its way intothe interleaved stream, even if the first stream is infinite.</p>
<p>We can thus generate the required stream of pairs as</p>
<p></p>
<p><pre><a name="%_idx_4002" id="%_idx_4002"></a>(define (pairs s t)
  (cons-stream
   (list (stream-car s) (stream-car t))
   (interleave
    (stream-map (lambda (x) (list (stream-car s) x))
                (stream-cdr t))
    (pairs (stream-cdr s) (stream-cdr t)))))
</pre></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_3.66" id="%_thm_3.66"></a><b>Exercise 3.66.</b>  Examine the stream <code>(pairs integers integers)</code>. Can you make any generalcomments about the order in which the pairs are placed into thestream? For example, about how many pairs precede the pair (1,100)?the pair (99,100)? the pair (100,100)? (If you can make precisemathematical statements here, all the better. But feel free to givemore qualitative answers if you find yourself getting bogged down.)</p>
<p></p>
<p></p>
<p><a name="%_thm_3.67" id="%_thm_3.67"></a><b>Exercise 3.67.</b>  Modify the <code>pairs</code> procedure so that <code>(pairs integersintegers)</code> will produce the stream of <em>all</em> pairs of integers(<em>i</em>,<em>j</em>) (without the condition <em>i</em> <u>&lt;</u> <em>j</em>).  Hint: You will need tomix in an additional stream.</p>
<p></p>
<p></p>
<p><a name="%_thm_3.68" id="%_thm_3.68"></a><b>Exercise 3.68.</b>  Louis Reasoner thinks that building a stream of pairs from threeparts is unnecessarily complicated.  Instead of separating thepair (<em>S</em><sub>0</sub>,<em>T</em><sub>0</sub>) from the rest of the pairs in the first row,he proposes to work with the whole first row, as follows:</p>
<p></p>
<p><pre>(define (pairs s t)
  (interleave
   (stream-map (lambda (x) (list (stream-car s) x))
               t)
   (pairs (stream-cdr s) (stream-cdr t))))
</pre></p>
<p></p>
<p>Does this work?  Consider what happens if we evaluate<code>(pairs integers integers)</code> using Louis's definition of <code>pairs</code>.</p>
<p></p>
<p></p>
<p><a name="%_thm_3.69" id="%_thm_3.69"></a><b>Exercise 3.69.</b>  Write a procedure <code>triples</code> that takes three infinitestreams, <em>S</em>, <em>T</em>, and <em>U</em>, and produces the stream of triples(<em>S</em><sub><em>i</em></sub>,<em>T</em><sub><em>j</em></sub>,<em>U</em><sub><em>k</em></sub>) such that <em>i</em> <u>&lt;</u> <em>j</em> <u>&lt;</u> <em>k</em>.Use <code>triples</code> togenerate the stream of all <a name="%_idx_4004" id="%_idx_4004"></a>Pythagorean triples of positive integers,i.e., the triples (<em>i</em>,<em>j</em>,<em>k</em>) such that <em>i</em> <u>&lt;</u> <em>j</em> and <em>i</em><sup>2</sup>  +  <em>j</em><sup>2</sup>  = <em>k</em><sup>2</sup>.</p>
<p></p>
<p></p>
<p><a name="%_thm_3.70" id="%_thm_3.70"></a><b>Exercise 3.70.</b>  <a name="%_idx_4006" id="%_idx_4006"></a><a name="%_idx_4008" id="%_idx_4008"></a>It would be nice to be able to generate streams in which the pairsappear in some useful order, rather than in the order that resultsfrom an <em>ad hoc</em> interleaving process.  We can use a techniquesimilar to the <code>merge</code> procedure of exercise <a href="#%_thm_3.56">3.56</a>, if wedefine a way to say that one pair of integers is “less than”another.  One way to do this is to define a “weighting function”<em>W</em>(<em>i</em>,<em>j</em>) and stipulate that (<em>i</em><sub>1</sub>,<em>j</em><sub>1</sub>) is less than (<em>i</em><sub>2</sub>,<em>j</em><sub>2</sub>) if<em>W</em>(<em>i</em><sub>1</sub>,<em>j</em><sub>1</sub>) &lt; <em>W</em>(<em>i</em><sub>2</sub>,<em>j</em><sub>2</sub>).  Write a procedure <code>merge-weighted</code>that is like <code>merge</code>, except that <code>merge-weighted</code> takes anadditional argument <code>weight</code>, which is a procedure that computesthe weight of a pair, and is used to determine the order in whichelements should appear in the resulting merged stream.<a name="call_footnote_Temp_485" href="#footnote_Temp_485" id="call_footnote_Temp_485"><sup><small>69</small></sup></a>Using this,generalize <code>pairs</code> to a procedure <code>weighted-pairs</code> thattakes two streams, together with a procedure that computes a weightingfunction, and generates the stream of pairs, ordered according toweight.  Use your procedure to generate</p>
<p></p>
<p></p>
<p>a. the stream of all pairs of positive integers (<em>i</em>,<em>j</em>) with <em>i</em> <u>&lt;</u><em>j</em> ordered according to the sum <em>i</em>  +  <em>j</em></p>
<p></p>
<p></p>
<p>b.  the stream of all pairs of positive integers (<em>i</em>,<em>j</em>) with <em>i</em> <u>&lt;</u><em>j</em>, where neither <em>i</em> nor <em>j</em> is divisible by 2, 3, or 5, and thepairs are ordered according to the sum 2 <em>i</em>  +  3 <em>j</em>  +  5 <em>i</em> <em>j</em>.</p>
<p></p>
<p></p>
<p><a name="%_thm_3.71" id="%_thm_3.71"></a><b>Exercise 3.71.</b>  <a name="%_idx_4010" id="%_idx_4010"></a>Numbers that can be expressed as the sum of two cubes in more than oneway are sometimes called <em>Ramanujan numbers</em>, in honor of themathematician Srinivasa Ramanujan.<a name="call_footnote_Temp_487" href="#footnote_Temp_487" id="call_footnote_Temp_487"><sup><small>70</small></sup></a>Ordered streams of pairs provide an elegant solution to the problem ofcomputing these numbers.  To find a number that can be written as thesum of two cubes in two different ways, we need only generate thestream of pairs of integers (<em>i</em>,<em>j</em>) weighted according to the sum <em>i</em><sup>3</sup> +  <em>j</em><sup>3</sup> (see exercise <a href="#%_thm_3.70">3.70</a>),then search the stream for two consecutive pairs with the sameweight.  Write a procedure to generate the Ramanujan numbers.  The firstsuch number is 1,729.  What are the next five?</p>
<p></p>
<p></p>
<p><a name="%_thm_3.72" id="%_thm_3.72"></a><b>Exercise 3.72.</b>  In a similar way to exercise <a href="#%_thm_3.71">3.71</a> generatea stream ofall numbers that can be written as the sum of two squares in threedifferent ways (showing how they can be so written).</p>
<p><a name="%_sec_Temp_489" id="%_sec_Temp_489"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_489">Streams as signals</a></h4>
<p><a name="%_idx_4018" id="%_idx_4018"></a><a name="%_idx_4020" id="%_idx_4020"></a>We began our discussion of streams by describing them as computationalanalogs of the “signals” in signal-processing systems.  In fact, wecan use streams to model signal-processing systems in a very directway, representing the values of a signal at successive time intervalsas consecutive elements of a stream.  For instance, we can implementan <a name="%_idx_4022" id="%_idx_4022"></a><em>integrator</em> or <em>summer</em> that, for an input stream<em>x</em> = (<em>x</em><sub><em>i</em></sub>), an initial value <em>C</em>, and a small increment <em>d</em><em>t</em>,accumulates the sum</p>
<p></p>
<div align="left"><img src="images/ch3-Z-G-48.gif" border="0"></div>
<p>and returns the stream of values <em>S</em> = (<em>S</em><sub><em>i</em></sub>).  The following <code>integral</code>procedure is reminiscent of the “implicit style” definition of thestream of integers (section <a href="#%_sec_3.5.2">3.5.2</a>):</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4024" id="%_idx_4024"></a>(define (integral integrand initial-value dt)
  (define int
    (cons-stream initial-value
                 (add-streams (scale-stream integrand dt)
                              int)))
  int)
</pre></p>
<p></p>
<p></p>
<p><a name="%_fig_3.32" id="%_fig_3.32"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch3-Z-G-49.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 3.32:</b>  The <code>integral</code> procedure viewed as asignal-processing system.</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p>Figure <a href="#%_fig_3.32">3.32</a> is a picture of a signal-processing system thatcorresponds to the <code>integral</code> procedure.  The input stream isscaled by <em>d</em><em>t</em> and passed through an adder, whose output is passedback through the same adder.  The self-reference in the definition of<code>int</code> is reflected in the figure by the feedback loop thatconnects the output of the adder to one of the inputs.</p>
<p></p>
<p><a name="%_thm_3.73" id="%_thm_3.73"></a><b>Exercise 3.73.</b>  <a name="%_fig_3.33" id="%_fig_3.33"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td>
<div align="center"> <img src="images/ch3-Z-G-50.gif" border="0">      <em>v</em>  =  <em>v</em><sub>0</sub>  +  (1/<em>C</em>)∫<sub>0</sub><sup><em>t</em></sup><em>i</em> <em>d</em><em>t</em>  +  <em>R</em> <em>i</em>     </div><p></p>
<p><img src="images/ch3-Z-G-51.gif" border="0"></p>
</td></tr>
<caption align="bottom"><div align="left">
<b>Figure 3.33:</b>  An RC circuit and the associated signal-flow diagram.</div></caption>
<tr><td><a name="%_idx_4026" id="%_idx_4026"></a></td></tr>
</table></div>
<p><a name="%_idx_4028" id="%_idx_4028"></a><a name="%_idx_4030" id="%_idx_4030"></a><a name="%_idx_4032" id="%_idx_4032"></a>We can model electrical circuits using streams to represent the valuesof currents or voltages at a sequence of times.  For instance, supposewe have an <em>RC circuit</em> consisting of a resistor of resistance <em>R</em>and a capacitor of capacitance <em>C</em> in series.  The voltage response<em>v</em> of the circuit to an injected current <em>i</em> is determined by theformula in figure <a href="#%_fig_3.33">3.33</a>, whose structure is shown by the accompanyingsignal-flow diagram.</p>
<p>Write a procedure <code>RC</code> that models this circuit.  <code>RC</code> shouldtake as inputs the values of <em>R</em>, <em>C</em>, and <em>d</em><em>t</em> and should return aprocedure that takes as inputs a stream representing the current <em>i</em>and an initial value for the capacitor voltage <em>v</em><sub>0</sub> and produces asoutput the stream of voltages <em>v</em>.  For example, you should be able touse <code>RC</code> to model an RC circuit with <em>R</em>  =  5 ohms, <em>C</em>  =  1 farad,and a 0.5-second time step by evaluating <code>(define RC1 (RC 5 10.5))</code>.  This defines <code>RC1</code> as a procedure that takes a streamrepresenting the time sequence of currents and an initial capacitorvoltage and produces the output stream of voltages.</p>
<p></p>
<p><a name="%_thm_3.74" id="%_thm_3.74"></a><b>Exercise 3.74.</b>  <a name="%_idx_4034" id="%_idx_4034"></a><a name="%_idx_4036" id="%_idx_4036"></a>Alyssa P. Hacker is designing a system to process signals coming fromphysical sensors.  One important feature she wishes to produce is asignal that describes the <em>zero crossings</em> of the input signal.That is, the resulting signal should be  + 1 whenever the input signalchanges from negative to positive,  - 1 whenever the input signalchanges from positive to negative, and 0 otherwise.  (Assume that thesign of a 0 input is positive.)  For example, a typical input signalwith its associated zero-crossing signal would be</p>
<p></p>
<p><code><code>...</code>1  2  1.5  1  0.5  -0.1  -2  -3  -2  -0.5  0.2  3  4 <code>...</code><code>...</code> 0  0    0  0    0     -1  0   0   0     0    1  0  0 <code>...</code></code></p>
<p></p>
<p>In Alyssa's system, the signal from the sensor is represented as astream <code>sense-data</code> and the stream <code>zero-crossings</code> isthe corresponding stream of zero crossings.  Alyssa first writes aprocedure <code>sign-change-detector</code> that takes two values asarguments and compares the signs of the values to produce anappropriate 0, 1, or  - 1.  She then constructs her zero-crossingstream as follows:</p>
<p></p>
<p></p>
<p><pre>(define (make-zero-crossings input-stream last-value)
  (cons-stream
   (sign-change-detector (stream-car input-stream) last-value)
   (make-zero-crossings (stream-cdr input-stream)
                        (stream-car input-stream))))

(define zero-crossings (make-zero-crossings sense-data 0))
</pre></p>
<p></p>
<p>Alyssa's boss, Eva Lu Ator, walks by and suggests that this program isapproximately equivalent to the following one, whichuses the generalized versionof <code>stream-map</code> from exercise <a href="#%_thm_3.50">3.50</a>:</p>
<p></p>
<p></p>
<p><pre>(define zero-crossings
  (stream-map sign-change-detector sense-data &lt;<em>expression</em>&gt;))
</pre></p>
<p></p>
<p>Complete the program by supplying the indicated &lt;<em>expression</em>&gt;.</p>
<p></p>
<p><a name="%_thm_3.75" id="%_thm_3.75"></a><b>Exercise 3.75.</b>  <a name="%_idx_4038" id="%_idx_4038"></a><a name="%_idx_4040" id="%_idx_4040"></a><a name="%_idx_4042" id="%_idx_4042"></a><a name="%_idx_4044" id="%_idx_4044"></a>Unfortunately, Alyssa's zero-crossing detector inexercise <a href="#%_thm_3.74">3.74</a> proves to be insufficient, because thenoisy signal from the sensor leads to spurious zero crossings.  Lem E.Tweakit, a hardware specialist, suggests that Alyssa smooth the signalto filter out the noise before extracting the zero crossings.  Alyssatakes his advice and decides to extract the zero crossings from thesignal constructed by averaging each value of the sense data with theprevious value.  She explains the problem to her assistant, LouisReasoner, who attempts to implement the idea, altering Alyssa's program asfollows:</p>
<p></p>
<p></p>
<p><pre>(define (make-zero-crossings input-stream last-value)
  (let ((avpt (/ (+ (stream-car input-stream) last-value) 2)))
    (cons-stream (sign-change-detector avpt last-value)
                 (make-zero-crossings (stream-cdr input-stream)
                                      avpt))))
</pre></p>
<p></p>
<p>This does not correctly implement Alyssa's plan.Find the bug that Louis has installedand fix it without changing the structure of the program.  (Hint: Youwill need to increase the number of arguments to <code>make-zero-crossings</code>.)</p>
<p></p>
<p><a name="%_thm_3.76" id="%_thm_3.76"></a><b>Exercise 3.76.</b>  <a name="%_idx_4046" id="%_idx_4046"></a><a name="%_idx_4048" id="%_idx_4048"></a><a name="%_idx_4050" id="%_idx_4050"></a><a name="%_idx_4052" id="%_idx_4052"></a>Eva Lu Ator has a criticism of Louis's approach inexercise <a href="#%_thm_3.75">3.75</a>.  The program he wrote is not modular,because it intermixes the operation of smoothing with thezero-crossing extraction.  For example, the extractor should not haveto be changed if Alyssa finds a better way to condition her inputsignal.  Help Louis by writing a procedure <code>smooth</code> that takes astream as input and produces a stream in which each element is theaverage of two successive input stream elements.  Then use <code>smooth</code> as a component to implement the zero-crossing detector in amore modular style.</p>
<p><a name="%_sec_3.5.4" id="%_sec_3.5.4"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_3.5.4">3.5.4  Streams and Delayed Evaluation</a></h3>
<p><a name="%_idx_4054" id="%_idx_4054"></a><a name="%_idx_4056" id="%_idx_4056"></a>The <code>integral</code> procedure at the end of the preceding section showshow we can use streams to model signal-processing systems that contain<a name="%_idx_4058" id="%_idx_4058"></a>feedback loops.  The feedback loop for the adder shown infigure <a href="#%_fig_3.32">3.32</a> is modeled by the fact that <code>integral</code>'s<a name="%_idx_4060" id="%_idx_4060"></a>internal stream <code>int</code> is defined in terms of itself:</p>
<p></p>
<p></p>
<p><pre>(define int
  (cons-stream initial-value
               (add-streams (scale-stream integrand dt)
                            int)))
</pre></p>
<p></p>
<p>The interpreter's ability to deal with such an implicit definitiondepends on the <code>delay</code> that is incorporated into <code>cons-stream</code>.  Without this <code>delay</code>, the interpreter could notconstruct <code>int</code> before evaluating both arguments to <code>cons-stream</code>, which would require that <code>int</code> already be defined.In general, <code>delay</code> is crucial for using streams to modelsignal-processing systems that contain loops.  Without <code>delay</code>,our models would have to be formulated so that the inputs to anysignal-processing component would be fully evaluated before the outputcould be produced.  This would outlaw loops.</p>
<p>Unfortunately, stream models of systems with loopsmay require uses of <code>delay</code> beyond the “hidden” <code>delay</code>supplied by <code>cons-stream</code>.  For instance,figure <a href="#%_fig_3.34">3.34</a> shows a signal-processing system forsolving the <a name="%_idx_4062" id="%_idx_4062"></a>differential equation <em>d</em><em>y</em>/<em>d</em><em>t</em> = <em>f</em>(<em>y</em>) where <em>f</em> is a givenfunction.  The figure shows a mapping component, whichapplies <em>f</em> to its input signal, linked in a feedback loop to anintegrator in a manner very similar to that of the analog computercircuits that are actually used to solve such equations.</p>
<p><a name="%_fig_3.34" id="%_fig_3.34"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch3-Z-G-52.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 3.34:</b>  An “analog computer circuit” that solves theequation<em>d</em><em>y</em>/<em>d</em><em>t</em> = <em>f</em>(<em>y</em>).</div></caption>
<tr><td><a name="%_idx_4064" id="%_idx_4064"></a></td></tr>
</table></div>
<p></p>
<p>Assuming we are given an initial value <em>y</em><sub>0</sub> for <em>y</em>, wecould try to model this system using the procedure</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4066" id="%_idx_4066"></a>(define (solve f y0 dt)
  (define y (integral dy y0 dt))
  (define dy (stream-map f y))
  y)
</pre></p>
<p></p>
<p>This procedure does not work, because in the first line of <code>solve</code>the call to <code>integral</code> requires that the input <code>dy</code> bedefined, which does not happen until the second line of <code>solve</code>.</p>
<p>On the other hand, the intent of our definition does make sense,because we can, in principle, begin to generate the <code>y</code> streamwithout knowing <code>dy</code>.  Indeed, <code>integral</code> and many otherstream operations have properties similar to those of <code>cons-stream</code>, in that we can generate part of the answer given onlypartial information about the arguments.  For <code>integral</code>, thefirst element of the output stream is the specified <code>initial-value</code>.  Thus, we can generate the first element of the outputstream without evaluating the integrand <code>dy</code>.  Once we know thefirst element of <code>y</code>, the <code>stream-map</code> in the second line of<code>solve</code> can begin working to generate the first element of <code>dy</code>, which will produce the next element of <code>y</code>, and so on.</p>
<p>To take advantage of this idea, we will redefine <code>integral</code> toexpect the integrand stream to be a <a name="%_idx_4068" id="%_idx_4068"></a><a name="%_idx_4070" id="%_idx_4070"></a><a name="%_idx_4072" id="%_idx_4072"></a><em>delayed argument</em>.  <code>Integral</code> will <code>force</code> the integrand to be evaluated only when itis required to generate more than the first element of the output stream:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4074" id="%_idx_4074"></a>(define (integral delayed-integrand initial-value dt)
  (define int
    (cons-stream initial-value
                 (let ((integrand (force delayed-integrand)))
                   (add-streams (scale-stream integrand dt)
                                int))))
  int)
</pre></p>
<p></p>
<p>Now we can implement our <code>solve</code> procedure by delaying theevaluation of <code>dy</code> in the definition of <code>y</code>:<a name="call_footnote_Temp_494" href="#footnote_Temp_494" id="call_footnote_Temp_494"><sup><small>71</small></sup></a></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4076" id="%_idx_4076"></a>(define (solve f y0 dt)
  (define y (integral (delay dy) y0 dt))
  (define dy (stream-map f y))
  y)
</pre></p>
<p></p>
<p>In general, every caller of <code>integral</code> must now <code>delay</code> theintegrand argument.  We can demonstrate that the <code>solve</code> procedureworks by approximating <a name="%_idx_4078" id="%_idx_4078"></a><em>e</em> ≈  2.718 by computing the value at<em>y</em> = 1 of the solution to the differential equation <em>d</em><em>y</em>/<em>d</em><em>t</em> = <em>y</em> withinitial condition <em>y</em>(0) = 1:</p>
<p></p>
<p></p>
<p><pre>(stream-ref (solve (lambda (y) y) 1 0.001) 1000)
<i>2.716924</i></pre></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_3.77" id="%_thm_3.77"></a><b>Exercise 3.77.</b>  The <code>integral</code> procedure used above was analogous to the“implicit” definition of the infinite stream of integers insection <a href="#%_sec_3.5.2">3.5.2</a>.  Alternatively, we can give adefinition of <code>integral</code> that is more like <code>integers-starting-from</code> (also in section <a href="#%_sec_3.5.2">3.5.2</a>):</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4080" id="%_idx_4080"></a>(define (integral integrand initial-value dt)
  (cons-stream initial-value
               (if (stream-null? integrand)
                   the-empty-stream
                   (integral (stream-cdr integrand)
                             (+ (* dt (stream-car integrand))
                                initial-value)
                             dt))))
</pre></p>
<p></p>
<p>When used in systems with loops, this procedure has the same problemas does our original version of <code>integral</code>.  Modify the procedureso that it expects the <code>integrand</code> as a delayed argument and hencecan be used in the <code>solve</code> procedure shown above.</p>
<p></p>
<p></p>
<p><a name="%_thm_3.78" id="%_thm_3.78"></a><b>Exercise 3.78.</b>  <a name="%_fig_3.35" id="%_fig_3.35"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch3-Z-G-53.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 3.35:</b>  Signal-flow diagram for the solution to a second-orderlinear differential equation.</div></caption>
<tr><td></td></tr>
</table></div>
<p><a name="%_idx_4082" id="%_idx_4082"></a>Consider the problem of designing a signal-processing system to studythe homogeneous second-order linear differential equation</p>
<p></p>
<div align="left"><img src="images/ch3-Z-G-54.gif" border="0"></div>
<p>The output stream, modeling <em>y</em>, is generated by a network thatcontains a loop. This is because the value of <em>d</em><sup>2</sup><em>y</em>/<em>d</em><em>t</em><sup>2</sup> dependsupon the values of <em>y</em> and <em>d</em><em>y</em>/<em>d</em><em>t</em> and both of these are determined byintegrating <em>d</em><sup>2</sup><em>y</em>/<em>d</em><em>t</em><sup>2</sup>.  The diagram we would like to encode isshown in figure <a href="#%_fig_3.35">3.35</a>.  Write a procedure <code>solve-2nd</code> thattakes as arguments the constants <em>a</em>, <em>b</em>, and <em>d</em><em>t</em> and the initialvalues <em>y</em><sub>0</sub> and <em>d</em><em>y</em><sub>0</sub> for <em>y</em> and <em>d</em><em>y</em>/<em>d</em><em>t</em> and generates thestream of successive values of <em>y</em>.</p>
<p></p>
<p></p>
<p><a name="%_thm_3.79" id="%_thm_3.79"></a><b>Exercise 3.79.</b>  <a name="%_idx_4084" id="%_idx_4084"></a>Generalize the <code>solve-2nd</code> procedure of exercise <a href="#%_thm_3.78">3.78</a> sothat it can be used to solve general second-order differentialequations <em>d</em><sup>2</sup><em>y</em>/<em>d</em><em>t</em><sup>2</sup> = <em>f</em>(<em>d</em><em>y</em>/<em>d</em><em>t</em>,  <em>y</em>).</p>
<p></p>
<p></p>
<p><a name="%_thm_3.80" id="%_thm_3.80"></a><b>Exercise 3.80.</b>  <a name="%_idx_4086" id="%_idx_4086"></a><a name="%_idx_4088" id="%_idx_4088"></a><a name="%_idx_4090" id="%_idx_4090"></a>A <em>series RLC circuit</em> consists of a resistor, a capacitor, and aninductor connected in series, as shown in figure <a href="#%_fig_3.36">3.36</a>.If <em>R</em>, <em>L</em>, and <em>C</em> are the resistance, inductance, and capacitance,then the relations between voltage (<em>v</em>) and current (<em>i</em>)for the three components are described by the equations</p>
<p></p>
<div align="left"><img src="images/ch3-Z-G-55.gif" border="0"></div>
<p></p>
<p>and the circuit connections dictate the relations</p>
<p></p>
<div align="left"><img src="images/ch3-Z-G-56.gif" border="0"></div>
<p>Combining these equations shows that the state of the circuit(summarized by <em>v</em><sub><em>C</em></sub>, the voltage across the capacitor, and <em>i</em><sub><em>L</em></sub>, thecurrent in the inductor)is described by the pair of differential equations</p>
<p></p>
<div align="left"><img src="images/ch3-Z-G-57.gif" border="0"></div>
<p>The signal-flow diagram representing this system of differentialequations is shown in figure <a href="#%_fig_3.37">3.37</a>.<a name="%_fig_3.36" id="%_fig_3.36"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch3-Z-G-58.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 3.36:</b>  A series RLC circuit.</div></caption>
<tr><td></td></tr>
</table></div>
<p><a name="%_fig_3.37" id="%_fig_3.37"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch3-Z-G-59.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 3.37:</b>  A signal-flow diagram for the solutionto a series RLC circuit.</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p>Write a procedure <code>RLC</code> that takes as arguments the parameters<em>R</em>, <em>L</em>, and <em>C</em> of the circuit and the time increment <em>d</em><em>t</em>.  In amanner similar to that of the <code>RC</code> procedure ofexercise <a href="#%_thm_3.73">3.73</a>, <code>RLC</code> should produce a procedurethat takes the initial values of the state variables, <em>v</em><sub><em>C</em><sub>0</sub></sub> and<em>i</em><sub><em>L</em><sub>0</sub></sub>, and produces a pair (using <code>cons</code>) of the streams ofstates <em>v</em><sub><em>C</em></sub> and <em>i</em><sub><em>L</em></sub>.  Using <code>RLC</code>, generate the pair ofstreams that models the behavior of a series RLC circuit with <em>R</em>  =  1ohm, <em>C</em> =  0.2 farad, <em>L</em>  =  1 henry, <em>d</em><em>t</em>  =  0.1 second, and initialvalues <em>i</em><sub><em>L</em><sub>0</sub></sub>  =  0 amps and <em>v</em><sub><em>C</em><sub>0</sub></sub>  =  10 volts.</p>
<p></p>
<p><a name="%_sec_Temp_499" id="%_sec_Temp_499"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_499">Normal-order evaluation</a></h4>
<p><a name="%_idx_4092" id="%_idx_4092"></a><a name="%_idx_4094" id="%_idx_4094"></a>The examples in this section illustrate how the explicit use of <code>delay</code> and <code>force</code> provides great programming flexibility, but thesame examples also show how this can make our programs more complex.Our new <code>integral</code> procedure, for instance, gives us the power tomodel systems with loops, but we must now remember that <code>integral</code>should be called with a delayed integrand, and every procedure thatuses <code>integral</code> must be aware of this.  In effect, we have createdtwo classes of procedures: ordinary procedures and procedures thattake delayed arguments.  In general, creating separate classes ofprocedures forces us to create separate classes of higher-orderprocedures as well.<a name="call_footnote_Temp_500" href="#footnote_Temp_500" id="call_footnote_Temp_500"><sup><small>72</small></sup></a></p>
<p>One way to avoid the need for two different classes of procedures isto make all procedures take delayed arguments.  We could adopt a modelof evaluation in which all arguments to procedures are automaticallydelayed and arguments are forced only when they are actually needed(for example, when they are required by a primitive operation).  Thiswould transform our language to use normal-order evaluation, which wefirst described when we introduced the substitution model forevaluation in section <a href="book-Z-H-10.html#%_sec_1.1.5">1.1.5</a>.  Converting tonormal-order evaluation provides a uniform and elegant way to simplifythe use of delayed evaluation, and this would be a natural strategy toadopt if we were concerned only with stream processing.  Insection <a href="book-Z-H-27.html#%_sec_4.2">4.2</a>, after we have studied the evaluator, wewill see how to transform our language in just this way.Unfortunately, including delays in procedure calls wreaks havoc withour ability to design programs that depend on the order of events,such as programs that use assignment, mutate data, or perform input oroutput.  Even the single <code>delay</code> in <code>cons-stream</code> can causegreat confusion, as illustrated by exercises <a href="#%_thm_3.51">3.51</a>and <a href="#%_thm_3.52">3.52</a>.  As far as anyone knows, mutability and delayedevaluation do not mix well in programming languages, and devising waysto deal with both of these at once is an active area of research.<a name="%_sec_3.5.5" id="%_sec_3.5.5"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_3.5.5">3.5.5  Modularity of Functional Programs and Modularity of Objects</a></h3>
<p><a name="%_idx_4116" id="%_idx_4116"></a><a name="%_idx_4118" id="%_idx_4118"></a>As we saw in section <a href="book-Z-H-20.html#%_sec_3.1.2">3.1.2</a>, one of themajor benefits of introducing assignment is that we can increase themodularity of our systems by encapsulating, or “hiding,” parts ofthe state of a large system within local variables.  Stream models canprovide an equivalent modularity without the use of assignment.  As an<a name="%_idx_4120" id="%_idx_4120"></a><a name="%_idx_4122" id="%_idx_4122"></a>illustration, we can reimplement the Monte Carlo estimation of π,which we examined in section <a href="book-Z-H-20.html#%_sec_3.1.2">3.1.2</a>, from astream-processing point of view.</p>
<p>The key modularity issue was that we wished to hide the internal stateof a random-number generator from programs that used random numbers.We began with a procedure <code>rand-update</code>, whose successive valuesfurnished our supply of random numbers, and used this to produce arandom-number generator:</p>
<p></p>
<p></p>
<p><pre>(define rand
  (let ((x random-init))
    (lambda ()
      (set! x (rand-update x))
      x)))
</pre></p>
<p></p>
<p></p>
<p>In the stream formulation there is no random-number generator <em>perse</em>, just a stream of random numbers produced by successive calls to<code>rand-update</code>:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4124" id="%_idx_4124"></a><a name="%_idx_4126" id="%_idx_4126"></a>(define random-numbers
  (cons-stream random-init
               (stream-map rand-update random-numbers)))
</pre></p>
<p></p>
<p>We use this to construct the stream of outcomes of the Cesàroexperiment performed on consecutive pairs in the <code>random-numbers</code>stream:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4128" id="%_idx_4128"></a>(define cesaro-stream
  (map-successive-pairs (lambda (r1 r2) (= (gcd r1 r2) 1))
                        random-numbers))

<a name="%_idx_4130" id="%_idx_4130"></a>(define (map-successive-pairs f s)
  (cons-stream
   (f (stream-car s) (stream-car (stream-cdr s)))
   (map-successive-pairs f (stream-cdr (stream-cdr s)))))
</pre></p>
<p></p>
<p>The <code>cesaro-stream</code> is now fed to a <code>monte-carlo</code> procedure,which produces a stream of estimates of probabilities.  The resultsare then converted into a stream of estimates of π.  This versionof the program doesn't need a parameter telling how many trials toperform.  Better estimates of π (from performing more experiments)are obtained by looking farther into the <code>pi</code> stream:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4132" id="%_idx_4132"></a>(define (monte-carlo experiment-stream passed failed)
  (define (next passed failed)
    (cons-stream
     (/ passed (+ passed failed))
     (monte-carlo
      (stream-cdr experiment-stream) passed failed)))
  (if (stream-car experiment-stream)
      (next (+ passed 1) failed)
      (next passed (+ failed 1))))

(define pi
  (stream-map (lambda (p) (sqrt (/ 6 p)))
              (monte-carlo cesaro-stream 0 0)))
</pre></p>
<p></p>
<p><a name="%_idx_4134" id="%_idx_4134"></a>There is considerable modularity in this approach, because we stillcan formulate a general <code>monte-carlo</code> procedure that can deal witharbitrary experiments.  Yet there is no assignment or local state.</p>
<p></p>
<p><a name="%_thm_3.81" id="%_thm_3.81"></a><b>Exercise 3.81.</b>  <a name="%_idx_4136" id="%_idx_4136"></a>Exercise <a href="book-Z-H-20.html#%_thm_3.6">3.6</a>discussed generalizing the random-number generator toallow one to reset the random-number sequence so as to producerepeatable sequences of “random” numbers.  Produce a streamformulation of this same generator that operates on an input stream ofrequests to <code>generate</code> a new random number or to <code>reset</code> thesequence to a specified value and that produces the desired stream ofrandom numbers.  Don't use assignment in your solution.</p>
<p></p>
<p></p>
<p><a name="%_thm_3.82" id="%_thm_3.82"></a><b>Exercise 3.82.</b>  <a name="%_idx_4138" id="%_idx_4138"></a><a name="%_idx_4140" id="%_idx_4140"></a><a name="%_idx_4142" id="%_idx_4142"></a>Redo exercise <a href="book-Z-H-20.html#%_thm_3.5">3.5</a> on Monte Carlointegration in terms of streams.  The stream version of <code>estimate-integral</code> will not have an argument telling how many trialsto perform.  Instead, it will produce a stream of estimates based onsuccessively more trials.</p>
<p></p>
<p><a name="%_sec_Temp_503" id="%_sec_Temp_503"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_503">A functional-programming view of time</a></h4>
<p><a name="%_idx_4144" id="%_idx_4144"></a><a name="%_idx_4146" id="%_idx_4146"></a>Let us now return to the issues of objects and state that were raisedat the beginning of this chapter and examine them in a new light.  Weintroduced assignment and mutable objects to provide a mechanism formodular construction of programs that model systems with state.We constructed computationalobjects with local state variables and used assignment to modify thesevariables.  We modeled the temporal behavior of the objects in theworld by the temporal behavior of the corresponding computationalobjects.</p>
<p>Now we have seen that streams provide an alternative way to modelobjects with local state.  We can model a changing quantity, such asthe local state of some object, using a stream that represents thetime history of successive states.  In essence, we represent timeexplicitly, using streams, so that we decouple time in our simulatedworld from the sequence of events that take place during evaluation.Indeed, because of the presence of <code>delay</code> there may be littlerelation between simulated time in the model and the order of eventsduring the evaluation.</p>
<p>In order to contrast these two approaches to modeling, let usreconsider the implementation of a “withdrawal processor” that<a name="%_idx_4148" id="%_idx_4148"></a>monitors the balance in a bank account.  Insection <a href="book-Z-H-20.html#%_sec_3.1.3">3.1.3</a> we implemented a simplifiedversion of such a processor:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4150" id="%_idx_4150"></a>(define (make-simplified-withdraw balance)
  (lambda (amount)
    (set! balance (- balance amount))
    balance))
</pre></p>
<p></p>
<p>Calls to <code>make-simplified-withdraw</code> produce computational objects,each with a local state variable <code>balance</code> that is decremented bysuccessive calls to the object.  The object takes an <code>amount</code> asan argument and returns the new balance.  We can imagine the user of abank account typing a sequence of inputs to such an object andobserving the sequence of returned values shown on a display screen.</p>
<p>Alternatively, we can model a withdrawal processor as a procedure thattakes as input a balance and a stream of amounts to withdraw andproduces the stream of successive balances in the account:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_4152" id="%_idx_4152"></a>(define (stream-withdraw balance amount-stream)
  (cons-stream
   balance
   (stream-withdraw (- balance (stream-car amount-stream))
                    (stream-cdr amount-stream))))
</pre></p>
<p></p>
<p><code>Stream-withdraw</code> implements a well-defined mathematical function whoseoutput is fully determined by its input.  Suppose, however, that theinput <code>amount-stream</code> is the stream of successive values typed bythe user and that the resulting stream of balances is displayed.Then, from the perspective of the user who is typing values andwatching results, the stream process has the same behavior as theobject created by <code>make-simplified-withdraw</code>.  However, with thestream version, there is no assignment, no local state variable, andconsequently none of the theoretical difficulties that we encountered<a name="%_idx_4154" id="%_idx_4154"></a>in section <a href="book-Z-H-20.html#%_sec_3.1.3">3.1.3</a>.  Yet the system has state!</p>
<p>This is really remarkable.  Even though <code>stream-withdraw</code> implements awell-defined mathematical function whose behavior does not change, theuser's perception here is one of interacting with a system that has achanging state.  One way to resolve this paradox is to realize that itis the user's temporal existence that imposes state on the system.  Ifthe user could step back from the interaction and think in terms ofstreams of balances rather than individual transactions, the systemwould appear stateless.<a name="call_footnote_Temp_504" href="#footnote_Temp_504" id="call_footnote_Temp_504"><sup><small>73</small></sup></a></p>
<p>From the point of view of one part of a complex process, the otherparts appear to change with time.  They have hidden time-varying localstate.  If we wish to write programs that model this kind of naturaldecomposition in our world (as we see it from our viewpoint as a part ofthat world) withstructures in our computer, we make computational objects that are notfunctional – they must change with time.  We model state with localstate variables, and we model the changes of state with assignments tothose variables.  By doing this we make the time of execution of acomputation model time in the world that we are part of, and thus weget “objects” in our computer.</p>
<p>Modeling with objects is powerful and intuitive, largely because thismatches the perception of interacting with a world of which we arepart.  However, as we've seen repeatedly throughout this chapter,these models raise thorny problems of constraining the order of eventsand of synchronizing multiple processes.  The possibility of avoidingthese problems has stimulated the development of <a name="%_idx_4158" id="%_idx_4158"></a><a name="%_idx_4160" id="%_idx_4160"></a><em>functionalprogramming languages</em>, which do not include any provision forassignment or mutable data.  In such a language, all proceduresimplement well-defined mathematical functions of their arguments,whose behavior does not change.  The functional approach is extremely<a name="%_idx_4162" id="%_idx_4162"></a><a name="%_idx_4164" id="%_idx_4164"></a>attractive for dealing with concurrent systems.<a name="call_footnote_Temp_505" href="#footnote_Temp_505" id="call_footnote_Temp_505"><sup><small>74</small></sup></a></p>
<p>On the other hand, if we look closely, we can see time-relatedproblems creeping into functional models as well.  One particularlytroublesome area arises when we wish to design interactive systems,especially ones that model interactions between independent entities.For instance, consider once more the implementation a banking systemthat permits joint bank accounts.  In a conventional system usingassignment and objects, we would model the fact that Peter and Paulshare an account by having both Peter and Paul send their transactionrequests to the same bank-account object, as we saw insection <a href="book-Z-H-20.html#%_sec_3.1.3">3.1.3</a>.From the stream point of view, where there are no “objects” <em>perse</em>, we have already indicated that a bank account can be modeled as aprocess that operates on a stream of transaction requests to produce astream of responses.  Accordingly, we could model the fact that Peterand Paul have a joint bank account by merging Peter's stream oftransaction requests with Paul's stream of requests and feeding theresult to the bank-account stream process, as shown infigure <a href="#%_fig_3.38">3.38</a>.</p>
<p><a name="%_fig_3.38" id="%_fig_3.38"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch3-Z-G-60.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 3.38:</b>  A joint bank account, modeled by merging two streams oftransaction requests.</div></caption>
<tr><td><a name="%_idx_4176" id="%_idx_4176"></a>
</td></tr>
</table></div>
<p></p>
<p><a name="%_idx_4178" id="%_idx_4178"></a>The trouble with this formulation is in the notion of <em>merge</em>.  Itwill not do to merge the two streams by simply taking alternately onerequest from Peter and one request from Paul. Suppose Paul accessesthe account only very rarely.  We could hardly force Peter to wait forPaul to access the account before he could issue a second transaction.However such a merge is implemented, it must interleave the twotransaction streams in some way that is constrained by “realtime” as perceived by Peter and Paul, in the sense that, if Peter andPaul meet, they can agree that certain transactions were processedbefore the meeting, and other transactions were processed after themeeting.<a name="call_footnote_Temp_506" href="#footnote_Temp_506" id="call_footnote_Temp_506"><sup><small>75</small></sup></a>This is precisely the same constraint that we had to deal with insection <a href="book-Z-H-23.html#%_sec_3.4.1">3.4.1</a>, where we found the need to introduceexplicit synchronization to ensure a “correct” order of events inconcurrent processing of objects with state.  Thus, in an attempt tosupport the functional style, the need to merge inputs from differentagents reintroduces the same problems that the functional style wasmeant to eliminate.</p>
<p>We began this chapter with the goal of building computational modelswhose structure matches our perception of the real world we are tryingto model.  We can model the world as a collection of separate,time-bound, interacting objects with state, or we can model the worldas a single, timeless, stateless unity.  Each view has powerfuladvantages, but neither view alone is completely satisfactory.  Agrand unification has yet to emerge.<a name="call_footnote_Temp_507" href="#footnote_Temp_507" id="call_footnote_Temp_507"><sup><small>76</small></sup></a></p>
<p></p>
<p></p>
<div class="smallprint"><hr></div>
<p></p>
<div class="footnote">
<p><a name="footnote_Temp_442" href="#call_footnote_Temp_442" id="footnote_Temp_442"><sup><small>52</small></sup></a> Physicists sometimes adopt this view by introducing the<a name="%_idx_3728" id="%_idx_3728"></a>“world lines” of particles as a device for reasoning about motion.We've also already mentioned(section <a href="book-Z-H-15.html#%_sec_2.2.3">2.2.3</a>) that this is thenatural way to think about signal-processing systems.  We will exploreapplications of streams to signal processing insection <a href="#%_sec_3.5.3">3.5.3</a>.</p>
<p><a name="footnote_Temp_443" href="#call_footnote_Temp_443" id="footnote_Temp_443"><sup><small>53</small></sup></a> Assume that we have apredicate <code>prime?</code> (e.g., as in section <a href="book-Z-H-11.html#%_sec_1.2.6">1.2.6</a>) thattests for primality.</p>
<p><a name="footnote_Temp_444" href="#call_footnote_Temp_444" id="footnote_Temp_444"><sup><small>54</small></sup></a> In the MIT implementation, <a name="%_idx_3752" id="%_idx_3752"></a><a name="%_idx_3754" id="%_idx_3754"></a><a name="%_idx_3756" id="%_idx_3756"></a><code>the-empty-stream</code> is thesame as the empty list <code>'()</code>, and <code>stream-null?</code> is the sameas <code>null?</code>.</p>
<p><a name="footnote_Temp_445" href="#call_footnote_Temp_445" id="footnote_Temp_445"><sup><small>55</small></sup></a> This should bother you.  The fact that we are defining suchsimilar procedures for streams and lists indicates that we are missing someunderlying abstraction.  Unfortunately, in order to exploit thisabstraction, we will need to exert finer control over the process ofevaluation than we can at present.  We will discuss this point furtherat the end of section <a href="#%_sec_3.5.4">3.5.4</a>.In section <a href="book-Z-H-27.html#%_sec_4.2">4.2</a>, we'll develop a framework thatunifies lists and streams.</p>
<p><a name="footnote_Temp_446" href="#call_footnote_Temp_446" id="footnote_Temp_446"><sup><small>56</small></sup></a> Although <code>stream-car</code> and<a name="%_idx_3784" id="%_idx_3784"></a><a name="%_idx_3786" id="%_idx_3786"></a><code>stream-cdr</code> can be defined as procedures, <code>cons-stream</code> mustbe a special form.  If <code>cons-stream</code> were a procedure, then,according to our model of evaluation, evaluating <code>(cons-stream&lt;<em>a</em>&gt; &lt;<em>b</em>&gt;)</code> would automatically cause &lt;<em>b</em>&gt; to be evaluated, which isprecisely what we do not want to happen.  For the same reason, <code>delay</code> must be a special form, though <code>force</code> can be an ordinaryprocedure.</p>
<p><a name="footnote_Temp_448" href="#call_footnote_Temp_448" id="footnote_Temp_448"><sup><small>57</small></sup></a> The numbers shown here donot really appear in the delayed expression.  What actually appears isthe original expression, in an environment in which the variables arebound to the appropriate numbers.  For example, <code>(+ low 1)</code> with<code>low</code> bound to 10,000 actually appears where <code>10001</code> isshown.</p>
<p><a name="footnote_Temp_450" href="#call_footnote_Temp_450" id="footnote_Temp_450"><sup><small>58</small></sup></a> There are manypossible implementations of streams other than the one described inthis section.  Delayed evaluation, which is the key to making streamspractical, was inherent in <a name="%_idx_3806" id="%_idx_3806"></a><a name="%_idx_3808" id="%_idx_3808"></a>Algol 60's <em>call-by-name</em>parameter-passing method.  The use of this mechanism to implementstreams was first described by <a name="%_idx_3810" id="%_idx_3810"></a>Landin (1965).  Delayed evaluation forstreams was introduced into Lisp by <a name="%_idx_3812" id="%_idx_3812"></a><a name="%_idx_3814" id="%_idx_3814"></a>Friedman and Wise (1976). In theirimplementation, <code>cons</code> always delays evaluating its arguments, sothat lists automatically behave as streams.  The memoizingoptimization is also known as <a name="%_idx_3816" id="%_idx_3816"></a><a name="%_idx_3818" id="%_idx_3818"></a><a name="%_idx_3820" id="%_idx_3820"></a><a name="%_idx_3822" id="%_idx_3822"></a><em>call-by-need</em>.  The Algol communitywould refer to our original delayed objects as <em>call-by-namethunks</em> and to the optimized versions as <em>call-by-need thunks</em>.</p>
<p><a name="footnote_Temp_453" href="#call_footnote_Temp_453" id="footnote_Temp_453"><sup><small>59</small></sup></a> Exercises such as <a href="#%_thm_3.51">3.51</a> and <a href="#%_thm_3.52">3.52</a>are valuable for testing our understanding of how <code>delay</code> works.On the other hand, intermixing delayed evaluation with printing – and,even worse, with assignment – is extremely confusing, and instructorsof courses on computer languages have traditionally tormented theirstudents with examination questions such as the ones in this section.Needless to say, writing programs that depend on such subtleties is<a name="%_idx_3828" id="%_idx_3828"></a>odious programming style.  Part of the power of stream processing isthat it lets us ignore the order in which events actually happen inour programs.  Unfortunately, this is precisely what we cannot affordto do in the presence of assignment, which forces us to be concernedwith time and change.</p>
<p><a name="footnote_Temp_455" href="#call_footnote_Temp_455" id="footnote_Temp_455"><sup><small>60</small></sup></a> Eratosthenes, a third-century <font size="-2">B</font>.<font size="-2">C</font>.<a name="%_idx_3846" id="%_idx_3846"></a><a name="%_idx_3848" id="%_idx_3848"></a>Alexandrian Greek philosopher, is famous for giving the first accurateestimate of the circumference of the Earth, which he computed byobserving shadows cast at noon on the day of the summer solstice.Eratosthenes's sieve method, although ancient, has formed the basisfor special-purpose hardware “sieves” that, until recently, were themost powerful tools in existence for locating large primes.  Since the70s, however, these methods have been superseded by outgrowths of the<a name="%_idx_3850" id="%_idx_3850"></a>probabilistic techniques discussed in section <a href="book-Z-H-11.html#%_sec_1.2.6">1.2.6</a>.</p>
<p><a name="footnote_Temp_456" href="#call_footnote_Temp_456" id="footnote_Temp_456"><sup><small>61</small></sup></a> We have named these figures after <a name="%_idx_3858" id="%_idx_3858"></a>Peter Henderson, whowas the first person to show us diagrams of this sort as a way ofthinking about stream processing.  Each solid line represents a streamof values being transmitted.  The dashed line from the <code>car</code> tothe <code>cons</code> and the <code>filter</code> indicates that this is a singlevalue rather than a stream.</p>
<p><a name="footnote_Temp_458" href="#call_footnote_Temp_458" id="footnote_Temp_458"><sup><small>62</small></sup></a> This uses the generalized versionof <code>stream-map</code> from exercise <a href="#%_thm_3.50">3.50</a>.</p>
<p><a name="footnote_Temp_459" href="#call_footnote_Temp_459" id="footnote_Temp_459"><sup><small>63</small></sup></a> This last point isvery subtle and relies on the fact that <em>p</em><sub><em>n</em>+1</sub><u>&lt;</u> <em>p</em><sub><em>n</em></sub><sup>2</sup>.(Here, <em>p</em><sub><em>k</em></sub> denotes the <em>k</em>th prime.)  Estimates such as these arevery difficult to establish.  The ancient proof by <a name="%_idx_3876" id="%_idx_3876"></a>Euclid that thereare an infinite number of primes shows that <em>p</em><sub><em>n</em>+1</sub><u>&lt;</u> <em>p</em><sub>1</sub><em>p</em><sub>2</sub><code>···</code>   <em>p</em><sub><em>n</em></sub>  + 1, and no substantially better result was proveduntil 1851, when the Russian mathematician P. L. Chebyshev established<a name="%_idx_3878" id="%_idx_3878"></a><a name="%_idx_3880" id="%_idx_3880"></a><a name="%_idx_3882" id="%_idx_3882"></a><a name="%_idx_3884" id="%_idx_3884"></a>that <em>p</em><sub><em>n</em>+1</sub><u>&lt;</u> 2<em>p</em><sub><em>n</em></sub> for all <em>n</em>.  This result, originallyconjectured in 1845, is known as <em>Bertrand's hypothesis</em>.  A proofcan be found in section 22.3 of Hardy and Wright 1960.</p>
<p><a name="footnote_Temp_465" href="#call_footnote_Temp_465" id="footnote_Temp_465"><sup><small>64</small></sup></a> This exercise shows how call-by-need is closely related to<a name="%_idx_3902" id="%_idx_3902"></a><a name="%_idx_3904" id="%_idx_3904"></a>ordinary memoization as described in exercise <a href="book-Z-H-22.html#%_thm_3.27">3.27</a>.In that exercise, we used assignment to explicitly construct a localtable.  Our call-by-need stream optimization effectively constructssuch a table automatically, storing values in the previously forcedparts of the stream.</p>
<p><a name="footnote_Temp_472" href="#call_footnote_Temp_472" id="footnote_Temp_472"><sup><small>65</small></sup></a> We can't use <code>let</code> to bind the local variable<code>guesses</code>, because the value of <code>guesses</code> depends on <code>guesses</code> itself.  Exercise <a href="#%_thm_3.63">3.63</a> addresses whywe want a local variable here.</p>
<p><a name="footnote_Temp_477" href="#call_footnote_Temp_477" id="footnote_Temp_477"><sup><small>66</small></sup></a> As in section <a href="book-Z-H-15.html#%_sec_2.2.3">2.2.3</a>,we represent a pair of integers as a list rather than a Lisp pair.</p>
<p><a name="footnote_Temp_478" href="#call_footnote_Temp_478" id="footnote_Temp_478"><sup><small>67</small></sup></a> See exercise <a href="#%_thm_3.68">3.68</a> for some insightinto why we chose this decomposition.</p>
<p><a name="footnote_Temp_479" href="#call_footnote_Temp_479" id="footnote_Temp_479"><sup><small>68</small></sup></a> The precise statement of therequired property on the order of combination is as follows: Thereshould be a function <em>f</em> of two arguments such that the paircorresponding to element <em>i</em> of the first stream and element <em>j</em> ofthe second stream will appear as element number <em>f</em>(<em>i</em>,<em>j</em>) of the outputstream.  The trick of using <code>interleave</code> to accomplish this wasshown to us by <a name="%_idx_3996" id="%_idx_3996"></a>David Turner, who employed it in the language <a name="%_idx_3998" id="%_idx_3998"></a>KRC(Turner 1981).</p>
<p><a name="footnote_Temp_485" href="#call_footnote_Temp_485" id="footnote_Temp_485"><sup><small>69</small></sup></a> We will require that the weighting function be such thatthe weight of a pair increases as we move out along a row or downalong a column of the array of pairs.</p>
<p><a name="footnote_Temp_487" href="#call_footnote_Temp_487" id="footnote_Temp_487"><sup><small>70</small></sup></a> To quote from G. H. Hardy's obituary of<a name="%_idx_4012" id="%_idx_4012"></a><a name="%_idx_4014" id="%_idx_4014"></a><a name="%_idx_4016" id="%_idx_4016"></a>Ramanujan (Hardy 1921): “It was Mr. Littlewood (I believe) who remarked that`every positive integer was one of his friends.'  I remember oncegoing to see him when he was lying ill at Putney.  I had ridden intaxi-cab No. 1729, and remarked that the number seemed to me a ratherdull one, and that I hoped it was not an unfavorable omen.  `No,' hereplied, `it is a very interesting number; it is the smallest numberexpressible as the sum of two cubes in two different ways.' ”The trick of using weighted pairs to generate the Ramanujan numberswas shown to us by Charles Leiserson.</p>
<p><a name="footnote_Temp_494" href="#call_footnote_Temp_494" id="footnote_Temp_494"><sup><small>71</small></sup></a> This procedure is not guaranteed to work in all Schemeimplementations, although for any implementation there is a simplevariation that will work.  The problem has to do with subtledifferences in the ways that Scheme implementations handle internaldefinitions.  (See section <a href="book-Z-H-26.html#%_sec_4.1.6">4.1.6</a>.)</p>
<p><a name="footnote_Temp_500" href="#call_footnote_Temp_500" id="footnote_Temp_500"><sup><small>72</small></sup></a> This is a small reflection, in Lisp, of the difficultiesthat conventional strongly typed languages such as <a name="%_idx_4096" id="%_idx_4096"></a><a name="%_idx_4098" id="%_idx_4098"></a><a name="%_idx_4100" id="%_idx_4100"></a><a name="%_idx_4102" id="%_idx_4102"></a><a name="%_idx_4104" id="%_idx_4104"></a>Pascal have incoping with higher-order procedures.  In such languages, theprogrammer must specify the data types of the arguments and the resultof each procedure: number, logical value, sequence, and so on.Consequently, we could not express an abstraction such as “map agiven procedure <code>proc</code> over all the elements in a sequence” by asingle higher-order procedure such as <code>stream-map</code>.  Rather, wewould need a different mapping procedure for each differentcombination of argument and result data types that might be specifiedfor a <code>proc</code>.  Maintaining a practical notion of “data type” inthe presence of higher-order procedures raises many difficult issues.One way of dealing with this problem is illustrated by the language ML<a name="%_idx_4106" id="%_idx_4106"></a><a name="%_idx_4108" id="%_idx_4108"></a><a name="%_idx_4110" id="%_idx_4110"></a><a name="%_idx_4112" id="%_idx_4112"></a>(Gordon, Milner, and Wadsworth 1979), whose “polymorphic data types”include templates for higher-order transformations between data types.Moreover, data types for most procedures in ML are never explicitlydeclared by the programmer.  Instead, ML includes a <a name="%_idx_4114" id="%_idx_4114"></a><em>type-inferencing</em> mechanism that uses information in the environmentto deduce the data types for newly defined procedures.</p>
<p><a name="footnote_Temp_504" href="#call_footnote_Temp_504" id="footnote_Temp_504"><sup><small>73</small></sup></a> Similarly in physics, when we observe a moving particle, wesay that the position (state) of the particle is changing.  However,from the perspective of the particle's <a name="%_idx_4156" id="%_idx_4156"></a>world line in space-time thereis no change involved.</p>
<p><a name="footnote_Temp_505" href="#call_footnote_Temp_505" id="footnote_Temp_505"><sup><small>74</small></sup></a> John Backus, the inventor of Fortran, gave high<a name="%_idx_4166" id="%_idx_4166"></a><a name="%_idx_4168" id="%_idx_4168"></a><a name="%_idx_4170" id="%_idx_4170"></a><a name="%_idx_4172" id="%_idx_4172"></a><a name="%_idx_4174" id="%_idx_4174"></a>visibility to functional programming when he was awardedthe ACM Turing award in 1978.  His acceptance speech (Backus 1978)strongly advocated the functional approach.  A good overview offunctional programming is given in Henderson 1980 and in Darlington,Henderson, and Turner 1982.</p>
<p><a name="footnote_Temp_506" href="#call_footnote_Temp_506" id="footnote_Temp_506"><sup><small>75</small></sup></a> Observe that, for any two streams, there is in general more than one<a name="%_idx_4180" id="%_idx_4180"></a><a name="%_idx_4182" id="%_idx_4182"></a>acceptable order of interleaving.  Thus, technically, “merge” is arelation rather than a function – the answer is not a deterministicfunction of the inputs.  We already mentioned(footnote <a href="book-Z-H-23.html#footnote_Temp_411">39</a>) that nondeterminism isessential when dealing with concurrency.  The merge relationillustrates the same essential nondeterminism, from the functionalperspective.  In section <a href="book-Z-H-28.html#%_sec_4.3">4.3</a>, wewill look at nondeterminism from yet another point of view.</p>
<p><a name="footnote_Temp_507" href="#call_footnote_Temp_507" id="footnote_Temp_507"><sup><small>76</small></sup></a> The object model approximates the world bydividing it into separate pieces.  The functional model does notmodularize along object boundaries.  The object model is useful when<a name="%_idx_4184" id="%_idx_4184"></a>the unshared state of the “objects” is much larger than the statethat they share.  An example of a place where the object viewpointfails is <a name="%_idx_4186" id="%_idx_4186"></a>quantummechanics, where thinking of things as individual particles leads toparadoxes and confusions.  Unifying the object view with thefunctional view may have little to do with programming, but ratherwith fundamental epistemological issues.</p>
</div></body>
</html>
