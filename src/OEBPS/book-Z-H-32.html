<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<?xml version="1.0" encoding="utf-8"?><html xmlns="http://www.w3.org/1999/xhtml" xmlns:ops="http://www.idpf.org/2007/ops">
<!-- Generated from TeX source by tex2page, v 4o,
     (c) Dorai Sitaram, http://www.cs.rice.edu/~dorai/tex2page --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Type: text/html; charset=utf-8">
<title>Structure and Interpretation of Computer Programs</title>
<link rel="stylesheet" type="text/css" href="book-Z-C.css" title="default">
</head>
<body><a name="%_sec_5.2" id="%_sec_5.2"></a><h2><a href="book-Z-H-4.html#%_toc_%_sec_5.2">5.2  A Register-Machine Simulator</a></h2>
<p><a name="%_idx_5622" id="%_idx_5622"></a><a name="%_idx_5624" id="%_idx_5624"></a>In order to gain a good understanding of the design of registermachines, we must test the machines we design to see if they performas expected.  One way to test a design is to hand-simulate theoperation of the controller, as in exercise <a href="book-Z-H-31.html#%_thm_5.5">5.5</a>.  But this isextremely tedious for all but the simplest machines.  In this sectionwe construct a simulator for machines described in theregister-machine language.  The simulator is a Scheme program withfour interface procedures.  The first uses a description of a registermachine to construct a model of the machine (a data structure whoseparts correspond to the parts of the machine to be simulated), and theother three allow us to simulate the machine by manipulating themodel:</p>
<p></p>
<blockquote><p><a name="%_idx_5626" id="%_idx_5626"></a><code>(make-machine &lt;<em>register-names</em>&gt; &lt;<em>operations</em>&gt; &lt;<em>controller</em>&gt;)</code>
constructs and returns a model of the machine with the givenregisters, operations, and controller.</p>
<p></p>
<p><a name="%_idx_5628" id="%_idx_5628"></a><code>(set-register-contents! &lt;<em>machine-model</em>&gt; &lt;<em>register-name</em>&gt; &lt;<em>value</em>&gt;)</code>
stores a value in a simulated register in the givenmachine.</p>
<p><a name="%_idx_5630" id="%_idx_5630"></a></p>
<p><code>(get-register-contents &lt;<em>machine-model</em>&gt; &lt;<em>register-name</em>&gt;)</code>
returns the contents of a simulated register in the given machine.</p>
<p><a name="%_idx_5632" id="%_idx_5632"></a></p>
<p><code>(start &lt;<em>machine-model</em>&gt;)</code>
simulates the execution of the givenmachine, starting from the beginning of the controller sequence andstopping when it reaches the end of the sequence.</p>
</blockquote>
<p>As an example of how these procedures are used, we can define<code>gcd-machine</code> to be a model of the GCD machineof section <a href="book-Z-H-31.html#%_sec_5.1.1">5.1.1</a> as follows:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_5634" id="%_idx_5634"></a>(define gcd-machine
  (make-machine
   '(a b t)
   (list (list 'rem remainder) (list '= =))
   '(test-b
       (test (op =) (reg b) (const 0))
       (branch (label gcd-done))
       (assign t (op rem) (reg a) (reg b))
       (assign a (reg b))
       (assign b (reg t))
       (goto (label test-b))
     gcd-done)))
</pre></p>
<p></p>
<p>The first argument to <code>make-machine</code> is a list of register names.The next argument is a table (a list of two-element lists) that pairseach operation name with a Scheme procedure that implements the operation(that is, produces the same output value given the same input values).The last argument specifies the controller as a list of labels andmachine instructions, as in section <a href="book-Z-H-31.html#%_sec_5.1">5.1</a>.</p>
<p>To compute GCDs with this machine, we set theinput registers, start the machine, and examine the result when thesimulation terminates:</p>
<p></p>
<p><pre>(set-register-contents! gcd-machine 'a 206)
<i>done</i>
(set-register-contents! gcd-machine 'b 40)
<i>done</i>
(start gcd-machine)
<i>done</i>
(get-register-contents gcd-machine 'a)
<i>2</i>
</pre></p>
<p></p>
<p>This computation will run much more slowly than a <code>gcd</code> procedurewritten in Scheme, because we will simulate low-level machineinstructions, such as <code>assign</code>, by much more complex operations.</p>
<p></p>
<p><a name="%_thm_5.7" id="%_thm_5.7"></a><b>Exercise 5.7.</b>  Use the simulator to test the machines you designed inexercise <a href="book-Z-H-31.html#%_thm_5.4">5.4</a>.</p>
<p></p>
<p><a name="%_sec_5.2.1" id="%_sec_5.2.1"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_5.2.1">5.2.1  The Machine Model</a></h3>
<p></p>
<p>The machine model generated by <code>make-machine</code> is represented as aprocedure with local state using the message-passing techniquesdeveloped in chapter 3.  To build this model, <code>make-machine</code>begins by calling the procedure <code>make-new-machine</code> to constructthe parts of the machine model that are common to all registermachines.  This basic machine model constructed by <code>make-new-machine</code> is essentially a container for some registers and astack, together with an execution mechanism that processes the controllerinstructions one by one.</p>
<p><code>Make-machine</code> then extends this basic model (by sending itmessages) to include the registers, operations, and controller of theparticular machine being defined.  First it allocates a register inthe new machine for each of the supplied register names and installsthe designated operations in the machine.  Then it uses an <a name="%_idx_5636" id="%_idx_5636"></a><em>assembler</em> (described below in section <a href="#%_sec_5.2.2">5.2.2</a>) totransform the controller list into instructions for the new machineand installs these as the machine's instruction sequence.  <code>Make-machine</code> returns as its value the modified machine model.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_5638" id="%_idx_5638"></a>(define (make-machine register-names ops controller-text)
  (let ((machine (make-new-machine)))
    (for-each (lambda (register-name)
                ((machine 'allocate-register) register-name))
              register-names)
    ((machine 'install-operations) ops)    
    ((machine 'install-instruction-sequence)
     (assemble controller-text machine))
    machine))
</pre></p>
<p></p>
<p></p>
<p><a name="%_sec_Temp_724" id="%_sec_Temp_724"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_724">Registers</a></h4>
<p><a name="%_idx_5640" id="%_idx_5640"></a>We will represent a register as a procedure with local state, as inchapter 3.  The procedure <code>make-register</code> creates a register thatholds a value that can be accessed or changed:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_5642" id="%_idx_5642"></a>(define (make-register name)
  (let ((contents '*unassigned*))
    (define (dispatch message)
      (cond ((eq? message 'get) contents)
            ((eq? message 'set)
             (lambda (value) (set! contents value)))
            (else
             (error "Unknown request -- REGISTER" message))))
    dispatch))
</pre></p>
<p></p>
<p>The following procedures are used to access registers:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_5644" id="%_idx_5644"></a>(define (get-contents register)
  (register 'get))

<a name="%_idx_5646" id="%_idx_5646"></a>(define (set-contents! register value)
  ((register 'set) value))
</pre></p>
<p></p>
<p></p>
<p><a name="%_sec_Temp_725" id="%_sec_Temp_725"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_725">The stack</a></h4>
<p><a name="%_idx_5648" id="%_idx_5648"></a>We can also represent a stack as a procedure with local state.  Theprocedure <code>make-stack</code> creates a stack whose local state consistsof a list of the items on the stack.  A stack accepts requests to <code>push</code> an item onto the stack, to <code>pop</code> the top item off the stackand return it, and to <code>initialize</code> the stack to empty.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_5650" id="%_idx_5650"></a>(define (make-stack)
  (let ((s '()))
    (define (push x)
      (set! s (cons x s)))
    (define (pop)
      (if (null? s)
          (error "Empty stack -- POP")
          (let ((top (car s)))
            (set! s (cdr s))
            top)))
    (define (initialize)
      (set! s '())
      'done)
    (define (dispatch message)
      (cond ((eq? message 'push) push)
            ((eq? message 'pop) (pop))
            ((eq? message 'initialize) (initialize))
            (else (error "Unknown request -- STACK"
                         message))))
    dispatch))
</pre></p>
<p></p>
<p>The following procedures are used to access stacks:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_5652" id="%_idx_5652"></a>(define (pop stack)
  (stack 'pop))

<a name="%_idx_5654" id="%_idx_5654"></a>(define (push stack value)
  ((stack 'push) value))
</pre></p>
<p></p>
<p></p>
<p><a name="%_sec_Temp_726" id="%_sec_Temp_726"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_726">The basic machine</a></h4>
<p>The <code>make-new-machine</code> procedure, shown infigure <a href="#%_fig_5.13">5.13</a>, constructs an object whose localstate consists of a stack, an initially empty instruction sequence, alist of operations that initially contains an operation to <a name="%_idx_5656" id="%_idx_5656"></a>initializethe stack, and a <a name="%_idx_5658" id="%_idx_5658"></a><em>register table</em> that initially contains two<a name="%_idx_5660" id="%_idx_5660"></a><a name="%_idx_5662" id="%_idx_5662"></a>registers, named <code>flag</code> and <code>pc</code> <a name="%_idx_5664" id="%_idx_5664"></a>(for “program counter”).The internal procedure <code>allocate-register</code> adds new entries to theregister table, and the internal procedure <code>lookup-register</code> looksup registers in the table.</p>
<p>The <code>flag</code> register is used to control branching in the simulatedmachine.  <code>Test</code> instructions set the contents of <code>flag</code> tothe result of the test (true or false).  <code>Branch</code> instructionsdecide whether or not to branch by examining the contents of <code>flag</code>.</p>
<p>The <code>pc</code> register determines the sequencing of instructions asthe machine runs.  This sequencing is implemented by the internalprocedure <code>execute</code>.In the simulation model, each machine instruction is a data structurethat includes a procedure of no arguments, called the <a name="%_idx_5666" id="%_idx_5666"></a><a name="%_idx_5668" id="%_idx_5668"></a><em>instructionexecution procedure</em>, such that calling this procedure simulatesexecuting the instruction.  As the simulation runs, <code>pc</code> points tothe place in the instruction sequence beginning with the nextinstruction to be executed.  <a name="%_idx_5670" id="%_idx_5670"></a><code>Execute</code> gets that instruction,executes it by calling the instruction execution procedure, andrepeats this cycle until there are no more instructions to execute(i.e., until <code>pc</code> points to the end of the instruction sequence).</p>
<p><a name="%_fig_5.13" id="%_fig_5.13"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td>
<p></p>
<p><pre><a name="%_idx_5672" id="%_idx_5672"></a>(define (make-new-machine)
  (let ((pc (make-register 'pc))
        (flag (make-register 'flag))
        (stack (make-stack))
        (the-instruction-sequence '()))
    (let ((the-ops
           (list (list 'initialize-stack
                       (lambda () (stack 'initialize)))))
          (register-table
           (list (list 'pc pc) (list 'flag flag))))
      (define (allocate-register name)
        (if (assoc name register-table)
            (error "Multiply defined register: " name)
            (set! register-table
                  (cons (list name (make-register name))
                        register-table)))
        'register-allocated)
      (define (lookup-register name)
        (let ((val (assoc name register-table)))
          (if val
              (cadr val)
              (error "Unknown register:" name))))
      (define (execute)
        (let ((insts (get-contents pc)))
          (if (null? insts)
              'done
              (begin
                ((instruction-execution-proc (car insts)))
                (execute)))))
      (define (dispatch message)
        (cond ((eq? message 'start)
               (set-contents! pc the-instruction-sequence)
               (execute))
              ((eq? message 'install-instruction-sequence)
               (lambda (seq) (set! the-instruction-sequence seq)))
              ((eq? message 'allocate-register) allocate-register)
              ((eq? message 'get-register) lookup-register)
              ((eq? message 'install-operations)
               (lambda (ops) (set! the-ops (append the-ops ops))))
              ((eq? message 'stack) stack)
              ((eq? message 'operations) the-ops)
              (else (error "Unknown request -- MACHINE" message))))
      dispatch)))
</pre></p>
<p></p>
<p></p>
<p></p>
<p></p>
</td></tr>
<caption align="bottom"><div align="left">
<b>Figure 5.13:</b>  The <code>make-new-machine</code> procedure, which implementsthe basic machine model.</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p>As part of its operation, each instruction execution proceduremodifies <code>pc</code> to indicate the next instruction to be executed.<code>Branch</code> and <code>goto</code> instructions change <code>pc</code> to point tothe new destination.  All other instructions simply advance <code>pc</code>,making it point to the next instruction in the sequence.  Observe thateach call to <code>execute</code> calls <code>execute</code> again, but this doesnot produce an infinite loop because running the instruction executionprocedure changes the contents of <code>pc</code>.</p>
<p><code>Make-new-machine</code> returns a<code>dispatch</code> procedure that implements message-passingaccess to the internal state.  Notice that starting the machine isaccomplished by setting <code>pc</code> to the beginning of the instructionsequence and calling <code>execute</code>.</p>
<p>For convenience, we provide an alternate procedural interface to amachine's <code>start</code> operation,as well as procedures to set and examine register contents,as specified at the beginning of section <a href="#%_sec_5.2">5.2</a>:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_5674" id="%_idx_5674"></a>(define (start machine)
  (machine 'start))
<a name="%_idx_5676" id="%_idx_5676"></a>(define (get-register-contents machine register-name)
  (get-contents (get-register machine register-name)))
<a name="%_idx_5678" id="%_idx_5678"></a>(define (set-register-contents! machine register-name value)
  (set-contents! (get-register machine register-name) value)
  'done)
</pre></p>
<p></p>
<p>These procedures (and many procedures in sections <a href="#%_sec_5.2.2">5.2.2</a>and <a href="#%_sec_5.2.3">5.2.3</a>) use the following to look up the register with agiven name in a given machine:</p>
<p></p>
<p><pre><a name="%_idx_5680" id="%_idx_5680"></a>(define (get-register machine reg-name)
  ((machine 'get-register) reg-name))
</pre></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_sec_5.2.2" id="%_sec_5.2.2"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_5.2.2">5.2.2  The Assembler</a></h3>
<p><a name="%_idx_5682" id="%_idx_5682"></a>The assembler transforms the sequence of controller expressions for amachine into a corresponding list of machine instructions, each withits execution procedure.  Overall, the assembler is much like theevaluators we studied in chapter 4 – there is an input language (inthis case, the register-machine language) and we must perform anappropriate action for each type of expression in the language.</p>
<p><a name="%_idx_5684" id="%_idx_5684"></a>The technique of producing an execution procedure for each instructionis just what we used in section <a href="book-Z-H-26.html#%_sec_4.1.7">4.1.7</a> to speedup the evaluator by separating analysis from runtime execution.  As wesaw in chapter 4, much useful analysis of Scheme expressions could beperformed without knowing the actual values of variables.  Here,analogously, much useful analysis of register-machine-languageexpressions can be performed without knowing the actual contents ofmachine registers.  For example, we can replace references toregisters by pointers to the register objects, and we canreplace references to labels by pointers to the place in theinstruction sequence that the label designates.</p>
<p>Before it can generate the instruction execution procedures, theassembler must know what all the labels refer to, so it begins byscanning the controller text to separate the labels from theinstructions.  As it scans the text, it constructs both a list ofinstructions and a table that associates each label with a pointerinto that list.  Then the assembler augments the instruction list byinserting the execution procedure for each instruction.</p>
<p>The <code>assemble</code> procedure is the main entry to the assembler.It takes the controller text and the machine model as arguments andreturns the instruction sequence to be stored in the model.<code>Assemble</code> calls <code>extract-labels</code> to build the initial instruction listand label table from the supplied controller text.  The second argumentto <code>extract-labels</code> is a procedure to be called to process these results:This procedure uses <code>update-insts!</code> to generate the instruction executionprocedures and insert them into the instruction list,and returns the modified list.</p>
<p></p>
<p><pre><a name="%_idx_5686" id="%_idx_5686"></a>(define (assemble controller-text machine)
  (extract-labels controller-text
    (lambda (insts labels)
      (update-insts! insts labels machine)
      insts)))
</pre></p>
<p></p>
<p></p>
<p><code>Extract-labels</code>takes as arguments a list <code>text</code> (the sequence of controllerinstruction expressions) and a <code>receive</code> procedure.  <code>Receive</code>will be called with two values: (1) a list <code>insts</code> of instructiondata structures, each containing an instruction from <code>text</code>; and(2) a table called <code>labels</code>, which associates each label from <code>text</code>with the position in the list <code>insts</code> that the label designates.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_5688" id="%_idx_5688"></a>(define (extract-labels text receive)
  (if (null? text)
      (receive '() '())
      (extract-labels (cdr text)
       (lambda (insts labels)
         (let ((next-inst (car text)))
           (if (symbol? next-inst)
               (receive insts
                        (cons (make-label-entry next-inst
                                                insts)
                              labels))
               (receive (cons (make-instruction next-inst)
                              insts)
                        labels)))))))
</pre></p>
<p></p>
<p><code>Extract-labels</code> works by sequentially scanning the elements ofthe <code>text</code> and accumulating the <code>insts</code> and the <code>labels</code>.If an element is a symbol (and thus a label) an appropriate entry isadded to the <code>labels</code> table.  Otherwise the element is accumulatedonto the <code>insts</code> list.<a name="call_footnote_Temp_727" href="#footnote_Temp_727" id="call_footnote_Temp_727"><sup><small>4</small></sup></a></p>
<p><code>Update-insts!</code> modifies the instruction list, which initiallycontains only the text of the instructions, to include thecorresponding execution procedures:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_5702" id="%_idx_5702"></a>(define (update-insts! insts labels machine)
  (let ((pc (get-register machine 'pc))
        (flag (get-register machine 'flag))
        (stack (machine 'stack))
        (ops (machine 'operations)))
    (for-each
     (lambda (inst)
       (set-instruction-execution-proc! 
        inst
        (make-execution-procedure
         (instruction-text inst) labels machine
         pc flag stack ops)))
     insts)))
</pre></p>
<p></p>
<p></p>
<p>The machine instruction data structure simply pairs theinstruction text with the corresponding execution procedure.The execution procedure is not yet available when <code>extract-labels</code>constructs the instruction, and is inserted later by <code>update-insts!</code>.</p>
<p></p>
<p><pre><a name="%_idx_5704" id="%_idx_5704"></a>(define (make-instruction text)
  (cons text '()))
<a name="%_idx_5706" id="%_idx_5706"></a>(define (instruction-text inst)
  (car inst))
<a name="%_idx_5708" id="%_idx_5708"></a>(define (instruction-execution-proc inst)
  (cdr inst))
<a name="%_idx_5710" id="%_idx_5710"></a>(define (set-instruction-execution-proc! inst proc)
  (set-cdr! inst proc))
</pre></p>
<p></p>
<p>The instruction text is not used by our simulator, but it is handy to keeparound for debugging (see exercise <a href="#%_thm_5.16">5.16</a>).</p>
<p>Elements of the label table are pairs:</p>
<p></p>
<p><pre><a name="%_idx_5712" id="%_idx_5712"></a>(define (make-label-entry label-name insts)
  (cons label-name insts))
</pre></p>
<p></p>
<p>Entries will be looked up in the table with</p>
<p></p>
<p><pre><a name="%_idx_5714" id="%_idx_5714"></a>(define (lookup-label labels label-name)
  (let ((val (assoc label-name labels)))
    (if val
        (cdr val)
        (error "Undefined label -- ASSEMBLE" label-name))))
</pre></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_5.8" id="%_thm_5.8"></a><b>Exercise 5.8.</b>  The following register-machine code is ambiguous, because the label<code>here</code> is defined more than once:</p>
<p></p>
<p><pre>start
  (goto (label here))
here
  (assign a (const 3))
  (goto (label there))
here
  (assign a (const 4))
  (goto (label there))
there
</pre></p>
<p></p>
<p>With the simulator as written, what will the contents of register <code>a</code>be when control reaches <code>there</code>?  Modify the <code>extract-labels</code>procedure so that the assembler will signal an error if the same labelname is used to indicate two different locations.</p>
<p></p>
<p><a name="%_sec_5.2.3" id="%_sec_5.2.3"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_5.2.3">5.2.3  Generating Execution Procedures for Instructions</a></h3>
<p><a name="%_idx_5716" id="%_idx_5716"></a>The assembler calls <code>make-execution-procedure</code> togenerate the execution procedure for an instruction.Like the <code>analyze</code> procedure in the evaluator ofsection <a href="book-Z-H-26.html#%_sec_4.1.7">4.1.7</a>, this dispatches on the type ofinstruction to generate the appropriate execution procedure.</p>
<p></p>
<p><pre><a name="%_idx_5718" id="%_idx_5718"></a>(define (make-execution-procedure inst labels machine
                                  pc flag stack ops)
  (cond ((eq? (car inst) 'assign)
         (make-assign inst machine labels ops pc))
        ((eq? (car inst) 'test)
         (make-test inst machine labels ops flag pc))
        ((eq? (car inst) 'branch)
         (make-branch inst machine labels flag pc))
        ((eq? (car inst) 'goto)
         (make-goto inst machine labels pc))
        ((eq? (car inst) 'save)
         (make-save inst machine stack pc))
        ((eq? (car inst) 'restore)
         (make-restore inst machine stack pc))
        ((eq? (car inst) 'perform)
         (make-perform inst machine labels ops pc))
        (else (error "Unknown instruction type -- ASSEMBLE"
                     inst))))
</pre></p>
<p></p>
<p></p>
<p>For each type of instruction in the register-machine language, thereis a generator that builds an appropriate execution procedure.  Thedetails of these procedures determine both the syntax and meaning ofthe individual instructions in the register-machine language.We use data abstraction to isolate the detailed syntax ofregister-machine expressions from the general execution mechanism, aswe did for evaluators in section <a href="book-Z-H-26.html#%_sec_4.1.2">4.1.2</a>,by using syntax procedures to extract and classify the parts of an instruction.</p>
<p><a name="%_sec_Temp_729" id="%_sec_Temp_729"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_729"><code>Assign</code> instructions</a></h4>
<p><a name="%_idx_5720" id="%_idx_5720"></a>The <code>make-assign</code> procedure handles <code>assign</code> instructions:</p>
<p></p>
<p><pre><a name="%_idx_5722" id="%_idx_5722"></a>(define (make-assign inst machine labels operations pc)
  (let ((target
         (get-register machine (assign-reg-name inst)))
        (value-exp (assign-value-exp inst)))
    (let ((value-proc
           (if (operation-exp? value-exp)
               (make-operation-exp
                value-exp machine labels operations)
               (make-primitive-exp
                (car value-exp) machine labels))))
      (lambda ()                <em>; execution procedure for <code>assign</code></em>
        (set-contents! target (value-proc))
        (advance-pc pc)))))
</pre></p>
<p></p>
<p><code>Make-assign</code> extracts the target register name (thesecond element of the instruction) and the value expression(the rest of the list that forms the instruction)from the <code>assign</code> instruction using the selectors</p>
<p></p>
<p><pre><a name="%_idx_5724" id="%_idx_5724"></a>(define (assign-reg-name assign-instruction)
  (cadr assign-instruction))
<a name="%_idx_5726" id="%_idx_5726"></a>(define (assign-value-exp assign-instruction)
  (cddr assign-instruction))
</pre></p>
<p></p>
<p>The register name is looked up with <code>get-register</code> to produce thetarget register object.  The value expression is passed to <code>make-operation-exp</code> if the value is the result of an operation, and to<code>make-primitive-exp</code> otherwise.  These procedures (shown below)parse the value expression and produce an execution procedure for thevalue.  This is a procedure of no arguments, called <a name="%_idx_5728" id="%_idx_5728"></a><code>value-proc</code>,which will be evaluated during the simulation to produce the actualvalue to be assigned to the register.  Notice that the work of lookingup the register name and parsing the value expression is performedjust once, at assembly time, not every time the instruction issimulated.  This saving of work is the reason we use execution<a name="%_idx_5730" id="%_idx_5730"></a>procedures, and corresponds directly to the saving in work we obtainedby separating program analysis from execution in the evaluator ofsection <a href="book-Z-H-26.html#%_sec_4.1.7">4.1.7</a>.</p>
<p>The result returned by <code>make-assign</code> is the executionprocedure for the <code>assign</code> instruction.  When this procedure iscalled (by the machine model's <code>execute</code> procedure),it sets the contents of the target register to the resultobtained by executing <code>value-proc</code>.  Then it advancesthe <code>pc</code> to the next instruction by running the procedure</p>
<p></p>
<p><pre><a name="%_idx_5732" id="%_idx_5732"></a>(define (advance-pc pc)
  (set-contents! pc (cdr (get-contents pc))))
</pre></p>
<p></p>
<p><code>Advance-pc</code> is the normal termination for all instructions except<code>branch</code> and <code>goto</code>.</p>
<p><a name="%_sec_Temp_730" id="%_sec_Temp_730"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_730"><code>Test</code>, <code>branch</code>, and <code>goto</code> instructions</a></h4>
<p><a name="%_idx_5734" id="%_idx_5734"></a><code>Make-test</code> handles <code>test</code> instructions in a similar way.  Itextracts the expression that specifies the condition to be tested andgenerates an execution procedure for it.  At simulation time, theprocedure for the condition is called, the result is assigned to the<code>flag</code> register, and the <code>pc</code> is advanced:</p>
<p></p>
<p><pre><a name="%_idx_5736" id="%_idx_5736"></a>(define (make-test inst machine labels operations flag pc)
  (let ((condition (test-condition inst)))
    (if (operation-exp? condition)
        (let ((condition-proc
               (make-operation-exp
                condition machine labels operations)))
          (lambda ()
            (set-contents! flag (condition-proc))
            (advance-pc pc)))
        (error "Bad TEST instruction -- ASSEMBLE" inst))))
<a name="%_idx_5738" id="%_idx_5738"></a>(define (test-condition test-instruction)
  (cdr test-instruction))
</pre></p>
<p></p>
<p></p>
<p><a name="%_idx_5740" id="%_idx_5740"></a>The execution procedure for a <code>branch</code> instruction checks thecontents of the <code>flag</code> register and either sets the contents ofthe <code>pc</code> to the branch destination (if the branch is taken) orelse just advances the <code>pc</code> (if the branch is not taken).  Noticethat the indicated destination in a <code>branch</code> instruction must be alabel, and the <code>make-branch</code> procedure enforces this.  Noticealso that the label is looked up at assembly time, not each time the<code>branch</code> instruction is simulated.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_5742" id="%_idx_5742"></a>(define (make-branch inst machine labels flag pc)
  (let ((dest (branch-dest inst)))
    (if (label-exp? dest)
        (let ((insts
               (lookup-label labels (label-exp-label dest))))
          (lambda ()
            (if (get-contents flag)
                (set-contents! pc insts)
                (advance-pc pc))))
        (error "Bad BRANCH instruction -- ASSEMBLE" inst))))
<a name="%_idx_5744" id="%_idx_5744"></a>(define (branch-dest branch-instruction)
  (cadr branch-instruction))
</pre></p>
<p></p>
<p></p>
<p><a name="%_idx_5746" id="%_idx_5746"></a>A <code>goto</code> instruction is similar to a branch, except that thedestination may be specified either as a label or as a register, andthere is no condition to check – the <code>pc</code> is always set to thenew destination.</p>
<p></p>
<p><pre><a name="%_idx_5748" id="%_idx_5748"></a>(define (make-goto inst machine labels pc)
  (let ((dest (goto-dest inst)))
    (cond ((label-exp? dest)
           (let ((insts
                  (lookup-label labels
                                (label-exp-label dest))))
             (lambda () (set-contents! pc insts))))
          ((register-exp? dest)
           (let ((reg
                  (get-register machine
                                (register-exp-reg dest))))
             (lambda ()
               (set-contents! pc (get-contents reg)))))
          (else (error "Bad GOTO instruction -- ASSEMBLE"
                       inst)))))
<a name="%_idx_5750" id="%_idx_5750"></a>(define (goto-dest goto-instruction)
  (cadr goto-instruction))
</pre></p>
<p></p>
<p></p>
<p><a name="%_sec_Temp_731" id="%_sec_Temp_731"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_731">Other instructions</a></h4>
<p>The stack instructions <code>save</code> and <code>restore</code> simply use thestack with the designated register and advance the <code>pc</code>:</p>
<p></p>
<p><pre><a name="%_idx_5752" id="%_idx_5752"></a><a name="%_idx_5754" id="%_idx_5754"></a>(define (make-save inst machine stack pc)
  (let ((reg (get-register machine
                           (stack-inst-reg-name inst))))
    (lambda ()
      (push stack (get-contents reg))
      (advance-pc pc))))
<a name="%_idx_5756" id="%_idx_5756"></a><a name="%_idx_5758" id="%_idx_5758"></a>(define (make-restore inst machine stack pc)
  (let ((reg (get-register machine
                           (stack-inst-reg-name inst))))
    (lambda ()
      (set-contents! reg (pop stack))    
      (advance-pc pc))))
<a name="%_idx_5760" id="%_idx_5760"></a>(define (stack-inst-reg-name stack-instruction)
  (cadr stack-instruction))
</pre></p>
<p></p>
<p></p>
<p><a name="%_idx_5762" id="%_idx_5762"></a>The final instruction type, handled by <code>make-perform</code>, generatesan execution procedure for the action to be performed.  At simulationtime, the action procedure is executed and the <code>pc</code> advanced.</p>
<p></p>
<p><pre><a name="%_idx_5764" id="%_idx_5764"></a>(define (make-perform inst machine labels operations pc)
  (let ((action (perform-action inst)))
    (if (operation-exp? action)
        (let ((action-proc
               (make-operation-exp
                action machine labels operations)))
          (lambda ()
            (action-proc)
            (advance-pc pc)))
        (error "Bad PERFORM instruction -- ASSEMBLE" inst))))
<a name="%_idx_5766" id="%_idx_5766"></a>(define (perform-action inst) (cdr inst))
</pre></p>
<p></p>
<p></p>
<p><a name="%_sec_Temp_732" id="%_sec_Temp_732"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_732">Execution procedures for subexpressions</a></h4>
<p><a name="%_idx_5768" id="%_idx_5768"></a><a name="%_idx_5770" id="%_idx_5770"></a><a name="%_idx_5772" id="%_idx_5772"></a>The value of a <code>reg</code>, <code>label</code>, or <code>const</code> expressionmay be needed for assignment to a register (<code>make-assign</code>) or for input toan operation (<code>make-operation-exp</code>, below).  The following proceduregenerates execution procedures to produce values for these expressionsduring the simulation:</p>
<p></p>
<p><pre><a name="%_idx_5774" id="%_idx_5774"></a>(define (make-primitive-exp exp machine labels)
  (cond ((constant-exp? exp)
         (let ((c (constant-exp-value exp)))
           (lambda () c)))
        ((label-exp? exp)
         (let ((insts
                (lookup-label labels
                              (label-exp-label exp))))
           (lambda () insts)))
        ((register-exp? exp)
         (let ((r (get-register machine
                                (register-exp-reg exp))))
           (lambda () (get-contents r))))
        (else
         (error "Unknown expression type -- ASSEMBLE" exp))))
</pre></p>
<p></p>
<p>The syntax of <code>reg</code>, <code>label</code>, and <code>const</code> expressionsis determined by</p>
<p></p>
<p><pre><a name="%_idx_5776" id="%_idx_5776"></a>(define (register-exp? exp) (tagged-list? exp 'reg))
<a name="%_idx_5778" id="%_idx_5778"></a>(define (register-exp-reg exp) (cadr exp))
<a name="%_idx_5780" id="%_idx_5780"></a>(define (constant-exp? exp) (tagged-list? exp 'const))
<a name="%_idx_5782" id="%_idx_5782"></a>(define (constant-exp-value exp) (cadr exp))
<a name="%_idx_5784" id="%_idx_5784"></a>(define (label-exp? exp) (tagged-list? exp 'label))
<a name="%_idx_5786" id="%_idx_5786"></a>(define (label-exp-label exp) (cadr exp))
</pre></p>
<p></p>
<p></p>
<p><a name="%_idx_5788" id="%_idx_5788"></a><code>Assign</code>, <code>perform</code>, and <code>test</code> instructionsmay include the application of a machine operation (specified byan <code>op</code> expression) to some operands (specified by <code>reg</code>and <code>const</code> expressions).The following procedure produces an execution procedurefor an “operation expression” – a list containing the operation andoperand expressions from the instruction:</p>
<p></p>
<p><pre><a name="%_idx_5790" id="%_idx_5790"></a>(define (make-operation-exp exp machine labels operations)
  (let ((op (lookup-prim (operation-exp-op exp) operations))
        (aprocs
         (map (lambda (e)
                (make-primitive-exp e machine labels))
              (operation-exp-operands exp))))
    (lambda ()
      (apply op (map (lambda (p) (p)) aprocs)))))
</pre></p>
<p></p>
<p>The syntax of operation expressions is determined by</p>
<p></p>
<p><pre><a name="%_idx_5792" id="%_idx_5792"></a>(define (operation-exp? exp)
  (and (pair? exp) (tagged-list? (car exp) 'op)))
<a name="%_idx_5794" id="%_idx_5794"></a>(define (operation-exp-op operation-exp)
  (cadr (car operation-exp)))
<a name="%_idx_5796" id="%_idx_5796"></a>(define (operation-exp-operands operation-exp)
  (cdr operation-exp))
</pre></p>
<p></p>
<p>Observe that the treatment of operation expressions is very much likethe treatment of procedure applications by the <code>analyze-application</code> procedure in the evaluator ofsection <a href="book-Z-H-26.html#%_sec_4.1.7">4.1.7</a> in that we generate an executionprocedure for each operand.  At simulation time, we call theoperand procedures and apply the Scheme procedure that simulatesthe operation to the resulting values.The simulation procedure is found by looking up the operation name inthe operation table for the machine:</p>
<p></p>
<p><pre><a name="%_idx_5798" id="%_idx_5798"></a>(define (lookup-prim symbol operations)
  (let ((val (assoc symbol operations)))
    (if val
        (cadr val)
        (error "Unknown operation -- ASSEMBLE" symbol))))
</pre></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_5.9" id="%_thm_5.9"></a><b>Exercise 5.9.</b>  The treatment of machine operations above permits them to operateon labels as well as on constants and the contents of registers.Modify the expression-processing procedures to enforce the conditionthat operations can be used only with registers and constants.</p>
<p></p>
<p></p>
<p><a name="%_thm_5.10" id="%_thm_5.10"></a><b>Exercise 5.10.</b>  Design a new syntax for register-machine instructions and modify thesimulator to use your new syntax.  Can you implement your newsyntax without changing any part of the simulator except thesyntax procedures in this section?</p>
<p></p>
<p></p>
<p><a name="%_thm_5.11" id="%_thm_5.11"></a><b>Exercise 5.11.</b>  <a name="%_idx_5800" id="%_idx_5800"></a><a name="%_idx_5802" id="%_idx_5802"></a>When we introduced <code>save</code> and <code>restore</code> insection <a href="book-Z-H-31.html#%_sec_5.1.4">5.1.4</a>, we didn't specify what would happenif you tried to restore a register that was not the last one saved, asin the sequence</p>
<p></p>
<p></p>
<p><pre>(save y)
(save x)
(restore y)
</pre></p>
<p></p>
<p>There are several reasonable possibilities for the meaning of <code>restore</code>:</p>
<p>a.  <code>(restore y)</code> puts into <code>y</code> the last value saved on thestack, regardless of what register that value came from.  This is theway our simulator behaves.  Show how to take advantage of thisbehavior to eliminate one instruction from the Fibonacci machine ofsection <a href="book-Z-H-31.html#%_sec_5.1.4">5.1.4</a> (figure <a href="book-Z-H-31.html#%_fig_5.12">5.12</a>).</p>
<p>b.  <code>(restore y)</code> puts into <code>y</code> the last value saved on thestack, but only if that value was saved from <code>y</code>; otherwise, itsignals an error.  Modify the simulator to behave this way.  You willhave to change <code>save</code> to put the register name on the stack alongwith the value.</p>
<p>c.  <code>(restore y)</code> puts into <code>y</code> the last value saved from <code>y</code> regardless of what other registers were saved after <code>y</code> and notrestored.  Modify the simulator to behave this way.  You will have toassociate a separate stack with each register.  You should make the<code>initialize-stack</code> operation initialize all the register stacks.</p>
<p></p>
<p></p>
<p><a name="%_thm_5.12" id="%_thm_5.12"></a><b>Exercise 5.12.</b>  The simulator can be used to help determine the data paths requiredfor implementing a machine with a given controller.  Extendthe assembler to store the following information in the machine model:</p>
<p></p>
<ul>
<li>a list of all instructions, with duplicates removed, sorted byinstruction type (<code>assign</code>, <code>goto</code>, and so on);<p></p>
</li>
<li>a list (without duplicates) of the registers used to hold entrypoints (these are the registers referenced by <code>goto</code>instructions);<p></p>
</li>
<li>a list (without duplicates) of the registers that are <code>save</code>dor <code>restore</code>d;<p></p>
</li>
<li>for each register, a list (without duplicates) of the sources fromwhich it is assigned (for example, the sources for register <code>val</code>in the factorial machine of figure <a href="book-Z-H-31.html#%_fig_5.11">5.11</a> are<code>(const 1)</code> and <code>((op *) (reg n) (reg val))</code>).</li>
</ul>
<p>Extend themessage-passing interface to the machine to provide access to this newinformation.  To test your analyzer, define the Fibonacci machine fromfigure <a href="book-Z-H-31.html#%_fig_5.12">5.12</a> and examine the lists you constructed.</p>
<p></p>
<p></p>
<p><a name="%_thm_5.13" id="%_thm_5.13"></a><b>Exercise 5.13.</b>  Modify the simulator so that it uses the controller sequence todetermine what registers the machine has rather than requiring a listof registers as an argument to <code>make-machine</code>.  Instead ofpre-allocating the registers in <code>make-machine</code>, you can allocatethem one at a time when they are first seen during assembly of theinstructions.</p>
<p><a name="%_sec_5.2.4" id="%_sec_5.2.4"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_5.2.4">5.2.4  Monitoring Machine Performance</a></h3>
<p><a name="%_idx_5804" id="%_idx_5804"></a><a name="%_idx_5806" id="%_idx_5806"></a>Simulation is useful not only for verifying the correctness of aproposed machine design but also for measuring the machine'sperformance.  For example, we can install in our simulation program a“meter” that measures the number of stack operations used in acomputation.  To do this, we modify our simulated stack to keep trackof the number of times registers are saved on the stack and themaximum depth reached by the stack, and add a message to the stack'sinterface that prints the statistics, as shown below.We also add an operation to the basic machine model to print thestack statistics, by initializing <code>the-ops</code> in <code>make-new-machine</code> to</p>
<p></p>
<p><pre><a name="%_idx_5808" id="%_idx_5808"></a><a name="%_idx_5810" id="%_idx_5810"></a>(list (list 'initialize-stack
            (lambda () (stack 'initialize)))
      (list 'print-stack-statistics
            (lambda () (stack 'print-statistics))))
</pre></p>
<p></p>
<p>Here is the new version of <code>make-stack</code>:</p>
<p></p>
<p><pre><a name="%_idx_5812" id="%_idx_5812"></a>(define (make-stack)
  (let ((s '())
        (number-pushes 0)
        (max-depth 0)
        (current-depth 0))
    (define (push x)
      (set! s (cons x s))
      (set! number-pushes (+ 1 number-pushes))
      (set! current-depth (+ 1 current-depth))
      (set! max-depth (max current-depth max-depth)))
    (define (pop)
      (if (null? s)
          (error "Empty stack -- POP")
          (let ((top (car s)))
            (set! s (cdr s))
            (set! current-depth (- current-depth 1))
            top)))    
    (define (initialize)
      (set! s '())
      (set! number-pushes 0)
      (set! max-depth 0)
      (set! current-depth 0)
      'done)
    (define (print-statistics)
      (newline)
      (display (list 'total-pushes  '= number-pushes
                     'maximum-depth '= max-depth)))
    (define (dispatch message)
      (cond ((eq? message 'push) push)
            ((eq? message 'pop) (pop))
            ((eq? message 'initialize) (initialize))
            ((eq? message 'print-statistics)
             (print-statistics))
            (else
             (error "Unknown request -- STACK" message))))
    dispatch))
</pre></p>
<p></p>
<p></p>
<p>Exercises <a href="#%_thm_5.15">5.15</a> through <a href="#%_thm_5.19">5.19</a>describe other useful monitoring and debugging features that can beadded to the register-machine simulator.</p>
<p></p>
<p></p>
<p><a name="%_thm_5.14" id="%_thm_5.14"></a><b>Exercise 5.14.</b>  <a name="%_idx_5814" id="%_idx_5814"></a>Measure the number of pushes and the maximum stack depth required tocompute <em>n</em>! for various small values of <em>n</em> using the factorialmachine shown in figure <a href="book-Z-H-31.html#%_fig_5.11">5.11</a>.  From your datadetermine formulas in terms of <em>n</em> for the total number of pushoperations and the maximum stack depth used in computing <em>n</em>! for any<em>n</em> &gt; 1. Note that each of these is a linear function of <em>n</em> and isthus determined by two constants.  In order to get the statisticsprinted, you will have to augment the factorial machine with instructions toinitialize the stack and print the statistics.You may want to also modify themachine so that it repeatedly reads a value for <em>n</em>, computes thefactorial, and prints the result (as we did for the GCD machine infigure <a href="book-Z-H-31.html#%_fig_5.4">5.4</a>), so that you will not have to repeatedlyinvoke <code>get-register-contents</code>, <code>set-register-contents!</code>, and<code>start</code>.</p>
<p></p>
<p></p>
<p><a name="%_thm_5.15" id="%_thm_5.15"></a><b>Exercise 5.15.</b>  Add <a name="%_idx_5816" id="%_idx_5816"></a><em>instruction counting</em> to the register machine simulation.That is, have the machine model keep track of the number ofinstructions executed.  Extend the machine model's interface to accepta new message that prints the value of the instruction count andresets the count to zero.</p>
<p></p>
<p></p>
<p><a name="%_thm_5.16" id="%_thm_5.16"></a><b>Exercise 5.16.</b>  Augment the simulator to provide for <a name="%_idx_5818" id="%_idx_5818"></a><a name="%_idx_5820" id="%_idx_5820"></a><em>instruction tracing</em>.That is, before each instruction is executed, the simulator should printthe text of the instruction.  Make the machine model accept <code>trace-on</code> and<code>trace-off</code> messages to turn tracing on and off.</p>
<p></p>
<p></p>
<p><a name="%_thm_5.17" id="%_thm_5.17"></a><b>Exercise 5.17.</b>  Extend the instruction tracing ofexercise <a href="#%_thm_5.16">5.16</a> so that beforeprinting an instruction, the simulator prints any labels thatimmediately precede that instruction in the controller sequence.  Becareful to do this in a way that does not interfere with instructioncounting (exercise <a href="#%_thm_5.15">5.15</a>).You will have to make the simulator retain the necessary label information.</p>
<p></p>
<p></p>
<p><a name="%_thm_5.18" id="%_thm_5.18"></a><b>Exercise 5.18.</b>  <a name="%_idx_5822" id="%_idx_5822"></a><a name="%_idx_5824" id="%_idx_5824"></a>Modify the <code>make-register</code> procedure ofsection <a href="#%_sec_5.2.1">5.2.1</a> so that registers can be traced.Registers should accept messages that turn tracing on and off.  When aregister is traced, assigning a value to the register should print thename of the register, the old contents of the register, and the newcontents being assigned.  Extend the interface to the machine modelto permit you to turn tracing on and off for designated machine registers.</p>
<p></p>
<p></p>
<p><a name="%_thm_5.19" id="%_thm_5.19"></a><b>Exercise 5.19.</b>  Alyssa P. Hacker wants a <a name="%_idx_5826" id="%_idx_5826"></a><em>breakpoint</em> feature in the simulator tohelp her debug her machine designs.  You have been hired to installthis feature for her.  She wants to be able to specify a place in thecontroller sequence where the simulator will stop and allow her toexamine the state of the machine.  You are to implement a procedure</p>
<p></p>
<p></p>
<p></p>
<p><pre>(set-breakpoint &lt;<em>machine</em>&gt; &lt;<em>label</em>&gt; &lt;<em>n</em>&gt;)
</pre></p>
<p></p>
<p>that sets a breakpoint just before the <em>n</em>th instruction after thegiven label.  For example,</p>
<p></p>
<p></p>
<p><pre>(set-breakpoint gcd-machine 'test-b 4)
</pre></p>
<p></p>
<p>installs a breakpoint in <code>gcd-machine</code> just before theassignment to register <code>a</code>.  When the simulator reaches thebreakpoint it should print the label and the offset of the breakpointand stop executing instructions.  Alyssa can then use <code>get-register-contents</code> and <code>set-register-contents!</code> to manipulatethe state of the simulated machine.  She should then be able tocontinue execution by saying</p>
<p></p>
<p></p>
<p><pre>(proceed-machine &lt;<em>machine</em>&gt;)
</pre></p>
<p></p>
<p>She should also be able to remove a specific breakpoint by means of</p>
<p></p>
<p></p>
<p><pre>(cancel-breakpoint &lt;<em>machine</em>&gt; &lt;<em>label</em>&gt; &lt;<em>n</em>&gt;)
</pre></p>
<p></p>
<p>or to remove all breakpoints by means of</p>
<p></p>
<p></p>
<p><pre>(cancel-all-breakpoints &lt;<em>machine</em>&gt;)
</pre></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<div class="smallprint"><hr></div>
<p></p>
<div class="footnote">
<p><a name="footnote_Temp_727" href="#call_footnote_Temp_727" id="footnote_Temp_727"><sup><small>4</small></sup></a> <a name="%_idx_5690" id="%_idx_5690"></a>Using the <code>receive</code> procedure here is a way to get <code>extract-labels</code> to effectively return two values – <code>labels</code> and<code>insts</code> – without explicitly making a compound data structure tohold them.  An alternative implementation, which returns an explicitpair of values, is</p>
<p></p>
<p><pre><a name="%_idx_5692" id="%_idx_5692"></a>(define (extract-labels text)
  (if (null? text)
      (cons '() '())
      (let ((result (extract-labels (cdr text))))
        (let ((insts (car result)) (labels (cdr result)))
          (let ((next-inst (car text)))
            (if (symbol? next-inst)
                (cons insts
                      (cons (make-label-entry next-inst insts) labels))
                (cons (cons (make-instruction next-inst) insts)
                      labels)))))))
</pre></p>
<p></p>
<p>which would be called by <code>assemble</code> as follows:</p>
<p></p>
<p><pre><a name="%_idx_5694" id="%_idx_5694"></a>(define (assemble controller-text machine)
  (let ((result (extract-labels controller-text)))
    (let ((insts (car result)) (labels (cdr result)))
      (update-insts! insts labels machine)
      insts)))
</pre></p>
<p></p>
<p><a name="%_idx_5696" id="%_idx_5696"></a><a name="%_idx_5698" id="%_idx_5698"></a><a name="%_idx_5700" id="%_idx_5700"></a>You can consider our use of <code>receive</code> as demonstrating an elegantway to return multiple values, or simply an excuse to show off aprogramming trick.  An argument like <code>receive</code> that is the nextprocedure to be invoked is called a “continuation.”  Recall that wealso used continuations to implement the backtracking controlstructure in the <code>amb</code> evaluator in section <a href="book-Z-H-28.html#%_sec_4.3.3">4.3.3</a>.</p>
</div></body>
</html>
