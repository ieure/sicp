<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<?xml version="1.0" encoding="utf-8"?><html xmlns="http://www.w3.org/1999/xhtml" xmlns:ops="http://www.idpf.org/2007/ops">
<!-- Generated from TeX source by tex2page, v 4o,
     (c) Dorai Sitaram, http://www.cs.rice.edu/~dorai/tex2page --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Type: text/html; charset=utf-8">
<title>Structure and Interpretation of Computer Programs</title>
<link rel="stylesheet" type="text/css" href="book-Z-C.css" title="default">
</head>
<body><a name="%_sec_2.5" id="%_sec_2.5"></a><h2><a href="book-Z-H-4.html#%_toc_%_sec_2.5">2.5  Systems with Generic Operations</a></h2>
<p></p>
<p><a name="%_idx_2496" id="%_idx_2496"></a>In the previous section, we saw how to design systems in which dataobjects can be represented in more than one way.  The key idea is tolink the code that specifies the data operations to the severalrepresentations by means of generic interface procedures.  Now we willsee how to use this same idea not only to define operations that aregeneric over different representations but also to define operationsthat are generic over different kinds of arguments.  We have alreadyseen several different packages of arithmetic operations: the primitivearithmetic (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>) built into ourlanguage, the rational-number arithmetic (<code>add-rat</code>, <code>sub-rat</code>, <code>mul-rat</code>, <code>div-rat</code>) ofsection <a href="book-Z-H-14.html#%_sec_2.1.1">2.1.1</a>, and the complex-number arithmetic that weimplemented in section <a href="book-Z-H-17.html#%_sec_2.4.3">2.4.3</a>.  We will now usedata-directed techniques to construct a package of arithmeticoperations that incorporates all the arithmetic packages we have alreadyconstructed.</p>
<p>Figure <a href="#%_fig_2.23">2.23</a> shows the structure of the system weshall build.  Notice the <a name="%_idx_2498" id="%_idx_2498"></a>abstraction barriers.  From the perspectiveof someone using “numbers,” there is a single procedure <code>add</code>that operates on whatever numbers are supplied.  <code>Add</code> is part ofa generic interface that allows the separate ordinary-arithmetic,rational-arithmetic, and complex-arithmetic packages to be accesseduniformly by programs that use numbers.  Any individual arithmeticpackage (such as the complex package) may itself be accessed throughgeneric procedures (such as <code>add-complex</code>) that combine packagesdesigned for different representations (such as rectangular andpolar).  Moreover, the structure of the system is additive, sothat one can design the individual arithmetic packages separately andcombine them to produce a generic arithmetic system.<a name="%_fig_2.23" id="%_fig_2.23"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch2-Z-G-64.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 2.23:</b>  Generic arithmetic system.</div></caption>
<tr><td><a name="%_idx_2500" id="%_idx_2500"></a></td></tr>
</table></div>
<p></p>
<p><a name="%_sec_2.5.1" id="%_sec_2.5.1"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_2.5.1">2.5.1  Generic Arithmetic Operations</a></h3>
<p><a name="%_idx_2502" id="%_idx_2502"></a>The task of designing generic arithmetic operations is analogous tothat of designing the generic complex-number operations.  We wouldlike, for instance, to have a generic addition procedure <code>add</code> thatacts like ordinary primitive addition <code>+</code> on ordinary numbers,like <code>add-rat</code> on rational numbers, and like <code>add-complex</code> oncomplex numbers.  We can implement <code>add</code>, and the other genericarithmetic operations, by following the same strategy we used insection <a href="book-Z-H-17.html#%_sec_2.4.3">2.4.3</a> to implement the generic selectors forcomplex numbers.  We will attach a type tag to each kind ofnumber and cause the generic procedure to dispatch to an appropriatepackage according to the data type of its arguments.</p>
<p>The generic arithmetic procedures are defined as follows:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_2504" id="%_idx_2504"></a>(define (add x y) (apply-generic 'add x y))
<a name="%_idx_2506" id="%_idx_2506"></a>(define (sub x y) (apply-generic 'sub x y))
<a name="%_idx_2508" id="%_idx_2508"></a>(define (mul x y) (apply-generic 'mul x y))
<a name="%_idx_2510" id="%_idx_2510"></a>(define (div x y) (apply-generic 'div x y))
</pre></p>
<p></p>
<p></p>
<p><a name="%_idx_2512" id="%_idx_2512"></a><a name="%_idx_2514" id="%_idx_2514"></a>We begin by installing a package for handling <em>ordinary</em> numbers,that is, the primitive numbers of our language.  We will tag thesewith the symbol <code>scheme-number</code>.  The arithmetic operations in thispackage are the primitive arithmetic procedures (so there is no need todefine extra procedures to handle the untagged numbers).  Sincethese operations each take two arguments, they are installed in thetable keyed by the list <code>(scheme-number scheme-number)</code>:<a name="%_idx_2516" id="%_idx_2516"></a><a name="%_idx_2518" id="%_idx_2518"></a></p>
<p></p>
<p><pre><a name="%_idx_2520" id="%_idx_2520"></a>(define (install-scheme-number-package)
  (define (tag x)
    (attach-tag 'scheme-number x))    
  (put 'add '(scheme-number scheme-number)
       (lambda (x y) (tag (+ x y))))
  (put 'sub '(scheme-number scheme-number)
       (lambda (x y) (tag (- x y))))
  (put 'mul '(scheme-number scheme-number)
       (lambda (x y) (tag (* x y))))
  (put 'div '(scheme-number scheme-number)
       (lambda (x y) (tag (/ x y))))
  (put 'make 'scheme-number
       (lambda (x) (tag x)))
  'done)
</pre></p>
<p></p>
<p></p>
<p>Users of the Scheme-number packagewill create (tagged) ordinary numbers by means of the procedure:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_2522" id="%_idx_2522"></a>(define (make-scheme-number n)
  ((get 'make 'scheme-number) n))
</pre></p>
<p></p>
<p></p>
<p>Now that the framework of the generic arithmetic system is in place,we can readily include new kinds of numbers.  Here is a package thatperforms rational arithmetic.  Notice that, as a benefit ofadditivity, we can use without modification the rational-number codefrom section <a href="book-Z-H-14.html#%_sec_2.1.1">2.1.1</a> as the internal procedures in thepackage:<a name="%_idx_2524" id="%_idx_2524"></a><a name="%_idx_2526" id="%_idx_2526"></a><a name="%_idx_2528" id="%_idx_2528"></a></p>
<p></p>
<p><pre><a name="%_idx_2530" id="%_idx_2530"></a>(define (install-rational-package)
  <em>;; internal procedures</em>
  (define (numer x) (car x))
  (define (denom x) (cdr x))
  (define (make-rat n d)
    (let ((g (gcd n d)))
      (cons (/ n g) (/ d g))))
  (define (add-rat x y)
    (make-rat (+ (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (- (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (* (numer x) (numer y))
              (* (denom x) (denom y))))
  (define (div-rat x y)
    (make-rat (* (numer x) (denom y))
              (* (denom x) (numer y))))
  <em>;; interface to rest of the system</em>
  (define (tag x) (attach-tag 'rational x))
  (put 'add '(rational rational)
       (lambda (x y) (tag (add-rat x y))))
  (put 'sub '(rational rational)
       (lambda (x y) (tag (sub-rat x y))))
  (put 'mul '(rational rational)
       (lambda (x y) (tag (mul-rat x y))))
  (put 'div '(rational rational)
       (lambda (x y) (tag (div-rat x y))))

  (put 'make 'rational
       (lambda (n d) (tag (make-rat n d))))
  'done)
<a name="%_idx_2532" id="%_idx_2532"></a>(define (make-rational n d)
  ((get 'make 'rational) n d))
</pre></p>
<p></p>
<p></p>
<p>We can install a similar package to handle complex numbers, using thetag <code>complex</code>.  In creating the package, we extract from the tablethe operations <code>make-from-real-imag</code> and <code>make-from-mag-ang</code>that were defined by the rectangular and polar packages.  <a name="%_idx_2534" id="%_idx_2534"></a>Additivitypermits us to use, as the internal operations, the same <code>add-complex</code>, <code>sub-complex</code>, <code>mul-complex</code>, and <code>div-complex</code> procedures fromsection <a href="book-Z-H-17.html#%_sec_2.4.1">2.4.1</a>.<a name="%_idx_2536" id="%_idx_2536"></a><a name="%_idx_2538" id="%_idx_2538"></a><a name="%_idx_2540" id="%_idx_2540"></a></p>
<p></p>
<p><pre><a name="%_idx_2542" id="%_idx_2542"></a>(define (install-complex-package)
  <em>;; imported procedures from rectangular and polar packages</em>
  (define (make-from-real-imag x y)
    ((get 'make-from-real-imag 'rectangular) x y))
  (define (make-from-mag-ang r a)
    ((get 'make-from-mag-ang 'polar) r a))
  <em>;; internal procedures</em>
  (define (add-complex z1 z2)
    (make-from-real-imag (+ (real-part z1) (real-part z2))
                         (+ (imag-part z1) (imag-part z2))))
  (define (sub-complex z1 z2)
    (make-from-real-imag (- (real-part z1) (real-part z2))
                         (- (imag-part z1) (imag-part z2))))
  (define (mul-complex z1 z2)
    (make-from-mag-ang (* (magnitude z1) (magnitude z2))
                       (+ (angle z1) (angle z2))))
  (define (div-complex z1 z2)
    (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
                       (- (angle z1) (angle z2))))
  <em>;; interface to rest of the system</em>
  (define (tag z) (attach-tag 'complex z))
  (put 'add '(complex complex)
       (lambda (z1 z2) (tag (add-complex z1 z2))))
  (put 'sub '(complex complex)
       (lambda (z1 z2) (tag (sub-complex z1 z2))))
  (put 'mul '(complex complex)
       (lambda (z1 z2) (tag (mul-complex z1 z2))))
  (put 'div '(complex complex)
       (lambda (z1 z2) (tag (div-complex z1 z2))))
  (put 'make-from-real-imag 'complex
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'complex
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)
</pre></p>
<p></p>
<p></p>
<p>Programs outside the complex-number package can construct complexnumbers either from real and imaginary parts or from magnitudes andangles.  Notice how the underlying procedures, originally defined inthe rectangular and polar packages, are exported to the complexpackage, and exported from there to the outside world.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_2544" id="%_idx_2544"></a>(define (make-complex-from-real-imag x y)
  ((get 'make-from-real-imag 'complex) x y))
<a name="%_idx_2546" id="%_idx_2546"></a>(define (make-complex-from-mag-ang r a)
  ((get 'make-from-mag-ang 'complex) r a))
</pre></p>
<p></p>
<p></p>
<p><a name="%_idx_2548" id="%_idx_2548"></a>What we have here is a two-level tag system.  A typical complex number,such as 3 + 4<em>i</em> in rectangular form, would berepresented as shown in figure <a href="#%_fig_2.24">2.24</a>.The outer tag (<code>complex</code>) is used to direct the number to thecomplex package.  Once within the complex package, the next tag (<code>rectangular</code>) is used to direct the number to the rectangular package.In a large and complicated system there might be many levels, eachinterfaced with the next by means of generic operations.  As a dataobject is passed “downward,” the outer tag that is used to directit to the appropriate package is stripped off (by applying <code>contents</code>) and the next level of tag (if any) becomes visible to be used forfurther dispatching.</p>
<p><a name="%_fig_2.24" id="%_fig_2.24"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch2-Z-G-65.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 2.24:</b>  Representation of 3 + 4<em>i</em> in rectangular form.</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p>In the above packages, we used <code>add-rat</code>, <code>add-complex</code>, andthe other arithmetic procedures exactly as originally written.Once these definitions are internal to different installation procedures,however, they no longer need names that are distinct from each other:we could simply name them <code>add</code>, <code>sub</code>, <code>mul</code>, and <code>div</code>in both packages.</p>
<p></p>
<p><a name="%_thm_2.77" id="%_thm_2.77"></a><b>Exercise 2.77.</b>  Louis Reasoner tries to evaluate theexpression <code>(magnitude z)</code> where <code>z</code> is the objectshown in figure <a href="#%_fig_2.24">2.24</a>.  To hissurprise, instead of the answer 5he gets an error message from <code>apply-generic</code>,saying there is no method for the operation <code>magnitude</code>on the types <code>(complex)</code>.He shows this interaction to Alyssa P. Hacker, who says“The problem is that the complex-number selectors were neverdefined for <code>complex</code> numbers, just for <code>polar</code> and <code>rectangular</code>numbers.  All you have to do to make this work is add the followingto the <code>complex</code> package:”</p>
<p></p>
<p></p>
<p><pre>(put 'real-part '(complex) real-part)
(put 'imag-part '(complex) imag-part)
(put 'magnitude '(complex) magnitude)
(put 'angle '(complex) angle)
</pre></p>
<p></p>
<p>Describe in detail why this works.  As an example, trace through allthe procedures called in evaluating the expression <code>(magnitude z)</code>where <code>z</code> is the object shown infigure <a href="#%_fig_2.24">2.24</a>.  In particular, how manytimes is <code>apply-generic</code> invoked?  What procedure is dispatched toin each case?</p>
<p></p>
<p></p>
<p><a name="%_thm_2.78" id="%_thm_2.78"></a><b>Exercise 2.78.</b>  <a name="%_idx_2550" id="%_idx_2550"></a><a name="%_idx_2552" id="%_idx_2552"></a><a name="%_idx_2554" id="%_idx_2554"></a><a name="%_idx_2556" id="%_idx_2556"></a><a name="%_idx_2558" id="%_idx_2558"></a><a name="%_idx_2560" id="%_idx_2560"></a><a name="%_idx_2562" id="%_idx_2562"></a>The internal procedures in the <code>scheme-number</code> package are essentiallynothing more than calls to the primitive procedures <code>+</code>, <code>-</code>,etc.  It was not possible to use the primitives of the languagedirectly because our type-tag system requires that each dataobject have a type attached to it.  In fact, however, all Lispimplementations do have a type system, which they use internally.Primitive predicates such as <code>symbol?</code> and <code>number?</code>determine whether data objects have particular types.  Modify thedefinitions of <code>type-tag</code>, <code>contents</code>, and <code>attach-tag</code>from section <a href="book-Z-H-17.html#%_sec_2.4.2">2.4.2</a> so that our generic system takesadvantage of Scheme's internal type system.  That is to say, the systemshould work as before except that ordinary numbers should berepresented simply as Scheme numbers rather than as pairs whose <code>car</code> isthe symbol <code>scheme-number</code>.</p>
<p></p>
<p></p>
<p><a name="%_thm_2.79" id="%_thm_2.79"></a><b>Exercise 2.79.</b>  <a name="%_idx_2564" id="%_idx_2564"></a><a name="%_idx_2566" id="%_idx_2566"></a>Define a generic equality predicate <code>equ?</code> that tests the equalityof two numbers, and install it in the generic arithmeticpackage.  This operation should work for ordinary numbers, rational numbers, andcomplex numbers.</p>
<p></p>
<p></p>
<p><a name="%_thm_2.80" id="%_thm_2.80"></a><b>Exercise 2.80.</b>  <a name="%_idx_2568" id="%_idx_2568"></a><a name="%_idx_2570" id="%_idx_2570"></a>Define a genericpredicate <code>=zero?</code> that tests if its argument is zero,and install it in the generic arithmetic package.  Thisoperation should work for ordinary numbers, rational numbers, andcomplex numbers.</p>
<p><a name="%_sec_2.5.2" id="%_sec_2.5.2"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_2.5.2">2.5.2  Combining Data of Different Types</a></h3>
<p></p>
<p>We have seen how to define a unified arithmetic system thatencompasses ordinary numbers, complex numbers, rational numbers, andany other type of number we might decide to invent, but we haveignored an important issue.  The operations we have defined so fartreat the different data types as being completely independent.  Thus,there are separate packages for adding, say, two ordinary numbers, ortwo complex numbers.  What we have not yet considered is the fact thatit is meaningful to define operations that cross the type boundaries,such as the addition of a complex number to an ordinary number.  Wehave gone to great pains to introduce barriers between parts of ourprograms so that they can be developed and understood separately.  Wewould like to introduce the cross-type operations in some carefullycontrolled way, so that we can support themwithout seriously violating our module boundaries.</p>
<p><a name="%_idx_2572" id="%_idx_2572"></a><a name="%_idx_2574" id="%_idx_2574"></a><a name="%_idx_2576" id="%_idx_2576"></a>One way to handle cross-type operations is to design a differentprocedure for each possible combination of types for which theoperation is valid.  For example, we could extend the complex-numberpackage so that it provides a procedure for adding complex numbers toordinary numbers and installs this in the table using the tag <code>(complex scheme-number)</code>:<a name="call_footnote_Temp_283" href="#footnote_Temp_283" id="call_footnote_Temp_283"><sup><small>49</small></sup></a></p>
<p></p>
<p><pre><em>;; to be included in the complex package</em>
<a name="%_idx_2578" id="%_idx_2578"></a>(define (add-complex-to-schemenum z x)
  (make-from-real-imag (+ (real-part z) x)
                       (imag-part z)))
(put 'add '(complex scheme-number)
     (lambda (z x) (tag (add-complex-to-schemenum z x))))
</pre></p>
<p></p>
<p></p>
<p>This technique works, but it is cumbersome.  With such a system, thecost of introducing a new type is not just the construction of thepackage of procedures for that type but also the construction andinstallation of the procedures that implement the cross-typeoperations.  This can easily be much more code than is needed todefine the operations on the type itself.  The method also underminesour ability to combine separate packages additively, orleast to limit the extent to which the implementors of the individualpackages need to take account of other packages.  For instance, in theexample above, it seems reasonable that handling mixed operations oncomplex numbers and ordinary numbers should be the responsibility ofthe complex-number package.  Combining rational numbers and complexnumbers, however, might be done by the complex package, by therational package, or by some third package that uses operationsextracted from these two packages.  Formulating coherent policies on thedivision of responsibility among packages can be an overwhelming taskin designing systems with many packages and many cross-typeoperations.</p>
<p><a name="%_sec_Temp_284" id="%_sec_Temp_284"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_284">Coercion</a></h4>
<p><a name="%_idx_2580" id="%_idx_2580"></a>In the general situation of completely unrelated operations acting oncompletely unrelated types, implementing explicit cross-typeoperations, cumbersome though it may be, is the best that one can hopefor.  Fortunately, we can usually do better by taking advantage ofadditional structure that may be latent in our type system.  Often thedifferent data types are not completely independent, and there may beways by which objects of one type may be viewed as being of anothertype.  This process is called <em>coercion</em>.  For example, if we areasked to arithmetically combine an ordinary number with a complexnumber, we can view the ordinary number as a complex number whoseimaginary part is zero.  This transforms the problem to that ofcombining two complex numbers, which can be handled in the ordinaryway by the complex-arithmetic package.</p>
<p><a name="%_idx_2582" id="%_idx_2582"></a>In general, we can implement this idea by designing coercionprocedures that transform an object of one type into an equivalentobject of another type.  Here is a typical coercion procedure, whichtransforms a given ordinary number to a complex number with that realpart and zero imaginary part:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_2584" id="%_idx_2584"></a>(define (scheme-number-&gt;complex n)
  (make-complex-from-real-imag (contents n) 0))
</pre></p>
<p></p>
<p><a name="%_idx_2586" id="%_idx_2586"></a><a name="%_idx_2588" id="%_idx_2588"></a>We install these coercion procedures in a special coercion table,indexed under the names of the two types:</p>
<p></p>
<p></p>
<p><pre>(put-coercion 'scheme-number 'complex scheme-number-&gt;complex)
</pre></p>
<p></p>
<p>(We assume that there are <code>put-coercion</code> and <code>get-coercion</code>procedures available for manipulating this table.)  Generally some ofthe slots in the table will be empty, because it is not generallypossible to coerce an arbitrary data object of each type into allother types.  For example, there is no way to coerce an arbitrarycomplex number to an ordinary number, so there will be no general <code>complex-&gt;scheme-number</code> procedure included in the table.</p>
<p>Once the coercion table has been set up, we can handle coercion in auniform manner by modifying the <code>apply-generic</code> procedure ofsection <a href="book-Z-H-17.html#%_sec_2.4.3">2.4.3</a>.  When asked to apply an operation, wefirst check whether the operation is defined for the arguments' types,just as before.  If so, we dispatch to the procedure found in theoperation-and-type table.Otherwise, we try coercion.  For simplicity, we consider only the casewhere there are two arguments.<a name="call_footnote_Temp_285" href="#footnote_Temp_285" id="call_footnote_Temp_285"><sup><small>50</small></sup></a>  Wecheck the coercion table to see if objects of the first type canbe coerced to the second type.  If so, we coerce the first argument and try theoperation again.  If objects of the first type cannot in general be coerced tothe second type, we try the coercion the other way around to see if there is away to coerce the second argument to the type of the first argument.Finally, if thereis no known way to coerce either type to the other type, we give up.Here is the procedure:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_2590" id="%_idx_2590"></a>(define (apply-generic op . args)
  (let ((type-tags (map type-tag args)))
    (let ((proc (get op type-tags)))
      (if proc
          (apply proc (map contents args))
          (if (= (length args) 2)
              (let ((type1 (car type-tags))
                    (type2 (cadr type-tags))
                    (a1 (car args))
                    (a2 (cadr args)))
                (let ((t1-&gt;t2 (get-coercion type1 type2))
                      (t2-&gt;t1 (get-coercion type2 type1)))
                  (cond (t1-&gt;t2
                         (apply-generic op (t1-&gt;t2 a1) a2))
                        (t2-&gt;t1
                         (apply-generic op a1 (t2-&gt;t1 a2)))
                        (else
                         (error "No method for these types"
                                (list op type-tags))))))
              (error "No method for these types"
                     (list op type-tags)))))))
</pre></p>
<p></p>
<p></p>
<p>This coercion scheme has many advantages over the method of definingexplicit cross-type operations, as outlined above.  Although we stillneed to write coercion procedures to relate the types (possibly <em>n</em><sup>2</sup>procedures for a system with <em>n</em> types), we need to write only oneprocedure for each pair of types rather than a different procedure foreach collection of types and each generic operation.<a name="call_footnote_Temp_286" href="#footnote_Temp_286" id="call_footnote_Temp_286"><sup><small>51</small></sup></a>  What we are counting on here is the fact that theappropriate transformation between types depends only on the typesthemselves, not on the operation to be applied.</p>
<p>On the other hand, there may be applications for which our coercionscheme is not general enough.  Even when neither of the objects to becombined can be converted to the type of the other it may still bepossible to perform the operation by converting both objects to athird type.  In order to deal with such complexity and still preservemodularity in our programs, it is usually necessary to build systemsthat take advantage of still further structure in the relations amongtypes, as we discuss next.</p>
<p><a name="%_sec_Temp_287" id="%_sec_Temp_287"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_287">Hierarchies of types</a></h4>
<p><a name="%_idx_2592" id="%_idx_2592"></a><a name="%_idx_2594" id="%_idx_2594"></a>The coercion scheme presented above relied on the existence of naturalrelations between pairs of types.  Often there is more “global”structure in how the different types relate to each other.  Forinstance, suppose we are building a generic arithmetic system tohandle integers, rational numbers, real numbers, and complex numbers.In such a system, it is quite natural to regard an integer as aspecial kind of rational number, which is in turn a special kind ofreal number, which is in turn a special kind of complex number.  Whatwe actually have is a so-called <em>hierarchy of types</em>, in which,for example, integers are a <a name="%_idx_2596" id="%_idx_2596"></a><a name="%_idx_2598" id="%_idx_2598"></a><em>subtype</em> of rational numbers (i.e.,any operation that can be applied to a rational number canautomatically be applied to an integer).  Conversely, we say thatrational numbers form a <a name="%_idx_2600" id="%_idx_2600"></a><a name="%_idx_2602" id="%_idx_2602"></a><em>supertype</em> of integers.  The particularhierarchy we have here is of a very simple kind, in which each typehas at most one supertype and at most one subtype.  Such a structure,called a <em>tower</em>, is illustrated in figure <a href="#%_fig_2.25">2.25</a>.</p><p><a name="%_fig_2.25" id="%_fig_2.25"></a></p>
<p class="centered">    complex
    ↑
    real
    ↑
    rational
    ↑
    integer
</p><div>
<b>Figure 2.25:</b>  A tower of types.</div><a name="%_idx_2604" id="%_idx_2604"></a><a name="%_idx_2606" id="%_idx_2606"></a><p>If we have a tower structure, then we can greatly simplify the problemof adding a new type to the hierarchy, for we need only specify howthe new type is embedded in the next supertype above it and how it isthe supertype of the type below it.  For example, if we want to add aninteger to a complex number, we need not explicitly define a specialcoercion procedure <code>integer-&gt;complex</code>.  Instead, we define how aninteger can be transformed into a rational number, how a rationalnumber is transformed into a real number, and how a real number istransformed into a complex number.  We then allow the system totransform the integer into a complex number through these steps andthen add the two complex numbers.</p>
<p><a name="%_idx_2608" id="%_idx_2608"></a><a name="%_idx_2610" id="%_idx_2610"></a>We can redesign our <code>apply-generic</code> procedure in the followingway: For each type, we need to supply a <code>raise</code> procedure, which“raises” objects of that type one level in the tower.  Then when thesystem is required to operate on objects of different types it cansuccessively raise the lower types until all the objects are atthe same level in the tower.  (Exercises <a href="#%_thm_2.83">2.83</a>and  <a href="#%_thm_2.84">2.84</a>concern the details of implementing such a strategy.)</p>
<p>Another advantage of a tower is that we can easily implement thenotion that every type “inherits” all operations defined on asupertype.  For instance, if we do not supply a special procedure forfinding the real part of an integer, we should nevertheless expectthat <code>real-part</code> will be defined for integers by virtue of thefact that integers are a subtype of complex numbers.  In a tower, wecan arrange for this to happen in a uniform way by modifying <code>apply-generic</code>.  If the required operation is not directly defined forthe type of the object given, we raise the object to its supertype andtry again.  We thus crawl up the tower, transforming our argument as wego, until we either find a level at which the desired operation can beperformed or hit the top (in which case we give up).</p>
<p><a name="%_idx_2612" id="%_idx_2612"></a>Yet another advantage of a tower over a more general hierarchy is thatit gives us a simple way to “lower” a data object to the simplestrepresentation.  For example, if we add 2 + 3<em>i</em> to 4 - 3<em>i</em>, it would benice to obtain the answer as the integer 6 rather than as the complexnumber 6 + 0<em>i</em>.  Exercise <a href="#%_thm_2.85">2.85</a> discusses a way to implementsuch a lowering operation.  (The trick is that we need a general wayto distinguish those objects that can be lowered, such as 6 + 0<em>i</em>, fromthose that cannot, such as 6 + 2<em>i</em>.)</p>
<p><a name="%_fig_2.26" id="%_fig_2.26"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch2-Z-G-67.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 2.26:</b>  Relations among types of geometric figures.</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p><a name="%_sec_Temp_288" id="%_sec_Temp_288"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_288">Inadequacies of hierarchies</a></h4>
<p><a name="%_idx_2614" id="%_idx_2614"></a>If the data types in our system can be naturally arranged in a tower,this greatly simplifies the problems of dealing with generic operationson different types, as we have seen.  Unfortunately, this is usuallynot the case.  Figure <a href="#%_fig_2.26">2.26</a> illustrates amore complex arrangement of mixed types, this one showing relationsamong different types of geometric figures.  We see that, in general,<a name="%_idx_2616" id="%_idx_2616"></a><a name="%_idx_2618" id="%_idx_2618"></a><a name="%_idx_2620" id="%_idx_2620"></a>a type may have more than one subtype.  Triangles and quadrilaterals,for instance, are both subtypes of polygons.  In addition, a type mayhave more than one supertype.  For example, an isosceles righttriangle may be regarded either as an isosceles triangle or as a righttriangle.  This multiple-supertypes issue is particularly thorny,since it means that there is no unique way to “raise” a type in thehierarchy.  Finding the “correct” supertype in which to apply anoperation to an object may involve considerable searching through theentire type network on the part of a procedure such as <code>apply-generic</code>.  Since there generally are multiple subtypes for atype, there is a similar problem in coercing a value “down” the typehierarchy.  Dealing with large numbers of interrelated types whilestill preserving modularity in the design of large systems is verydifficult, and is an area of much current research.<a name="call_footnote_Temp_289" href="#footnote_Temp_289" id="call_footnote_Temp_289"><sup><small>52</small></sup></a></p>
<p></p>
<p><a name="%_thm_2.81" id="%_thm_2.81"></a><b>Exercise 2.81.</b>  <a name="%_idx_2626" id="%_idx_2626"></a>Louis Reasoner has noticed that <code>apply-generic</code> may try tocoerce the arguments to each other's type even if they already havethe same type.  Therefore, he reasons, we need to put proceduresin the coercion table to "coerce" arguments of each type to theirown type.  For example, in addition to the <code>scheme-number-&gt;complex</code>coercion shown above, he would do:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_2628" id="%_idx_2628"></a>(define (scheme-number-&gt;scheme-number n) n)
<a name="%_idx_2630" id="%_idx_2630"></a>(define (complex-&gt;complex z) z)
(put-coercion 'scheme-number 'scheme-number
              scheme-number-&gt;scheme-number)
(put-coercion 'complex 'complex complex-&gt;complex)
</pre></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p>a. With Louis's coercion procedures installed, what happens if <code>apply-generic</code>is called with two arguments of type <code>scheme-number</code> or two arguments oftype <code>complex</code> for an operation that is not found in the table for thosetypes?  For example, assume that we've defined a generic exponentiationoperation:</p>
<p></p>
<p></p>
<p><pre>(define (exp x y) (apply-generic 'exp x y))
</pre></p>
<p></p>
<p>and have put a procedure for exponentiation in the Scheme-numberpackage but not in any other package:</p>
<p></p>
<p></p>
<p><pre><em>;; following added to Scheme-number package</em>
(put 'exp '(scheme-number scheme-number)
     (lambda (x y) (tag (expt x y)))) <em>; using primitive <code>expt</code></em>
</pre></p>
<p></p>
<p>What happens if we call <code>exp</code> with two complex numbers as arguments?</p>
<p></p>
<p></p>
<p>b. Is Louis correct that something had to be done aboutcoercion with arguments of the same type, or does <code>apply-generic</code>work correctly as is?</p>
<p></p>
<p></p>
<p>c. Modify <code>apply-generic</code> so that it doesn't try coercion ifthe two arguments have the same type.</p>
<p></p>
<p></p>
<p><a name="%_thm_2.82" id="%_thm_2.82"></a><b>Exercise 2.82.</b>  <a name="%_idx_2632" id="%_idx_2632"></a>Show how to generalize <code>apply-generic</code> to handlecoercion in the general case of multiple arguments.  One strategy isto attempt to coerce all the arguments to the type of the first argument, thento the type of the second argument, and so on.  Give an example of a situationwhere this strategy (and likewise the two-argument version givenabove) is not sufficiently general.  (Hint: Consider the case wherethere are some suitable mixed-type operations present in the tablethat will not be tried.)</p>
<p></p>
<p></p>
<p><a name="%_thm_2.83" id="%_thm_2.83"></a><b>Exercise 2.83.</b>  <a name="%_idx_2634" id="%_idx_2634"></a>Suppose you are designing a generic arithmetic system for dealing withthe tower of types shown in figure <a href="#%_fig_2.25">2.25</a>:integer, rational, real, complex.  Foreach type (except complex), design a procedure that raises objects ofthat type one level in the tower.  Show how to install a generic <code>raise</code> operation that will work for each type (except complex).</p>
<p></p>
<p></p>
<p><a name="%_thm_2.84" id="%_thm_2.84"></a><b>Exercise 2.84.</b>  <a name="%_idx_2636" id="%_idx_2636"></a>Using the <code>raise</code> operation of exercise <a href="#%_thm_2.83">2.83</a>, modify the <code>apply-generic</code> procedure so that it coerces its arguments to have thesame type by the method of successive raising, as discussed in thissection.  You will need to devise a way to test which of two types ishigher in the tower.  Do this in a manner that is “compatible” withthe rest of the system and will not lead to problems in adding newlevels to the tower.</p>
<p></p>
<p></p>
<p><a name="%_thm_2.85" id="%_thm_2.85"></a><b>Exercise 2.85.</b>  <a name="%_idx_2638" id="%_idx_2638"></a><a name="%_idx_2640" id="%_idx_2640"></a>This section mentioned a method for “simplifying” a data objectby lowering it in the tower of types as far as possible.  Designa procedure <code>drop</code> that accomplishes this for the tower describedin exercise <a href="#%_thm_2.83">2.83</a>.  The key is to decide, in some general way, whetheran object can be lowered.  For example, the complex number 1.5 + 0<em>i</em>can be lowered as far as <code>real</code>, the complex number 1 + 0<em>i</em> can belowered as far as <code>integer</code>, and the complex number 2 + 3<em>i</em> cannotbe lowered at all.  Here is a plan for determining whether an objectcan be lowered: Begin by defining a generic operation <code>project</code>that “pushes” an object down in the tower.  For example, projectinga complex number would involve throwing away the imaginary part.  Thena number can be dropped if, when we <code>project</code> it and <code>raise</code>the result back to the type we started with, we end up with somethingequal to what we started with.  Show how to implement this idea indetail, by writing a <code>drop</code> procedure that drops an object as faras possible.  You will need to design the various projectionoperations<a name="call_footnote_Temp_295" href="#footnote_Temp_295" id="call_footnote_Temp_295"><sup><small>53</small></sup></a> and install <code>project</code> as a generic operation inthe system.  You will also need to make use of a generic equalitypredicate, such as described in exercise <a href="#%_thm_2.79">2.79</a>.  Finally, use <code>drop</code>to rewrite <code>apply-generic</code> from exercise <a href="#%_thm_2.84">2.84</a> so that it“simplifies” its answers.</p>
<p> </p>
<p></p>
<p><a name="%_thm_2.86" id="%_thm_2.86"></a><b>Exercise 2.86.</b>  Suppose we want to handle complex numbers whose realparts, imaginary parts, magnitudes, and angles can be either ordinarynumbers, rational numbers, or other numbers we might wish to add tothe system.  Describe and implement the changes to the system neededto accommodate this.  You will have to define operations such as <code>sine</code> and <code>cosine</code> that are generic over ordinary numbers andrational numbers.</p>
<p></p>
<p><a name="%_sec_2.5.3" id="%_sec_2.5.3"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_2.5.3">2.5.3  Example: Symbolic Algebra</a></h3>
<p><a name="%_idx_2646" id="%_idx_2646"></a>The manipulation of symbolic algebraic expressions is a complexprocess that illustrates many of the hardest problems that occur inthe design of large-scale systems.  An algebraic expression, in<a name="%_idx_2648" id="%_idx_2648"></a>general, can be viewed as a hierarchical structure, a tree ofoperators applied to operands.  We can construct algebraic expressionsby starting with a set of primitive objects, such as constants andvariables, and combining these by means of algebraic operators, suchas addition and multiplication.  As in other languages, we formabstractions that enable us to refer to compound objects in simpleterms.  Typical abstractions in symbolic algebra are ideas such aslinear combination, polynomial, rational function, or trigonometricfunction.  We can regard these as compound “types,” which are oftenuseful for directing the processing of expressions.  For example, wecould describe the expression</p><p><em>x</em><sup>2</sup> sin(<em>y</em><sup>2</sup> + 1) + <em>x</em> cos 2<em>y</em> + cos(<em>y</em><sup>3</sup> - 2<em>y</em><sup>2</sup>)</p><p>as a polynomial in <em>x</em> with coefficients that are trigonometricfunctions of polynomials in <em>y</em> whose coefficients are integers.</p>
<p>We will not attempt to develop a complete algebraic-manipulationsystem here.  Such systems are exceedingly complex programs, embodyingdeep algebraic knowledge and elegant algorithms.  What we will do islook at a simple but important part of algebraic manipulation: thearithmetic of polynomials.  We will illustrate the kinds of decisionsthe designer of such a system faces, and how to apply the ideas ofabstract data and generic operations to help organize this effort.</p>
<p><a name="%_sec_Temp_297" id="%_sec_Temp_297"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_297">Arithmetic on polynomials</a></h4>
<p><a name="%_idx_2650" id="%_idx_2650"></a><a name="%_idx_2652" id="%_idx_2652"></a>Our first task in designing a system for performing arithmetic onpolynomials is to decide just what a polynomial is.  Polynomials arenormally defined relative to certain variables (the <a name="%_idx_2654" id="%_idx_2654"></a><a name="%_idx_2656" id="%_idx_2656"></a><em>indeterminates</em> of the polynomial).  For simplicity, we will restrictourselves to polynomials having just one indeterminate (<a name="%_idx_2658" id="%_idx_2658"></a><a name="%_idx_2660" id="%_idx_2660"></a><em>univariate polynomials</em>).<a name="call_footnote_Temp_298" href="#footnote_Temp_298" id="call_footnote_Temp_298"><sup><small>54</small></sup></a> We will define a polynomial to be asum of terms, each of which is either a coefficient, a power of theindeterminate, or a product of a coefficient and a power of theindeterminate.  A coefficient is defined as an algebraic expressionthat is not dependent upon the indeterminate of the polynomial.  Forexample,</p><p>5<em>x</em><sup>2</sup> + 3<em>x</em> + 7</p><p>is a simple polynomial in <em>x</em>, and</p><p>(<em>y</em><sup>2</sup> + 1)<em>x</em><sup>3</sup> + (2<em>y</em>)<em>x</em> + 1</p><p>is a polynomial in <em>x</em> whose coefficients are polynomials in <em>y</em>.</p>
<p>Already we are skirting some thorny issues.  Is the first of thesepolynomials the same as the polynomial 5<em>y</em><sup>2</sup>  + 3<em>y</em>  + 7, or not?  Areasonable answer might be “yes, if we are considering a polynomialpurely as a mathematical function, but no, if we are considering apolynomial to be a syntactic form.”  The second polynomial isalgebraically equivalent to a polynomial in <em>y</em> whose coefficients arepolynomials in <em>x</em>.  Should our system recognize this, or not?Furthermore, there are other ways to represent a polynomial – forexample, as a product of factors, or (for a univariate polynomial) asthe set of roots, or as a listing of the values of the polynomial at aspecified set of points.<a name="call_footnote_Temp_299" href="#footnote_Temp_299" id="call_footnote_Temp_299"><sup><small>55</small></sup></a>We can finesse these questions by deciding that in ouralgebraic-manipulation system a “polynomial” will be aparticular syntactic form, not its underlying mathematical meaning.</p>
<p>Now we must consider how to go about doing arithmetic on polynomials.In this simple system, we will consider only addition andmultiplication.  Moreover, we will insist that two polynomials to becombined must have the same indeterminate.</p>
<p>We will approach the design of our system by following the familiardiscipline of data abstraction.  We will represent polynomials using adata structure called a <a name="%_idx_2664" id="%_idx_2664"></a><em>poly</em>, which consists of a variable and a<a name="%_idx_2666" id="%_idx_2666"></a>collection of terms.  We assume that we have selectors <code>variable</code>and <code>term-list</code> that extract those parts from a poly anda constructor <code>make-poly</code> that assembles apoly from a given variable and a term list.A variable will be just a symbol, so we can use the <a name="%_idx_2668" id="%_idx_2668"></a><code>same-variable?</code>procedure of section <a href="book-Z-H-16.html#%_sec_2.3.2">2.3.2</a> to compare variables.<a name="%_idx_2670" id="%_idx_2670"></a><a name="%_idx_2672" id="%_idx_2672"></a>The following procedures define addition and multiplication of polys:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_2674" id="%_idx_2674"></a>(define (add-poly p1 p2)
  (if (same-variable? (variable p1) (variable p2))
      (make-poly (variable p1)
                 (add-terms (term-list p1)
                            (term-list p2)))
      (error "Polys not in same var -- ADD-POLY"
             (list p1 p2))))
<a name="%_idx_2676" id="%_idx_2676"></a>(define (mul-poly p1 p2)
  (if (same-variable? (variable p1) (variable p2))
      (make-poly (variable p1)
                 (mul-terms (term-list p1)
                            (term-list p2)))
      (error "Polys not in same var -- MUL-POLY"
             (list p1 p2))))
</pre></p>
<p></p>
<p></p>
<p>To incorporate polynomials into our generic arithmetic system, we needto supply them with type tags.  We'll use the tag <code>polynomial</code>,and install appropriate operations on tagged polynomials inthe operation table.  We'll embed all our codein an installation procedure for the polynomial package,similar to the ones insection <a href="#%_sec_2.5.1">2.5.1</a>:<a name="%_idx_2678" id="%_idx_2678"></a><a name="%_idx_2680" id="%_idx_2680"></a><a name="%_idx_2682" id="%_idx_2682"></a></p>
<p></p>
<p><pre><a name="%_idx_2684" id="%_idx_2684"></a><a name="%_idx_2686" id="%_idx_2686"></a><a name="%_idx_2688" id="%_idx_2688"></a><a name="%_idx_2690" id="%_idx_2690"></a>(define (install-polynomial-package)
  <em>;; internal procedures</em>
  <em>;; representation of poly</em>
  (define (make-poly variable term-list)
    (cons variable term-list))
  (define (variable p) (car p))
  (define (term-list p) (cdr p))
  &lt;<em>procedures <code>same-variable?</code> and <code>variable?</code> from section <a href="book-Z-H-16.html#%_sec_2.3.2">2.3.2</a></em>&gt;
  <em>;; representation of terms and term lists</em>
  &lt;<em>procedures <code>adjoin-term <code>...</code><code>coeff</code></code> from text below</em>&gt;

  <em>;; continued on next page</em>

  (define (add-poly p1 p2) <code>...</code>)
  &lt;<em>procedures used by <code>add-poly</code></em>&gt;
  (define (mul-poly p1 p2) <code>...</code>)
  &lt;<em>procedures used by <code>mul-poly</code></em>&gt;
  <em>;; interface to rest of the system</em>
  (define (tag p) (attach-tag 'polynomial p))
  (put 'add '(polynomial polynomial) 
       (lambda (p1 p2) (tag (add-poly p1 p2))))
  (put 'mul '(polynomial polynomial) 
       (lambda (p1 p2) (tag (mul-poly p1 p2))))
  (put 'make 'polynomial
       (lambda (var terms) (tag (make-poly var terms))))
  'done)
</pre></p>
<p></p>
<p></p>
<p>Polynomial addition is performed termwise.  Terms of the same order(i.e., with the same power of the indeterminate) must be combined.This is done by forming a new term of the same order whose coefficientis the sum of the coefficients of the addends.  Terms in one addendfor which there are no terms of the same order in the other addend aresimply accumulated into the sum polynomial being constructed.</p>
<p>In order to manipulate term lists, we will assume that we have aconstructor <a name="%_idx_2692" id="%_idx_2692"></a><code>the-empty-termlist</code> that returns an empty term listand a constructor <a name="%_idx_2694" id="%_idx_2694"></a><code>adjoin-term</code> that adjoins a new term to a termlist.  We will also assume that we have a predicate <a name="%_idx_2696" id="%_idx_2696"></a><code>empty-termlist?</code> that tells if a given term list is empty, a selector<a name="%_idx_2698" id="%_idx_2698"></a><code>first-term</code> that extracts the highest-order term from a termlist, and a selector <a name="%_idx_2700" id="%_idx_2700"></a><code>rest-terms</code> that returns all but the highest-orderterm.  To manipulate terms, we will suppose that we have aconstructor <a name="%_idx_2702" id="%_idx_2702"></a><code>make-term</code> that constructs a term with givenorder and coefficient, and selectors <a name="%_idx_2704" id="%_idx_2704"></a><code>order</code> and <a name="%_idx_2706" id="%_idx_2706"></a><code>coeff</code> that return, respectively, the order and thecoefficient of the term.  These operations allow us to consider bothterms and term lists as data abstractions, whose concreterepresentations we can worry about separately.</p>
<p>Here is the procedure that constructs the term list for the sum of twopolynomials:<a name="call_footnote_Temp_300" href="#footnote_Temp_300" id="call_footnote_Temp_300"><sup><small>56</small></sup></a></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_2708" id="%_idx_2708"></a>(define (add-terms L1 L2)
  (cond ((empty-termlist? L1) L2)
        ((empty-termlist? L2) L1)
        (else
         (let ((t1 (first-term L1)) (t2 (first-term L2)))
           (cond ((&gt; (order t1) (order t2))
                  (adjoin-term
                   t1 (add-terms (rest-terms L1) L2)))
                 ((&lt; (order t1) (order t2))
                  (adjoin-term
                   t2 (add-terms L1 (rest-terms L2))))
                 (else
                  (adjoin-term
                   (make-term (order t1)
                              (add (coeff t1) (coeff t2)))
                   (add-terms (rest-terms L1)
                              (rest-terms L2)))))))))
</pre></p>
<p></p>
<p>The most important point to note here is that we used the genericaddition procedure <a name="%_idx_2710" id="%_idx_2710"></a><code>add</code> to add together the coefficients of theterms being combined.  This has powerful consequences, as we will seebelow.</p>
<p>In order to multiply two term lists, we multiply each term of thefirst list by all the terms of the other list, repeatedly using<code>mul-term-by-all-terms</code>, which multiplies a given term byall terms in a given term list.  The resulting term lists (one foreach term of the first list) are accumulated into a sum.  Multiplyingtwo terms forms a term whose order is the sum of the orders of thefactors and whose coefficient is the product of the coefficients ofthe factors:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_2712" id="%_idx_2712"></a>(define (mul-terms L1 L2)
  (if (empty-termlist? L1)
      (the-empty-termlist)
      (add-terms (mul-term-by-all-terms (first-term L1) L2)
                 (mul-terms (rest-terms L1) L2))))
(define (mul-term-by-all-terms t1 L)
  (if (empty-termlist? L)
      (the-empty-termlist)
      (let ((t2 (first-term L)))
        (adjoin-term
         (make-term (+ (order t1) (order t2))
                    (mul (coeff t1) (coeff t2)))
         (mul-term-by-all-terms t1 (rest-terms L))))))
</pre></p>
<p></p>
<p></p>
<p>This is really all there is to polynomial addition and multiplication.<a name="%_idx_2714" id="%_idx_2714"></a><a name="%_idx_2716" id="%_idx_2716"></a>Notice that, since we operate on terms using the generic procedures<code>add</code> and <code>mul</code>, our polynomial package is automatically ableto handle any type of coefficient that is known about by the genericarithmetic package.  If we include a <a name="%_idx_2718" id="%_idx_2718"></a>coercion mechanism such as one ofthose discussed in section <a href="#%_sec_2.5.2">2.5.2</a>,then we also are automatically able to handle operations onpolynomials of different coefficient types, such as</p><div align="left"><img src="images/ch2-Z-G-71.gif" border="0"></div><p>Because we installed the polynomial addition andmultiplication procedures <code>add-poly</code> and <code>mul-poly</code> in the genericarithmetic system as the <code>add</code> and <code>mul</code> operationsfor type <code>polynomial</code>, our system is alsoautomatically able to handle polynomial operations such as</p><p>[(<em>y</em> + 1)<em>x</em><sup>2</sup> + (<em>y</em><sup>2</sup> + 1)<em>x</em> + (<em>y</em> - 1)] · [(<em>y</em> - 2)<em>x</em> + (<em>y</em><sup>3</sup>) + 7]</p><p>The reason is that when the system tries to combine coefficients, itwill dispatch through <code>add</code> and <code>mul</code>.  Since the coefficientsare themselves polynomials (in <em>y</em>), these will be combined using <code>add-poly</code> and <code>mul-poly</code>.  The result is a kind of <a name="%_idx_2720" id="%_idx_2720"></a><a name="%_idx_2722" id="%_idx_2722"></a>“data-directedrecursion” in which, for example, a call to <code>mul-poly</code> will resultin recursive calls to <code>mul-poly</code> in order to multiply thecoefficients.  If the coefficients of the coefficients were themselvespolynomials (as might be used to represent polynomials in threevariables), the data direction would ensure that the system wouldfollow through another level of recursive calls, and so on through asmany levels as the structure of the data dictates.<a name="call_footnote_Temp_301" href="#footnote_Temp_301" id="call_footnote_Temp_301"><sup><small>57</small></sup></a><a name="%_sec_Temp_302" id="%_sec_Temp_302"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_302">Representing term lists</a></h4>
<p><a name="%_idx_2724" id="%_idx_2724"></a>Finally, we must confront the job of implementing a goodrepresentation for term lists.  A term list is, in effect, a set ofcoefficients keyed by the order of the term.  Hence, any of themethods for representing sets, as discussed insection <a href="book-Z-H-16.html#%_sec_2.3.3">2.3.3</a>, can be applied to this task.  Onthe other hand, our procedures <code>add-terms</code> and <code>mul-terms</code> alwaysaccess term lists sequentially from highest to lowest order.  Thus, wewill use some kind of ordered list representation.</p>
<p>How should we structure the list that represents a term list?  Oneconsideration is the “density” of the polynomials we intend tomanipulate.  A polynomial is said to be <a name="%_idx_2726" id="%_idx_2726"></a><a name="%_idx_2728" id="%_idx_2728"></a><em>dense</em> if it has nonzerocoefficients in terms of most orders.  If it has many zero terms itis said to be <a name="%_idx_2730" id="%_idx_2730"></a><a name="%_idx_2732" id="%_idx_2732"></a><em>sparse</em>.  For example,</p><p>A:     <em>x</em><sup>5</sup> + 2<em>x</em><sup>4</sup> + 3<em>x</em><sup>2</sup> - 2<em>x</em> - 5</p><p>is a dense polynomial, whereas</p><p>B:     <em>x</em><sup>100</sup> + 2<em>x</em><sup>2</sup> + 1</p><p>is sparse.</p><p>The term lists of dense polynomials are most efficiently representedas lists of the coefficients.  For example, <em>A</em> above would be nicelyrepresented as <code>(1 2 0 3 -2 -5)</code>.  The order of a term in thisrepresentation is the length of the sublist beginning with that term'scoefficient, decremented by 1.<a name="call_footnote_Temp_303" href="#footnote_Temp_303" id="call_footnote_Temp_303"><sup><small>58</small></sup></a>  This would be a terrible representation for asparse polynomial such as <em>B</em>: There would be a giant list of zerospunctuated by a few lonely nonzero terms.  A more reasonablerepresentation of the term list of a sparse polynomial is as a list ofthe nonzero terms, where each term is a list containing the order of theterm and the coefficient for that order.  In such a scheme, polynomial<em>B</em> is efficiently represented as <code>((100 1) (2 2) (0 1))</code>.  Asmost polynomial manipulations are performed on sparse polynomials, wewill use this method.  We will assume that term lists are representedas lists of terms, arranged from highest-order to lowest-order term.Once we have made this decision, implementing the selectors andconstructors for terms and term lists is straightforward:<a name="call_footnote_Temp_304" href="#footnote_Temp_304" id="call_footnote_Temp_304"><sup><small>59</small></sup></a></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_2734" id="%_idx_2734"></a>(define (adjoin-term term term-list)
  (if (=zero? (coeff term))
      term-list
      (cons term term-list)))
<a name="%_idx_2736" id="%_idx_2736"></a>(define (the-empty-termlist) '())
<a name="%_idx_2738" id="%_idx_2738"></a>(define (first-term term-list) (car term-list))
<a name="%_idx_2740" id="%_idx_2740"></a>(define (rest-terms term-list) (cdr term-list))
<a name="%_idx_2742" id="%_idx_2742"></a>(define (empty-termlist? term-list) (null? term-list))
<a name="%_idx_2744" id="%_idx_2744"></a>(define (make-term order coeff) (list order coeff))
<a name="%_idx_2746" id="%_idx_2746"></a>(define (order term) (car term))
<a name="%_idx_2748" id="%_idx_2748"></a>(define (coeff term) (cadr term))
</pre></p>
<p></p>
<p>where <code>=zero?</code> is as defined inexercise <a href="#%_thm_2.80">2.80</a>.  (See also exercise <a href="#%_thm_2.87">2.87</a> below.)</p>
<p>Users of the polynomial packagewill create (tagged) polynomials by means of the procedure:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_2750" id="%_idx_2750"></a>(define (make-polynomial var terms)
  ((get 'make 'polynomial) var terms))
</pre></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_2.87" id="%_thm_2.87"></a><b>Exercise 2.87.</b>  <a name="%_idx_2752" id="%_idx_2752"></a><a name="%_idx_2754" id="%_idx_2754"></a>Install <code>=zero?</code> for polynomials in the generic arithmeticpackage.  This will allow <code>adjoin-term</code> to work for polynomialswith coefficients that are themselves polynomials.</p>
<p> </p>
<p></p>
<p><a name="%_thm_2.88" id="%_thm_2.88"></a><b>Exercise 2.88.</b>  <a name="%_idx_2756" id="%_idx_2756"></a>Extend the polynomial system to include subtraction of polynomials.(Hint: You may find it helpful to define a generic negation operation.)</p>
<p> </p>
<p></p>
<p><a name="%_thm_2.89" id="%_thm_2.89"></a><b>Exercise 2.89.</b>  Define procedures that implement the term-list representationdescribed above as appropriate for dense polynomials.</p>
<p> </p>
<p></p>
<p><a name="%_thm_2.90" id="%_thm_2.90"></a><b>Exercise 2.90.</b>  Suppose we want to have a polynomial system that is efficient for bothsparse and dense polynomials.  One way to do this is to allow bothkinds of term-list representations in our system.  The situation isanalogous to the complex-number example of section <a href="book-Z-H-17.html#%_sec_2.4">2.4</a>,where we allowed both rectangular and polar representations.To do this we must distinguish different types of term lists and makethe operations on term lists generic.  Redesign the polynomial systemto implement this generalization.  This is a major effort, not a localchange.</p>
<p></p>
<p><a name="%_thm_2.91" id="%_thm_2.91"></a><b>Exercise 2.91.</b>  <a name="%_idx_2758" id="%_idx_2758"></a>A univariate polynomial can be divided by another one to produce apolynomial quotient and a polynomial remainder.  For example,</p>
<p></p>
<p></p>
<div align="left"><img src="images/ch2-Z-G-76.gif" border="0"></div>
<p></p>
<p>Division can be performed via long division.That is, divide the highest-order term of the dividend bythe highest-order term of the divisor.  The result is the first term of thequotient.  Next, multiply the result by the divisor, subtract thatfrom the dividend, and produce the rest of the answer by recursivelydividing the difference by the divisor.  Stop when the order of thedivisor exceeds the order of the dividend and declare the dividend tobe the remainder.  Also, if the dividend ever becomes zero, returnzero as both quotient and remainder.</p>
<p><a name="%_idx_2760" id="%_idx_2760"></a>We can design a <code>div-poly</code> procedure on the model of <code>add-poly</code> and<code>mul-poly</code>. The procedure checks to see if the two polys havethe same variable.  If so, <code>div-poly</code> strips off the variable andpasses the problem to <code>div-terms</code>, which performs the divisionoperation on term lists. <code>Div-poly</code> finally reattaches the variableto the result supplied by <code>div-terms</code>.  It is convenientto design <code>div-terms</code> to compute both the quotient and the remainderof a division.  <code>Div-terms</code> can take two term lists as arguments andreturn a list of the quotient term list and the remainder term list.</p>
<p>Complete the following definition of <code>div-terms</code> by filling in themissing expressions.  Use this to implement <code>div-poly</code>, which takestwo polys as arguments and returns a list of the quotient andremainder polys.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_2762" id="%_idx_2762"></a>(define (div-terms L1 L2)
  (if (empty-termlist? L1)
      (list (the-empty-termlist) (the-empty-termlist))
      (let ((t1 (first-term L1))
            (t2 (first-term L2)))
        (if (&gt; (order t2) (order t1))
            (list (the-empty-termlist) L1)
            (let ((new-c (div (coeff t1) (coeff t2)))
                  (new-o (- (order t1) (order t2))))
              (let ((rest-of-result
                     &lt;<em>compute rest of result recursively</em>&gt;
                     ))
                &lt;<em>form complete result</em>&gt;
                ))))))
</pre></p>
<p></p>
<p></p>
<p> </p>
<p><a name="%_sec_Temp_310" id="%_sec_Temp_310"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_310">Hierarchies of types in symbolic algebra</a></h4>
<p><a name="%_idx_2764" id="%_idx_2764"></a><a name="%_idx_2766" id="%_idx_2766"></a><a name="%_idx_2768" id="%_idx_2768"></a>Our polynomial system illustrates how objects of one type(polynomials) may in fact be complex objects that have objects of manydifferent types as parts.  This poses no real difficulty in defininggeneric operations.  We need only install appropriate generic operationsfor performing the necessary manipulations of the parts of thecompound types.  In fact, we saw that polynomials form a kind of“recursive data abstraction,” in that parts of a polynomial maythemselves be polynomials.  Our generic operations and ourdata-directed programming style can handle this complication withoutmuch trouble.</p>
<p>On the other hand, polynomial algebra is a system for which the datatypes cannot be naturally arranged in a tower.  For instance, it ispossible to have polynomials in <em>x</em> whose coefficients are polynomialsin <em>y</em>.  It is also possible to have polynomials in <em>y</em> whosecoefficients are polynomials in <em>x</em>.  Neither of these types is“above” the other in any natural way, yet it is often necessary toadd together elements from each set.  There are several ways to dothis.  One possibility is to convert one polynomial to the type of theother by expanding and rearranging terms so that both polynomials havethe same principal variable.  One can impose a towerlike structure onthis by ordering the variables and thus always converting anypolynomial to a <a name="%_idx_2770" id="%_idx_2770"></a><a name="%_idx_2772" id="%_idx_2772"></a>“canonical form” with the highest-priority variabledominant and the lower-priority variables buried in the coefficients.This strategy works fairly well, except that the conversion may expanda polynomial unnecessarily, making it hard to read and perhaps lessefficient to work with.  The tower strategy is certainly not naturalfor this domain or for any domain where the user can invent new typesdynamically using old types in various combining forms, such astrigonometric functions, power series, and integrals.</p>
<p>It should not be surprising that controlling <a name="%_idx_2774" id="%_idx_2774"></a>coercion is a seriousproblem in the design of large-scale algebraic-manipulation systems.Much of the complexity of such systems is concerned with relationshipsamong diverse types.  Indeed, it is fair to say that we do not yetcompletely understand coercion.  In fact, we do not yet completelyunderstand the concept of a data type.  Nevertheless, what we knowprovides us with powerful structuring and modularity principles tosupport the design of large systems.</p>
<p></p>
<p><a name="%_thm_2.92" id="%_thm_2.92"></a><b>Exercise 2.92.</b>  By imposing an ordering on variables, extend the polynomial package sothat addition and multiplication of polynomials works for polynomialsin different variables.  (This is not easy!)</p>
<p><a name="%_sec_Temp_312" id="%_sec_Temp_312"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_312">Extended exercise: Rational functions</a></h4>
<p><a name="%_idx_2776" id="%_idx_2776"></a><a name="%_idx_2778" id="%_idx_2778"></a><a name="%_idx_2780" id="%_idx_2780"></a>We can extend our generic arithmetic system to include <em>rationalfunctions</em>.  These are “fractions” whose numerator and denominatorare polynomials, such as</p>
<p></p>
<p></p>
<div align="left"><img src="images/ch2-Z-G-77.gif" border="0"></div>
<p>The system should be able to add, subtract, multiply, and dividerational functions, and to perform such computations as</p>
<p></p>
<div align="left"><img src="images/ch2-Z-G-78.gif" border="0"></div>
<p>(Here the sum has been simplified by removing common factors.Ordinary “cross multiplication” would have produced afourth-degree polynomial over a fifth-degree polynomial.)</p>
<p>If we modify our rational-arithmetic package so that it uses genericoperations, then it will do what we want, except for the problemof reducing fractions to lowest terms.</p>
<p></p>
<p><a name="%_thm_2.93" id="%_thm_2.93"></a><b>Exercise 2.93.</b>  Modify the rational-arithmetic package to use generic operations, butchange <code>make-rat</code> so that it does not attempt to reduce fractionsto lowest terms.  Test your system by calling <code>make-rational</code> ontwo polynomials to produce a rational function</p>
<p></p>
<p></p>
<p><pre>(define p1 (make-polynomial 'x '((2 1)(0 1))))
(define p2 (make-polynomial 'x '((3 1)(0 1))))
(define rf (make-rational p2 p1))
</pre></p>
<p></p>
<p>Now add <code>rf</code> to itself, using <code>add</code>. You will observe thatthis addition procedure does not reduce fractions to lowest terms.</p>
<p> </p>
<p></p>
<p></p>
<p>We can reduce polynomial fractions to lowest terms using the same ideawe used with integers: modifying <code>make-rat</code> to divide both thenumerator and the denominator by their greatest common divisor.  Thenotion of <a name="%_idx_2782" id="%_idx_2782"></a><a name="%_idx_2784" id="%_idx_2784"></a>“greatest common divisor” makes sense for polynomials.  Infact, we can compute the GCD of two polynomials using essentially thesame Euclid's Algorithm that works for integers.<a name="call_footnote_Temp_314" href="#footnote_Temp_314" id="call_footnote_Temp_314"><sup><small>60</small></sup></a>  Theinteger version is</p>
<p></p>
<p></p>
<p><pre>(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))
</pre></p>
<p></p>
<p>Using this, we could make the obvious modification to define a GCDoperation that works on term lists:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_2794" id="%_idx_2794"></a>(define (gcd-terms a b)
  (if (empty-termlist? b)
      a
      (gcd-terms b (remainder-terms a b))))
</pre></p>
<p></p>
<p>where <code>remainder-terms</code> picks out the remainder component of thelist returned by the term-list division operation <code>div-terms</code> thatwas implemented in exercise <a href="#%_thm_2.91">2.91</a>.</p>
<p></p>
<p><a name="%_thm_2.94" id="%_thm_2.94"></a><b>Exercise 2.94.</b>  <a name="%_idx_2796" id="%_idx_2796"></a><a name="%_idx_2798" id="%_idx_2798"></a>Using <code>div-terms</code>, implement the procedure <code>remainder-terms</code> anduse this to define <code>gcd-terms</code> as above.  Now write a procedure<code>gcd-poly</code> that computes the polynomial GCD of two polys.(The procedure should signal an error if the two polys are notin the same variable.)  Install in the system a generic operation <code>greatest-common-divisor</code> that reduces to <code>gcd-poly</code> for polynomialsand to ordinary <code>gcd</code> for ordinary numbers.  As a test, try</p>
<p></p>
<p></p>
<p><pre>(define p1 (make-polynomial 'x '((4 1) (3 -1) (2 -2) (1 2))))
(define p2 (make-polynomial 'x '((3 1) (1 -1))))
(greatest-common-divisor p1 p2)
</pre></p>
<p></p>
<p>and check your result by hand.</p>
<p> </p>
<p></p>
<p><a name="%_thm_2.95" id="%_thm_2.95"></a><b>Exercise 2.95.</b>  Define <em>P</em><sub>1</sub>, <em>P</em><sub>2</sub>, and <em>P</em><sub>3</sub> to be the polynomials</p><p><em>P</em><sub>1</sub>:    <em>x</em><sup>2</sup> - 2<em>x</em> + 1</p><p><em>P</em><sub>2</sub>:    11<em>x</em><sup>2</sup> + 7</p><p><em>P</em><sub>3</sub>:    13<em>x</em> + 5</p><p>Now define <em>Q</em><sub>1</sub> to be the product of <em>P</em><sub>1</sub> and <em>P</em><sub>2</sub> and <em>Q</em><sub>2</sub> tobe the product of <em>P</em><sub>1</sub> and <em>P</em><sub>3</sub>, and use <code>greatest-common-divisor</code>(exercise <a href="#%_thm_2.94">2.94</a>) tocompute the GCD of <em>Q</em><sub>1</sub> and <em>Q</em><sub>2</sub>.Note that the answer is not the same as <em>P</em><sub>1</sub>.This example introduces nonintegeroperations into the computation, causing difficulties with the GCDalgorithm.<a name="call_footnote_Temp_317" href="#footnote_Temp_317" id="call_footnote_Temp_317"><sup><small>61</small></sup></a>To understand what is happening,try tracing <code>gcd-terms</code> while computing the GCD ortry performing the division by hand.</p>
<p> </p>
<p></p>
<p></p>
<p>We can solve the problem exhibited in exercise <a href="#%_thm_2.95">2.95</a> ifwe use the following modification of the GCD algorithm (which reallyworks only in the case of polynomials with integer coefficients).Before performing any polynomial division in the GCD computation, wemultiply the dividend by an integer constant factor, chosen toguarantee that no fractions will arise during the division process.Our answer will thus differ from the actual GCD by an integer constantfactor, but this does not matter in the case of reducing rationalfunctions to lowest terms; the GCD will be used to divide both thenumerator and denominator, so the integer constant factor will cancelout.</p>
<p>More precisely, if <em>P</em> and <em>Q</em> are polynomials, let <em>O</em><sub>1</sub> be theorder of <em>P</em> (i.e., the order of the largest term of <em>P</em>) and let<em>O</em><sub>2</sub> be the order of <em>Q</em>.  Let <em>c</em> be the leading coefficient of<em>Q</em>.  Then it can be shown that, if we multiply <em>P</em> by the <a name="%_idx_2800" id="%_idx_2800"></a><em>integerizing factor</em> <em>c</em><sup>1+<em>O</em><sub>1</sub> -<em>O</em><sub>2</sub></sup>, the resulting polynomial canbe divided by <em>Q</em> by using the <code>div-terms</code> algorithm withoutintroducing any fractions.  The operation of multiplying the dividendby this constant and then dividing is sometimes called the <a name="%_idx_2802" id="%_idx_2802"></a><a name="%_idx_2804" id="%_idx_2804"></a><em>pseudodivision</em> of <em>P</em> by <em>Q</em>.  The remainder of the division iscalled the <em>pseudoremainder</em>.</p>
<p></p>
<p><a name="%_thm_2.96" id="%_thm_2.96"></a><b>Exercise 2.96.</b>  a.    Implement the procedure <code>pseudoremainder-terms</code>, which is just like<code>remainder-terms</code> except that it multiplies the dividend bythe integerizing factor described above before calling <code>div-terms</code>.Modify <code>gcd-terms</code> to use <code>pseudoremainder-terms</code>, and verifythat <code>greatest-common-divisor</code> now produces an answer with integercoefficients on the example in exercise <a href="#%_thm_2.95">2.95</a>.</p>
<p></p>
<p></p>
<p>b.    The GCD now has integer coefficients, but they are larger than thoseof <em>P</em><sub>1</sub>.  Modify <code>gcd-terms</code> so that it removes common factors fromthe coefficients of the answer by dividing all the coefficients by their(integer) greatest common divisor.</p>
<p></p>
<p></p>
<p><a name="%_idx_2806" id="%_idx_2806"></a><a name="%_idx_2808" id="%_idx_2808"></a>Thus, here is how to reduce a rational function to lowest terms:</p>
<p></p>
<p></p>
<ul>
<li>Compute the GCD of the numerator and denominator, usingthe version of <code>gcd-terms</code> from exercise <a href="#%_thm_2.96">2.96</a>.<p></p>
</li>
<li>When you obtain the GCD, multiply both numerator anddenominator by the same integerizing factor before dividing through bythe GCD, so that division by the GCD will not introduce any nonintegercoefficients.  As the factor you can use the leading coefficient ofthe GCD raised to the power 1 + <em>O</em><sub>1</sub>  - <em>O</em><sub>2</sub>, where <em>O</em><sub>2</sub> is the orderof the GCD and <em>O</em><sub>1</sub> is the maximum of the orders of the numeratorand denominator.  This will ensure that dividing the numerator anddenominator by the GCD will not introduce any fractions.<p></p>
</li>
<li>The result of this operation will be a numerator and denominatorwith integer coefficients.  The coefficients will normally be verylarge because of all of the integerizing factors, so the last step isto remove the redundant factors by computing the (integer) greatestcommon divisor of all the coefficients of the numerator and thedenominator and dividing through by this factor.</li>
</ul>
<p></p>
<p></p>
<p><a name="%_thm_2.97" id="%_thm_2.97"></a><b>Exercise 2.97.</b>  a. Implement this algorithm as a procedure <code>reduce-terms</code> that takes twoterm lists <code>n</code> and <code>d</code> as arguments and returns a list <code>nn</code>, <code>dd</code>, which are <code>n</code> and <code>d</code> reduced to lowest termsvia the algorithm given above.Also write a procedure <code>reduce-poly</code>, analogous to <code>add-poly</code>,that checks to see if the two polys havethe same variable.  If so, <code>reduce-poly</code> strips off the variable andpasses the problem to <code>reduce-terms</code>, then reattaches the variableto the two term lists supplied by <code>reduce-terms</code>.</p>
<p></p>
<p></p>
<p>b. Define a procedure analogous to <code>reduce-terms</code>that does what the original <code>make-rat</code> did for integers:</p>
<p></p>
<p></p>
<p><pre>(define (reduce-integers n d)
  (let ((g (gcd n d)))
    (list (/ n g) (/ d g))))
</pre></p>
<p></p>
<p>and define<code>reduce</code> as a generic operation that calls <code>apply-generic</code> todispatch to either <code>reduce-poly</code> (for <code>polynomial</code> arguments)or <code>reduce-integers</code> (for <code>scheme-number</code> arguments).You can now easily make therational-arithmetic package reduce fractions to lowest terms byhaving <code>make-rat</code> call <code>reduce</code> before combining the givennumerator and denominator to form a rational number.The system nowhandles rational expressions in either integers or polynomials.To test your program, try the example at the beginning of thisextended exercise:</p>
<p></p>
<p></p>
<p><pre>(define p1 (make-polynomial 'x '((1 1)(0 1))))
(define p2 (make-polynomial 'x '((3 1)(0 -1))))
(define p3 (make-polynomial 'x '((1 1))))
(define p4 (make-polynomial 'x '((2 1)(0 -1))))

(define rf1 (make-rational p1 p2))
(define rf2 (make-rational p3 p4))

(add rf1 rf2)
</pre></p>
<p></p>
<p>See if you get the correct answer, correctly reduced to lowest terms.</p>
<p></p>
<p></p>
<p>The GCD computation is at the heart of any system that does operationson rational functions.  The algorithm used above, althoughmathematically straightforward, is extremely slow.  The slowness isdue partly to the large number of division operations and partly tothe enormous size of the intermediate coefficients generated by thepseudodivisions.  One of the active areas in the development ofalgebraic-manipulation systems is the design of better algorithms forcomputing polynomial GCDs.<a name="call_footnote_Temp_320" href="#footnote_Temp_320" id="call_footnote_Temp_320"><sup><small>62</small></sup></a></p>
<p></p>
<p></p>
<div class="smallprint"><hr></div>
<p></p>
<div class="footnote">
<p><a name="footnote_Temp_283" href="#call_footnote_Temp_283" id="footnote_Temp_283"><sup><small>49</small></sup></a> We also have to supply an almost identicalprocedure to handle the types <code>(scheme-number complex)</code>.</p>
<p><a name="footnote_Temp_285" href="#call_footnote_Temp_285" id="footnote_Temp_285"><sup><small>50</small></sup></a> Seeexercise <a href="#%_thm_2.82">2.82</a> for generalizations.</p>
<p><a name="footnote_Temp_286" href="#call_footnote_Temp_286" id="footnote_Temp_286"><sup><small>51</small></sup></a> If we areclever, we can usually get by with fewer than <em>n</em><sup>2</sup> coercionprocedures.  For instance, if we know how to convert from type 1 totype 2 and from type 2 to type 3, then we can use this knowledge toconvert from type 1 to type 3.  This can greatly decrease the numberof coercion procedures we need to supply explicitly when we add a newtype to the system.  If we are willing to build the required amount ofsophistication into our system, we can have it search the “graph” ofrelations among types and automatically generate those coercionprocedures that can be inferred from the ones that are suppliedexplicitly.</p>
<p><a name="footnote_Temp_289" href="#call_footnote_Temp_289" id="footnote_Temp_289"><sup><small>52</small></sup></a> This statement, which also appears in the first edition of this book,is just as true now as it was when we wrote it twelve years ago.Developing a useful, general framework for expressing the relationsamong different types of entities (what philosophers call“ontology”) seems intractably difficult.  The main differencebetween the confusion that existed ten years ago and the confusionthat exists now is that now a variety of inadequate ontologicaltheories have been embodied in a plethora of correspondinglyinadequate programming languages.  For example, much of the complexityof <a name="%_idx_2622" id="%_idx_2622"></a><a name="%_idx_2624" id="%_idx_2624"></a>object-oriented programming languages – and the subtle andconfusing differences among contemporary object-orientedlanguages – centers on the treatment of generic operations oninterrelated types.  Our own discussion of computational objects inchapter 3 avoids these issues entirely.  Readers familiar withobject-oriented programming will notice that we have much to say inchapter 3 about local state, but we do not even mention “classes” or“inheritance.”  In fact, we suspect that these problems cannot beadequately addressed in terms of computer-language design alone,without also drawing on work in knowledge representation and automatedreasoning.</p>
<p><a name="footnote_Temp_295" href="#call_footnote_Temp_295" id="footnote_Temp_295"><sup><small>53</small></sup></a> A real number can be projected to an integerusing the <a name="%_idx_2642" id="%_idx_2642"></a><a name="%_idx_2644" id="%_idx_2644"></a><code>round</code> primitive, which returns the closest integerto its argument.</p>
<p><a name="footnote_Temp_298" href="#call_footnote_Temp_298" id="footnote_Temp_298"><sup><small>54</small></sup></a> On the other hand, we will allowpolynomials whose coefficients are themselves polynomials in othervariables.  This will give us essentially the same representationalpower as a full multivariate system, although it does lead to coercionproblems, as discussed below.</p>
<p><a name="footnote_Temp_299" href="#call_footnote_Temp_299" id="footnote_Temp_299"><sup><small>55</small></sup></a> For univariate polynomials, givingthe value of a polynomial at a given set of points can be aparticularly good representation.  This makes polynomial arithmeticextremely simple.  To obtain, for example, the sum of two polynomialsrepresented in this way, we need only add the values of thepolynomials at corresponding points.  To transform back to a morefamiliar representation, we can use the <a name="%_idx_2662" id="%_idx_2662"></a>Lagrange interpolationformula, which shows how to recover the coefficients of a polynomialof degree <em>n</em> given the values of the polynomial at <em>n</em> + 1 points.</p>
<p><a name="footnote_Temp_300" href="#call_footnote_Temp_300" id="footnote_Temp_300"><sup><small>56</small></sup></a> This operation is very much like the ordered<code>union-set</code> operation we developed in exercise  <a href="book-Z-H-16.html#%_thm_2.62">2.62</a>.In fact, if we think of the terms of the polynomial as a set orderedaccording to the power of the indeterminate, then the program thatproduces the term list for a sum is almost identical to <code>union-set</code>.</p>
<p><a name="footnote_Temp_301" href="#call_footnote_Temp_301" id="footnote_Temp_301"><sup><small>57</small></sup></a> To makethis work completely smoothly, we should also add to our genericarithmetic system the ability to coerce a “number” to a polynomialby regarding it as a polynomial of degree zero whose coefficient isthe number.  This is necessary if we are going to perform operationssuch as</p><p>[<em>x</em><sup>2</sup> + (<em>y</em> + 1)<em>x</em> + 5] + [<em>x</em><sup>2</sup> + 2<em>x</em> + 1]</p><p>which requires adding the coefficient <em>y</em> + 1 to the coefficient 2.</p>
<p><a name="footnote_Temp_303" href="#call_footnote_Temp_303" id="footnote_Temp_303"><sup><small>58</small></sup></a> In these polynomial examples,we assume that we have implemented the generic arithmetic system usingthe type mechanism suggested in exercise <a href="#%_thm_2.78">2.78</a>.Thus, coefficients that are ordinary numbers will be represented asthe numbers themselves rather than as pairs whose <code>car</code> is thesymbol <code>scheme-number</code>.</p>
<p><a name="footnote_Temp_304" href="#call_footnote_Temp_304" id="footnote_Temp_304"><sup><small>59</small></sup></a> Althoughwe are assuming that termlists are ordered, we have implemented <code>adjoin-term</code> to simply<code>cons</code> the new term onto the existing term list.  We can get awaywith this so long as we guarantee that the procedures (such as <code>add-terms</code>) that use <code>adjoin-term</code> always call it with a higher-orderterm than appears in the list.  If we did not want to make such aguarantee, we could have implemented <code>adjoin-term</code> to be similarto the <code>adjoin-set</code> constructor for the ordered-listrepresentation of sets (exercise <a href="book-Z-H-16.html#%_thm_2.61">2.61</a>).</p>
<p><a name="footnote_Temp_314" href="#call_footnote_Temp_314" id="footnote_Temp_314"><sup><small>60</small></sup></a> The factthat <a name="%_idx_2786" id="%_idx_2786"></a><a name="%_idx_2788" id="%_idx_2788"></a>Euclid's Algorithm works for polynomials is formalized in algebraby saying that polynomials form a kind of algebraic domain called a<a name="%_idx_2790" id="%_idx_2790"></a><a name="%_idx_2792" id="%_idx_2792"></a><em>Euclidean ring</em>.  A Euclidean ring is a domain that admitsaddition, subtraction, and commutative multiplication, together with away of assigning to each element <em>x</em> of the ring a positive integer“measure” <em>m</em>(<em>x</em>) with the properties that <em>m</em>(<em>x</em><em>y</em>)<u>&gt;</u> <em>m</em>(<em>x</em>) forany nonzero <em>x</em> and <em>y</em> and that, given any <em>x</em> and <em>y</em>, there existsa <em>q</em> such that <em>y</em> = <em>q</em><em>x</em> + <em>r</em> and either <em>r</em> = 0 or <em>m</em>(<em>r</em>)&lt; <em>m</em>(<em>x</em>).  From anabstract point of view, this is what is needed to prove that Euclid'sAlgorithm works.  For the domain of integers, the measure <em>m</em> of aninteger is the absolute value of the integer itself.  For the domainof polynomials, the measure of a polynomial is its degree.</p>
<p><a name="footnote_Temp_317" href="#call_footnote_Temp_317" id="footnote_Temp_317"><sup><small>61</small></sup></a> In an implementation like MIT Scheme, this produces a polynomialthat is indeed a divisor of <em>Q</em><sub>1</sub> and <em>Q</em><sub>2</sub>, but with rational coefficients.In many other Scheme systems, in which division of integers can producelimited-precision decimal numbers, we may fail to get a valid divisor.</p>
<p><a name="footnote_Temp_320" href="#call_footnote_Temp_320" id="footnote_Temp_320"><sup><small>62</small></sup></a> One extremely efficient andelegant method for computing <a name="%_idx_2810" id="%_idx_2810"></a><a name="%_idx_2812" id="%_idx_2812"></a><a name="%_idx_2814" id="%_idx_2814"></a><a name="%_idx_2816" id="%_idx_2816"></a>polynomial GCDs was discovered by <a name="%_idx_2818" id="%_idx_2818"></a>RichardZippel (1979).  The method is a probabilistic algorithm, as is thefast test for primality that we discussed in chapter 1.  Zippel's book(1993) describes this method, together with other ways to computepolynomial GCDs.</p>
</div></body>
</html>
