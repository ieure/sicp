<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<?xml version="1.0" encoding="utf-8"?><html xmlns="http://www.w3.org/1999/xhtml" xmlns:ops="http://www.idpf.org/2007/ops">
<!-- Generated from TeX source by tex2page, v 4o,
     (c) Dorai Sitaram, http://www.cs.rice.edu/~dorai/tex2page --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Type: text/html; charset=utf-8">
<title>Structure and Interpretation of Computer Programs</title>
<link rel="stylesheet" type="text/css" href="book-Z-C.css" title="default">
</head>
<body><a name="%_sec_3.3" id="%_sec_3.3"></a><h2><a href="book-Z-H-4.html#%_toc_%_sec_3.3">3.3  Modeling with Mutable Data</a></h2>
<p><a name="%_idx_3128" id="%_idx_3128"></a>Chapter 2 dealt with compound data as a means for constructingcomputational objects that have several parts, in order to modelreal-world objects that have several aspects.  In that chapter weintroduced the discipline of data abstraction, according to which datastructures are specified in terms of constructors, which create dataobjects, and selectors, which access the parts of compound dataobjects.  But we now know that there is another aspect of data thatchapter 2 did not address.  The desire to model systems composed ofobjects that have changing state leads us to the need to modifycompound data objects, as well as to construct and select from them.In order to model compound objects with changing state, we will designdata abstractions to include, in addition to selectors andconstructors, operations called <a name="%_idx_3130" id="%_idx_3130"></a><em>mutators</em>, which modify dataobjects.  For instance, modeling a banking system requires us tochange account balances.  Thus, a data structure for representing bankaccounts might admit an operation</p>
<p></p>
<p></p>
<p><pre>(set-balance! &lt;<em>account</em>&gt; &lt;<em>new-value</em>&gt;)
</pre></p>
<p></p>
<p>that changes the balance of the designated account to the designatednew value.  Data objects for which mutators are defined are known as<em>mutable data objects</em>.</p>
<p>Chapter 2 introduced pairs as a general-purpose “glue” forsynthesizing compound data.  We begin this section by defining basicmutators for pairs, so that pairs can serve as building blocks forconstructing mutable data objects.  These mutators greatly enhance therepresentational power of pairs, enabling us to build data structuresother than the sequences and trees that we worked with insection <a href="book-Z-H-15.html#%_sec_2.2">2.2</a>.  We also present some examples ofsimulations in which complex systems are modeled as collections ofobjects with local state.</p>
<p><a name="%_sec_3.3.1" id="%_sec_3.3.1"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_3.3.1">3.3.1  Mutable List Structure</a></h3>
<p><a name="%_idx_3132" id="%_idx_3132"></a><a name="%_idx_3134" id="%_idx_3134"></a><a name="%_idx_3136" id="%_idx_3136"></a><a name="%_idx_3138" id="%_idx_3138"></a>The basic operations on pairs – <code>cons</code>, <code>car</code>, and <code>cdr</code> – can be used to construct list structure and to select partsfrom list structure, but they are incapable of modifying liststructure.  The same is true of the list operations we have used sofar, such as <code>append</code> and <code>list</code>, since these can be definedin terms of <code>cons</code>, <code>car</code>, and <code>cdr</code>.  To modify liststructures we need new operations.</p>
<p><a name="%_fig_3.12" id="%_fig_3.12"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch3-Z-G-13.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 3.12:</b>  Lists <code>x</code>: <code>((a b) c d)</code> and <code>y</code>: <code>(ef)</code>.</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p><a name="%_fig_3.13" id="%_fig_3.13"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch3-Z-G-14.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 3.13:</b>  Effect of <code>(set-car! x y)</code> on the lists infigure <a href="#%_fig_3.12">3.12</a>.</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p><a name="%_fig_3.14" id="%_fig_3.14"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch3-Z-G-15.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 3.14:</b>  Effect of <code>(define z (cons y (cdr x)))</code> onthe lists in figure <a href="#%_fig_3.12">3.12</a>.</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p><a name="%_fig_3.15" id="%_fig_3.15"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch3-Z-G-16.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 3.15:</b>  Effect of <code>(set-cdr! x y)</code> on the lists infigure <a href="#%_fig_3.12">3.12</a>.</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p><a name="%_idx_3140" id="%_idx_3140"></a><a name="%_idx_3142" id="%_idx_3142"></a><a name="%_idx_3144" id="%_idx_3144"></a><a name="%_idx_3146" id="%_idx_3146"></a>The primitive mutators for pairs are <code>set-car!</code> and <code>set-cdr!</code>. <code>Set-car!</code> takes two arguments, the first of whichmust be a pair.  It modifies this pair, replacing the <code>car</code>pointer by a pointer to the second argument of <code>set-car!</code>.<a name="call_footnote_Temp_349" href="#footnote_Temp_349" id="call_footnote_Temp_349"><sup><small>16</small></sup></a></p>
<p>As an example, suppose that <code>x</code> is bound to the list <code>((a b) cd)</code> and <code>y</code> to the list <code>(e f)</code> as illustrated infigure <a href="#%_fig_3.12">3.12</a>.  Evaluating the expression <code>(set-car!x y)</code> modifies the pair to which <code>x</code> is bound, replacing its <code>car</code> by the value of <code>y</code>.  The result of the operation is shown infigure <a href="#%_fig_3.13">3.13</a>.  The structure <code>x</code> has been modified andwould now be printedas <code>((e f) c d)</code>.  Thepairs representing the list <code>(a b)</code>, identified by the pointerthat was replaced, are now detached from the originalstructure.<a name="call_footnote_Temp_350" href="#footnote_Temp_350" id="call_footnote_Temp_350"><sup><small>17</small></sup></a></p>
<p>Compare figure <a href="#%_fig_3.13">3.13</a> with figure <a href="#%_fig_3.14">3.14</a>,which illustrates the result of executing <code>(define z (cons y (cdrx)))</code> with <code>x</code> and <code>y</code> bound to the original lists offigure <a href="#%_fig_3.12">3.12</a>.  The variable <code>z</code> is now bound to anew pair created by the <code>cons</code> operation; the list to which <code>x</code> is bound is unchanged.</p>
<p>The <code>set-cdr!</code> operation is similar to <code>set-car!</code>.  Theonly difference is that the <code>cdr</code> pointer of the pair, rather thanthe <code>car</code> pointer, is replaced.  The effect of executing <code>(set-cdr! x y)</code> on the lists of figure <a href="#%_fig_3.12">3.12</a> is shownin figure <a href="#%_fig_3.15">3.15</a>.Here the <code>cdr</code> pointer of <code>x</code> has been replaced by the pointerto <code>(e f)</code>.  Also, the list <code>(c d)</code>, which used to be the <code>cdr</code> of <code>x</code>, is now detached from the structure.</p>
<p><a name="%_idx_3158" id="%_idx_3158"></a><code>Cons</code> builds new list structure by creating new pairs, while<code>set-car!</code> and <code>set-cdr!</code> modify existing pairs.  Indeed, wecould implement <code>cons</code> in terms of the two mutators, together witha procedure <code>get-new-pair</code>, which returns a new pair that is notpart of any existing list structure.  We obtain the new pair, set its<code>car</code> and <code>cdr</code> pointers to the designated objects, and returnthe new pair as the result of the <code>cons</code>.<a name="call_footnote_Temp_351" href="#footnote_Temp_351" id="call_footnote_Temp_351"><sup><small>18</small></sup></a></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3160" id="%_idx_3160"></a>(define (cons x y)
  (let ((new (get-new-pair)))
    (set-car! new x)
    (set-cdr! new y)
    new))
</pre></p>
<p></p>
<p></p>
<p><a name="%_thm_3.12" id="%_thm_3.12"></a><b>Exercise 3.12.</b>  <a name="%_idx_3162" id="%_idx_3162"></a>The following procedure for appending lists was introduced insection <a href="book-Z-H-15.html#%_sec_2.2.1">2.2.1</a>:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3164" id="%_idx_3164"></a>(define (append x y)
  (if (null? x)
      y
      (cons (car x) (append (cdr x) y))))
</pre></p>
<p></p>
<p><code>Append</code> forms a new list by successively <code>cons</code>ing theelements of <code>x</code> onto <code>y</code>.  The procedure <code>append!</code> issimilar to <code>append</code>, but it is a mutator rather than a constructor.It appends the lists by splicing them together, modifying the finalpair of <code>x</code> so that its <code>cdr</code> is now <code>y</code>.(It is an error to call <code>append!</code> with an empty <code>x</code>.)</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3166" id="%_idx_3166"></a>(define (append! x y)
  (set-cdr! (last-pair x) y)
  x)
</pre></p>
<p></p>
<p>Here <code>last-pair</code> is a procedure that returns the last pair in itsargument:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3168" id="%_idx_3168"></a>(define (last-pair x)
  (if (null? (cdr x))
      x
      (last-pair (cdr x))))
</pre></p>
<p></p>
<p>Consider the interaction</p>
<p></p>
<p></p>
<p><pre>(define x (list 'a 'b))
(define y (list 'c 'd))
(define z (append x y))
z
<i>(a b c d)</i>
(cdr x)
&lt;<em>response</em>&gt;
(define w (append! x y))
w
<i>(a b c d)</i>
(cdr x)
&lt;<em>response</em>&gt;
</pre></p>
<p></p>
<p>What are the missing &lt;<em>response</em>&gt;s?Draw box-and-pointer diagrams to explain your answer.</p>
<p></p>
<p></p>
<p><a name="%_thm_3.13" id="%_thm_3.13"></a><b>Exercise 3.13.</b>  <a name="%_idx_3170" id="%_idx_3170"></a>Consider the following <code>make-cycle</code> procedure, which uses the <code>last-pair</code> procedure defined in exercise <a href="#%_thm_3.12">3.12</a>:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3172" id="%_idx_3172"></a>(define (make-cycle x)
  (set-cdr! (last-pair x) x)
  x)
</pre></p>
<p></p>
<p>Draw a box-and-pointer diagram that shows the structure <code>z</code>created by</p>
<p></p>
<p></p>
<p><pre>(define z (make-cycle (list 'a 'b 'c)))
</pre></p>
<p></p>
<p>What happens if we try to compute <code>(last-pair z)</code>?</p>
<p></p>
<p></p>
<p><a name="%_thm_3.14" id="%_thm_3.14"></a><b>Exercise 3.14.</b>  The following procedure is quite useful, although obscure:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3174" id="%_idx_3174"></a>(define (mystery x)
  (define (loop x y)
    (if (null? x)
        y
        (let ((temp (cdr x)))
          (set-cdr! x y)
          (loop temp x))))
  (loop x '()))
</pre></p>
<p></p>
<p><code>Loop</code> uses the “temporary” variable <code>temp</code> to holdthe old value of the <code>cdr</code> of <code>x</code>, since the <code>set-cdr!</code>on the next line destroys the <code>cdr</code>.  Explain what <code>mystery</code>does in general.  Suppose <code>v</code> is defined by <code>(define v (list 'a'b 'c 'd))</code>. Draw the box-and-pointer diagram that represents the listto which <code>v</code> is bound.  Suppose that we now evaluate <code>(definew (mystery v))</code>. Draw box-and-pointer diagrams that show thestructures <code>v</code> and <code>w</code> after evaluating this expression.  Whatwould be printed as the values of <code>v</code> and <code>w</code> ?</p>
<p><a name="%_sec_Temp_355" id="%_sec_Temp_355"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_355">Sharing and identity</a></h4>
<p><a name="%_idx_3176" id="%_idx_3176"></a><a name="%_idx_3178" id="%_idx_3178"></a><a name="%_idx_3180" id="%_idx_3180"></a><a name="%_idx_3182" id="%_idx_3182"></a>We mentioned in section <a href="book-Z-H-20.html#%_sec_3.1.3">3.1.3</a> the theoreticalissues of “sameness” and “change” raised by the introduction ofassignment.  These issues arise in practice when individual pairs are<em>shared</em> among different data objects.  For example, consider thestructure formed by</p>
<p></p>
<p></p>
<p><pre>(define x (list 'a 'b))
(define z1 (cons x x))
</pre></p>
<p></p>
<p>As shown in figure <a href="#%_fig_3.16">3.16</a>, <code>z1</code> is a pair whose <code>car</code> and <code>cdr</code> both point to the same pair <code>x</code>.  This sharingof <code>x</code> by the <code>car</code> and <code>cdr</code> of <code>z1</code> is a consequenceof the straightforward way in which <code>cons</code> is implemented.  Ingeneral, using <code>cons</code> to construct lists will result in aninterlinked structure of pairs in which many individual pairs areshared by many different structures.</p>
<p><a name="%_fig_3.16" id="%_fig_3.16"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch3-Z-G-17.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 3.16:</b>  The list <code>z1</code> formed by <code>(cons x x)</code>.</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p><a name="%_fig_3.17" id="%_fig_3.17"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch3-Z-G-18.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 3.17:</b>  The list <code>z2</code> formed by<code>(cons (list 'a 'b) (list 'a 'b))</code>.</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p>In contrast to figure <a href="#%_fig_3.16">3.16</a>, figure <a href="#%_fig_3.17">3.17</a> showsthe structure created by</p>
<p></p>
<p></p>
<p><pre>(define z2 (cons (list 'a 'b) (list 'a 'b)))
</pre></p>
<p></p>
<p>In this structure, the pairs in the two <code>(a b)</code> lists aredistinct, although the actual symbols are shared.<a name="call_footnote_Temp_356" href="#footnote_Temp_356" id="call_footnote_Temp_356"><sup><small>19</small></sup></a></p>
<p>When thought of as a list, <code>z1</code> and <code>z2</code> both represent “thesame” list, <code>((a b) a b)</code>.  In general, sharing is completelyundetectable if we operate on lists using only <code>cons</code>, <code>car</code>,and <code>cdr</code>.  However, if we allow mutators on list structure,sharing becomes significant.  As an example of the difference thatsharing can make, consider the following procedure, which modifies the<code>car</code> of the structure to which it is applied:</p>
<p></p>
<p></p>
<p><pre>(define (set-to-wow! x)
  (set-car! (car x) 'wow)
  x)
</pre></p>
<p></p>
<p>Even though <code>z1</code> and <code>z2</code> are “the same” structure,applying <code>set-to-wow!</code> to them yields different results.  With<code>z1</code>, altering the <code>car</code> also changes the <code>cdr</code>, becausein <code>z1</code> the <code>car</code> and the <code>cdr</code> are the same pair.  With<code>z2</code>, the <code>car</code> and <code>cdr</code> are distinct, so <code>set-to-wow!</code> modifies only the <code>car</code>:</p>
<p></p>
<p></p>
<p><pre>z1
<i>((a b) a b)</i>

(set-to-wow! z1)
<i>((wow b) wow b)</i>

z2
<i>((a b) a b)</i>

(set-to-wow! z2)
<i>((wow b) a b)</i>
</pre></p>
<p></p>
<p></p>
<p>One way to detect sharing in list structures is to use the predicate<a name="%_idx_3186" id="%_idx_3186"></a><a name="%_idx_3188" id="%_idx_3188"></a><code>eq?</code>, which we introduced in section <a href="book-Z-H-16.html#%_sec_2.3.1">2.3.1</a> as away to test whether two symbols are equal.  More generally, <code>(eq?x y)</code> tests whether <code>x</code> and <code>y</code> are the same object (that is,whether <code>x</code> and <code>y</code> are equal as pointers).  Thus, with <code>z1</code> and <code>z2</code> as defined in figures <a href="#%_fig_3.16">3.16</a>and <a href="#%_fig_3.17">3.17</a>, <code>(eq? (car z1) (cdr z1))</code> is true and<code>(eq? (car z2) (cdr z2))</code> is false.</p>
<p><a name="%_idx_3190" id="%_idx_3190"></a>As will be seen in the following sections, we can exploit sharing togreatly extend the repertoire of data structures that can berepresented by pairs.  On the other hand, sharing can also bedangerous, since modifications made to structures will also affectother structures that happen to share the modified parts.  Themutation operations <code>set-car!</code> and <code>set-cdr!</code> should be usedwith care; unless we have a good understanding of how our data objectsare shared, mutation can have unanticipated results.<a name="call_footnote_Temp_357" href="#footnote_Temp_357" id="call_footnote_Temp_357"><sup><small>20</small></sup></a></p>
<p></p>
<p><a name="%_thm_3.15" id="%_thm_3.15"></a><b>Exercise 3.15.</b>  Draw box-and-pointer diagrams to explain the effect of <code>set-to-wow!</code> on the structures <code>z1</code> and <code>z2</code> above.</p>
<p></p>
<p></p>
<p><a name="%_thm_3.16" id="%_thm_3.16"></a><b>Exercise 3.16.</b>  Ben Bitdiddle decides to write a procedure to count the number ofpairs in any list structure.  “It's easy,” he reasons.  “The numberof pairs in any structure is the number in the <code>car</code> plus thenumber in the <code>cdr</code> plus one more to count the current pair.”So Ben writes the following procedure:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3192" id="%_idx_3192"></a>(define (count-pairs x)
  (if (not (pair? x))
      0
      (+ (count-pairs (car x))
         (count-pairs (cdr x))
         1)))
</pre></p>
<p></p>
<p>Show that this procedure is not correct.  In particular, drawbox-and-pointer diagrams representing list structures made up ofexactly three pairs for which Ben's procedure would return 3; return4; return 7; never return at all.</p>
<p></p>
<p></p>
<p><a name="%_thm_3.17" id="%_thm_3.17"></a><b>Exercise 3.17.</b>  Devise a correct version of the <code>count-pairs</code> procedure ofexercise <a href="#%_thm_3.16">3.16</a> that returns the number of distinctpairs in any structure.  (Hint: Traverse the structure, maintaining anauxiliary data structure that is used to keep track of which pairshave already been counted.)</p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_3.18" id="%_thm_3.18"></a><b>Exercise 3.18.</b>  <a name="%_idx_3194" id="%_idx_3194"></a>Write a procedure that examines a list and determines whether itcontains a cycle, that is, whether a program that tried to find theend of the list by taking successive <code>cdr</code>s would go into aninfinite loop.  Exercise <a href="#%_thm_3.13">3.13</a> constructed such lists.</p>
<p></p>
<p></p>
<p><a name="%_thm_3.19" id="%_thm_3.19"></a><b>Exercise 3.19.</b>  Redo exercise <a href="#%_thm_3.18">3.18</a> using an algorithm that takes only aconstant amount of space.  (This requires a very clever idea.)</p>
<p><a name="%_sec_Temp_363" id="%_sec_Temp_363"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_363">Mutation is just assignment</a></h4>
<p><a name="%_idx_3196" id="%_idx_3196"></a><a name="%_idx_3198" id="%_idx_3198"></a><a name="%_idx_3200" id="%_idx_3200"></a><a name="%_idx_3202" id="%_idx_3202"></a>When we introduced compound data, we observed insection <a href="book-Z-H-14.html#%_sec_2.1.3">2.1.3</a> that pairs can be represented purely in termsof procedures:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3204" id="%_idx_3204"></a>(define (cons x y)
  (define (dispatch m)
    (cond ((eq? m 'car) x)
          ((eq? m 'cdr) y)
          (else (error "Undefined operation -- CONS" m))))
  dispatch)
<a name="%_idx_3206" id="%_idx_3206"></a>(define (car z) (z 'car))
<a name="%_idx_3208" id="%_idx_3208"></a>(define (cdr z) (z 'cdr))
</pre></p>
<p></p>
<p>The same observation is true for mutable data.  We can implementmutable data objects as procedures using assignment and local state.For instance, we can extend the above pair implementation to handle<code>set-car!</code> and <code>set-cdr!</code> in a manner analogous to the waywe implemented bank accounts using <code>make-account</code> insection <a href="book-Z-H-20.html#%_sec_3.1.1">3.1.1</a>:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3210" id="%_idx_3210"></a>(define (cons x y)
  (define (set-x! v) (set! x v))
  (define (set-y! v) (set! y v))
  (define (dispatch m)
    (cond ((eq? m 'car) x)
          ((eq? m 'cdr) y)
          ((eq? m 'set-car!) set-x!)
          ((eq? m 'set-cdr!) set-y!)
          (else (error "Undefined operation -- CONS" m))))
  dispatch)
<a name="%_idx_3212" id="%_idx_3212"></a>(define (car z) (z 'car))
<a name="%_idx_3214" id="%_idx_3214"></a>(define (cdr z) (z 'cdr))
<a name="%_idx_3216" id="%_idx_3216"></a>(define (set-car! z new-value)
  ((z 'set-car!) new-value)
  z)
<a name="%_idx_3218" id="%_idx_3218"></a>(define (set-cdr! z new-value)
  ((z 'set-cdr!) new-value)
  z)
</pre></p>
<p></p>
<p></p>
<p>Assignment is all that is needed, theoretically, to account for thebehavior of mutable data.  As soon as we admit <code>set!</code> to ourlanguage, we raise all the issues, not only of assignment, but ofmutable data in general.<a name="call_footnote_Temp_364" href="#footnote_Temp_364" id="call_footnote_Temp_364"><sup><small>21</small></sup></a></p>
<p></p>
<p><a name="%_thm_3.20" id="%_thm_3.20"></a><b>Exercise 3.20.</b>  Draw environment diagrams to illustrate the evaluation of the sequenceof expressions</p>
<p></p>
<p></p>
<p><pre>(define x (cons 1 2))
(define z (cons x x))
(set-car! (cdr z) 17)
(car x)
<i>17</i>
</pre></p>
<p></p>
<p>using the procedural implementation of pairs given above.  (Compareexercise <a href="book-Z-H-21.html#%_thm_3.11">3.11</a>.)</p>
<p><a name="%_sec_3.3.2" id="%_sec_3.3.2"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_3.3.2">3.3.2  Representing Queues</a></h3>
<p><a name="%_idx_3220" id="%_idx_3220"></a>The mutators <code>set-car!</code> and <code>set-cdr!</code> enable us to usepairs to construct data structures that cannot be built with <code>cons</code>, <code>car</code>, and <code>cdr</code> alone.  This section shows how to usepairs to represent a data structure called a queue.  Section <a href="#%_sec_3.3.3">3.3.3</a>will show how to represent data structures called tables.</p>
<p>A <em>queue</em> is a sequence in which items are inserted at one end(called the <a name="%_idx_3222" id="%_idx_3222"></a><em>rear</em> of the queue) and deleted from the other end(the <a name="%_idx_3224" id="%_idx_3224"></a><em>front</em>).  Figure <a href="#%_fig_3.18">3.18</a> shows an initially emptyqueue in which the items <code>a</code> and <code>b</code> are inserted.  Then <code>a</code> is removed, <code>c</code> and <code>d</code> are inserted, and <code>b</code> isremoved.  Because items are always removed in the order in which theyare inserted, a queue is sometimes called a <a name="%_idx_3226" id="%_idx_3226"></a><em>FIFO</em> (first in,first out) buffer.</p>
<p><a name="%_fig_3.18" id="%_fig_3.18"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><table border="0">
<tr>
<td valign="top">Operation </td>
<td valign="top">Resulting Queue  </td>
</tr>
<tr>
<td valign="top">
<code>(define q (make-queue))</code> </td>
<td valign="top"></td>
</tr>
<tr>
<td valign="top">
<code>(insert-queue! q 'a)</code> </td>
<td valign="top"><code>a</code></td>
</tr>
<tr>
<td valign="top">
<code>(insert-queue! q 'b)</code> </td>
<td valign="top"><code>a b</code></td>
</tr>
<tr>
<td valign="top">
<code>(delete-queue! q)</code> </td>
<td valign="top"><code>b</code></td>
</tr>
<tr>
<td valign="top">
<code>(insert-queue! q 'c)</code> </td>
<td valign="top"><code>b c</code></td>
</tr>
<tr>
<td valign="top">
<code>(insert-queue! q 'd)</code> </td>
<td valign="top"><code>b c d</code></td>
</tr>
<tr>
<td valign="top">
<code>(delete-queue! q)</code> </td>
<td valign="top">
<code>c d</code></td>
</tr>
</table></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 3.18:</b>  Queue operations.</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p><a name="%_idx_3228" id="%_idx_3228"></a><a name="%_idx_3230" id="%_idx_3230"></a>In terms of data abstraction, we can regard a queue as defined by thefollowing set of operations:</p>
<p></p>
<ul>
<li>a constructor:
<a name="%_idx_3232" id="%_idx_3232"></a><code>(make-queue)</code>
returns an empty queue (a queue containing no items).<p></p>
</li>
<li>two selectors:
<a name="%_idx_3234" id="%_idx_3234"></a><code>(empty-queue? &lt;<em>queue</em>&gt;)</code>
tests if the queue is empty.
<a name="%_idx_3236" id="%_idx_3236"></a><code>(front-queue &lt;<em>queue</em>&gt;)</code>
returns the object at the front ofthe queue, signaling an error if the queue is empty; it does notmodify the queue.<p></p>
</li>
<li>two mutators:
<a name="%_idx_3238" id="%_idx_3238"></a><code>(insert-queue! &lt;<em>queue</em>&gt; &lt;<em>item</em>&gt;)</code>
inserts the item at the rear of the queue and returns the modifiedqueue as its value.
<a name="%_idx_3240" id="%_idx_3240"></a><code>(delete-queue! &lt;<em>queue</em>&gt;)</code>
removes the item at thefront of the queue and returns the modified queue as its value,signaling an error if the queue is empty before the deletion.</li>
</ul>
<p></p>
<p>Because a queue is a sequence of items, we could certainly representit as an ordinary list; the front of the queue would be the <code>car</code>of the list, inserting an item in the queue would amount to appendinga new element at the end of the list, and deleting an item from thequeue would just be taking the <code>cdr</code> of the list.  However, thisrepresentation is inefficient, because in order to insert an item wemust scan the list until we reach the end.  Since the only method wehave for scanning a list is by successive <code>cdr</code> operations, thisscanning requires θ(<em>n</em>) steps for a list of <em>n</em> items.  A simplemodification to the list representation overcomes this disadvantage byallowing the queue operations to be implemented so that they requireθ(1) steps; that is, so that the number of stepsneeded is independent of the length of the queue.</p>
<p>The difficulty with the list representation arises from the need toscan to find the end of the list.  The reason we need to scan is that,although the standard way of representing a list as a chain of pairsreadily provides us with a pointer to the beginning of the list, itgives us no easily accessible pointer to the end.  The modificationthat avoids the drawback is to represent the queue as a list, togetherwith an additional pointer that indicates the final pair in the list.That way, when we go to insert an item, we can consult the rearpointer and so avoid scanning the list.</p>
<p>A queue is represented, then, as a pair of pointers, <code>front-ptr</code>and <code>rear-ptr</code>, which indicate, respectively, the first and lastpairs in an ordinary list.  Since we would like the queue to be anidentifiable object, we can use <code>cons</code> to combine the twopointers.  Thus, the queue itself will be the <code>cons</code> of the twopointers.  Figure <a href="#%_fig_3.19">3.19</a> illustrates thisrepresentation.</p>
<p><a name="%_fig_3.19" id="%_fig_3.19"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch3-Z-G-19.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 3.19:</b>  Implementation of a queue as a list with front and rearpointers.</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p>To define the queue operations we use the following procedures, whichenable us to select and to modify the front and rear pointers of aqueue:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3242" id="%_idx_3242"></a>(define (front-ptr queue) (car queue))
<a name="%_idx_3244" id="%_idx_3244"></a>(define (rear-ptr queue) (cdr queue))
<a name="%_idx_3246" id="%_idx_3246"></a>(define (set-front-ptr! queue item) (set-car! queue item))
<a name="%_idx_3248" id="%_idx_3248"></a>(define (set-rear-ptr! queue item) (set-cdr! queue item))
</pre></p>
<p></p>
<p></p>
<p>Now we can implement the actual queue operations.  We will consider aqueue to be empty if its front pointer is the empty list:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3250" id="%_idx_3250"></a>(define (empty-queue? queue) (null? (front-ptr queue)))
</pre></p>
<p></p>
<p>The <code>make-queue</code> constructor returns, as an initially empty queue,a pair whose <code>car</code> and <code>cdr</code> are both the empty list:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3252" id="%_idx_3252"></a>(define (make-queue) (cons '() '()))
</pre></p>
<p></p>
<p>To select the item at the front of the queue, we return the <code>car</code>of the pair indicated by the front pointer:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3254" id="%_idx_3254"></a>(define (front-queue queue)
  (if (empty-queue? queue)
      (error "FRONT called with an empty queue" queue)
      (car (front-ptr queue))))
</pre></p>
<p></p>
<p></p>
<p>To insert an item in a queue, we follow the method whose result isindicated in figure <a href="#%_fig_3.20">3.20</a>.  We first create a newpair whose <code>car</code> is the item to be inserted and whose <code>cdr</code> isthe empty list.  If the queue was initially empty, we set the front andrear pointers of the queue to this new pair.  Otherwise, we modify thefinal pair in the queue to point to the new pair, and also set therear pointer to the new pair.</p>
<p><a name="%_fig_3.20" id="%_fig_3.20"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch3-Z-G-20.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 3.20:</b>  Result of using <code>(insert-queue! q 'd)</code>on the queue of figure <a href="#%_fig_3.19">3.19</a>.</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3256" id="%_idx_3256"></a>(define (insert-queue! queue item)
  (let ((new-pair (cons item '())))
    (cond ((empty-queue? queue)
           (set-front-ptr! queue new-pair)
           (set-rear-ptr! queue new-pair)
           queue)
          (else
           (set-cdr! (rear-ptr queue) new-pair)
           (set-rear-ptr! queue new-pair)
           queue)))) 
</pre></p>
<p></p>
<p></p>
<p>To delete the item at the front of the queue, we merely modify thefront pointer so that it now points at the second item in the queue,which can be found by following the <code>cdr</code> pointer of the firstitem (see figure <a href="#%_fig_3.21">3.21</a>):<a name="call_footnote_Temp_366" href="#footnote_Temp_366" id="call_footnote_Temp_366"><sup><small>22</small></sup></a></p>
<p><a name="%_fig_3.21" id="%_fig_3.21"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch3-Z-G-21.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 3.21:</b>  Result of using <code>(delete-queue! q)</code> onthe queue of figure <a href="#%_fig_3.20">3.20</a>.</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3258" id="%_idx_3258"></a>(define (delete-queue! queue)
  (cond ((empty-queue? queue)
         (error "DELETE! called with an empty queue" queue))
        (else
         (set-front-ptr! queue (cdr (front-ptr queue)))
         queue))) 
</pre></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_3.21" id="%_thm_3.21"></a><b>Exercise 3.21.</b>  Ben Bitdiddle decides to test the queue implementation describedabove.  He types in the procedures to the Lisp interpreter andproceeds to try them out:</p>
<p></p>
<p></p>
<p><pre>(define q1 (make-queue))
(insert-queue! q1 'a)
<i>((a) a)</i>
(insert-queue! q1 'b)
<i>((a b) b)</i>
(delete-queue! q1)
<i>((b) b)</i>
(delete-queue! q1)
<i>(() b)</i>
</pre></p>
<p></p>
<p>“It's all wrong!” he complains.  “The interpreter's response showsthat the last item is inserted into the queue twice.  And when Idelete both items, the second <code>b</code> is still there, so the queueisn't empty, even though it's supposed to be.”  Eva Lu Ator suggeststhat Ben has misunderstood what is happening.  “It's not that theitems are going into the queue twice,” she explains.  “It's justthat the standard Lisp printer doesn't know how to make sense of thequeue representation.  If you want to see the queue printed correctly,you'll have to define your own print procedure for queues.” Explainwhat Eva Lu is talking about.  In particular, show why Ben's examplesproduce the printed results that they do.  Define a procedure <a name="%_idx_3260" id="%_idx_3260"></a><code>print-queue</code> that takes a queue as input and prints the sequence ofitems in the queue.</p>
<p></p>
<p></p>
<p><a name="%_thm_3.22" id="%_thm_3.22"></a><b>Exercise 3.22.</b>  <a name="%_idx_3262" id="%_idx_3262"></a>Instead of representing a queue as a pair of pointers, we can build aqueue as a procedure with local state.  The local state will consistof pointers to the beginning and the end of an ordinary list.  Thus,the <code>make-queue</code> procedure will have the form</p>
<p></p>
<p></p>
<p><pre>(define (make-queue)
  (let ((front-ptr <code>...</code>)
        (rear-ptr <code>...</code>))
    &lt;<em>definitions of internal procedures</em>&gt;
    (define (dispatch m) <code>...</code>)
    dispatch))
</pre></p>
<p></p>
<p>Complete the definition of <code>make-queue</code> and provideimplementations of the queue operations using this representation.</p>
<p></p>
<p></p>
<p><a name="%_thm_3.23" id="%_thm_3.23"></a><b>Exercise 3.23.</b>  <a name="%_idx_3264" id="%_idx_3264"></a><a name="%_idx_3266" id="%_idx_3266"></a>A <em>deque</em> (“double-ended queue”) is a sequence in which itemscan be inserted and deleted at either the front or the rear.Operations on deques are the constructor <code>make-deque</code>, the predicate <code>empty-deque?</code>, selectors <code>front-deque</code> and <code>rear-deque</code>, and mutators <code>front-insert-deque!</code>, <code>rear-insert-deque!</code>, <code>front-delete-deque!</code>, and <code>rear-delete-deque!</code>.  Show how to represent deques using pairs, andgive implementations of the operations.<a name="call_footnote_Temp_370" href="#footnote_Temp_370" id="call_footnote_Temp_370"><sup><small>23</small></sup></a>All operations should be accomplished in θ(1) steps.</p>
<p><a name="%_sec_3.3.3" id="%_sec_3.3.3"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_3.3.3">3.3.3  Representing Tables</a></h3>
<p><a name="%_idx_3268" id="%_idx_3268"></a><a name="%_idx_3270" id="%_idx_3270"></a>When we studied various ways of representing sets in chapter 2, wementioned in section <a href="book-Z-H-16.html#%_sec_2.3.3">2.3.3</a> the task ofmaintaining a table of records indexed by identifying keys.  In theimplementation of data-directed programming insection <a href="book-Z-H-17.html#%_sec_2.4.3">2.4.3</a>, we made extensive use oftwo-dimensional tables, in which information is stored and retrievedusing two keys.  Here we see how to build tables as mutable liststructures.</p>
<p><a name="%_idx_3272" id="%_idx_3272"></a>We first consider a one-dimensional table, in which each value isstored under a single key.  We implement the table as a list ofrecords, each of which is implemented as a pair consisting of a keyand the associated value. The records are glued together to form alist by pairs whose <code>car</code>s point to successive records.  Thesegluing pairs are called the <a name="%_idx_3274" id="%_idx_3274"></a><em>backbone</em> of the table.  In order tohave a place that we can change when we add a new record to the table,we build the table as a <a name="%_idx_3276" id="%_idx_3276"></a><a name="%_idx_3278" id="%_idx_3278"></a><em>headed list</em>.  A headed list has aspecial backbone pair at the beginning, which holds a dummy“record” – in this case the arbitrarily chosen symbol <code>*table*</code>.Figure <a href="#%_fig_3.22">3.22</a> shows the box-and-pointer diagram for the table</p>
<p></p>
<p></p>
<p><pre>a:  1
b:  2
c:  3
</pre></p>
<p></p>
<p></p>
<p><a name="%_fig_3.22" id="%_fig_3.22"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch3-Z-G-22.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 3.22:</b>  A table represented as a headed list.</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p>To extract information from a table we use the <code>lookup</code>procedure, which takes a key as argument and returns the associatedvalue (or false if there is no value stored under that key).<code>Lookup</code> is defined in terms of the <code>assoc</code> operation, whichexpects a key and a list of records as arguments.  Note that <code>assoc</code> never sees the dummy record.  <code>Assoc</code> returns the recordthat has the given key as its <code>car</code>.<a name="call_footnote_Temp_371" href="#footnote_Temp_371" id="call_footnote_Temp_371"><sup><small>24</small></sup></a><code>Lookup</code> thenchecks to see that the resulting record returned by <code>assoc</code> is notfalse, and returns the value (the <code>cdr</code>) of the record.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3280" id="%_idx_3280"></a>(define (lookup key table)
  (let ((record (assoc key (cdr table))))
    (if record
        (cdr record)
        false)))
<a name="%_idx_3282" id="%_idx_3282"></a>(define (assoc key records)
  (cond ((null? records) false)
        ((equal? key (caar records)) (car records))
        (else (assoc key (cdr records)))))
</pre></p>
<p></p>
<p></p>
<p>To insert a value in a table under a specified key, we first use <code>assoc</code> to see if there is already a record in the table with this key.If not, we form a new record by <code>cons</code>ing the key with the value,and insert this at the head of the table's list of records, after thedummy record.  If there already is a record with this key, we set the<code>cdr</code> of this record to the designated new value.  The header ofthe table provides us with a fixed location to modify in order toinsert the new record.<a name="call_footnote_Temp_372" href="#footnote_Temp_372" id="call_footnote_Temp_372"><sup><small>25</small></sup></a></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3284" id="%_idx_3284"></a>(define (insert! key value table)
  (let ((record (assoc key (cdr table))))
    (if record
        (set-cdr! record value)
        (set-cdr! table
                  (cons (cons key value) (cdr table)))))
  'ok)
</pre></p>
<p></p>
<p></p>
<p>To construct a new table, we simply create a list containing thesymbol <code>*table*</code>:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3286" id="%_idx_3286"></a>(define (make-table)
  (list '*table*))
</pre></p>
<p></p>
<p><a name="%_sec_Temp_373" id="%_sec_Temp_373"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_373">Two-dimensional tables</a></h4>
<p><a name="%_idx_3288" id="%_idx_3288"></a>In a two-dimensional table, each value is indexed by two keys.  We canconstruct such a table as a one-dimensional table in which each keyidentifies a subtable.Figure <a href="#%_fig_3.23">3.23</a> shows the box-and-pointer diagram for the table</p>
<p></p>
<p><pre>math:
    +:  43
    -:  45
    *:  42
letters:
    a:  97
    b:  98
</pre></p>
<p></p>
<p>which has two subtables.  (The subtables don't need aspecial header symbol, since the key that identifies the subtableserves this purpose.)</p>
<p><a name="%_fig_3.23" id="%_fig_3.23"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch3-Z-G-23.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 3.23:</b>  A two-dimensional table.</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p>When we look up an item, we use the first keyto identify the correct subtable.  Then we use the second key toidentify the record within the subtable.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3290" id="%_idx_3290"></a>(define (lookup key-1 key-2 table)
  (let ((subtable (assoc key-1 (cdr table))))
    (if subtable
        (let ((record (assoc key-2 (cdr subtable))))
          (if record
              (cdr record)
              false))
        false)))
</pre></p>
<p></p>
<p></p>
<p>To insert a new item under a pair of keys, we use <code>assoc</code> to see ifthere is a subtable stored under the first key.  If not, we build anew subtable containing the single record (<code>key-2</code>, <code>value</code>)and insert it into the table under the first key.  If a subtablealready exists for the first key, we insert the new record into thissubtable, using the insertion method for one-dimensional tablesdescribed above:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3292" id="%_idx_3292"></a>(define (insert! key-1 key-2 value table)
  (let ((subtable (assoc key-1 (cdr table))))
    (if subtable
        (let ((record (assoc key-2 (cdr subtable))))
          (if record
              (set-cdr! record value)
              (set-cdr! subtable
                        (cons (cons key-2 value)
                              (cdr subtable)))))
        (set-cdr! table
                  (cons (list key-1
                              (cons key-2 value))
                        (cdr table)))))
  'ok)
</pre></p>
<p></p>
<p><a name="%_sec_Temp_374" id="%_sec_Temp_374"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_374">Creating local tables</a></h4>
<p><a name="%_idx_3294" id="%_idx_3294"></a>The <code>lookup</code> and <code>insert!</code> operations defined above take thetable as an argument.  This enables us to use programs that accessmore than one table.  Another way to deal with multiple tables is tohave separate <code>lookup</code> and <code>insert!</code> procedures for eachtable.  We can do this by representing a table procedurally, as anobject that maintains an internal table as part of its local state.When sent an appropriate message, this “table object” supplies theprocedure with which to operate on the internal table.  Here is agenerator for two-dimensional tables represented in this fashion:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3296" id="%_idx_3296"></a>(define (make-table)
  (let ((local-table (list '*table*)))
    (define (lookup key-1 key-2)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (cdr record)
                  false))
            false)))
    (define (insert! key-1 key-2 value)
      (let ((subtable (assoc key-1 (cdr local-table))))
        (if subtable
            (let ((record (assoc key-2 (cdr subtable))))
              (if record
                  (set-cdr! record value)
                  (set-cdr! subtable
                            (cons (cons key-2 value)
                                  (cdr subtable)))))
            (set-cdr! local-table
                      (cons (list key-1
                                  (cons key-2 value))
                            (cdr local-table)))))
      'ok)    
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
            ((eq? m 'insert-proc!) insert!)
            (else (error "Unknown operation -- TABLE" m))))
    dispatch))
</pre></p>
<p></p>
<p></p>
<p>Using <code>make-table</code>, we could implement the <code>get</code> and <code>put</code>operations used in section <a href="book-Z-H-17.html#%_sec_2.4.3">2.4.3</a> for data-directedprogramming, as follows:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3298" id="%_idx_3298"></a>(define operation-table (make-table))
<a name="%_idx_3300" id="%_idx_3300"></a>(define get (operation-table 'lookup-proc))
<a name="%_idx_3302" id="%_idx_3302"></a>(define put (operation-table 'insert-proc!))
</pre></p>
<p></p>
<p><code>Get</code> takes as arguments two keys, and <code>put</code> takesas arguments two keys and a value.  Both operations access the samelocal table, which is encapsulated within the object created by thecall to <code>make-table</code>.</p>
<p><a name="%_thm_3.24" id="%_thm_3.24"></a><b>Exercise 3.24.</b>  <a name="%_idx_3304" id="%_idx_3304"></a><a name="%_idx_3306" id="%_idx_3306"></a>In the table implementations above, the keys are tested for equalityusing <code>equal?</code> (called by <code>assoc</code>).  This is not always the appropriate test.  Forinstance, we might have a table with numeric keys in which we don'tneed an exact match to the number we're looking up,but only a number within some tolerance of it.Design a table constructor <code>make-table</code> that takes as an argument a <code>same-key?</code> procedurethat will be used to test “equality” of keys.  <code>Make-table</code> shouldreturn a <code>dispatch</code> procedure that can be used to accessappropriate <code>lookup</code> and <code>insert!</code> procedures for a localtable.</p>
<p></p>
<p></p>
<p><a name="%_thm_3.25" id="%_thm_3.25"></a><b>Exercise 3.25.</b>  <a name="%_idx_3308" id="%_idx_3308"></a>Generalizing one- and two-dimensional tables, show how to implement atable in which values are stored under an arbitrary number of keys anddifferent values may be stored under different numbers of keys.  The<code>lookup</code> and <code>insert!</code> procedures should take as input a listof keys used to access the table.</p>
<p></p>
<p></p>
<p><a name="%_thm_3.26" id="%_thm_3.26"></a><b>Exercise 3.26.</b>  <a name="%_idx_3310" id="%_idx_3310"></a><a name="%_idx_3312" id="%_idx_3312"></a>To search a table as implemented above, one needs to scan through thelist of records.  This is basically the unordered list representation ofsection <a href="book-Z-H-16.html#%_sec_2.3.3">2.3.3</a>.  For large tables, it may be moreefficient to structure the table in a different manner.  Describe atable implementation where the (key, value) records are organizedusing a binary tree, assuming that keys can be ordered in some way(e.g., numerically or alphabetically).  (Compareexercise <a href="book-Z-H-16.html#%_thm_2.66">2.66</a> of chapter 2.)</p>
<p></p>
<p></p>
<p><a name="%_thm_3.27" id="%_thm_3.27"></a><b>Exercise 3.27.</b>  <a name="%_idx_3314" id="%_idx_3314"></a><a name="%_idx_3316" id="%_idx_3316"></a><a name="%_idx_3318" id="%_idx_3318"></a><a name="%_idx_3320" id="%_idx_3320"></a><em>Memoization</em> (also called <em>tabulation</em>) is a technique thatenables a procedure to record, in a local table, values that havepreviously been computed.  This technique can make a vast differencein the performance of a program.  A memoized procedure maintains atable in which values of previous calls are storedusing as keys the arguments that produced the values.  When thememoized procedure is asked to compute a value, it first checks thetable to see if the value is already there and, if so, just returnsthat value.  Otherwise, it computes the new value in the ordinary wayand stores this in the table.  As an example of memoization, recallfrom section <a href="book-Z-H-11.html#%_sec_1.2.2">1.2.2</a> the exponential process forcomputing Fibonacci numbers:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3322" id="%_idx_3322"></a>(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2))))))
</pre></p>
<p></p>
<p>The memoized version of the same procedure is</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3324" id="%_idx_3324"></a>(define memo-fib
  (memoize (lambda (n)
             (cond ((= n 0) 0)
                   ((= n 1) 1)
                   (else (+ (memo-fib (- n 1))
                            (memo-fib (- n 2))))))))
</pre></p>
<p></p>
<p>where the memoizer is defined as</p>
<p></p>
<p><pre><a name="%_idx_3326" id="%_idx_3326"></a>(define (memoize f)
  (let ((table (make-table)))
    (lambda (x)
      (let ((previously-computed-result (lookup x table)))
        (or previously-computed-result
            (let ((result (f x)))
              (insert! x result table)
              result))))))
</pre></p>
<p></p>
<p>Draw an environment diagram to analyze the computation of <code>(memo-fib 3)</code>.  Explain why <code>memo-fib</code> computes the <em>n</em>thFibonacci number in a number of steps proportional to <em>n</em>.Would the scheme stillwork if we had simply defined <code>memo-fib</code> to be <code>(memoizefib)</code>?</p>
<p><a name="%_sec_3.3.4" id="%_sec_3.3.4"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_3.3.4">3.3.4  A Simulator for Digital Circuits</a></h3>
<p><a name="%_idx_3328" id="%_idx_3328"></a>Designing complex digital systems, such as computers, is an importantengineering activity.  Digital systems are constructed byinterconnecting simple elements.  Although the behavior of theseindividual elements is simple, networks of them can have very complexbehavior.  Computer simulation of proposed circuit designs is animportant tool used by digital systems engineers.  In this section wedesign a system for performing digital logic simulations.  This systemtypifies a kind of program called an <a name="%_idx_3330" id="%_idx_3330"></a><a name="%_idx_3332" id="%_idx_3332"></a><em>event-driven simulation</em>, inwhich actions (“events”) trigger further events that happen at alater time, which in turn trigger more events, and so so.</p>
<p>Our computational model of a circuit will be composed of objects thatcorrespond to the elementary components from which the circuit isconstructed.  There are <a name="%_idx_3334" id="%_idx_3334"></a><em>wires</em>, which carry <a name="%_idx_3336" id="%_idx_3336"></a><a name="%_idx_3338" id="%_idx_3338"></a><em>digital signals</em>.  Adigital signal may at any moment have only one of two possible values,0 and 1.  There are also various types of digital <a name="%_idx_3340" id="%_idx_3340"></a><em>functionboxes</em>, which connect wires carrying input signals to other outputwires.  Such boxes produce output signals computed from their inputsignals.  The output signal is <a name="%_idx_3342" id="%_idx_3342"></a>delayed by a time that depends on thetype of the function box.  For example, an <a name="%_idx_3344" id="%_idx_3344"></a><em>inverter</em> is aprimitive function box that inverts its input.  If theinput signal to an inverter changes to 0, then one inverter-delaylater the inverter will change its output signal to 1.  If the inputsignal to an inverter changes to 1, then one inverter-delay later theinverter will change its output signal to 0.  We draw an invertersymbolically as in figure <a href="#%_fig_3.24">3.24</a>.  An <a name="%_idx_3346" id="%_idx_3346"></a><em>and-gate</em>,also shown in figure <a href="#%_fig_3.24">3.24</a>, is a primitive functionbox with two inputs and one output.  It drives its output signal to avalue that is the <a name="%_idx_3348" id="%_idx_3348"></a><em>logical and</em> of the inputs.  That is, if bothof its input signals become 1, then one and-gate-delay time later theand-gate will force its output signal to be 1; otherwise the outputwill be 0.  An <a name="%_idx_3350" id="%_idx_3350"></a><em>or-gate</em> is a similar two-input primitive functionbox that drives its output signal to a value that is the <a name="%_idx_3352" id="%_idx_3352"></a><em>logicalor</em> of the inputs.  That is, the output will become 1 if at least oneof the input signals is 1; otherwise the output will become 0.</p>
<p><a name="%_fig_3.24" id="%_fig_3.24"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch3-Z-G-24.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 3.24:</b>  Primitive functions in the digital logic simulator.</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p>We can connect primitive functions together to construct more complexfunctions.  To accomplish this we wire the outputs of somefunction boxes to the inputs of other function boxes.  For example,the <a name="%_idx_3354" id="%_idx_3354"></a><a name="%_idx_3356" id="%_idx_3356"></a><em>half-adder</em> circuit shown in figure <a href="#%_fig_3.25">3.25</a> consists of anor-gate, two and-gates, and an inverter.  It takes two input signals,A and B, and has two output signals, S and C.  S will become 1whenever precisely one of A and B is 1, and C will become 1 whenever Aand B are both 1.  We can see from the figure that, because of thedelays involved, the outputs may be generated at different times.Many of the difficulties in the design of digital circuits arise fromthis fact.</p>
<p><a name="%_fig_3.25" id="%_fig_3.25"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch3-Z-G-25.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 3.25:</b>  A half-adder circuit.</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p>We will now build a program for modeling the digital logic circuits wewish to study.  The program will construct computational objectsmodeling the wires, which will “hold” the signals.  Function boxeswill be modeled by procedures that enforce the correct relationshipsamong the signals.</p>
<p><a name="%_idx_3358" id="%_idx_3358"></a>One basic element of our simulation will be a procedure <code>make-wire</code>, which constructs wires.  For example, we can construct sixwires as follows:</p>
<p></p>
<p></p>
<p><pre>(define a (make-wire))
(define b (make-wire))
(define c (make-wire))

(define d (make-wire))
(define e (make-wire))
(define s (make-wire))
</pre></p>
<p></p>
<p>We attach a function box to a set of wires by calling a procedure thatconstructs that kind of box.  The arguments to the constructorprocedure are the wires to be attached to the box.  For example, giventhat we can construct and-gates, or-gates, and inverters, we can wiretogether the half-adder shown in figure <a href="#%_fig_3.25">3.25</a>:</p>
<p></p>
<p></p>
<p><pre>(or-gate a b d)
<i>ok</i>

(and-gate a b c)
<i>ok</i>

(inverter c e)
<i>ok</i>

(and-gate d e s)
<i>ok</i>
</pre></p>
<p></p>
<p></p>
<p>Better yet, we can explicitly name this operation by defining a procedure <code>half-adder</code> that constructs this circuit, given the fourexternal wires to be attached to the half-adder:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3360" id="%_idx_3360"></a>(define (half-adder a b s c)
  (let ((d (make-wire)) (e (make-wire)))
    (or-gate a b d)
    (and-gate a b c)
    (inverter c e)
    (and-gate d e s)
    'ok))
</pre></p>
<p></p>
<p>The advantage of making this definition is that we can use<code>half-adder</code> itself as a building block in creating more complexcircuits.  Figure <a href="#%_fig_3.26">3.26</a>, for example, shows a <a name="%_idx_3362" id="%_idx_3362"></a><a name="%_idx_3364" id="%_idx_3364"></a><em>full-adder</em> composed of two half-adders and an or-gate.<a name="call_footnote_Temp_379" href="#footnote_Temp_379" id="call_footnote_Temp_379"><sup><small>26</small></sup></a> We can construct a full-adderas follows:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3366" id="%_idx_3366"></a>(define (full-adder a b c-in sum c-out)
  (let ((s (make-wire))
        (c1 (make-wire))
        (c2 (make-wire)))
    (half-adder b c-in s c1)
    (half-adder a s sum c2)
    (or-gate c1 c2 c-out)
    'ok))
</pre></p>
<p></p>
<p>Having defined <code>full-adder</code> as a procedure, we can now use it as abuilding block for creating still more complex circuits.  (Forexample, see exercise <a href="#%_thm_3.30">3.30</a>.)</p>
<p><a name="%_fig_3.26" id="%_fig_3.26"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch3-Z-G-26.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 3.26:</b>  A full-adder circuit.</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p>In essence, our simulator provides us with the tools to construct alanguage of circuits.  If we adopt the general perspective onlanguages with which we approached the study of Lisp insection <a href="book-Z-H-10.html#%_sec_1.1">1.1</a>,we can say that the primitive function boxes form the primitiveelements of the language, that wiring boxes together provides a meansof combination, and that specifying wiring patterns as proceduresserves as a means of abstraction.</p>
<p><a name="%_sec_Temp_380" id="%_sec_Temp_380"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_380">Primitive function boxes</a></h4>
<p><a name="%_idx_3368" id="%_idx_3368"></a>The primitive function boxes implement the “forces” by which achange in the signal on one wire influences the signals on otherwires.  To build function boxes, we use the following operations onwires:</p>
<p></p>
<p></p>
<ul>
<li>
<code>(get-signal &lt;<em>wire</em>&gt;)</code>
<a name="%_idx_3370" id="%_idx_3370"></a>returns the current value of the signal on the wire.<p></p>
</li>
<li>
<code>(set-signal! &lt;<em>wire</em>&gt; &lt;<em>new value</em>&gt;)</code>
<a name="%_idx_3372" id="%_idx_3372"></a>changes the value of the signal on the wire to the new value.<p></p>
</li>
<li>
<code>(add-action! &lt;<em>wire</em>&gt; &lt;<em>procedure of no arguments</em>&gt;)</code>
<a name="%_idx_3374" id="%_idx_3374"></a>asserts that the designated procedure should be run whenever thesignal on the wire changes value.  Such procedures are the vehicles bywhich changes in the signal value on the wire are communicated toother wires.</li>
</ul>
<p><a name="%_idx_3376" id="%_idx_3376"></a>In addition, we will make use of a procedure <code>after-delay</code> thattakes a time delay and a procedure to be run and executes thegiven procedure after the given delay.</p>
<p>Using these procedures, we can define the primitive digital logicfunctions.  To connect an input to an output through an inverter, weuse <code>add-action!</code> to associate with the input wire a procedurethat will be run whenever the signal on the input wire changes value.The procedure computes the <code>logical-not</code> of the input signal, andthen, after one <code>inverter-delay</code>, sets the output signal to bethis new value:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3378" id="%_idx_3378"></a>(define (inverter input output)
  (define (invert-input)
    (let ((new-value (logical-not (get-signal input))))
      (after-delay inverter-delay
                   (lambda ()
                     (set-signal! output new-value)))))
  (add-action! input invert-input)
  'ok)
<a name="%_idx_3380" id="%_idx_3380"></a>(define (logical-not s)
  (cond ((= s 0) 1)
        ((= s 1) 0)
        (else (error "Invalid signal" s))))
</pre></p>
<p></p>
<p></p>
<p>An and-gate is a little more complex.  The action procedure must be run ifeither of the inputs to the gate changes.  It computes the <code>logical-and</code> (using a procedure analogous to <code>logical-not</code>) of thevalues of the signals on the input wires and sets up a change to thenew value to occur on the output wire after one <code>and-gate-delay</code>.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3382" id="%_idx_3382"></a>(define (and-gate a1 a2 output)
  (define (and-action-procedure)
    (let ((new-value
           (logical-and (get-signal a1) (get-signal a2))))
      (after-delay and-gate-delay
                   (lambda ()
                     (set-signal! output new-value)))))
  (add-action! a1 and-action-procedure)
  (add-action! a2 and-action-procedure)
  'ok)
</pre></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_3.28" id="%_thm_3.28"></a><b>Exercise 3.28.</b>  <a name="%_idx_3384" id="%_idx_3384"></a>Define an or-gate as a primitive function box.  Your <code>or-gate</code>constructor should be similar to <code>and-gate</code>.</p>
<p></p>
<p></p>
<p><a name="%_thm_3.29" id="%_thm_3.29"></a><b>Exercise 3.29.</b>  <a name="%_idx_3386" id="%_idx_3386"></a>Another way to construct an or-gate is as a compound digital logicdevice, built from and-gates and inverters.  Define a procedure <code>or-gate</code> that accomplishes this.  What is the delay time of theor-gate in terms of <code>and-gate-delay</code> and <code>inverter-delay</code>?</p>
<p></p>
<p></p>
<p><a name="%_thm_3.30" id="%_thm_3.30"></a><b>Exercise 3.30.</b>  Figure <a href="#%_fig_3.27">3.27</a> shows a <a name="%_idx_3388" id="%_idx_3388"></a><a name="%_idx_3390" id="%_idx_3390"></a><em>ripple-carry adder</em> formed by stringingtogether <em>n</em> full-adders.  This is the simplest form of parallel adderfor adding two <em>n</em>-bit binary numbers.  The inputs A<sub>1</sub>, A<sub>2</sub>,A<sub>3</sub>, <code>...</code>, A<sub><em>n</em></sub> and B<sub>1</sub>, B<sub>2</sub>, B<sub>3</sub>, <code>...</code>,B<sub><em>n</em></sub> are the two binary numbers to be added (each A<sub><em>k</em></sub> and B<sub><em>k</em></sub>is a 0 or a 1).  The circuit generates S<sub>1</sub>, S<sub>2</sub>, S<sub>3</sub>,<code>...</code>, S<sub><em>n</em></sub>, the <em>n</em> bits of the sum, and C, the carry fromthe addition.  Write a procedure <code>ripple-carry-adder</code> thatgenerates this circuit.  The procedure should take as arguments threelists of <em>n</em> wires each – the A<sub><em>k</em></sub>, the B<sub><em>k</em></sub>, and the S<sub><em>k</em></sub> – andalso another wire C.  The major drawback of the ripple-carry adder isthe need to wait for the carry signals to propagate.  What is thedelay needed to obtain the complete output from an <em>n</em>-bitripple-carry adder, expressed in terms of the delays for and-gates,or-gates, and inverters?</p>
<p></p>
<p><a name="%_fig_3.27" id="%_fig_3.27"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch3-Z-G-27.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 3.27:</b>  A ripple-carry adder for <em>n</em>-bit numbers.</div></caption>
<tr><td></td></tr>
</table></div>
<p><a name="%_sec_Temp_384" id="%_sec_Temp_384"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_384">Representing wires</a></h4>
<p><a name="%_idx_3392" id="%_idx_3392"></a>A wire in our simulation will be a computational object with two localstate variables: a <code>signal-value</code> (initially taken to be 0) and acollection of <code>action-procedures</code> to be run when the signalchanges value.  We implement the wire, using message-passing style, as<a name="%_idx_3394" id="%_idx_3394"></a>a collection of local procedures together with a <code>dispatch</code>procedure that selects the appropriate local operation, just as we didwith the simple bank-account object in section <a href="book-Z-H-20.html#%_sec_3.1.1">3.1.1</a>:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3396" id="%_idx_3396"></a>(define (make-wire)
  (let ((signal-value 0) (action-procedures '()))
    (define (set-my-signal! new-value)
      (if (not (= signal-value new-value))
          (begin (set! signal-value new-value)
                 (call-each action-procedures))
          'done))
    (define (accept-action-procedure! proc)
      (set! action-procedures (cons proc action-procedures))
      (proc))
    (define (dispatch m)
      (cond ((eq? m 'get-signal) signal-value)
            ((eq? m 'set-signal!) set-my-signal!)
            ((eq? m 'add-action!) accept-action-procedure!)
            (else (error "Unknown operation -- WIRE" m))))
    dispatch))
</pre></p>
<p></p>
<p>The local procedure <code>set-my-signal!</code> tests whether the new signalvalue changes the signal on the wire.  If so, it runs each of theaction procedures, using the following procedure <code>call-each</code>,which calls each of the items in a list of no-argument procedures:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3398" id="%_idx_3398"></a>(define (call-each procedures)
  (if (null? procedures)
      'done
      (begin
        ((car procedures))
        (call-each (cdr procedures)))))
</pre></p>
<p></p>
<p>The local procedure <code>accept-action-procedure!</code> adds the givenprocedure to the list of procedures to be run, and then runs the newprocedure once.  (See exercise <a href="#%_thm_3.31">3.31</a>.)</p>
<p>With the local <code>dispatch</code> procedure set up as specified, we canprovide the following procedures to access the local operations onwires:<a name="call_footnote_Temp_385" href="#footnote_Temp_385" id="call_footnote_Temp_385"><sup><small>27</small></sup></a></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3404" id="%_idx_3404"></a>(define (get-signal wire)
  (wire 'get-signal))
<a name="%_idx_3406" id="%_idx_3406"></a>(define (set-signal! wire new-value)
  ((wire 'set-signal!) new-value))
<a name="%_idx_3408" id="%_idx_3408"></a>(define (add-action! wire action-procedure)
  ((wire 'add-action!) action-procedure))
</pre></p>
<p></p>
<p></p>
<p>Wires, which have time-varying signals and may be incrementallyattached to devices, are typical of mutable objects.  We have modeledthem as procedures with local state variables that are modified byassignment.  When a new wire is created, a new set of state variablesis allocated (by the <code>let</code> expression in <code>make-wire</code>) and anew <code>dispatch</code> procedure is constructed and returned, capturingthe environment with the new state variables.</p>
<p>The wires are shared among the various devices that have beenconnected to them.  Thus, a change made by an interaction with onedevice will affect all the other devices attached to the wire.  Thewire communicates the change to its neighbors by calling the actionprocedures provided to it when the connections were established.<a name="%_sec_Temp_386" id="%_sec_Temp_386"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_386">The agenda</a></h4>
<p><a name="%_idx_3410" id="%_idx_3410"></a>The only thing needed to complete the simulator is <code>after-delay</code>.The idea here is that we maintain a data structure, called an <em>agenda</em>, that contains a schedule of things to do.  The followingoperations are defined for agendas:</p>
<p></p>
<p></p>
<ul>
<li>
<a name="%_idx_3412" id="%_idx_3412"></a><code>(make-agenda)</code>
returns a new empty agenda.<p></p>
</li>
<li>
<a name="%_idx_3414" id="%_idx_3414"></a><code>(empty-agenda? &lt;<em>agenda</em>&gt;)</code>
is true if the specified agenda is empty.<p></p>
</li>
<li>
<a name="%_idx_3416" id="%_idx_3416"></a><code>(first-agenda-item &lt;<em>agenda</em>&gt;)</code>
returns the first item on the agenda.<p></p>
</li>
<li>
<a name="%_idx_3418" id="%_idx_3418"></a><code>(remove-first-agenda-item! &lt;<em>agenda</em>&gt;)</code>
modifies the agenda by removing the first item.<p></p>
</li>
<li>
<a name="%_idx_3420" id="%_idx_3420"></a><code>(add-to-agenda! &lt;<em>time</em>&gt; &lt;<em>action</em>&gt; &lt;<em>agenda</em>&gt;)</code>
modifies the agenda by adding the given action procedure to be run atthe specified time.<p></p>
</li>
<li>
<a name="%_idx_3422" id="%_idx_3422"></a><code>(current-time &lt;<em>agenda</em>&gt;)</code>
returns the current simulation time.</li>
</ul>
<p></p>
<p>The particular agenda that we use is denoted by<code>the-agenda</code>.  The procedure <code>after-delay</code> adds newelements to <code>the-agenda</code>:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3424" id="%_idx_3424"></a>(define (after-delay delay action)
  (add-to-agenda! (+ delay (current-time the-agenda))
                  action
                  the-agenda))
</pre></p>
<p></p>
<p></p>
<p>The simulation is driven by the procedure <code>propagate</code>, whichoperates on <code>the-agenda</code>, executing each procedure on the agendain sequence.  In general, as the simulation runs, new items will beadded to the agenda, and <code>propagate</code> will continue the simulationas long as there are items on the agenda:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3426" id="%_idx_3426"></a>(define (propagate)
  (if (empty-agenda? the-agenda)
      'done
      (let ((first-item (first-agenda-item the-agenda)))
        (first-item)
        (remove-first-agenda-item! the-agenda)
        (propagate))))
</pre></p>
<p></p>
<p></p>
<p><a name="%_sec_Temp_387" id="%_sec_Temp_387"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_387">A sample simulation</a></h4>
<p><a name="%_idx_3428" id="%_idx_3428"></a><a name="%_idx_3430" id="%_idx_3430"></a>The following procedure, which places a “probe” on a wire, shows thesimulator in action.  The probe tells the wire that, whenever itssignal changes value, it should print the new signal value, togetherwith the current time and a name that identifies the wire:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3432" id="%_idx_3432"></a>(define (probe name wire)
  (add-action! wire
               (lambda ()        
                 (newline)
                 (display name)
                 (display " ")
                 (display (current-time the-agenda))
                 (display "  New-value = ")
                 (display (get-signal wire)))))
</pre></p>
<p></p>
<p></p>
<p>We begin by initializing the agenda and specifying delays for theprimitive function boxes:</p>
<p></p>
<p></p>
<p><pre>(define the-agenda (make-agenda))
(define inverter-delay 2)
(define and-gate-delay 3)
(define or-gate-delay 5)
</pre></p>
<p></p>
<p>Now we define four wires, placing probes on two of them:</p>
<p></p>
<p></p>
<p><pre>(define input-1 (make-wire))
(define input-2 (make-wire))
(define sum (make-wire))
(define carry (make-wire))
(probe 'sum sum)
<i>sum 0  New-value = 0</i>
(probe 'carry carry)
<i>carry 0  New-value = 0</i>
</pre></p>
<p></p>
<p>Next we connect the wires in a half-adder circuit (as infigure <a href="#%_fig_3.25">3.25</a>), set the signal on <code>input-1</code> to 1,and run the simulation:</p>
<p></p>
<p></p>
<p><pre>(half-adder input-1 input-2 sum carry)
<i>ok</i>
(set-signal! input-1 1)
<i>done</i>
(propagate)
<i>sum 8  New-value = 1</i>
<i>done</i>
</pre></p>
<p></p>
<p>The <code>sum</code> signal changes to 1 at time 8.  We are now eight timeunits from the beginning of the simulation.  At this point, we can setthe signal on <code>input-2</code> to 1 and allow the values to propagate:</p>
<p></p>
<p></p>
<p><pre>(set-signal! input-2 1)
<i>done</i>
(propagate)
<i>carry 11  New-value = 1</i>
<i>sum 16  New-value = 0</i>
<i>done</i>
</pre></p>
<p></p>
<p>The <code>carry</code> changes to 1 at time 11 and the <code>sum</code> changes to 0at time 16.</p>
<p><a name="%_thm_3.31" id="%_thm_3.31"></a><b>Exercise 3.31.</b>  <a name="%_idx_3434" id="%_idx_3434"></a>The internal procedure <code>accept-action-procedure!</code> defined in <code>make-wire</code> specifies that when a new action procedure is added toa wire, the procedure is immediately run.  Explain why this initializationis necessary.  In particular, trace through the half-adder example inthe paragraphs above and say how the system's response would differ ifwe had defined <code>accept-action-procedure!</code> as</p>
<p></p>
<p></p>
<p><pre>(define (accept-action-procedure! proc)
  (set! action-procedures (cons proc action-procedures)))
</pre></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_sec_Temp_389" id="%_sec_Temp_389"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_389">Implementing the agenda</a></h4>
<p><a name="%_idx_3436" id="%_idx_3436"></a>Finally, we give details of the agenda data structure, which holds theprocedures that are scheduled for future execution.</p>
<p>The agenda is made up of <a name="%_idx_3438" id="%_idx_3438"></a><em>time segments</em>.  Each time segment is apair consisting of a number (the time) and a <a name="%_idx_3440" id="%_idx_3440"></a>queue (seeexercise <a href="#%_thm_3.32">3.32</a>) that holds the procedures that arescheduled to be run during that time segment.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3442" id="%_idx_3442"></a>(define (make-time-segment time queue)
  (cons time queue))
<a name="%_idx_3444" id="%_idx_3444"></a>(define (segment-time s) (car s))
<a name="%_idx_3446" id="%_idx_3446"></a>(define (segment-queue s) (cdr s))
</pre></p>
<p></p>
<p>We will operate on the time-segment queues using the queue operationsdescribed in section <a href="#%_sec_3.3.2">3.3.2</a>.</p>
<p><a name="%_idx_3448" id="%_idx_3448"></a>The agenda itself is a one-dimensional table of time segments.  Itdiffers from the tables described in section <a href="#%_sec_3.3.3">3.3.3</a> in thatthe segments will be sorted in order of increasing time.  In addition,we store the <a name="%_idx_3450" id="%_idx_3450"></a><em>current time</em> (i.e., the time of the last actionthat was processed) at the head of the agenda.  A newly constructedagenda has no time segments and has a current time of 0:<a name="call_footnote_Temp_390" href="#footnote_Temp_390" id="call_footnote_Temp_390"><sup><small>28</small></sup></a></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3456" id="%_idx_3456"></a>(define (make-agenda) (list 0))
<a name="%_idx_3458" id="%_idx_3458"></a>(define (current-time agenda) (car agenda))
<a name="%_idx_3460" id="%_idx_3460"></a>(define (set-current-time! agenda time)
  (set-car! agenda time))
<a name="%_idx_3462" id="%_idx_3462"></a>(define (segments agenda) (cdr agenda))
<a name="%_idx_3464" id="%_idx_3464"></a>(define (set-segments! agenda segments)
  (set-cdr! agenda segments))
<a name="%_idx_3466" id="%_idx_3466"></a>(define (first-segment agenda) (car (segments agenda)))
<a name="%_idx_3468" id="%_idx_3468"></a>(define (rest-segments agenda) (cdr (segments agenda)))
</pre></p>
<p></p>
<p></p>
<p>An agenda is empty if it has no time segments:</p>
<p></p>
<p><pre><a name="%_idx_3470" id="%_idx_3470"></a>(define (empty-agenda? agenda)
  (null? (segments agenda)))
</pre></p>
<p></p>
<p></p>
<p>To add an action to an agenda, we first check if the agenda is empty.If so, we create a time segment for the action and install this inthe agenda.  Otherwise, we scan the agenda, examining the time of eachsegment.  If we find a segment for our appointed time, we add theaction to the associated queue.  If we reach a time later than the oneto which we are appointed, we insert a new time segment into theagenda just before it.  If we reach the end of the agenda, we mustcreate a new time segment at the end.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3472" id="%_idx_3472"></a>(define (add-to-agenda! time action agenda)
  (define (belongs-before? segments)
    (or (null? segments)
        (&lt; time (segment-time (car segments)))))
  (define (make-new-time-segment time action)
    (let ((q (make-queue)))
      (insert-queue! q action)
      (make-time-segment time q)))
  (define (add-to-segments! segments)
    (if (= (segment-time (car segments)) time)
        (insert-queue! (segment-queue (car segments))
                       action)
        (let ((rest (cdr segments)))
          (if (belongs-before? rest)
              (set-cdr!
               segments
               (cons (make-new-time-segment time action)
                     (cdr segments)))
              (add-to-segments! rest)))))
  (let ((segments (segments agenda)))
    (if (belongs-before? segments)
        (set-segments!
         agenda
         (cons (make-new-time-segment time action)
               segments))
        (add-to-segments! segments))))
</pre></p>
<p></p>
<p></p>
<p>The procedure that removes the first item from the agenda deletes theitem at the front of the queue in the first time segment.  If thisdeletion makes the time segment empty, we remove it from the list ofsegments:<a name="call_footnote_Temp_391" href="#footnote_Temp_391" id="call_footnote_Temp_391"><sup><small>29</small></sup></a></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3478" id="%_idx_3478"></a>(define (remove-first-agenda-item! agenda)
  (let ((q (segment-queue (first-segment agenda))))
    (delete-queue! q)
    (if (empty-queue? q)
        (set-segments! agenda (rest-segments agenda)))))
</pre></p>
<p></p>
<p></p>
<p>The first agenda item is found at the head of the queue in the firsttime segment.  Whenever we extract an item, we also update the currenttime:<a name="call_footnote_Temp_392" href="#footnote_Temp_392" id="call_footnote_Temp_392"><sup><small>30</small></sup></a></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3480" id="%_idx_3480"></a>(define (first-agenda-item agenda)
  (if (empty-agenda? agenda)
      (error "Agenda is empty -- FIRST-AGENDA-ITEM")
      (let ((first-seg (first-segment agenda)))
        (set-current-time! agenda (segment-time first-seg))
        (front-queue (segment-queue first-seg)))))
</pre></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_3.32" id="%_thm_3.32"></a><b>Exercise 3.32.</b>  The procedures to be run during each time segment of the agenda arekept in a queue.  Thus, the procedures for each segment are called inthe order in which they were added to the agenda (first in, firstout).  Explain why this order must be used.  In particular, trace thebehavior of an and-gate whose inputs change from 0,1 to 1,0 in thesame segment and say how the behavior would differ if we stored asegment's procedures in an ordinary list, adding and removingprocedures only at the front (last in, first out).</p>
<p><a name="%_sec_3.3.5" id="%_sec_3.3.5"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_3.3.5">3.3.5  Propagation of Constraints</a></h3>
<p><a name="%_idx_3482" id="%_idx_3482"></a><a name="%_idx_3484" id="%_idx_3484"></a>Computer programs are traditionally organized asone-directional computations, which perform operations on prespecifiedarguments to produce desired outputs.  On the other hand, we oftenmodel systems in terms of relations among quantities.  For example, amathematical model of a mechanical structure might include theinformation that the deflection <em>d</em> of a metal rod is related to theforce <em>F</em> on the rod, the length <em>L</em> of the rod, the cross-sectionalarea <em>A</em>, and the elastic modulus <em>E</em> via the equation</p><p><em>dAE</em> = <em>FL</em></p><p>Such an equation is not one-directional.  Given any four of thequantities, we can use it to compute the fifth.  Yet translating theequation into a traditional computer language would force us to chooseone of the quantities to be computed in terms of the other four.Thus, a procedure for computing the area <em>A</em> could not be used tocompute the deflection <em>d</em>, even though the computations of <em>A</em> and<em>d</em> arise from the same equation.<a name="call_footnote_Temp_394" href="#footnote_Temp_394" id="call_footnote_Temp_394"><sup><small>31</small></sup></a></p>
<p><a name="%_idx_3508" id="%_idx_3508"></a>In this section, we sketch the design of a language that enables us towork in terms of relations themselves.  The primitive elements of thelanguage are <a name="%_idx_3510" id="%_idx_3510"></a><a name="%_idx_3512" id="%_idx_3512"></a><em>primitive constraints</em>, which state that certainrelations hold between quantities.  For example, <code>(adder a b c)</code>specifies that the quantities <em>a</em>, <em>b</em>, and <em>c</em> must be related by theequation <em>a</em> + <em>b</em> = <em>c</em>, <code>(multiplier x y z)</code> expresses the constraint<em>x</em><em>y</em>  =  <em>z</em>, and <code>(constant 3.14 x)</code> says that the value of <em>x</em> mustbe 3.14.</p>
<p>Our language provides a means of combining primitive constraints inorder to express more complex relations.  We combine constraints byconstructing <a name="%_idx_3514" id="%_idx_3514"></a><em>constraint networks</em>, in which constraints arejoined by <a name="%_idx_3516" id="%_idx_3516"></a><em>connectors</em>.  A connector is an object that “holds” avalue that may participate in one or more constraints.  For example,we know that the relationship between Fahrenheit and Celsiustemperatures is</p><p>9<em>C</em> = 5(<em>F</em> - 32)</p><p>Such a constraint can be thought of as a network consisting ofprimitive adder, multiplier, and constant constraints(figure <a href="#%_fig_3.28">3.28</a>).  In the figure, we see on the left amultiplier box with three terminals, labeled <em>m</em>1, <em>m</em>2, and <em>p</em>.These connect the multiplier to the rest of the network as follows:The <em>m</em>1 terminal is linked to a connector <em>C</em>, which will hold theCelsius temperature.  The <em>m</em>2 terminal is linked to a connector<em>w</em>, which is also linked to a constant box that holds 9.  The <em>p</em>terminal, which the multiplier box constrains to be the product of<em>m</em>1 and <em>m</em>2, is linked to the <em>p</em> terminalof another multiplier box, whose <em>m</em>2 is connected to a constant 5 andwhose <em>m</em>1 is connected to one of the terms in a sum.</p>
<p><a name="%_fig_3.28" id="%_fig_3.28"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch3-Z-G-30.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 3.28:</b>  The relation 9<em>C</em>  =  5(<em>F</em>  -  32)expressed as a constraint network.</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p>Computation by such a network proceeds as follows: When a connector isgiven a value (by the user or by a constraint box to which it islinked), it awakens all of its associated constraints (except for theconstraint that just awakened it) to inform them that it has a value.Each awakened constraint box then polls its connectors to see if thereis enough information to determine a value for a connector.  If so,the box sets that connector, which then awakens all of its associatedconstraints, and so on.  For instance, in conversion betweenCelsius and Fahrenheit, <em>w</em>, <em>x</em>, and <em>y</em> are immediately set bythe constant boxes to 9, 5, and 32, respectively.  The connectorsawaken the multipliers and the adder, which determine that there isnot enough information to proceed.  If the user (or some other part ofthe network) sets <em>C</em> to a value (say 25), the leftmost multiplierwill be awakened, and it will set <em>u</em> to 25 ·  9 = 225.  Then <em>u</em>awakens the second multiplier, which sets <em>v</em> to 45, and <em>v</em> awakensthe adder, which sets <em>F</em> to 77.</p>
<p><a name="%_sec_Temp_395" id="%_sec_Temp_395"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_395">Using the constraint system</a></h4>
<p>To use the constraint system to carry out the temperature computationoutlined above, we first create two connectors, <code>C</code> and <code>F</code>,by calling the constructor <code>make-connector</code>, and link <code>C</code> and<code>F</code> in an appropriate network:</p>
<p></p>
<p></p>
<p><pre>(define C (make-connector))
(define F (make-connector))
(celsius-fahrenheit-converter C F)
<i>ok</i>
</pre></p>
<p></p>
<p>The procedure that creates the network is defined as follows:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3518" id="%_idx_3518"></a>(define (celsius-fahrenheit-converter c f)
  (let ((u (make-connector))
        (v (make-connector))
        (w (make-connector))
        (x (make-connector))
        (y (make-connector)))
    (multiplier c w u)
    (multiplier v x u)
    (adder v y f)
    (constant 9 w)
    (constant 5 x)
    (constant 32 y)
    'ok))
</pre></p>
<p></p>
<p>This procedure creates the internal connectors <code>u</code>, <code>v</code>, <code>w</code>, <code>x</code>, and <code>y</code>, and links them as shown infigure <a href="#%_fig_3.28">3.28</a> using the primitive constraintconstructors <code>adder</code>, <code>multiplier</code>, and <code>constant</code>.  Justas with the digital-circuit simulator ofsection <a href="#%_sec_3.3.4">3.3.4</a>, expressing these combinations ofprimitive elements in terms of procedures automatically provides ourlanguage with a means of abstraction for compound objects.</p>
<p>To watch the network in action, we can place probes on the connectors<code>C</code> and <code>F</code>, using a <code>probe</code> procedure similar to the onewe used to monitor wires in section <a href="#%_sec_3.3.4">3.3.4</a>.Placing a probe on a connector will cause a message to be printedwhenever the connector is given a value:</p>
<p></p>
<p></p>
<p><pre>(probe "Celsius temp" C)
(probe "Fahrenheit temp" F)
</pre></p>
<p></p>
<p>Next we set the value of <code>C</code> to 25.  (The third argument to <code>set-value!</code> tells <code>C</code> that this directive comes from the <code>user</code>.)</p>
<p></p>
<p></p>
<p><pre>(set-value! C 25 'user)
<i>Probe: Celsius temp = 25</i>
<i>Probe: Fahrenheit temp = 77</i>
<i>done</i>
</pre></p>
<p></p>
<p>The probe on <code>C</code> awakens and reports the value.  <code>C</code> alsopropagates its value through the network as described above.  Thissets <code>F</code> to 77, which is reported by the probe on <code>F</code>.</p>
<p>Now we can try to set <code>F</code> to a new value, say 212:</p>
<p></p>
<p></p>
<p><pre>(set-value! F 212 'user)
<i>Error! Contradiction (77 212)</i>
</pre></p>
<p></p>
<p>The connector complains that it has sensed a contradiction: Its valueis 77, and someone is trying to set it to 212.  If we really want toreuse the network with new values, we can tell <code>C</code> to forget itsold value:</p>
<p></p>
<p></p>
<p><pre>(forget-value! C 'user)
<i>Probe: Celsius temp = ?</i>
<i>Probe: Fahrenheit temp = ?</i>
<i>done</i>
</pre></p>
<p></p>
<p><code>C</code> finds that the <code>user</code>, who set its value originally, isnow retracting that value, so <code>C</code> agrees to lose its value, asshown by the probe, and informs the rest of the network of this fact.This information eventually propagates to <code>F</code>, which now findsthat it has no reason for continuing to believe that its own value is77.  Thus, <code>F</code> also gives up its value, as shown by the probe.</p>
<p>Now that <code>F</code> has no value, we are free to set it to 212:</p>
<p></p>
<p></p>
<p><pre>(set-value! F 212 'user)
<i>Probe: Fahrenheit temp = 212</i>
<i>Probe: Celsius temp = 100</i>
<i>done</i>
</pre></p>
<p></p>
<p>This new value, when propagated through the network, forces <code>C</code> tohave a value of 100, and this is registered by the probe on <code>C</code>.Notice that the very same network is being used to compute <code>C</code>given <code>F</code> and to compute <code>F</code> given <code>C</code>.  Thisnondirectionality of computation is the distinguishing feature ofconstraint-based systems.</p>
<p><a name="%_sec_Temp_396" id="%_sec_Temp_396"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_396">Implementing the constraint system</a></h4>
<p>The constraint system is implemented via procedural objects with localstate, in a manner very similar to the digital-circuit simulator ofsection <a href="#%_sec_3.3.4">3.3.4</a>.  Although the primitive objectsof the constraint system are somewhat more complex, the overall systemis simpler, since there is no concern about agendas and logic delays.</p>
<p><a name="%_idx_3520" id="%_idx_3520"></a>The basic operations on connectors are the following:</p>
<p></p>
<ul>
<li>
<a name="%_idx_3522" id="%_idx_3522"></a><code>(has-value? &lt;<em>connector</em>&gt;)</code>
tells whether the connector has a value.<p></p>
</li>
<li>
<a name="%_idx_3524" id="%_idx_3524"></a><code>(get-value &lt;<em>connector</em>&gt;)</code>
returns the connector's current value.<p></p>
</li>
<li>
<a name="%_idx_3526" id="%_idx_3526"></a><code>(set-value! &lt;<em>connector</em>&gt; &lt;<em>new-value</em>&gt; &lt;<em>informant</em>&gt;)</code>
indicates that the informant is requesting the connector to set itsvalue to the new value.<p></p>
</li>
<li>
<a name="%_idx_3528" id="%_idx_3528"></a><code>(forget-value! &lt;<em>connector</em>&gt; &lt;<em>retractor</em>&gt;)</code>
tells the connector that the retractor is requesting it to forget its value.<p></p>
</li>
<li>
<a name="%_idx_3530" id="%_idx_3530"></a><code>(connect &lt;<em>connector</em>&gt; &lt;<em>new-constraint</em>&gt;)</code>
tells the connector to participate in the new constraint.</li>
</ul>
<p></p>
<p>The connectors communicate with the constraints by means of theprocedures <code>inform-about-value</code>, which tells the givenconstraint that the connector has a value, and <code>inform-about-no-value</code>, which tells the constraint that the connectorhas lost its value.</p>
<p><code>Adder</code> constructs an adder constraint among summand connectors<code>a1</code> and <code>a2</code> and a <code>sum</code> connector.  An adder isimplemented as a procedure with local state (the procedure <code>me</code>below):</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3532" id="%_idx_3532"></a>(define (adder a1 a2 sum)
  (define (process-new-value)
    (cond ((and (has-value? a1) (has-value? a2))
           (set-value! sum
                       (+ (get-value a1) (get-value a2))
                       me))
          ((and (has-value? a1) (has-value? sum))
           (set-value! a2
                       (- (get-value sum) (get-value a1))
                       me))
          ((and (has-value? a2) (has-value? sum))
           (set-value! a1
                       (- (get-value sum) (get-value a2))
                       me))))
  (define (process-forget-value)
    (forget-value! sum me)
    (forget-value! a1 me)
    (forget-value! a2 me)
    (process-new-value))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)  
           (process-new-value))
          ((eq? request 'I-lost-my-value) 
           (process-forget-value))
          (else 
           (error "Unknown request -- ADDER" request))))
  (connect a1 me)
  (connect a2 me)
  (connect sum me)
  me)
</pre></p>
<p></p>
<p><code>Adder</code> connects the new adder to the designated connectors andreturns it as its value.  The procedure <code>me</code>, which represents theadder, acts as a dispatch to the local procedures.  The following“syntax interfaces” (see footnote <a href="#footnote_Temp_385">27</a> insection <a href="#%_sec_3.3.4">3.3.4</a>) are used in conjunction with thedispatch:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3534" id="%_idx_3534"></a>(define (inform-about-value constraint)
  (constraint 'I-have-a-value))
<a name="%_idx_3536" id="%_idx_3536"></a>(define (inform-about-no-value constraint)
  (constraint 'I-lost-my-value))
</pre></p>
<p></p>
<p>The adder's local procedure <code>process-new-value</code> is called when theadder is informed that one of its connectors has a value. The adderfirst checks to see if both <code>a1</code> and <code>a2</code> have values. If so,it tells <code>sum</code> to set its value to the sum of the two addends.The <code>informant</code> argument to <code>set-value!</code> is <code>me</code>, which isthe adder object itself.  If <code>a1</code> and <code>a2</code> do not both havevalues, then the adder checks to see if perhaps <code>a1</code> and <code>sum</code>have values.  If so, it sets <code>a2</code> to the difference of these two.Finally, if <code>a2</code> and <code>sum</code> have values, this gives the adderenough information to set <code>a1</code>.  If the adder is told that one ofits connectors has lost a value, it requests that all of itsconnectors now lose their values.  (Only those values that were set bythis adder are actually lost.)  Then it runs <code>process-new-value</code>.The reason for this last step is that one or more connectors may stillhave a value (that is, a connector may have had a value that was notoriginally set by the adder), and these values may need to bepropagated back through the adder.</p>
<p>A multiplier is very similar to an adder. It will set its <code>product</code> to 0 if either of the factors is 0, even if the other factoris not known.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3538" id="%_idx_3538"></a>(define (multiplier m1 m2 product)
  (define (process-new-value)
    (cond ((or (and (has-value? m1) (= (get-value m1) 0))
               (and (has-value? m2) (= (get-value m2) 0)))
           (set-value! product 0 me))
          ((and (has-value? m1) (has-value? m2))
           (set-value! product
                       (* (get-value m1) (get-value m2))
                       me))
          ((and (has-value? product) (has-value? m1))
           (set-value! m2
                       (/ (get-value product) (get-value m1))
                       me))
          ((and (has-value? product) (has-value? m2))
           (set-value! m1
                       (/ (get-value product) (get-value m2))
                       me))))
  (define (process-forget-value)
    (forget-value! product me)
    (forget-value! m1 me)
    (forget-value! m2 me)
    (process-new-value))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)
           (process-new-value))
          ((eq? request 'I-lost-my-value)
           (process-forget-value))
          (else
           (error "Unknown request -- MULTIPLIER" request))))
  (connect m1 me)
  (connect m2 me)
  (connect product me)
  me)
</pre></p>
<p></p>
<p>A <code>constant</code> constructor simply sets the value of the designatedconnector.  Any <code>I-have-a-value</code> or <code>I-lost-my-value</code> messagesent to the constant box will produce an error.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3540" id="%_idx_3540"></a>(define (constant value connector)
  (define (me request)
    (error "Unknown request -- CONSTANT" request))
  (connect connector me)
  (set-value! connector value me)
  me)
</pre></p>
<p></p>
<p>Finally, a probe prints a message about the setting or unsetting ofthe designated connector:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3542" id="%_idx_3542"></a>(define (probe name connector)
  (define (print-probe value)
    (newline)
    (display "Probe: ")
    (display name)
    (display " = ")
    (display value))
  (define (process-new-value)
    (print-probe (get-value connector)))
  (define (process-forget-value)
    (print-probe "?"))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)
           (process-new-value))
          ((eq? request 'I-lost-my-value)
           (process-forget-value))
          (else
           (error "Unknown request -- PROBE" request))))
  (connect connector me)
  me)
</pre></p>
<p></p>
<p></p>
<p><a name="%_sec_Temp_397" id="%_sec_Temp_397"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_397">Representing connectors</a></h4>
<p><a name="%_idx_3544" id="%_idx_3544"></a>A connector is represented as a procedural object with local statevariables <code>value</code>, the current value of the connector; <code>informant</code>, the object that set the connector's value; and <code>constraints</code>, a list of the constraints in which the connectorparticipates.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3546" id="%_idx_3546"></a>(define (make-connector)
  (let ((value false) (informant false) (constraints '()))
    (define (set-my-value newval setter)
      (cond ((not (has-value? me))
             (set! value newval)
             (set! informant setter)
             (for-each-except setter
                              inform-about-value
                              constraints))
            ((not (= value newval))
             (error "Contradiction" (list value newval)))
            (else 'ignored)))
    (define (forget-my-value retractor)
      (if (eq? retractor informant)
          (begin (set! informant false)
                 (for-each-except retractor
                                  inform-about-no-value
                                  constraints))
          'ignored))
    (define (connect new-constraint)
      (if (not (memq new-constraint constraints))
          (set! constraints 
                (cons new-constraint constraints)))
      (if (has-value? me)
          (inform-about-value new-constraint))
      'done)
    (define (me request)
      (cond ((eq? request 'has-value?)
             (if informant true false))
            ((eq? request 'value) value)
            ((eq? request 'set-value!) set-my-value)
            ((eq? request 'forget) forget-my-value)
            ((eq? request 'connect) connect)
            (else (error "Unknown operation -- CONNECTOR"
                         request))))
    me))
</pre></p>
<p></p>
<p></p>
<p>The connector's local procedure <code>set-my-value</code> is called whenthere is a request to set the connector's value.  If the connectordoes not currently have a value, it will set its value and remember as<code>informant</code> the constraint that requested the value to beset.<a name="call_footnote_Temp_398" href="#footnote_Temp_398" id="call_footnote_Temp_398"><sup><small>32</small></sup></a>Then the connector will notify all of its participatingconstraints except the constraint that requested the value to be set.This is accomplished using the following iterator, which applies adesignated procedure to all items in a list except a given one:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3548" id="%_idx_3548"></a>(define (for-each-except exception procedure list)
  (define (loop items)
    (cond ((null? items) 'done)
          ((eq? (car items) exception) (loop (cdr items)))
          (else (procedure (car items))
                (loop (cdr items)))))
  (loop list))
</pre></p>
<p></p>
<p></p>
<p>If a connector is asked to forget its value, it runs the localprocedure <code>forget-my-value</code>, which first checks to make sure thatthe request is coming from the same object that set the valueoriginally.  If so, the connector informs its associated constraintsabout the loss of the value.</p>
<p>The local procedure <code>connect</code> adds the designated new constraintto the list of constraints if it is not already in that list.  Then,if the connector has a value, it informs the new constraint of thisfact.</p>
<p>The connector's procedure <code>me</code> serves as a dispatch to the otherinternal procedures and also represents the connector as an object.The following procedures provide a syntax interface for the dispatch:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3550" id="%_idx_3550"></a>(define (has-value? connector)
  (connector 'has-value?))
<a name="%_idx_3552" id="%_idx_3552"></a>(define (get-value connector)
  (connector 'value))
<a name="%_idx_3554" id="%_idx_3554"></a>(define (set-value! connector new-value informant)
  ((connector 'set-value!) new-value informant))
<a name="%_idx_3556" id="%_idx_3556"></a>(define (forget-value! connector retractor)
  ((connector 'forget) retractor))
<a name="%_idx_3558" id="%_idx_3558"></a>(define (connect connector new-constraint)
  ((connector 'connect) new-constraint))
</pre></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_3.33" id="%_thm_3.33"></a><b>Exercise 3.33.</b>  Using primitive multiplier, adder, and constant constraints, define aprocedure <a name="%_idx_3560" id="%_idx_3560"></a><code>averager</code> that takes three connectors <code>a</code>, <code>b</code>,and <code>c</code> as inputs and establishes the constraint that the value of<code>c</code> is the average of the values of <code>a</code> and <code>b</code>.</p>
<p></p>
<p></p>
<p><a name="%_thm_3.34" id="%_thm_3.34"></a><b>Exercise 3.34.</b>  <a name="%_idx_3562" id="%_idx_3562"></a>Louis Reasoner wants to build a squarer, a constraint device with twoterminals such that the value of connector <code>b</code> on the secondterminal will always be the square of the value <code>a</code> on the firstterminal.  He proposes the following simple device made from amultiplier:</p>
<p></p>
<p></p>
<p><pre>(define (squarer a b)
  (multiplier a a b))
</pre></p>
<p></p>
<p>There is a serious flaw in this idea.  Explain.</p>
<p></p>
<p></p>
<p><a name="%_thm_3.35" id="%_thm_3.35"></a><b>Exercise 3.35.</b>  <a name="%_idx_3564" id="%_idx_3564"></a>Ben Bitdiddle tells Louis that one way to avoid the trouble inexercise <a href="#%_thm_3.34">3.34</a> is to define a squarer as a newprimitive constraint.  Fill in the missing portions in Ben's outlinefor a procedure to implement such a constraint:</p>
<p></p>
<p></p>
<p><pre>(define (squarer a b)
  (define (process-new-value)
    (if (has-value? b)
        (if (&lt; (get-value b) 0)
            (error "square less than 0 -- SQUARER" (get-value b))
            &lt;<em>alternative1</em>&gt;)
        &lt;<em>alternative2</em>&gt;))
  (define (process-forget-value) &lt;<em>body1</em>&gt;)
  (define (me request) &lt;<em>body2</em>&gt;)
  &lt;<em>rest of definition</em>&gt;
  me)
</pre></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_3.36" id="%_thm_3.36"></a><b>Exercise 3.36.</b>  Suppose we evaluate the following sequence of expressions in theglobal environment:</p>
<p></p>
<p></p>
<p><pre>(define a (make-connector))
(define b (make-connector))
(set-value! a 10 'user)
</pre></p>
<p></p>
<p>At some time during evaluation of the <code>set-value!</code>, the followingexpression from the connector's local procedure is evaluated:</p>
<p></p>
<p></p>
<p><pre>(for-each-except setter inform-about-value constraints)
</pre></p>
<p></p>
<p>Draw an environment diagram showing the environment in which the aboveexpression is evaluated.</p>
<p></p>
<p></p>
<p><a name="%_thm_3.37" id="%_thm_3.37"></a><b>Exercise 3.37.</b>  The <code>celsius-fahrenheit-converter</code> procedure is cumbersome whencompared with a more expression-oriented style of definition, such as</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_3566" id="%_idx_3566"></a>(define (celsius-fahrenheit-converter x)
  (c+ (c* (c/ (cv 9) (cv 5))
          x)
      (cv 32)))
(define C (make-connector))
(define F (celsius-fahrenheit-converter C))
</pre></p>
<p></p>
<p>Here <code>c+</code>, <code>c*</code>, etc. are the “constraint” versions of thearithmetic operations.  For example, <code>c+</code> takes two connectors asarguments and returns a connector that is related to these by an adderconstraint:</p>
<p></p>
<p></p>
<p><pre>(define (c+ x y)
  (let ((z (make-connector)))
    (adder x y z)
    z))
</pre></p>
<p></p>
<p>Define analogous procedures <code>c-</code>, <code>c*</code>, <code>c/</code>, and <code>cv</code>(constant value) that enable us to define compound constraints as inthe converter example above.<a name="call_footnote_Temp_404" href="#footnote_Temp_404" id="call_footnote_Temp_404"><sup><small>33</small></sup></a></p>
<p></p>
<p></p>
<div class="smallprint"><hr></div>
<p></p>
<div class="footnote">
<p><a name="footnote_Temp_349" href="#call_footnote_Temp_349" id="footnote_Temp_349"><sup><small>16</small></sup></a> <code>Set-car!</code> and <code>set-cdr!</code> return implementation-dependent<a name="%_idx_3148" id="%_idx_3148"></a><a name="%_idx_3150" id="%_idx_3150"></a><a name="%_idx_3152" id="%_idx_3152"></a><a name="%_idx_3154" id="%_idx_3154"></a>values.  Like <code>set!</code>, they should be used only for their effect.</p>
<p><a name="footnote_Temp_350" href="#call_footnote_Temp_350" id="footnote_Temp_350"><sup><small>17</small></sup></a> We see from this that mutation operations on listscan create “garbage” that is not part of any accessible structure.We will see in section <a href="book-Z-H-33.html#%_sec_5.3.2">5.3.2</a> that Lisp memory-managementsystems include a <a name="%_idx_3156" id="%_idx_3156"></a><em>garbage collector</em>, which identifies andrecycles the memory space used by unneeded pairs.</p>
<p><a name="footnote_Temp_351" href="#call_footnote_Temp_351" id="footnote_Temp_351"><sup><small>18</small></sup></a> <code>Get-new-pair</code> is one of the operations that must be implemented aspart of the memory management required by a Lisp implementation.  Wewill discuss this in section <a href="book-Z-H-33.html#%_sec_5.3.1">5.3.1</a>.</p>
<p><a name="footnote_Temp_356" href="#call_footnote_Temp_356" id="footnote_Temp_356"><sup><small>19</small></sup></a> The two pairsare distinct because each call to <code>cons</code> returns a new pair.  Thesymbols are shared; in Scheme there is a unique symbol with any given<a name="%_idx_3184" id="%_idx_3184"></a>name.  Since Scheme provides no way to mutate a symbol, this sharing isundetectable.  Note also that the sharing is what enables us tocompare symbols using <code>eq?</code>, which simply checks equality ofpointers.</p>
<p><a name="footnote_Temp_357" href="#call_footnote_Temp_357" id="footnote_Temp_357"><sup><small>20</small></sup></a> Thesubtleties of dealing with sharing of mutable data objects reflect theunderlying issues of “sameness” and “change” that were raised insection <a href="book-Z-H-20.html#%_sec_3.1.3">3.1.3</a>.  We mentioned there thatadmitting change to our language requires that a compound object musthave an “identity” that is something different from the pieces fromwhich it is composed.  In Lisp, we consider this “identity” to bethe quality that is tested by <code>eq?</code>, i.e., by equality ofpointers.  Since in most Lisp implementations a pointer isessentially a memory address, we are “solving the problem” ofdefining the identity of objects by stipulating that a data object“itself” is the information stored in some particular set of memorylocations in the computer.  This suffices for simple Lisp programs,but is hardly a general way to resolve the issue of “sameness” incomputational models.</p>
<p><a name="footnote_Temp_364" href="#call_footnote_Temp_364" id="footnote_Temp_364"><sup><small>21</small></sup></a> On the other hand, from theviewpoint of implementation, assignment requires us to modify theenvironment, which is itself a mutable data structure.  Thus,assignment and mutation are equipotent: Each can be implemented interms of the other.</p>
<p><a name="footnote_Temp_366" href="#call_footnote_Temp_366" id="footnote_Temp_366"><sup><small>22</small></sup></a> If the first item isthe final item in the queue, the front pointer will be the empty list afterthe deletion, which will mark the queue as empty; we needn't worryabout updating the rear pointer, which will still point to the deleteditem, because <code>empty-queue?</code> looks only at the front pointer.</p>
<p><a name="footnote_Temp_370" href="#call_footnote_Temp_370" id="footnote_Temp_370"><sup><small>23</small></sup></a> Be careful not tomake the interpreter try to print a structure that contains cycles.(See exercise <a href="#%_thm_3.13">3.13</a>.)</p>
<p><a name="footnote_Temp_371" href="#call_footnote_Temp_371" id="footnote_Temp_371"><sup><small>24</small></sup></a> Because <code>assoc</code>uses <code>equal?</code>, it can recognize keys that are symbols, numbers,or list structure.</p>
<p><a name="footnote_Temp_372" href="#call_footnote_Temp_372" id="footnote_Temp_372"><sup><small>25</small></sup></a> Thus, the first backbone pair is theobject that represents the table “itself”; that is, a pointer to thetable is a pointer to this pair.  This same backbone pair alwaysstarts the table.  If we did not arrange things in this way, <code>insert!</code> would have to return a new value for the start of the tablewhen it added a new record.</p>
<p><a name="footnote_Temp_379" href="#call_footnote_Temp_379" id="footnote_Temp_379"><sup><small>26</small></sup></a> Afull-adder is a basic circuit element used in adding two binarynumbers.  Here A and B are the bits at corresponding positions in thetwo numbers to be added, and C<sub><em>i</em><em>n</em></sub> is the carry bit from theaddition one place to the right.  The circuit generates SUM, which isthe sum bit in the corresponding position, and C<sub><em>o</em><em>u</em><em>t</em></sub>, which is thecarry bit to be propagated to the left.</p>
<p><a name="footnote_Temp_385" href="#call_footnote_Temp_385" id="footnote_Temp_385"><sup><small>27</small></sup></a> These procedures are simply syntactic sugar that allow<a name="%_idx_3400" id="%_idx_3400"></a><a name="%_idx_3402" id="%_idx_3402"></a>us to use ordinary procedural syntax to access the local procedures ofobjects.  It is striking that we can interchange the role of“procedures” and “data” in such a simple way.  For example, if wewrite <code>(wire 'get-signal)</code> we think of <code>wire</code> as a procedurethat is called with the message <code>get-signal</code> as input.Alternatively, writing <code>(get-signal wire)</code> encourages us to thinkof <code>wire</code> as a data object that is the input to a procedure <code>get-signal</code>.  The truth of the matter is that, in a language in whichwe can deal with procedures as objects, there is no fundamentaldifference between “procedures” and “data,” and we can choose oursyntactic sugar to allow us to program in whatever style we choose.</p>
<p><a name="footnote_Temp_390" href="#call_footnote_Temp_390" id="footnote_Temp_390"><sup><small>28</small></sup></a> Theagenda is a <a name="%_idx_3452" id="%_idx_3452"></a><a name="%_idx_3454" id="%_idx_3454"></a>headed list, like the tables in section <a href="#%_sec_3.3.3">3.3.3</a>,but since the list is headed by the time, we do not need an additionaldummy header (such as the <code>*table*</code> symbol used with tables).</p>
<p><a name="footnote_Temp_391" href="#call_footnote_Temp_391" id="footnote_Temp_391"><sup><small>29</small></sup></a> Observe that the <code>if</code> expression inthis procedure has no&lt;<em>alternative</em>&gt; expression.  Such a “one-armed <code>if</code> statement”<a name="%_idx_3474" id="%_idx_3474"></a><a name="%_idx_3476" id="%_idx_3476"></a>is used to decide whether to do something, rather than to selectbetween two expressions.  An <code>if</code> expression returns anunspecified value if the predicate is false and there is no&lt;<em>alternative</em>&gt;.</p>
<p><a name="footnote_Temp_392" href="#call_footnote_Temp_392" id="footnote_Temp_392"><sup><small>30</small></sup></a> In this way, the current time will always be the timeof the action most recently processed.  Storing this time at the headof the agenda ensures that it will still be available even if theassociated time segment has been deleted.</p>
<p><a name="footnote_Temp_394" href="#call_footnote_Temp_394" id="footnote_Temp_394"><sup><small>31</small></sup></a> Constraint propagationfirst appeared in the incredibly forward-looking <a name="%_idx_3486" id="%_idx_3486"></a>SKETCHPAD system of<a name="%_idx_3488" id="%_idx_3488"></a>Ivan Sutherland (1963).  A beautiful constraint-propagation systembased on the <a name="%_idx_3490" id="%_idx_3490"></a>Smalltalk language was developed by <a name="%_idx_3492" id="%_idx_3492"></a>Alan Borning (1977)at <a name="%_idx_3494" id="%_idx_3494"></a>Xerox Palo Alto Research Center.  Sussman, Stallman, and Steele<a name="%_idx_3496" id="%_idx_3496"></a><a name="%_idx_3498" id="%_idx_3498"></a><a name="%_idx_3500" id="%_idx_3500"></a><a name="%_idx_3502" id="%_idx_3502"></a><a name="%_idx_3504" id="%_idx_3504"></a><a name="%_idx_3506" id="%_idx_3506"></a>applied constraint propagation to electrical circuit analysis (Sussmanand Stallman 1975; Sussman and Steele 1980). TK!Solver (Konopasek andJayaraman 1984) is an extensive modeling environment based onconstraints.</p>
<p><a name="footnote_Temp_398" href="#call_footnote_Temp_398" id="footnote_Temp_398"><sup><small>32</small></sup></a> The <code>setter</code> might not be a constraint.  In ourtemperature example, we used <code>user</code> as the <code>setter</code>.</p>
<p><a name="footnote_Temp_404" href="#call_footnote_Temp_404" id="footnote_Temp_404"><sup><small>33</small></sup></a> The expression-oriented formatis convenient because it avoids the need to name the intermediateexpressions in a computation.  Our original formulation of the<a name="%_idx_3568" id="%_idx_3568"></a><a name="%_idx_3570" id="%_idx_3570"></a><a name="%_idx_3572" id="%_idx_3572"></a><a name="%_idx_3574" id="%_idx_3574"></a><a name="%_idx_3576" id="%_idx_3576"></a>constraint language is cumbersome in the same way that many languagesare cumbersome when dealing with operations on compound data.  Forexample, if we wanted to compute the product (<em>a</em> + <em>b</em>) · (<em>c</em> + <em>d</em>), where thevariables represent vectors, we could work in “imperative style,”using procedures that set the values of designated vector argumentsbut do not themselves return vectors as values:</p>
<p></p>
<p><pre>(v-sum a b temp1)
(v-sum c d temp2)
(v-prod temp1 temp2 answer)
</pre></p>
<p></p>
<p>Alternatively, we could deal with expressions, usingprocedures that return vectors as values, and thus avoidexplicitly mentioning <code>temp1</code> and <code>temp2</code>:</p>
<p></p>
<p><pre>(define answer (v-prod (v-sum a b) (v-sum c d)))
</pre></p>
<p></p>
<p>Since Lisp allows us to return compound objects as values ofprocedures, we can transform our imperative-style constraint languageinto an expression-oriented style as shown in this exercise.  Inlanguages that are impoverished in handling compound objects, such asAlgol, Basic, and Pascal (unless one explicitly uses Pascal pointervariables), one is usually stuck with the imperative style whenmanipulating compound objects.  Given the advantage of theexpression-oriented format, one might ask if there is any reason tohave implemented the system in imperative style, as we did in thissection.  One reason is that the non-expression-oriented constraintlanguage provides a handle on constraint objects (e.g., the value ofthe <code>adder</code> procedure) as well as on connector objects.  This isuseful if we wish to extend the system with new operations thatcommunicate with constraints directly rather than only indirectly viaoperations on connectors.  Although it is easy to implement theexpression-oriented style in terms of the imperative implementation,it is very difficult to do the converse.</p>
</div></body>
</html>
