<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<?xml version="1.0" encoding="utf-8"?><html xmlns="http://www.w3.org/1999/xhtml" xmlns:ops="http://www.idpf.org/2007/ops">
<!-- Generated from TeX source by tex2page, v 4o,
     (c) Dorai Sitaram, http://www.cs.rice.edu/~dorai/tex2page --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Type: text/html; charset=utf-8">
<title>Structure and Interpretation of Computer Programs</title>
<link rel="stylesheet" type="text/css" href="book-Z-C.css" title="default">
</head>
<body><a name="%_sec_5.4" id="%_sec_5.4"></a><h2><a href="book-Z-H-4.html#%_toc_%_sec_5.4">5.4  The Explicit-Control Evaluator</a></h2>
<p><a name="%_idx_5996" id="%_idx_5996"></a>In section <a href="book-Z-H-31.html#%_sec_5.1">5.1</a> we saw how totransform simple Scheme programs into descriptions of registermachines.  We will now perform this transformation on a more complexprogram, the metacircular evaluator ofsections <a href="book-Z-H-26.html#%_sec_4.1.1">4.1.1</a>-<a href="book-Z-H-26.html#%_sec_4.1.4">4.1.4</a>,which shows howthe behavior of a Scheme interpreter can be described in terms of theprocedures <code>eval</code> and <code>apply</code>.The <em>explicit-controlevaluator</em> that we develop in this section shows how the underlyingprocedure-calling and argument-passing mechanisms used in theevaluation process can be described in terms of operations onregisters and stacks.  In addition, the explicit-control evaluator canserve as an implementation of a Scheme interpreter, written in alanguage that is very similar to the native machine language ofconventional computers.  The evaluator can be executed by theregister-machine simulator of section <a href="book-Z-H-32.html#%_sec_5.2">5.2</a>.Alternatively, it can be used as a starting point for building amachine-language implementation of a Scheme evaluator, or even a<a name="%_idx_5998" id="%_idx_5998"></a><a name="%_idx_6000" id="%_idx_6000"></a><a name="%_idx_6002" id="%_idx_6002"></a>special-purpose machine for evaluating Scheme expressions.Figure <a href="#%_fig_5.16">5.16</a> shows such a hardware implementation: asilicon chip that acts as an evaluator for Scheme.  The chip designersstarted with the data-path and controller specifications for aregister machine similar to the evaluator described in this sectionand used design automation programs to construct theintegrated-circuit layout.<a name="call_footnote_Temp_765" href="#footnote_Temp_765" id="call_footnote_Temp_765"><sup><small>19</small></sup></a></p>
<p></p>
<p><a name="%_sec_Temp_766" id="%_sec_Temp_766"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_766">Registers and operations</a></h4>
<p><a name="%_idx_6006" id="%_idx_6006"></a><a name="%_idx_6008" id="%_idx_6008"></a>In designing the explicit-control evaluator, we must specify theoperations to be used in our register machine.  We described themetacircular evaluator in terms of abstract syntax, using proceduressuch as <code>quoted?</code> and <code>make-procedure</code>.  In implementing theregister machine, we could expand these procedures into sequences ofelementary list-structure memory operations, and implement theseoperations on our register machine.  However, this would make ourevaluator very long, obscuring the basic structure withdetails.  To clarify the presentation, we will include as primitiveoperations of the register machine the syntax procedures given insection <a href="book-Z-H-26.html#%_sec_4.1.2">4.1.2</a> and the procedures forrepresenting environments and other run-time data given insections <a href="book-Z-H-26.html#%_sec_4.1.3">4.1.3</a> and <a href="book-Z-H-26.html#%_sec_4.1.4">4.1.4</a>.In order to completely specify an evaluator that could be programmedin a low-level machine language or implemented in hardware, we wouldreplace these operations by more elementary operations, using thelist-structure implementation we described insection <a href="book-Z-H-33.html#%_sec_5.3">5.3</a>.</p>
<p><a name="%_fig_5.16" id="%_fig_5.16"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/chip.jpg" border="0" height="310"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 5.16:</b>  A silicon-chip implementation of an evaluator forScheme.</div></caption>
<tr><td><a name="%_idx_6010" id="%_idx_6010"></a><a name="%_idx_6012" id="%_idx_6012"></a><a name="%_idx_6014" id="%_idx_6014"></a></td></tr>
</table></div>
<p></p>
<p><a name="%_idx_6016" id="%_idx_6016"></a><a name="%_idx_6018" id="%_idx_6018"></a><a name="%_idx_6020" id="%_idx_6020"></a><a name="%_idx_6022" id="%_idx_6022"></a><a name="%_idx_6024" id="%_idx_6024"></a><a name="%_idx_6026" id="%_idx_6026"></a><a name="%_idx_6028" id="%_idx_6028"></a><a name="%_idx_6030" id="%_idx_6030"></a>Our Scheme evaluator register machine includes a stack and sevenregisters: <code>exp</code>, <code>env</code>, <code>val</code>, <code>continue</code>, <code>proc</code>,<code>argl</code>, and <code>unev</code>.  <code>Exp</code> is used to hold the expressionto be evaluated, and <code>env</code> contains the environment in which theevaluation is to be performed.  At the end of an evaluation, <code>val</code>contains the value obtained by evaluating the expression in thedesignated environment.  The <code>continue</code> register is used toimplement recursion, as explained insection <a href="book-Z-H-31.html#%_sec_5.1.4">5.1.4</a>.  (The evaluator needs to callitself recursively, since evaluating an expression requires evaluatingits subexpressions.)  The registers <code>proc</code>, <code>argl</code>, and <code>unev</code> are used in evaluating combinations.</p>
<p>We will not provide a data-path diagram to show how the registers andoperations of the evaluator are connected, nor will we give thecomplete list of machine operations.  These are implicit in theevaluator's controller, which will be presented in detail.</p>
<p><a name="%_sec_5.4.1" id="%_sec_5.4.1"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_5.4.1">5.4.1  The Core of the Explicit-Control Evaluator</a></h3>
<p><a name="%_idx_6032" id="%_idx_6032"></a>The central element in the evaluator is the sequence of instructionsbeginning at <code>eval-dispatch</code>.  This corresponds to the <code>eval</code>procedure of the metacircular evaluator described insection <a href="book-Z-H-26.html#%_sec_4.1.1">4.1.1</a>.  When the controller starts at <code>eval-dispatch</code>, it evaluates the expression specified by <code>exp</code> inthe environment specified by <code>env</code>.  When evaluation is complete,the controller will go to the entry point stored in <code>continue</code>, and the<code>val</code> register will hold the value of the expression.  As with themetacircular <code>eval</code>, the structure of <code>eval-dispatch</code> is acase analysis on the syntactic type of the expression to beevaluated.<a name="call_footnote_Temp_767" href="#footnote_Temp_767" id="call_footnote_Temp_767"><sup><small>20</small></sup></a></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_6034" id="%_idx_6034"></a>eval-dispatch
  (test (op self-evaluating?) (reg exp))
  (branch (label ev-self-eval))
  (test (op variable?) (reg exp))
  (branch (label ev-variable))
  (test (op quoted?) (reg exp))
  (branch (label ev-quoted))
  (test (op assignment?) (reg exp))
  (branch (label ev-assignment))
  (test (op definition?) (reg exp))
  (branch (label ev-definition))
  (test (op if?) (reg exp))
  (branch (label ev-if))
  (test (op lambda?) (reg exp))
  (branch (label ev-lambda))
  (test (op begin?) (reg exp))
  (branch (label ev-begin))
  (test (op application?) (reg exp))
  (branch (label ev-application))
  (goto (label unknown-expression-type))
</pre></p>
<p></p>
<p></p>
<p><a name="%_sec_Temp_768" id="%_sec_Temp_768"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_768">Evaluating simple expressions</a></h4>
<p><a name="%_idx_6036" id="%_idx_6036"></a>Numbers and strings (which are self-evaluating),variables, quotations, and <code>lambda</code> expressions have nosubexpressions to be evaluated.  For these, the evaluator simplyplaces the correct value in the <code>val</code> register and continuesexecution at the entry point specified by <code>continue</code>.  Evaluationof simple expressions is performed by the following controller code:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_6038" id="%_idx_6038"></a>ev-self-eval
  (assign val (reg exp))
  (goto (reg continue))
<a name="%_idx_6040" id="%_idx_6040"></a>ev-variable
  (assign val (op lookup-variable-value) (reg exp) (reg env))
  (goto (reg continue))
<a name="%_idx_6042" id="%_idx_6042"></a>ev-quoted
  (assign val (op text-of-quotation) (reg exp))
  (goto (reg continue))
<a name="%_idx_6044" id="%_idx_6044"></a>ev-lambda
  (assign unev (op lambda-parameters) (reg exp))
  (assign exp (op lambda-body) (reg exp))
  (assign val (op make-procedure)
              (reg unev) (reg exp) (reg env))
  (goto (reg continue))
</pre></p>
<p></p>
<p>Observe how <code>ev-lambda</code> uses the <code>unev</code> and <code>exp</code>registers to hold the parameters and body of the lambda expression sothat they can be passed to the <code>make-procedure</code> operation, alongwith the environment in <code>env</code>.</p>
<p><a name="%_sec_Temp_769" id="%_sec_Temp_769"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_769">Evaluating procedure applications</a></h4>
<p><a name="%_idx_6046" id="%_idx_6046"></a><a name="%_idx_6048" id="%_idx_6048"></a>A procedure application is specified by a combination containing anoperator and operands.  The operator is a subexpression whose value isa procedure, and the operands are subexpressions whose values are thearguments to which the procedure should be applied.  The metacircular<code>eval</code> handles applications by calling itself recursively toevaluate each element of the combination, and then passing the resultsto <code>apply</code>, which performs the actual procedure application.  Theexplicit-control evaluator does the same thing; these recursive callsare implemented by <code>goto</code> instructions, together with <a name="%_idx_6050" id="%_idx_6050"></a>use of thestack to save registers that will be restored after the recursive callreturns.  Before each call we will be careful to identify whichregisters must be saved (because their values will be neededlater).<a name="call_footnote_Temp_770" href="#footnote_Temp_770" id="call_footnote_Temp_770"><sup><small>21</small></sup></a></p>
<p>We begin the evaluation of an application by evaluating the operatorto produce a procedure, which will later be applied to the evaluatedoperands.  To evaluate the operator, we move it to the <code>exp</code>register and go to <code>eval-dispatch</code>.  The environment in the <code>env</code> register is already the correct one in which to evaluate theoperator.  However, we save <code>env</code> because we will need it later toevaluate the operands.  We also extract the operands into <code>unev</code>and save this on the stack.  We set up <code>continue</code> so that <code>eval-dispatch</code> will resume at <code>ev-appl-did-operator</code> after theoperator has been evaluated.  First, however, we save the old value of<code>continue</code>, which tells the controller where to continue after theapplication.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_6056" id="%_idx_6056"></a>ev-application
  (save continue)
  (save env)
  (assign unev (op operands) (reg exp))
  (save unev)
  (assign exp (op operator) (reg exp))
  (assign continue (label ev-appl-did-operator))
  (goto (label eval-dispatch))
</pre></p>
<p></p>
<p></p>
<p><a name="%_idx_6058" id="%_idx_6058"></a>Upon returning from evaluating the operator subexpression, we proceedto evaluate the operands of the combination and to accumulate theresulting arguments in a list, held in <code>argl</code>.  First we restorethe unevaluated operands and the environment.  We initialize <code>argl</code> to an empty list.  Then we assign to the <code>proc</code> register theprocedure that was produced by evaluating the operator.  If there areno operands, we go directly to <code>apply-dispatch</code>.  Otherwise wesave <code>proc</code> on the stack and start the argument-evaluationloop:<a name="call_footnote_Temp_771" href="#footnote_Temp_771" id="call_footnote_Temp_771"><sup><small>22</small></sup></a></p>
<p></p>
<p></p>
<p><pre>ev-appl-did-operator
  (restore unev)                  <em>; the operands</em>
  (restore env)
  (assign argl (op empty-arglist))
  (assign proc (reg val))         <em>; the operator</em>
  (test (op no-operands?) (reg unev))
  (branch (label apply-dispatch))
  (save proc)
</pre></p>
<p></p>
<p></p>
<p>Each cycle of the argument-evaluation loop evaluates an operandfrom the list in <code>unev</code> and accumulates the result into <code>argl</code>.To evaluate an operand, we place it in the <code>exp</code> registerand go to <code>eval-dispatch</code>, after setting <code>continue</code> so thatexecution will resume with the argument-accumulation phase.  But firstwe save the arguments accumulated so far (held in <code>argl</code>), theenvironment (held in <code>env</code>), and the remaining operands to be evaluated(held in <code>unev</code>).  A special case is made for the evaluation of thelast operand, which is handled at <code>ev-appl-last-arg</code>.</p>
<p></p>
<p></p>
<p><pre>ev-appl-operand-loop
  (save argl)
  (assign exp (op first-operand) (reg unev))
  (test (op last-operand?) (reg unev))
  (branch (label ev-appl-last-arg))
  (save env)
  (save unev)
  (assign continue (label ev-appl-accumulate-arg))
  (goto (label eval-dispatch))
</pre></p>
<p></p>
<p></p>
<p>When an operand has been evaluated, the value is accumulated into thelist held in <code>argl</code>.  The operand is then removed from the list ofunevaluated operands in <code>unev</code>, and the argument-evaluation continues.</p>
<p></p>
<p></p>
<p><pre>ev-appl-accumulate-arg
  (restore unev)
  (restore env)
  (restore argl)
  (assign argl (op adjoin-arg) (reg val) (reg argl))
  (assign unev (op rest-operands) (reg unev))
  (goto (label ev-appl-operand-loop))
</pre></p>
<p></p>
<p></p>
<p>Evaluation of the last argument is handled differently.  There is noneed to save the environment or the list of unevaluated operandsbefore going to <code>eval-dispatch</code>,since they will not be required after the last operand is evaluated.Thus, we return from the evaluation to a special entry point <code>ev-appl-accum-last-arg</code>, which restores the argument list, accumulatesthe new argument, restores the saved procedure, and goes off toperform the application.<a name="call_footnote_Temp_772" href="#footnote_Temp_772" id="call_footnote_Temp_772"><sup><small>23</small></sup></a></p>
<p></p>
<p></p>
<p><pre>ev-appl-last-arg
  (assign continue (label ev-appl-accum-last-arg))
  (goto (label eval-dispatch))
ev-appl-accum-last-arg
  (restore argl)
  (assign argl (op adjoin-arg) (reg val) (reg argl))
  (restore proc)
  (goto (label apply-dispatch))
</pre></p>
<p></p>
<p></p>
<p><a name="%_idx_6070" id="%_idx_6070"></a>The details of the argument-evaluation loop determine the order inwhich the interpreter evaluates the operands of a combination (e.g.,left to right or right to left – seeexercise <a href="book-Z-H-20.html#%_thm_3.8">3.8</a>).  This order is not determinedby the metacircular evaluator, which inherits its control structurefrom the underlying Scheme in which it is implemented.<a name="call_footnote_Temp_773" href="#footnote_Temp_773" id="call_footnote_Temp_773"><sup><small>24</small></sup></a> Because the <code>first-operand</code>selector (used in <code>ev-appl-operand-loop</code> to extract successive operandsfrom <code>unev</code>) is implemented as <code>car</code> and the <code>rest-operands</code> selector is implemented as <code>cdr</code>, theexplicit-control evaluator will evaluate the operands of a combinationin left-to-right order.</p>
<p><a name="%_sec_Temp_774" id="%_sec_Temp_774"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_774">Procedure application</a></h4>
<p></p>
<p>The entry point <code>apply-dispatch</code> corresponds to the <code>apply</code>procedure of the metacircular evaluator.  By the time we get to <code>apply-dispatch</code>, the <code>proc</code> register contains the procedure toapply and <code>argl</code> contains the list of evaluated arguments to whichit must be applied.  The saved value of <code>continue</code> (originallypassed to <code>eval-dispatch</code> and saved at <code>ev-application</code>),which tells where to return with the result of the procedureapplication, is on the stack.  When the application is complete, thecontroller transfers to the entry point specified by the saved <code>continue</code>, with the result of the application in <code>val</code>.  As withthe metacircular <code>apply</code>, there are two cases to consider.  Eitherthe procedure to be applied is a primitive or it is a compoundprocedure.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_6072" id="%_idx_6072"></a>apply-dispatch
  (test (op primitive-procedure?) (reg proc))
  (branch (label primitive-apply))
  (test (op compound-procedure?) (reg proc))  
  (branch (label compound-apply))
  (goto (label unknown-procedure-type))
</pre></p>
<p></p>
<p></p>
<p><a name="%_idx_6074" id="%_idx_6074"></a>We assume that each primitive is implemented so as to obtain itsarguments from <code>argl</code> and place its result in <code>val</code>.  Tospecify how the machine handles primitives, we would have to provide asequence of controller instructions to implement each primitive andarrange for <code>primitive-apply</code> to dispatch to theinstructions for the primitive identified by thecontents of <code>proc</code>.  Since we are interested in the structure ofthe evaluation process rather than the details of the primitives, wewill instead just use an <code>apply-primitive-procedure</code> operationthat applies the procedure in <code>proc</code> to the arguments in <code>argl</code>.  For the purpose of simulating the evaluator with the simulatorof section <a href="book-Z-H-32.html#%_sec_5.2">5.2</a> we use the procedure <code>apply-primitive-procedure</code>, which calls on the underlying Schemesystem to perform the application, just as we did for the metacircularevaluator in section <a href="book-Z-H-26.html#%_sec_4.1.4">4.1.4</a>.  After computing thevalue of the primitive application, we restore <code>continue</code> and goto the designated entry point.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_6076" id="%_idx_6076"></a>primitive-apply
  (assign val (op apply-primitive-procedure)
              (reg proc)
              (reg argl))
  (restore continue)
  (goto (reg continue))
</pre></p>
<p></p>
<p></p>
<p><a name="%_idx_6078" id="%_idx_6078"></a>To apply a compound procedure, we proceed just as with themetacircular evaluator.  We construct a frame that binds theprocedure's parameters to the arguments, use this frame toextend the environment carried by the procedure, and evaluate in thisextended environment the sequence of expressions that forms the bodyof the procedure.  <code>Ev-sequence</code>, described below insection <a href="#%_sec_5.4.2">5.4.2</a>, handles the evaluationof the sequence.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_6080" id="%_idx_6080"></a>compound-apply
  (assign unev (op procedure-parameters) (reg proc))
  (assign env (op procedure-environment) (reg proc))
  (assign env (op extend-environment)
              (reg unev) (reg argl) (reg env))
  (assign unev (op procedure-body) (reg proc))
  (goto (label ev-sequence))
</pre></p>
<p></p>
<p></p>
<p><code>Compound-apply</code> is the only place in the interpreter where the<code>env</code> register is ever assigned a new value.  Just as in themetacircular evaluator, the new environment is constructed from theenvironment carried by the procedure, together with the argument listand the corresponding list of variables to be bound.</p>
<p><a name="%_sec_5.4.2" id="%_sec_5.4.2"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_5.4.2">5.4.2  Sequence Evaluation and Tail Recursion</a></h3>
<p><a name="%_idx_6082" id="%_idx_6082"></a>The portion of the explicit-control evaluator at <code>ev-sequence</code> isanalogous to the metacircular evaluator's <code>eval-sequence</code> procedure.  Ithandles sequences of expressions in procedure bodies or in explicit<code>begin</code> expressions.</p>
<p>Explicit <code>begin</code> expressions are evaluated by placing the sequenceof expressions to be evaluated in <code>unev</code>, saving <code>continue</code> on thestack, and jumping to <code>ev-sequence</code>.</p>
<p></p>
<p><pre><a name="%_idx_6084" id="%_idx_6084"></a>ev-begin
  (assign unev (op begin-actions) (reg exp))
  (save continue)
  (goto (label ev-sequence))
</pre></p>
<p></p>
<p>The implicit sequences in procedure bodies are handled by jumping to<code>ev-sequence</code> from <code>compound-apply</code>, at which point <code>continue</code> is already on the stack, having been saved at<code>ev-application</code>.</p>
<p>The entries at <code>ev-sequence</code>and <code>ev-sequence-continue</code> form a loop thatsuccessively evaluates each expression in a sequence.  The list ofunevaluated expressions is kept in <code>unev</code>.  Before evaluating eachexpression, we check to see if there are additional expressions to beevaluated in the sequence.  If so, we save the rest of the unevaluatedexpressions (held in <code>unev</code>) and the environment in which thesemust be evaluated (held in <code>env</code>) and call <code>eval-dispatch</code> toevaluate the expression.  The two saved registers are restored uponthe return from this evaluation, at <code>ev-sequence-continue</code>.</p>
<p>The final expression in the sequence is handled differently, at theentry point <code>ev-sequence-last-exp</code>.  Since there are no moreexpressions to be evaluated after this one, we need not save <code>unev</code> or <code>env</code> before going to <code>eval-dispatch</code>.  The value ofthe whole sequence is the value of the last expression, so after theevaluation of the last expression there is nothing left to do exceptcontinue at the entry point currently held on the stack (which was savedby <code>ev-application</code> or <code>ev-begin</code>.)Rather than setting up <code>continue</code> to arrange for <code>eval-dispatch</code> to return here and then restoring <code>continue</code> fromthe stack and continuing at that entry point, we restore <code>continue</code> fromthe stack before going to <code>eval-dispatch</code>, so that <code>eval-dispatch</code> will continue at that entry point after evaluating theexpression.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_6086" id="%_idx_6086"></a>ev-sequence
  (assign exp (op first-exp) (reg unev))
  (test (op last-exp?) (reg unev))
  (branch (label ev-sequence-last-exp))
  (save unev)
  (save env)
  (assign continue (label ev-sequence-continue))
  (goto (label eval-dispatch))
ev-sequence-continue
  (restore env)
  (restore unev)
  (assign unev (op rest-exps) (reg unev))
  (goto (label ev-sequence))
ev-sequence-last-exp
  (restore continue)
  (goto (label eval-dispatch))
</pre></p>
<p></p>
<p></p>
<p><a name="%_sec_Temp_775" id="%_sec_Temp_775"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_775">Tail recursion</a></h4>
<p><a name="%_idx_6088" id="%_idx_6088"></a><a name="%_idx_6090" id="%_idx_6090"></a>In chapter 1 we said that the process described by a procedure such as</p>
<p></p>
<p></p>
<p><pre>(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x)
                 x)))
</pre></p>
<p></p>
<p>is an iterative process.  Even though the procedure is syntacticallyrecursive (defined in terms of itself), it is not logically necessaryfor an evaluator to save information in passing from one call to <code>sqrt-iter</code> to the next.<a name="call_footnote_Temp_776" href="#footnote_Temp_776" id="call_footnote_Temp_776"><sup><small>25</small></sup></a> An evaluator that canexecute a procedure such as <code>sqrt-iter</code> without requiringincreasing storage as the procedure continues to call itself is calleda <a name="%_idx_6092" id="%_idx_6092"></a><em>tail-recursive</em> evaluator.  <a name="%_idx_6094" id="%_idx_6094"></a><a name="%_idx_6096" id="%_idx_6096"></a>The metacircular implementation ofthe evaluator in chapter 4 does not specify whether the evaluator istail-recursive, because that evaluator inherits its mechanism forsaving state from the underlying Scheme.  With the explicit-controlevaluator, however, we can trace through the evaluation process to seewhen procedure calls cause a net accumulation of information on thestack.</p>
<p>Our evaluator is tail-recursive, because in order to evaluate the finalexpression of a sequence we transfer directly to <code>eval-dispatch</code> withoutsaving any information on the stack.  Hence, evaluating the final expressionin a sequence – even if it is a procedure call (as in <code>sqrt-iter</code>, wherethe <code>if</code> expression, which is the last expression in the procedure body,reduces to a call to <code>sqrt-iter</code>) – will not cause any information to beaccumulated on the stack.<a name="call_footnote_Temp_777" href="#footnote_Temp_777" id="call_footnote_Temp_777"><sup><small>26</small></sup></a></p>
<p>If we did not think to take advantage of the fact that it wasunnecessary to save information in this case, we might haveimplemented <code>eval-sequence</code> by treating all the expressions in asequence in the same way – saving the registers, evaluating the expression,returning to restore the registers, and repeating this until all theexpressions have been evaluated:<a name="call_footnote_Temp_778" href="#footnote_Temp_778" id="call_footnote_Temp_778"><sup><small>27</small></sup></a></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_6100" id="%_idx_6100"></a>ev-sequence
  (test (op no-more-exps?) (reg unev))
  (branch (label ev-sequence-end))
  (assign exp (op first-exp) (reg unev))
  (save unev)
  (save env)
  (assign continue (label ev-sequence-continue))
  (goto (label eval-dispatch))
ev-sequence-continue
  (restore env)
  (restore unev)
  (assign unev (op rest-exps) (reg unev))
  (goto (label ev-sequence))
ev-sequence-end
  (restore continue)
  (goto (reg continue))
</pre></p>
<p></p>
<p></p>
<p>This may seem like a minor change to our previous code for evaluationof a sequence:  The only difference is that we go through thesave-restore cycle for the last expression in a sequence as well asfor theothers.  The interpreter will still give the same value forany expression.  But this change is fatal to the tail-recursiveimplementation, because we must now return after evaluating the finalexpression in a sequence in order to undo the (useless) registersaves.  These extra saves will accumulate during a nest of procedurecalls.  Consequently, processes such as <code>sqrt-iter</code> will requirespace proportional to the number of iterations rather than requiringconstant space.  This difference can be significant.  For example,<a name="%_idx_6102" id="%_idx_6102"></a>with tail recursion, an infinite loop can be expressed using only theprocedure-call mechanism:</p>
<p></p>
<p></p>
<p><pre>(define (count n)
  (newline)
  (display n)
  (count (+ n 1)))
</pre></p>
<p></p>
<p>Without tail recursion, such a procedure would eventually run out ofstack space, and expressing a true iteration would require somecontrol mechanism other than procedure call.</p>
<p><a name="%_sec_5.4.3" id="%_sec_5.4.3"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_5.4.3">5.4.3  Conditionals, Assignments, and Definitions</a></h3>
<p><a name="%_idx_6104" id="%_idx_6104"></a>As with the metacircular evaluator, special forms are handled byselectively evaluating fragments of the expression.  For an <code>if</code>expression, we must evaluate the predicate and decide, based on thevalue of predicate, whether to evaluate the consequent or thealternative.</p>
<p>Before evaluating the predicate, we save the <code>if</code> expressionitself so that we can later extract the consequent or alternative.  Wealso save the environment, which we will need later in order toevaluate the consequent or the alternative, and we save <code>continue</code>, which we will need later in order to return to theevaluation of the expression that is waiting for the value of the <code>if</code>.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_6106" id="%_idx_6106"></a>ev-if
  (save exp)                    <em>; save expression for later</em>
  (save env)
  (save continue)
  (assign continue (label ev-if-decide))
  (assign exp (op if-predicate) (reg exp))
  (goto (label eval-dispatch))  <em>; evaluate the predicate</em>
</pre></p>
<p></p>
<p></p>
<p>When we return from evaluating the predicate, we test whether it wastrue or false and, depending on the result, place either theconsequent or the alternative in <code>exp</code> before going to <code>eval-dispatch</code>.  Notice that restoring <code>env</code> and <code>continue</code>here sets up <code>eval-dispatch</code> to have the correct environment andto continue at the right place to receive the value of the <code>if</code>expression. </p>
<p></p>
<p></p>
<p><pre>ev-if-decide
  (restore continue)
  (restore env)
  (restore exp)
  (test (op true?) (reg val))
  (branch (label ev-if-consequent))

ev-if-alternative
  (assign exp (op if-alternative) (reg exp))
  (goto (label eval-dispatch))
ev-if-consequent
  (assign exp (op if-consequent) (reg exp))
  (goto (label eval-dispatch))
</pre></p>
<p></p>
<p></p>
<p><a name="%_sec_Temp_779" id="%_sec_Temp_779"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_779">Assignments and definitions</a></h4>
<p><a name="%_idx_6108" id="%_idx_6108"></a>Assignments are handled by <code>ev-assignment</code>, which is reached from<code>eval-dispatch</code> with the assignment expression in <code>exp</code>.  The code at <code>ev-assignment</code> first evaluates the value part of the expression andthen installs the new value in the environment.  <code>Set-variable-value!</code> is assumed to be available as a machineoperation.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_6110" id="%_idx_6110"></a>ev-assignment
  (assign unev (op assignment-variable) (reg exp))
  (save unev)                   <em>; save variable for later</em>
  (assign exp (op assignment-value) (reg exp))
  (save env)
  (save continue)
  (assign continue (label ev-assignment-1))
  (goto (label eval-dispatch))  <em>; evaluate the assignment value</em>
ev-assignment-1
  (restore continue)
  (restore env)
  (restore unev)
  (perform
   (op set-variable-value!) (reg unev) (reg val) (reg env))
  (assign val (const ok))
  (goto (reg continue))
</pre></p>
<p></p>
<p></p>
<p><a name="%_idx_6112" id="%_idx_6112"></a>Definitions are handled in a similar way:</p>
<p></p>
<p><pre><a name="%_idx_6114" id="%_idx_6114"></a>ev-definition
  (assign unev (op definition-variable) (reg exp))
  (save unev)                   <em>; save variable for later</em>
  (assign exp (op definition-value) (reg exp))
  (save env)
  (save continue)
  (assign continue (label ev-definition-1))
  (goto (label eval-dispatch))  <em>; evaluate the definition value</em>
ev-definition-1
  (restore continue)
  (restore env)
  (restore unev)
  (perform
   (op define-variable!) (reg unev) (reg val) (reg env))
  (assign val (const ok))
  (goto (reg continue))
</pre></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_5.23" id="%_thm_5.23"></a><b>Exercise 5.23.</b>  <a name="%_idx_6116" id="%_idx_6116"></a><a name="%_idx_6118" id="%_idx_6118"></a><a name="%_idx_6120" id="%_idx_6120"></a>Extend the evaluator to handle derived expressions such as <code>cond</code>,<code>let</code>, and so on (section <a href="book-Z-H-26.html#%_sec_4.1.2">4.1.2</a>).You may “cheat” and assume that the syntaxtransformers such as <code>cond-&gt;if</code> are available as machineoperations.<a name="call_footnote_Temp_781" href="#footnote_Temp_781" id="call_footnote_Temp_781"><sup><small>28</small></sup></a></p>
<p></p>
<p></p>
<p><a name="%_thm_5.24" id="%_thm_5.24"></a><b>Exercise 5.24.</b>  <a name="%_idx_6122" id="%_idx_6122"></a>Implement <code>cond</code> as a new basic special form withoutreducing it to <code>if</code>.  You will have to construct a loop that teststhe predicates of successive <code>cond</code> clauses until you find onethat is true, and then use <code>ev-sequence</code> to evaluate the actionsof the clause.</p>
<p></p>
<p></p>
<p><a name="%_thm_5.25" id="%_thm_5.25"></a><b>Exercise 5.25.</b>  <a name="%_idx_6124" id="%_idx_6124"></a><a name="%_idx_6126" id="%_idx_6126"></a>Modify the evaluator so that it uses normal-order evaluation,based on the lazy evaluator of section <a href="book-Z-H-27.html#%_sec_4.2">4.2</a>.</p>
<p></p>
<p><a name="%_sec_5.4.4" id="%_sec_5.4.4"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_5.4.4">5.4.4  Running the Evaluator</a></h3>
<p><a name="%_idx_6128" id="%_idx_6128"></a><a name="%_idx_6130" id="%_idx_6130"></a><a name="%_idx_6132" id="%_idx_6132"></a>With the implementation of the explicit-control evaluator we come tothe end of a development, begun in chapter 1, in which we haveexplored successively more precise models of the evaluation process.We started with the relatively informal substitution model, thenextended this in chapter 3 to the environment model, which enabled usto deal with state and change.  In the metacircular evaluator ofchapter 4, we used Scheme itself as a language for making more explicitthe environment structure constructed during evaluation of anexpression.  Now, with register machines, we have taken a close lookat the evaluator's mechanisms for storage management,argument passing, and control.  Ateach new level of description, we have had to raise issues and resolveambiguities that were not apparent at the previous, less precisetreatment of evaluation.  To understand the behavior of theexplicit-control evaluator, we can simulate it and monitor itsperformance.</p>
<p><a name="%_idx_6134" id="%_idx_6134"></a><a name="%_idx_6136" id="%_idx_6136"></a>We will install a driver loop in our evaluator machine.  This playsthe role of the <code>driver-loop</code> procedure ofsection <a href="book-Z-H-26.html#%_sec_4.1.4">4.1.4</a>.  The evaluator will repeatedly print aprompt, read an expression, evaluate the expression by going to <code>eval-dispatch</code>, and print the result.  The following instructions formthe beginning of the explicit-control evaluator's controllersequence:<a name="call_footnote_Temp_784" href="#footnote_Temp_784" id="call_footnote_Temp_784"><sup><small>29</small></sup></a></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_6142" id="%_idx_6142"></a><a name="%_idx_6144" id="%_idx_6144"></a>read-eval-print-loop
  (perform (op initialize-stack))
  (perform
   (op prompt-for-input) (const ";;; EC-Eval input:"))
  (assign exp (op read))
  (assign env (op get-global-environment))
  (assign continue (label print-result))
  (goto (label eval-dispatch))
<a name="%_idx_6146" id="%_idx_6146"></a>print-result
  (perform
   (op announce-output) (const ";;; EC-Eval value:"))
  (perform (op user-print) (reg val))
  (goto (label read-eval-print-loop))
</pre></p>
<p></p>
<p></p>
<p><a name="%_idx_6148" id="%_idx_6148"></a><a name="%_idx_6150" id="%_idx_6150"></a>When we encounter an error in a procedure (such as the “unknownprocedure type error” indicated at <code>apply-dispatch</code>), we print anerror message and return to the driver loop.<a name="call_footnote_Temp_785" href="#footnote_Temp_785" id="call_footnote_Temp_785"><sup><small>30</small></sup></a></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_6152" id="%_idx_6152"></a>unknown-expression-type
  (assign val (const unknown-expression-type-error))
  (goto (label signal-error))
<a name="%_idx_6154" id="%_idx_6154"></a>unknown-procedure-type
  (restore continue)    <em>; clean up stack (from <code>apply-dispatch</code>)</em>
  (assign val (const unknown-procedure-type-error))
  (goto (label signal-error))
<a name="%_idx_6156" id="%_idx_6156"></a>signal-error
  (perform (op user-print) (reg val))
  (goto (label read-eval-print-loop))
</pre></p>
<p></p>
<p></p>
<p>For the purposes of the simulation, we initialize the stack each timethrough the driver loop, since it might not be empty after an error(such as an undefined variable) interrupts an evaluation.<a name="call_footnote_Temp_786" href="#footnote_Temp_786" id="call_footnote_Temp_786"><sup><small>31</small></sup></a></p>
<p><a name="%_idx_6158" id="%_idx_6158"></a>If we combine all the code fragments presented in sections<a href="#%_sec_5.4.1">5.4.1</a>-<a href="#%_sec_5.4.4">5.4.4</a>, we can create anevaluator machine model that we can run using the register-machine simulatorof section <a href="book-Z-H-32.html#%_sec_5.2">5.2</a>.</p>
<p></p>
<p></p>
<p><pre>(define eceval
  (make-machine
   '(exp env val proc argl continue unev)
   eceval-operations
  '(
    read-eval-print-loop
      &lt;<em>entire machine controller as given above</em>&gt;
   )))
</pre></p>
<p></p>
<p>We must define Scheme procedures to simulate theoperations used as primitives by the evaluator.  These arethe same procedures we used for the metacircular evaluator insection <a href="book-Z-H-26.html#%_sec_4.1">4.1</a>, together with the few additional onesdefined in footnotes throughout section <a href="#%_sec_5.4">5.4</a>.</p>
<p></p>
<p><pre>(define eceval-operations
  (list (list 'self-evaluating? self-evaluating)
        <em>&lt;complete list of operations for eceval machine&gt;</em>))
</pre></p>
<p></p>
<p></p>
<p>Finally, we can initialize the global environment and run the evaluator:</p>
<p></p>
<p><pre>(define the-global-environment (setup-environment))

(start eceval)
<i>;;; EC-Eval input:</i>
(define (append x y)
  (if (null? x)
      y
      (cons (car x)
            (append (cdr x) y))))
<i>;;; EC-Eval value:</i>
<i>ok</i>
<i>;;; EC-Eval input:</i>
(append '(a b c) '(d e f))
<i>;;; EC-Eval value:</i>
<i>(a b c d e f)</i>
</pre></p>
<p></p>
<p></p>
<p>Of course, evaluating expressions in this way will take much longerthan if we had directly typed them into Scheme, because of themultiple levels of simulation involved.  Our expressions are evaluatedby the explicit-control-evaluator machine, which is being simulated bya Scheme program, which is itself being evaluated by the Schemeinterpreter.</p>
<p><a name="%_sec_Temp_787" id="%_sec_Temp_787"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_787">Monitoring the performance of the evaluator</a></h4>
<p><a name="%_idx_6160" id="%_idx_6160"></a><a name="%_idx_6162" id="%_idx_6162"></a>Simulation can be a powerful tool to guide the implementation ofevaluators.  Simulations make it easy not only to explore variationsof the register-machine design but also to monitor the performance ofthe simulated evaluator.  For example, one important factor inperformance is how efficiently the evaluator uses the stack.  We canobserve the number of stack operations required to evaluate variousexpressions by defining the evaluator register machine with theversion of the simulator that collects statistics on stack use(section <a href="book-Z-H-32.html#%_sec_5.2.4">5.2.4</a>), and adding an instruction at theevaluator's <code>print-result</code> entry point to print thestatistics:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_6164" id="%_idx_6164"></a>print-result
  (perform (op print-stack-statistics))<em>; added instruction</em>
  (perform
   (op announce-output) (const ";;; EC-Eval value:"))
  <code>...</code> <em>; same as before</em>
</pre></p>
<p></p>
<p>Interactions with the evaluator now look like this:</p>
<p></p>
<p><pre><i>;;; EC-Eval input:</i>
(define (factorial n)
  (if (= n 1)
      1
      (* (factorial (- n 1)) n)))
<i>(total-pushes = 3 maximum-depth = 3)</i>
<i>;;; EC-Eval value:</i>
<i>ok</i>
<i>;;; EC-Eval input:</i>
(factorial 5)
<i>(total-pushes = 144 maximum-depth = 28)</i>
<i>;;; EC-Eval value:</i>
<i>120</i>
</pre></p>
<p></p>
<p>Note that the driver loop of the evaluator reinitializes the stackat the start ofeach interaction, so that the statistics printed will refer only tostack operations used to evaluate the previous expression.</p>
<p></p>
<p><a name="%_thm_5.26" id="%_thm_5.26"></a><b>Exercise 5.26.</b>  <a name="%_idx_6166" id="%_idx_6166"></a><a name="%_idx_6168" id="%_idx_6168"></a><a name="%_idx_6170" id="%_idx_6170"></a>Use the monitored stack to explore the tail-recursive property of theevaluator (section <a href="#%_sec_5.4.2">5.4.2</a>).  Start theevaluator and define the iterative <code>factorial</code> procedure fromsection <a href="book-Z-H-11.html#%_sec_1.2.1">1.2.1</a>:</p>
<p></p>
<p></p>
<p><pre>(define (factorial n)
  (define (iter product counter)
    (if (&gt; counter n)
        product
        (iter (* counter product)
              (+ counter 1))))
  (iter 1 1))
</pre></p>
<p></p>
<p>Run the procedure with some small values of <em>n</em>.  Record the maximumstack depth and the number of pushes required to compute <em>n</em>! for each ofthese values.</p>
<p></p>
<p></p>
<p>a.  You will find that the maximum depth required to evaluate <em>n</em>! isindependent of <em>n</em>.  What is that depth?</p>
<p></p>
<p></p>
<p>b.  Determine from your data a formula in terms of <em>n</em> for the totalnumber of push operations used in evaluating <em>n</em>! for any <em>n</em> <u>&gt;</u> 1.Note that the number of operations used is a linear function of <em>n</em>and is thus determined by two constants.</p>
<p></p>
<p></p>
<p><a name="%_thm_5.27" id="%_thm_5.27"></a><b>Exercise 5.27.</b>  <a name="%_idx_6172" id="%_idx_6172"></a>For comparison with exercise <a href="#%_thm_5.26">5.26</a>, explore thebehavior of the following procedure for computing factorialsrecursively:</p>
<p></p>
<p><pre>(define (factorial n)
  (if (= n 1)
      1
      (* (factorial (- n 1)) n)))
</pre></p>
<p></p>
<p>By running this procedure with the monitored stack, determine, as afunction of <em>n</em>, the maximum depth of the stack and the total numberof pushes used in evaluating <em>n</em>! for <em>n</em> <u>&gt;</u> 1.  (Again, these functionswill be linear.)  Summarize your experiments by filling in thefollowing table with the appropriate expressions in terms of <em>n</em>:</p>
<p></p>
<table border="1">
<tr>
<td valign="top"></td>
<td valign="top">Maximum depth </td>
<td valign="top">Number of pushes</td>
</tr>
<tr>
<td valign="top">Recursive </td>
<td valign="top"></td>
<td valign="top"></td>
</tr>
<tr>
<td valign="top">factorial </td>
<td valign="top"></td>
<td valign="top"></td>
</tr>
<tr>
<td valign="top">Iterative </td>
<td valign="top"></td>
<td valign="top"></td>
</tr>
<tr>
<td valign="top">factorial </td>
<td valign="top"></td>
<td valign="top"></td>
</tr>
<tr><td valign="top"></td></tr>
</table>
<p>The maximum depth is a measure of the amount of space used by theevaluator in carrying out the computation, and the number of pushescorrelates well with the time required.</p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_5.28" id="%_thm_5.28"></a><b>Exercise 5.28.</b>  <a name="%_idx_6174" id="%_idx_6174"></a><a name="%_idx_6176" id="%_idx_6176"></a>Modify the definition of the evaluator by changing<code>eval-sequence</code> as described insection <a href="#%_sec_5.4.2">5.4.2</a> so that the evaluator is nolonger tail-recursive.  Rerun your experiments fromexercises <a href="#%_thm_5.26">5.26</a> and <a href="#%_thm_5.27">5.27</a> to demonstratethat both versions of the <code>factorial</code> procedure now require spacethat grows linearly with their input.</p>
<p></p>
<p></p>
<p><a name="%_thm_5.29" id="%_thm_5.29"></a><b>Exercise 5.29.</b>  <a name="%_idx_6178" id="%_idx_6178"></a>Monitor the stack operations in the tree-recursive Fibonacci computation:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_6180" id="%_idx_6180"></a>(define (fib n)
  (if (&lt; n 2)
      n
      (+ (fib (- n 1)) (fib (- n 2)))))
</pre></p>
<p></p>
<p>a.  Give a formula in terms of <em>n</em> for the maximum depth of the stackrequired to compute  <em>F</em><em>i</em><em>b</em>(<em>n</em>) for <em>n</em> <u>&gt;</u> 2.  Hint: Insection <a href="book-Z-H-11.html#%_sec_1.2.2">1.2.2</a> we argued that the space used by thisprocess grows linearly with <em>n</em>.</p>
<p></p>
<p></p>
<p>b.  Give a formula for the total number of pushes used to compute <em>F</em><em>i</em><em>b</em>(<em>n</em>) for <em>n</em> <u>&gt;</u> 2.  You should find that the number ofpushes (which correlates well with the time used) grows exponentiallywith <em>n</em>.  Hint: Let <em>S</em>(<em>n</em>) be the number of pushes used in computing <em>F</em><em>i</em><em>b</em>(<em>n</em>).  You should be able to argue that there is a formulathat expresses <em>S</em>(<em>n</em>) in terms of <em>S</em>(<em>n</em> - 1), <em>S</em>(<em>n</em> - 2), and some fixed“overhead” constant <em>k</em> that is independent of <em>n</em>.  Give theformula, and say what <em>k</em> is.  Then show that <em>S</em>(<em>n</em>) can be expressedas <em>a</em>  <em>F</em><em>i</em><em>b</em>(<em>n</em> + 1)  +  <em>b</em> and give the values of <em>a</em> and <em>b</em>.</p>
<p></p>
<p></p>
<p><a name="%_thm_5.30" id="%_thm_5.30"></a><b>Exercise 5.30.</b>  <a name="%_idx_6182" id="%_idx_6182"></a><a name="%_idx_6184" id="%_idx_6184"></a>Our evaluator currently catches and signals only two kinds oferrors – unknown expression types and unknown procedure types.  Othererrors will take us out of the evaluator read-eval-print loop.  Whenwe run the evaluator using the register-machine simulator, theseerrors are caught by the underlying Scheme system.  This is analogousto the computer crashing when a user program makes anerror.<a name="call_footnote_Temp_793" href="#footnote_Temp_793" id="call_footnote_Temp_793"><sup><small>32</small></sup></a>  It is a large project to make a realerror system work, but it is well worth the effort to understand whatis involved here.</p>
<p></p>
<p></p>
<p>a. Errors that occur in the evaluation process, such as an attempt toaccess an unbound variable, could be caught by changing the lookupoperation to make it return a distinguished condition code, which cannotbe a possible value of any user variable.  The evaluator can testfor this condition code and then do what is necessary to go to <code>signal-error</code>.  Find all of the places in the evaluator where such achange is necessary and fix them.  This is lots of work.</p>
<p></p>
<p></p>
<p>b. Much worse is the problem of handling errors that are signaled byapplying primitive procedures, such as an attempt to divide by zero oran attempt to extract the <code>car</code> of a symbol.  In a professionallywritten high-quality system, each primitive application is checked forsafety as part of the primitive.  For example, every call to <code>car</code>could first check that the argument is a pair.  If the argument is nota pair, the application would return a distinguished condition code tothe evaluator, which would then report the failure.  We could arrangefor this in our register-machine simulator by making each primitiveprocedurecheck for applicability and returning an appropriate distinguishedcondition code on failure. Then the <code>primitive-apply</code> code in theevaluator can check for the condition code and go to <code>signal-error</code> if necessary.  Build this structure and make it work.This is a major project.</p>
<p></p>
<p></p>
<p></p>
<div class="smallprint"><hr></div>
<p></p>
<div class="footnote">
<p><a name="footnote_Temp_765" href="#call_footnote_Temp_765" id="footnote_Temp_765"><sup><small>19</small></sup></a> See Batali et al. 1982 for more<a name="%_idx_6004" id="%_idx_6004"></a>information on the chip and the method by which it was designed.</p>
<p><a name="footnote_Temp_767" href="#call_footnote_Temp_767" id="footnote_Temp_767"><sup><small>20</small></sup></a> In our controller, the dispatch is written as asequence of <code>test</code> and <code>branch</code> instructions.  Alternatively,it could have been written in a data-directed style (and in a realsystem it probably would have been) to avoid the need to performsequential tests and to facilitate the definition of new expressiontypes.  A machine designed to run Lisp would probably include a <code>dispatch-on-type</code> instruction that would efficiently execute suchdata-directed dispatches.</p>
<p><a name="footnote_Temp_770" href="#call_footnote_Temp_770" id="footnote_Temp_770"><sup><small>21</small></sup></a> This is an important but subtle point in translatingalgorithms from a procedural language, such as Lisp, to aregister-machine language.  As an alternative to saving only what isneeded, we could save all the registers (except <code>val</code>) before eachrecursive call. This is called a <a name="%_idx_6052" id="%_idx_6052"></a><a name="%_idx_6054" id="%_idx_6054"></a><em>framed-stack</em> discipline.  Thiswould work but might save more registers than necessary; this could bean important consideration in a system where stack operations areexpensive.  Saving registers whose contents will not be needed latermay also hold onto useless data that could otherwise begarbage-collected, freeing space to be reused.</p>
<p><a name="footnote_Temp_771" href="#call_footnote_Temp_771" id="footnote_Temp_771"><sup><small>22</small></sup></a> We add to the evaluator data-structure procedures insection <a href="book-Z-H-26.html#%_sec_4.1.3">4.1.3</a> the following two proceduresfor manipulating argument lists:</p>
<p></p>
<p><pre><a name="%_idx_6060" id="%_idx_6060"></a>(define (empty-arglist) '())

<a name="%_idx_6062" id="%_idx_6062"></a>(define (adjoin-arg arg arglist)
  (append arglist (list arg)))
</pre></p>
<p></p>
<p>We also use an additional syntax procedure to test for thelast operand in a combination:</p>
<p></p>
<p><pre><a name="%_idx_6064" id="%_idx_6064"></a>(define (last-operand? ops)
  (null? (cdr ops)))
</pre></p>
<p></p>
<p></p>
<p><a name="footnote_Temp_772" href="#call_footnote_Temp_772" id="footnote_Temp_772"><sup><small>23</small></sup></a> The optimization of treating the last operand<a name="%_idx_6066" id="%_idx_6066"></a>specially is known as <i>evlis tail recursion</i> (see <a name="%_idx_6068" id="%_idx_6068"></a>Wand 1980).We could be somewhat more efficientin the argument evaluation loop if we made evaluation of the firstoperand a special case too.  This would permit us to postponeinitializing <code>argl</code> until after evaluating the first operand, soas to avoid saving <code>argl</code> in this case.  The compiler insection <a href="book-Z-H-35.html#%_sec_5.5">5.5</a> performs this optimization.  (Comparethe <code>construct-arglist</code> procedure ofsection <a href="book-Z-H-35.html#%_sec_5.5.3">5.5.3</a>.)</p>
<p><a name="footnote_Temp_773" href="#call_footnote_Temp_773" id="footnote_Temp_773"><sup><small>24</small></sup></a> Theorder of operand evaluation in the metacircular evaluator isdetermined by the order of evaluation of the arguments to <code>cons</code>in the procedure <code>list-of-values</code> of section <a href="book-Z-H-26.html#%_sec_4.1.1">4.1.1</a>(see exercise <a href="book-Z-H-26.html#%_thm_4.1">4.1</a>).</p>
<p><a name="footnote_Temp_776" href="#call_footnote_Temp_776" id="footnote_Temp_776"><sup><small>25</small></sup></a> We saw insection <a href="book-Z-H-31.html#%_sec_5.1">5.1</a> how to implement such aprocess with a register machine that had no stack; the state of theprocess was stored in a fixed set of registers.</p>
<p><a name="footnote_Temp_777" href="#call_footnote_Temp_777" id="footnote_Temp_777"><sup><small>26</small></sup></a> This implementation of tail recursion in<code>ev-sequence</code> is one variety of a well-known optimization technique usedby many compilers.  In compiling a procedure that ends with a procedure call,one can replace the call by a jump to the called procedure's entry point.Building this strategy into the interpreter, as we have done in this section,provides the optimization uniformly throughout the language.</p>
<p><a name="footnote_Temp_778" href="#call_footnote_Temp_778" id="footnote_Temp_778"><sup><small>27</small></sup></a> We can define <code>no-more-exps?</code> as follows:</p>
<p></p>
<p><pre><a name="%_idx_6098" id="%_idx_6098"></a>(define (no-more-exps? seq) (null? seq))
</pre></p>
<p></p>
<p></p>
<p><a name="footnote_Temp_781" href="#call_footnote_Temp_781" id="footnote_Temp_781"><sup><small>28</small></sup></a> This isn't really cheating.  In an actualimplementation built from scratch, we would use our explicit-controlevaluator to interpret a Scheme program that performs source-leveltransformations like <code>cond-&gt;if</code> in a syntax phase that runs beforeexecution.</p>
<p><a name="footnote_Temp_784" href="#call_footnote_Temp_784" id="footnote_Temp_784"><sup><small>29</small></sup></a> We assume here that <code>read</code> and thevarious printing operations areavailable as primitive machine operations, which is useful for oursimulation, but completely unrealistic in practice.  Theseare actually extremely complex operations.  In practice, they would beimplemented using low-level input-output operationssuch as transferring single characters to and from a device.</p>
<p>To support the <code>get-global-environment</code> operation we define</p>
<p></p>
<p><pre><a name="%_idx_6138" id="%_idx_6138"></a>(define the-global-environment (setup-environment))

<a name="%_idx_6140" id="%_idx_6140"></a>(define (get-global-environment)
  the-global-environment)
</pre></p>
<p></p>
<p></p>
<p><a name="footnote_Temp_785" href="#call_footnote_Temp_785" id="footnote_Temp_785"><sup><small>30</small></sup></a> There are othererrors that we would like the interpreter to handle, but these are notso simple.  See exercise <a href="#%_thm_5.30">5.30</a>.</p>
<p><a name="footnote_Temp_786" href="#call_footnote_Temp_786" id="footnote_Temp_786"><sup><small>31</small></sup></a> Wecould perform the stack initialization only after errors, but doing it inthe driver loop will be convenient for monitoring the evaluator'sperformance, as described below.</p>
<p><a name="footnote_Temp_793" href="#call_footnote_Temp_793" id="footnote_Temp_793"><sup><small>32</small></sup></a> Regrettably, this is the normal state of affairs in<a name="%_idx_6186" id="%_idx_6186"></a>conventional compiler-based language systems such as C.<a name="%_idx_6188" id="%_idx_6188"></a><a name="%_idx_6190" id="%_idx_6190"></a><a name="%_idx_6192" id="%_idx_6192"></a>In UNIX<sup><em>T</em><em>M</em></sup> the system “dumps core,” and inDOS/Windows<sup><em>T</em><em>M</em></sup> it becomes catatonic.The Macintosh<sup><em>T</em><em>M</em></sup> displays apicture of an exploding bomb and offers you the opportunity to rebootthe computer – if you're lucky.</p>
</div></body>
</html>
