<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<?xml version="1.0" encoding="utf-8"?><html xmlns="http://www.w3.org/1999/xhtml" xmlns:ops="http://www.idpf.org/2007/ops">
<!-- Generated from TeX source by tex2page, v 4o,
     (c) Dorai Sitaram, http://www.cs.rice.edu/~dorai/tex2page --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Type: text/html; charset=utf-8">
<title>Structure and Interpretation of Computer Programs</title>
<link rel="stylesheet" type="text/css" href="book-Z-C.css" title="default">
</head>
<body><a name="%_sec_2.4" id="%_sec_2.4"></a><h2><a href="book-Z-H-4.html#%_toc_%_sec_2.4">2.4  Multiple Representations for Abstract Data</a></h2>
<p><a name="%_idx_2286" id="%_idx_2286"></a><a name="%_idx_2288" id="%_idx_2288"></a>We have introduced data abstraction, a methodology for structuringsystems in such a way that much of a program can be specifiedindependent of the choices involved in implementing the data objectsthat the program manipulates.  For example, we saw insection <a href="book-Z-H-14.html#%_sec_2.1.1">2.1.1</a> how to separate the task of designing aprogram that uses rational numbers from the task of implementingrational numbers in terms of the computer language's primitivemechanisms for constructing compound data.  The key idea was to erectan abstraction barrier – in this case, the selectors and constructorsfor rational numbers (<code>make-rat</code>, <code>numer</code>, <code>denom</code>) – thatisolates the way rational numbers are used from their underlyingrepresentation in terms of list structure.  A similar abstractionbarrier isolates the details of the procedures that perform rationalarithmetic (<code>add-rat</code>, <code>sub-rat</code>, <code>mul-rat</code>, and <code>div-rat</code>) from the “higher-level” procedures that use rationalnumbers.  The resulting program has the structure shown infigure <a href="book-Z-H-14.html#%_fig_2.1">2.1</a>.</p>
<p>These data-abstraction barriers are powerful tools for controllingcomplexity.  By isolating the underlying representations of dataobjects, we can divide the task of designing a large program intosmaller tasks that can be performed separately.  But this kind of dataabstraction is not yet powerful enough, because it may not always makesense to speak of “the underlying representation” for a data object.</p>
<p>For one thing, there might be more than one useful representation fora data object, and we might like to design systems that can deal withmultiple representations.  To take a simple example, complex numbersmay be represented in two almost equivalent ways: in rectangular form(real and imaginary parts) and in polar form (magnitude and angle).Sometimes rectangular form is more appropriate and sometimes polarform is more appropriate.  Indeed, it is perfectly plausible toimagine a system in which complex numbers are represented in bothways, and in which the procedures for manipulating complex numbers workwith either representation.</p>
<p>More importantly, programming systems are often designed by manypeople working over extended periods of time, subject to requirementsthat change over time.  In such an environment, it is simply notpossible for everyone to agree in advance on choices of datarepresentation.  So in addition to the data-abstraction barriers thatisolate representation from use, we need abstraction barriers thatisolate different design choices from each other and permit differentchoices to coexist in a single program.  Furthermore, since largeprograms are often created by combining pre-existing modules that weredesigned in isolation, we need conventions that permit programmers toincorporate modules into larger systems <a name="%_idx_2290" id="%_idx_2290"></a><em>additively</em>, that is,without having to redesign or reimplement these modules.</p>
<p>In this section, we will learn how to cope with data that may berepresented in different ways by different parts of a program.  Thisrequires constructing <a name="%_idx_2292" id="%_idx_2292"></a><a name="%_idx_2294" id="%_idx_2294"></a><em>generic procedures</em> – procedures that canoperate on data that may be represented in more than one way.  Ourmain technique for building generic procedures will be to work in termsof data objects that have <a name="%_idx_2296" id="%_idx_2296"></a><em>type tags</em>, that is, data objectsthat include explicit information about how they are to be processed.We will also discuss <a name="%_idx_2298" id="%_idx_2298"></a><em>data-directed</em> programming, a powerful andconvenient implementation strategy for additively assembling systemswith generic operations.</p>
<p>We begin with the simple complex-number example. We will see howtype tags and data-directed style enable us to design separaterectangular and polar representations for complex numbers whilemaintaining the notion of an abstract “complex-number” data object.<a name="%_idx_2300" id="%_idx_2300"></a><a name="%_idx_2302" id="%_idx_2302"></a>We will accomplish this by defining arithmetic procedures for complexnumbers (<code>add-complex</code>, <code>sub-complex</code>, <code>mul-complex</code>, and<code>div-complex</code>) in terms of generic selectors that access parts ofa complex number independent of how the number is represented.  Theresulting complex-number system, as shown infigure <a href="#%_fig_2.19">2.19</a>, contains two different kinds of<a name="%_idx_2304" id="%_idx_2304"></a>abstraction barriers.  The “horizontal” abstraction barriers playthe same role as the ones infigure <a href="book-Z-H-14.html#%_fig_2.1">2.1</a>.  They isolate “higher-level”operations from “lower-level” representations.  In addition, thereis a “vertical” barrier that gives us the ability to separatelydesign and install alternative representations.</p>
<p><a name="%_fig_2.19" id="%_fig_2.19"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch2-Z-G-54.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 2.19:</b>  Data-abstraction barriers in the complex-number system.</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p>In section <a href="book-Z-H-18.html#%_sec_2.5">2.5</a> we will show how to usetype tags and data-directed style to develop a generic arithmeticpackage.  This provides procedures (<code>add</code>, <code>mul</code>, and so on)that can be used to manipulate all sorts of “numbers” and can beeasily extended when a new kind of number is needed.In section <a href="book-Z-H-18.html#%_sec_2.5.3">2.5.3</a>, we'll show how to use genericarithmetic in a system that performs symbolic algebra.</p>
<p><a name="%_sec_2.4.1" id="%_sec_2.4.1"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_2.4.1">2.4.1  Representations for Complex Numbers</a></h3>
<p></p>
<p><a name="%_idx_2306" id="%_idx_2306"></a>We will develop a system that performs arithmetic operations oncomplex numbers as a simple but unrealistic example of a program thatuses generic operations.  We begin by discussing two plausiblerepresentations for complex numbers as ordered pairs: rectangular form(real part and imaginary part) and polar form (magnitude andangle).<a name="call_footnote_Temp_268" href="#footnote_Temp_268" id="call_footnote_Temp_268"><sup><small>43</small></sup></a>  Section <a href="#%_sec_2.4.2">2.4.2</a>will show how both representations can be made to coexist in a singlesystem through the use of type tags and generic operations.</p>
<p>Like rational numbers, complex numbers are naturally represented asordered pairs.  The set of complex numbers can be thought of as atwo-dimensional space with two orthogonal axes, the “real” axis andthe “imaginary” axis. (See figure <a href="#%_fig_2.20">2.20</a>.)  Fromthis point of view, the complex number <em>z</em> = <em>x</em> + <em>i</em><em>y</em> (where <em>i</em><sup>2</sup>  =  - 1)can be thought of as the point in the plane whose real coordinate is <em>x</em> and whoseimaginary coordinate is <em>y</em>.  Addition of complex numbers reduces inthis representation to addition of coordinates:</p><p>Real-part(<em>z</em><sub>1</sub> + <em>z</em><sub>2</sub>) = Real-part(<em>z</em><sub>1</sub>) + Real-part(<em>z</em><sub>2</sub>)</p><p>Imaginary-part(<em>z</em><sub>1</sub> + <em>z</em><sub>2</sub>) = Imaginary-part(<em>z</em><sub>1</sub>) + Imaginary-part(<em>z</em><sub>2</sub>)</p><p>When multiplying complex numbers, it is more natural to think in termsof representing a complex number in polar form, as a magnitude and anangle (<em>r</em> and <em>A</em> in figure <a href="#%_fig_2.20">2.20</a>).The product of two complex numbers is the vector obtained bystretching one complex number by the length of the other and thenrotating it through the angle of the other:</p><p>Magnitude(<em>z</em><sub>1</sub> · <em>z</em><sub>2</sub>) = Magnitude(<em>z</em><sub>1</sub>) · Magnitude(<em>z</em><sub>2</sub>)</p><p>Angle(<em>z</em><sub>1</sub> · <em>z</em><sub>2</sub>) = Angle(<em>z</em><sub>1</sub>) + Angle(<em>z</em><sub>2</sub>)</p><p>Thus, there are two different representations for complex numbers,which are appropriate for different operations.  Yet, from theviewpoint of someone writing a program that uses complex numbers, theprinciple of data abstraction suggests that all the operations formanipulating complex numbers should be available regardless of whichrepresentation is used by the computer.  For example, it is oftenuseful to be able to find the magnitude of a complex number that isspecified by rectangular coordinates.  Similarly, it is often usefulto be able to determine the real part of a complex number that isspecified by polar coordinates.</p>
<p><a name="%_fig_2.20" id="%_fig_2.20"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch2-Z-G-59.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 2.20:</b>  Complex numbers as points in the plane.</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p>To design such a system, we can follow the same <a name="%_idx_2310" id="%_idx_2310"></a>data-abstractionstrategy we followed in designing the rational-number package insection <a href="book-Z-H-14.html#%_sec_2.1.1">2.1.1</a>.  Assume that the operations on complex numbers areimplemented in terms of four selectors: <code>real-part</code>,<code>imag-part</code>, <code>magnitude</code>, and <code>angle</code>.  Also assume thatwe have two procedures for constructing complex numbers: <code>make-from-real-imag</code> returns a complex number with specified real andimaginary parts, and <code>make-from-mag-ang</code> returns a complex number withspecified magnitude and angle.  These procedures have the property that,for any complex number <code>z</code>, both</p>
<p></p>
<p></p>
<p><pre>(make-from-real-imag (real-part z) (imag-part z))
</pre></p>
<p></p>
<p>and</p>
<p></p>
<p></p>
<p><pre>(make-from-mag-ang (magnitude z) (angle z))
</pre></p>
<p></p>
<p>produce complex numbers that are equal to <code>z</code>.</p>
<p>Using these constructors and selectors, we can implementarithmetic on complex numbers using the “abstract data” specified bythe constructors and selectors, just as we did for rational numbers insection <a href="book-Z-H-14.html#%_sec_2.1.1">2.1.1</a>.  As shown in the formulas above, we can add andsubtract complex numbers in terms of real and imaginary parts whilemultiplying and dividing complex numbers in terms of magnitudes andangles:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_2312" id="%_idx_2312"></a>(define (add-complex z1 z2)
  (make-from-real-imag (+ (real-part z1) (real-part z2))
                       (+ (imag-part z1) (imag-part z2))))
<a name="%_idx_2314" id="%_idx_2314"></a>(define (sub-complex z1 z2)
  (make-from-real-imag (- (real-part z1) (real-part z2))
                       (- (imag-part z1) (imag-part z2))))
<a name="%_idx_2316" id="%_idx_2316"></a>(define (mul-complex z1 z2)
  (make-from-mag-ang (* (magnitude z1) (magnitude z2))
                     (+ (angle z1) (angle z2))))
<a name="%_idx_2318" id="%_idx_2318"></a>(define (div-complex z1 z2)
  (make-from-mag-ang (/ (magnitude z1) (magnitude z2))
                     (- (angle z1) (angle z2))))
</pre></p>
<p></p>
<p></p>
<p>To complete the complex-number package, we must choose arepresentation and we must implement the constructors and selectors interms of primitive numbers and primitive list structure.There are two obvious ways to do this: We can represent a complexnumber in “rectangular form” as a pair (real part, imaginary part)or in “polar form” as a pair (magnitude, angle).  Which shall wechoose?</p>
<p>In order to make the different choices concrete, imagine that thereare two programmers, Ben Bitdiddle and Alyssa P. Hacker, who areindependently designing representations for the complex-number system.<a name="%_idx_2320" id="%_idx_2320"></a>Ben chooses to represent complex numbers in rectangular form.  Withthis choice, selecting the real and imaginary parts of a complexnumber is straightforward, as is constructing a complex number withgiven real and imaginary parts.  To find the magnitude and the angle,or to construct a complex number with a given magnitude and angle, heuses the trigonometric relations</p>
<p></p>
<p></p>
<div align="left"><img src="images/ch2-Z-G-60.gif" border="0"></div>
<p></p>
<p></p>
<div align="left"><img src="images/ch2-Z-G-61.gif" border="0"></div>
<p></p>
<p>which relate the real and imaginary parts (<em>x</em>, <em>y</em>) to the magnitudeand the angle (<em>r</em>, <em>A</em>).<a name="call_footnote_Temp_269" href="#footnote_Temp_269" id="call_footnote_Temp_269"><sup><small>44</small></sup></a>  Ben's representation istherefore given by the following selectors and constructors:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_2328" id="%_idx_2328"></a>(define (real-part z) (car z))
<a name="%_idx_2330" id="%_idx_2330"></a>(define (imag-part z) (cdr z))
<a name="%_idx_2332" id="%_idx_2332"></a>(define (magnitude z)
  (sqrt (+ (square (real-part z)) (square (imag-part z)))))
<a name="%_idx_2334" id="%_idx_2334"></a>(define (angle z)
  (atan (imag-part z) (real-part z)))
<a name="%_idx_2336" id="%_idx_2336"></a>(define (make-from-real-imag x y) (cons x y))
<a name="%_idx_2338" id="%_idx_2338"></a>(define (make-from-mag-ang r a) 
  (cons (* r (cos a)) (* r (sin a))))
</pre></p>
<p></p>
<p></p>
<p><a name="%_idx_2340" id="%_idx_2340"></a>Alyssa, in contrast, chooses to represent complex numbers in polarform.  For her, selecting the magnitude and angle is straightforward,but she has to use the <a name="%_idx_2342" id="%_idx_2342"></a>trigonometric relations to obtain the real andimaginary parts.  Alyssa's representation is:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_2344" id="%_idx_2344"></a>(define (real-part z)
  (* (magnitude z) (cos (angle z))))
<a name="%_idx_2346" id="%_idx_2346"></a>(define (imag-part z)
  (* (magnitude z) (sin (angle z))))
<a name="%_idx_2348" id="%_idx_2348"></a>(define (magnitude z) (car z))
<a name="%_idx_2350" id="%_idx_2350"></a>(define (angle z) (cdr z))
<a name="%_idx_2352" id="%_idx_2352"></a>(define (make-from-real-imag x y) 
  (cons (sqrt (+ (square x) (square y)))
        (atan y x)))
<a name="%_idx_2354" id="%_idx_2354"></a>(define (make-from-mag-ang r a) (cons r a))
</pre></p>
<p></p>
<p></p>
<p>The discipline of data abstraction ensures that the same implementation of<code>add-complex</code>, <code>sub-complex</code>, <code>mul-complex</code>, and <code>div-complex</code> will work with either Ben's representation or Alyssa'srepresentation. </p>
<p><a name="%_sec_2.4.2" id="%_sec_2.4.2"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_2.4.2">2.4.2  Tagged data</a></h3>
<p><a name="%_idx_2356" id="%_idx_2356"></a><a name="%_idx_2358" id="%_idx_2358"></a><a name="%_idx_2360" id="%_idx_2360"></a>One way to view data abstraction is as an application of the<a name="%_idx_2362" id="%_idx_2362"></a><a name="%_idx_2364" id="%_idx_2364"></a>“principle of least commitment.”  In implementing the complex-numbersystem in section <a href="#%_sec_2.4.1">2.4.1</a>, we canuse either Ben's rectangular representation or Alyssa's polarrepresentation.  The abstraction barrier formed by the selectors andconstructors permits us to defer to the last possible moment thechoice of a concrete representation for our data objects and thusretain maximum flexibility in our system design.</p>
<p>The principle of least commitment can be carried to even furtherextremes.  If we desire, we can maintain the ambiguity ofrepresentation even <em>after</em> we have designed the selectors andconstructors, and elect to use both Ben's representation <em>and</em>Alyssa's representation.  If both representations are included in asingle system, however, we will need some way to distinguish data inpolar form from data in rectangular form.  Otherwise, if we wereasked, for instance, to find the <code>magnitude</code> of the pair (3,4),we wouldn't know whether to answer 5 (interpreting the number inrectangular form) or 3 (interpreting the number in polar form).  Astraightforward way to accomplish this distinction is to include a<a name="%_idx_2366" id="%_idx_2366"></a><em>type tag</em> – the symbol <code>rectangular</code> or <code>polar</code> – aspart of each complex number.  Then when we need to manipulate acomplex number we can use the tag to decide which selector to apply.</p>
<p>In order to manipulate tagged data,we will assume that we have procedures <code>type-tag</code> and <code>contents</code> that extract from a data object the tag and the actualcontents (the polar or rectangular coordinates, in the case of acomplex number).  We will also postulate a procedure <code>attach-tag</code> that takes a tag and contents and produces a tagged dataobject.  A straightforward way to implement this is to use ordinarylist structure:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_2368" id="%_idx_2368"></a>(define (attach-tag type-tag contents)
  (cons type-tag contents))
<a name="%_idx_2370" id="%_idx_2370"></a>(define (type-tag datum)
  (if (pair? datum)
      (car datum)
      (error "Bad tagged datum -- TYPE-TAG" datum)))
<a name="%_idx_2372" id="%_idx_2372"></a>(define (contents datum)
  (if (pair? datum)
      (cdr datum)
      (error "Bad tagged datum -- CONTENTS" datum)))
</pre></p>
<p></p>
<p></p>
<p>Using these procedures, we can define predicates <code>rectangular?</code>and <code>polar?</code>, which recognize polar and rectangular numbers,respectively:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_2374" id="%_idx_2374"></a>(define (rectangular? z)
  (eq? (type-tag z) 'rectangular))
<a name="%_idx_2376" id="%_idx_2376"></a>(define (polar? z)
  (eq? (type-tag z) 'polar))
</pre></p>
<p></p>
<p></p>
<p>With type tags, Ben and Alyssa can now modify their code so thattheir two different representations can coexist in the same system.Whenever Ben constructs a complex number, he tags it as rectangular.Whenever Alyssa constructs a complex number, she tags it as polar.In addition, Ben and Alyssa must make sure that the names of theirprocedures do not conflict.  One way to do this is for Ben to appendthe suffix <code>rectangular</code> to the name of each of his representationprocedures and for Alyssa to append <code>polar</code> to the names of hers.Here is Ben's revised rectangular representation fromsection <a href="#%_sec_2.4.1">2.4.1</a>:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_2378" id="%_idx_2378"></a>(define (real-part-rectangular z) (car z))
<a name="%_idx_2380" id="%_idx_2380"></a>(define (imag-part-rectangular z) (cdr z))
<a name="%_idx_2382" id="%_idx_2382"></a>(define (magnitude-rectangular z)
  (sqrt (+ (square (real-part-rectangular z))
           (square (imag-part-rectangular z)))))
<a name="%_idx_2384" id="%_idx_2384"></a>(define (angle-rectangular z)
  (atan (imag-part-rectangular z)
        (real-part-rectangular z)))
<a name="%_idx_2386" id="%_idx_2386"></a>(define (make-from-real-imag-rectangular x y)
  (attach-tag 'rectangular (cons x y)))
<a name="%_idx_2388" id="%_idx_2388"></a>(define (make-from-mag-ang-rectangular r a) 
  (attach-tag 'rectangular
              (cons (* r (cos a)) (* r (sin a)))))
</pre></p>
<p></p>
<p>and here is Alyssa's revised polar representation:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_2390" id="%_idx_2390"></a>(define (real-part-polar z)
  (* (magnitude-polar z) (cos (angle-polar z))))
<a name="%_idx_2392" id="%_idx_2392"></a>(define (imag-part-polar z)
  (* (magnitude-polar z) (sin (angle-polar z))))
<a name="%_idx_2394" id="%_idx_2394"></a>(define (magnitude-polar z) (car z))
<a name="%_idx_2396" id="%_idx_2396"></a>(define (angle-polar z) (cdr z))
<a name="%_idx_2398" id="%_idx_2398"></a>(define (make-from-real-imag-polar x y) 
  (attach-tag 'polar
               (cons (sqrt (+ (square x) (square y)))
                     (atan y x))))
<a name="%_idx_2400" id="%_idx_2400"></a>(define (make-from-mag-ang-polar r a)
  (attach-tag 'polar (cons r a)))
</pre></p>
<p></p>
<p></p>
<p><a name="%_idx_2402" id="%_idx_2402"></a><a name="%_idx_2404" id="%_idx_2404"></a>Each generic selector is implemented as a procedure that checks thetag of its argument and calls the appropriate procedure for handlingdata of that type.  For example, to obtain the real part of a complexnumber, <code>real-part</code> examines the tag to determine whether to useBen's <code>real-part-rectangular</code> or Alyssa's <code>real-part-polar</code>.In either case, we use <code>contents</code> to extract the bare, untaggeddatum and send this to the rectangular or polar procedure as required:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_2406" id="%_idx_2406"></a>(define (real-part z)
  (cond ((rectangular? z) 
         (real-part-rectangular (contents z)))
        ((polar? z)
         (real-part-polar (contents z)))
        (else (error "Unknown type -- REAL-PART" z))))
<a name="%_idx_2408" id="%_idx_2408"></a>(define (imag-part z)
  (cond ((rectangular? z)
         (imag-part-rectangular (contents z)))
        ((polar? z)
         (imag-part-polar (contents z)))
        (else (error "Unknown type -- IMAG-PART" z))))
<a name="%_idx_2410" id="%_idx_2410"></a>(define (magnitude z)
  (cond ((rectangular? z)
         (magnitude-rectangular (contents z)))
        ((polar? z)
         (magnitude-polar (contents z)))
        (else (error "Unknown type -- MAGNITUDE" z))))
<a name="%_idx_2412" id="%_idx_2412"></a>(define (angle z)
  (cond ((rectangular? z)
         (angle-rectangular (contents z)))
        ((polar? z)
         (angle-polar (contents z)))
        (else (error "Unknown type -- ANGLE" z))))
</pre></p>
<p></p>
<p></p>
<p>To implement the complex-number arithmetic operations, we can use thesame procedures <code>add-complex</code>, <code>sub-complex</code>, <code>mul-complex</code>, and <code>div-complex</code> fromsection <a href="#%_sec_2.4.1">2.4.1</a>, because theselectors they call are generic, and so will work with eitherrepresentation.  For example, the procedure <code>add-complex</code> is still</p>
<p></p>
<p></p>
<p><pre>(define (add-complex z1 z2)
  (make-from-real-imag (+ (real-part z1) (real-part z2))
                       (+ (imag-part z1) (imag-part z2))))
</pre></p>
<p></p>
<p></p>
<p>Finally, we must choose whether to construct complex numbers usingBen's representation or Alyssa's representation.  One reasonablechoice is to construct rectangular numbers whenever we have real andimaginary parts and to construct polar numbers whenever we havemagnitudes and angles:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_2414" id="%_idx_2414"></a>(define (make-from-real-imag x y)
  (make-from-real-imag-rectangular x y))
<a name="%_idx_2416" id="%_idx_2416"></a>(define (make-from-mag-ang r a)
  (make-from-mag-ang-polar r a))
</pre></p>
<p></p>
<p></p>
<p><a name="%_fig_2.21" id="%_fig_2.21"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch2-Z-G-62.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 2.21:</b>  Structure of the generic complex-arithmetic system.</div></caption>
<tr><td><a name="%_idx_2418" id="%_idx_2418"></a></td></tr>
</table></div>
<p></p>
<p>The resulting complex-number system has the structure shown infigure <a href="#%_fig_2.21">2.21</a>.  The system has beendecomposed into three relatively independent parts: thecomplex-number-arithmetic operations, Alyssa's polarimplementation, and Ben's rectangular implementation.  The polar andrectangular implementations could have been written by Ben and Alyssaworking separately, and both of these can be used as underlyingrepresentations by a third programmer implementing thecomplex-arithmetic procedures in terms of the abstractconstructor/selector interface.</p>
<p><a name="%_idx_2420" id="%_idx_2420"></a><a name="%_idx_2422" id="%_idx_2422"></a>Since each data object is tagged with its type, the selectors operateon the data in a generic manner.  That is, each selector is defined tohave a behavior that depends upon the particular type of data it isapplied to.  Notice the general mechanism for interfacing the separaterepresentations: Within a given representation implementation (say,Alyssa's polar package) a complex number is an untyped pair(magnitude, angle).  When a generic selector operates on a number of<code>polar</code> type, it strips off the tag and passes the contents on toAlyssa's code.  Conversely, when Alyssa constructs a number for generaluse, she tags it with a type so that it can be appropriatelyrecognized by the higher-level procedures.  This discipline ofstripping off and attaching tags as data objects are passed from levelto level can be an important organizational strategy, as we shall seein section <a href="book-Z-H-18.html#%_sec_2.5">2.5</a>.</p>
<p><a name="%_sec_2.4.3" id="%_sec_2.4.3"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_2.4.3">2.4.3  Data-Directed Programming and Additivity</a></h3>
<p><a name="%_idx_2424" id="%_idx_2424"></a><a name="%_idx_2426" id="%_idx_2426"></a><a name="%_idx_2428" id="%_idx_2428"></a>The general strategy of checking the type of a datum and calling anappropriate procedure is called <a name="%_idx_2430" id="%_idx_2430"></a><a name="%_idx_2432" id="%_idx_2432"></a><em>dispatching on type</em>.  This is apowerful strategy for obtaining modularity in system design.  Onthe other hand, implementing the dispatch as insection <a href="#%_sec_2.4.2">2.4.2</a> has two significant weaknesses.  Oneweakness is that the generic interface procedures (<code>real-part</code>,<code>imag-part</code>, <code>magnitude</code>, and <code>angle</code>) must know about allthe different representations.  For instance, suppose we wanted toincorporate a new representation for complex numbers into ourcomplex-number system.  We would need to identify this newrepresentation with a type, and then add a clause to each of thegeneric interface procedures to check for the new type and apply theappropriate selector for that representation.</p>
<p>Another weakness of the technique is that even though the individualrepresentations can be designed separately, we must guarantee thatno two procedures in the entire system have the same name.  This iswhy Ben and Alyssa had to change the names of their originalprocedures from section <a href="#%_sec_2.4.1">2.4.1</a>.</p>
<p>The issue underlying both of these weaknesses is that the techniquefor implementing generic interfaces is not <em>additive</em>.  The personimplementing the generic selector procedures must modify thoseprocedures each time a new representation is installed, and the peopleinterfacing the individual representations must modify theircode to avoid name conflicts.  In each of these cases, the changesthat must be made to the code are straightforward, but they must bemade nonetheless, and this is a source of inconvenience and error.This is not much of a problem for the complex-number system as itstands, but suppose there were not two but hundreds of differentrepresentations for complex numbers.  And suppose that there were manygeneric selectors to be maintained in the abstract-data interface.Suppose, in fact, that no one programmer knew all the interfaceprocedures or all the representations.  The problem is real and mustbe addressed in such programs as large-scale data-base-managementsystems.</p>
<p>What we need is a means for modularizing the system design evenfurther.  This is provided by the programming technique known as <em>data-directed programming</em>.  To understand how data-directedprogramming works, begin with the observation that whenever we dealwith a set of generic operations that are common to a set ofdifferent types we are, in effect, dealing with a two-dimensionaltable that contains the possible operations on one axis and thepossible types on the other axis.  The entries in the table are theprocedures that implement each operation for each type of argumentpresented.  In the complex-number system developed in the previoussection, the correspondence between operation name, data type, andactual procedure was spread out among the various conditional clausesin the generic interface procedures.  But the same information couldhave been organized in a table, as shown infigure <a href="#%_fig_2.22">2.22</a>.</p>
<p><a name="%_idx_2434" id="%_idx_2434"></a>Data-directed programming is the technique of designing programs towork with such a table directly.  Previously, we implemented themechanism that interfaces the complex-arithmetic code with the tworepresentation packages as a set of procedures that each perform anexplicit dispatch on type.  Here we will implement the interface as a singleprocedure that looks up the combination of the operation name andargument type inthe table to find the correct procedure to apply, and then applies itto the contents of the argument.  If we do this, then to add a newrepresentation package to the system we need not change any existingprocedures; we need only add new entries to the table.</p>
<p><a name="%_fig_2.22" id="%_fig_2.22"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch2-Z-G-63.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 2.22:</b>  Table of operations for the complex-number system.</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p>To implement this plan, assume that we have two procedures,<code>put</code> and <code>get</code>, for manipulating theoperation-and-type table:<a name="%_idx_2436" id="%_idx_2436"></a></p>
<p></p>
<ul>
<a name="%_idx_2438" id="%_idx_2438"></a><li>
<code>(put &lt;<em>op</em>&gt; &lt;<em>type</em>&gt; &lt;<em>item</em>&gt;)</code>
installs the <code>&lt;<em>item</em>&gt;</code> in the table, indexed by the<code>&lt;<em>op</em>&gt;</code> and the <code>&lt;<em>type</em>&gt;</code>.<p><a name="%_idx_2440" id="%_idx_2440"></a></p>
</li>
<li>
<code>(get &lt;<em>op</em>&gt; &lt;<em>type</em>&gt;)</code>
looks up the <code>&lt;<em>op</em>&gt;</code>, <code>&lt;<em>type</em>&gt;</code> entry in the tableand returns the item found there.  If no item is found, <code>get</code>returns false.</li>
</ul>
<p></p>
<p>For now, we can assume that <code>put</code> and <code>get</code> areincluded in our language.  In chapter 3(section <a href="book-Z-H-22.html#%_sec_3.3.3">3.3.3</a>, exercise <a href="book-Z-H-22.html#%_thm_3.24">3.24</a>)we will see how to implement these andother operations for manipulating tables.</p>
<p>Here is how data-directed programming can be used in thecomplex-number system.  Ben, who developed the rectangularrepresentation, implements his code just as he did originally.  Hedefines a collection of procedures, or a <a name="%_idx_2442" id="%_idx_2442"></a><em>package</em>, and interfacesthese to the rest of the system by adding entries to the table thattell the system how to operate on rectangular numbers.This is accomplished by calling the following procedure:<a name="%_idx_2444" id="%_idx_2444"></a><a name="%_idx_2446" id="%_idx_2446"></a></p>
<p></p>
<p><pre><a name="%_idx_2448" id="%_idx_2448"></a>(define (install-rectangular-package)
  <em>;; internal procedures</em>
  (define (real-part z) (car z))
  (define (imag-part z) (cdr z))
  (define (make-from-real-imag x y) (cons x y))
  (define (magnitude z)
    (sqrt (+ (square (real-part z))
             (square (imag-part z)))))
  (define (angle z)
    (atan (imag-part z) (real-part z)))
  (define (make-from-mag-ang r a) 
    (cons (* r (cos a)) (* r (sin a))))
  <em>;; interface to the rest of the system</em>
  (define (tag x) (attach-tag 'rectangular x))
  (put 'real-part '(rectangular) real-part)
  (put 'imag-part '(rectangular) imag-part)
  (put 'magnitude '(rectangular) magnitude)
  (put 'angle '(rectangular) angle)
  (put 'make-from-real-imag 'rectangular 
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'rectangular 
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)
</pre></p>
<p></p>
<p></p>
<p>Notice that the internal procedures here are the same procedures fromsection <a href="#%_sec_2.4.1">2.4.1</a> that Ben wrote whenhe was working in isolation.  No changes are necessary in order tointerface them to the rest of the system.  Moreover, since theseprocedure definitions are internal to the installation procedure, Benneedn't worry about name conflicts with other procedures outside therectangular package.  To interface these to the rest of the system,Ben installs his <code>real-part</code> procedure under the operation name<code>real-part</code> and the type <code>(rectangular)</code>, and similarlyfor the other selectors.<a name="call_footnote_Temp_270" href="#footnote_Temp_270" id="call_footnote_Temp_270"><sup><small>45</small></sup></a>  The interface also definesthe constructors to be used by the external system.<a name="call_footnote_Temp_271" href="#footnote_Temp_271" id="call_footnote_Temp_271"><sup><small>46</small></sup></a>These areidentical to Ben's internally defined constructors, except that theyattach the tag.</p>
<p><a name="%_idx_2450" id="%_idx_2450"></a><a name="%_idx_2452" id="%_idx_2452"></a>Alyssa's polar package is analogous:</p>
<p></p>
<p><pre><a name="%_idx_2454" id="%_idx_2454"></a>(define (install-polar-package)
  <em>;; internal procedures</em>
  (define (magnitude z) (car z))
  (define (angle z) (cdr z))
  (define (make-from-mag-ang r a) (cons r a))
  (define (real-part z)
    (* (magnitude z) (cos (angle z))))
  (define (imag-part z)
    (* (magnitude z) (sin (angle z))))
  (define (make-from-real-imag x y) 
    (cons (sqrt (+ (square x) (square y)))
          (atan y x)))
  <em>;; interface to the rest of the system</em>
  (define (tag x) (attach-tag 'polar x))
  (put 'real-part '(polar) real-part)
  (put 'imag-part '(polar) imag-part)
  (put 'magnitude '(polar) magnitude)
  (put 'angle '(polar) angle)
  (put 'make-from-real-imag 'polar
       (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'polar 
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)
</pre></p>
<p></p>
<p></p>
<p>Even though Ben and Alyssa both still use their original proceduresdefined with the same names as each other's (e.g., <code>real-part</code>), thesedefinitions are now internal to different procedures (seesection <a href="book-Z-H-10.html#%_sec_1.1.8">1.1.8</a>), so there is no nameconflict.</p>
<p>The complex-arithmetic selectors access the table by means of ageneral “operation” procedure called <code>apply-generic</code>, whichapplies a generic operation to some arguments.  <code>Apply-generic</code>looks in the table under the name of the operation and the types of thearguments and applies the resulting procedure if one is present:<a name="call_footnote_Temp_272" href="#footnote_Temp_272" id="call_footnote_Temp_272"><sup><small>47</small></sup></a></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_2462" id="%_idx_2462"></a>(define (apply-generic op . args)
  (let ((type-tags (map type-tag args)))
    (let ((proc (get op type-tags)))
      (if proc
          (apply proc (map contents args))
          (error
            "No method for these types -- APPLY-GENERIC"
            (list op type-tags))))))
</pre></p>
<p></p>
<p>Using <code>apply-generic</code>, we can define our generic selectors as follows:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_2464" id="%_idx_2464"></a>(define (real-part z) (apply-generic 'real-part z))
<a name="%_idx_2466" id="%_idx_2466"></a>(define (imag-part z) (apply-generic 'imag-part z))
<a name="%_idx_2468" id="%_idx_2468"></a>(define (magnitude z) (apply-generic 'magnitude z))
<a name="%_idx_2470" id="%_idx_2470"></a>(define (angle z) (apply-generic 'angle z))
</pre></p>
<p></p>
<p>Observe that these do not change at all if a new representation isadded to the system.</p>
<p>We can also extract from the table theconstructors to be used by the programs external to the packages inmaking complex numbers from real and imaginary parts and frommagnitudes and angles.As in section <a href="#%_sec_2.4.2">2.4.2</a>, weconstruct rectangular numbers whenever we have real andimaginary parts, and polar numbers whenever we have magnitudes and angles:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_2472" id="%_idx_2472"></a>(define (make-from-real-imag x y)
  ((get 'make-from-real-imag 'rectangular) x y))
<a name="%_idx_2474" id="%_idx_2474"></a>(define (make-from-mag-ang r a)
  ((get 'make-from-mag-ang 'polar) r a))
</pre></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_2.73" id="%_thm_2.73"></a><b>Exercise 2.73.</b>  Section <a href="book-Z-H-16.html#%_sec_2.3.2">2.3.2</a> described a program thatperforms symbolic differentiation:<a name="%_idx_2476" id="%_idx_2476"></a><a name="%_idx_2478" id="%_idx_2478"></a></p>
<p></p>
<p><pre>(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp) (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
           (make-product (multiplier exp)
                         (deriv (multiplicand exp) var))
           (make-product (deriv (multiplier exp) var)
                         (multiplicand exp))))
        &lt;<em>more rules can be added here</em>&gt;
        (else (error "unknown expression type -- DERIV" exp))))
</pre></p>
<p></p>
<p>We can regard this program as performing a dispatch on the type of theexpression to be differentiated.  In this situation the “type tag” of thedatum is the algebraic operator symbol (such as <code>+</code>) and theoperation being performed is <code>deriv</code>.  We can transform thisprogram into data-directed style by rewriting the basic derivativeprocedure as</p>
<p></p>
<p><pre><a name="%_idx_2480" id="%_idx_2480"></a>(define (deriv exp var)
   (cond ((number? exp) 0)
         ((variable? exp) (if (same-variable? exp var) 1 0))
         (else ((get 'deriv (operator exp)) (operands exp)
                                            var))))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
</pre></p>
<p></p>
<p></p>
<p>a.  Explain what was done above.Why can't we assimilate the predicates <code>number?</code> and <code>same-variable?</code> into the data-directed dispatch?</p>
<p>b.  Write the procedures for derivatives of sums and products, and theauxiliary code required to install them in the table used by theprogram above.</p>
<p>c.  Choose any additional differentiation rule that you like, such asthe one for exponents (exercise <a href="book-Z-H-16.html#%_thm_2.56">2.56</a>),and install it in this data-directed system.</p>
<p>d.  In this simple algebraic manipulator the type of an expression isthe algebraic operator that binds it together.  Suppose, however, weindexed the procedures in the opposite way, so that the dispatch linein <code>deriv</code> looked like</p>
<p></p>
<p></p>
<p><pre>((get (operator exp) 'deriv) (operands exp) var)
</pre></p>
<p></p>
<p>What corresponding changes to the derivative system are required?</p>
<p></p>
<p></p>
<p><a name="%_thm_2.74" id="%_thm_2.74"></a><b>Exercise 2.74.</b>  <a name="%_idx_2482" id="%_idx_2482"></a><a name="%_idx_2484" id="%_idx_2484"></a>Insatiable Enterprises, Inc., is a highly decentralized conglomeratecompany consisting of a large number of independent divisions locatedall over the world.  The company's computer facilities have just beeninterconnected by means of a clever network-interfacing scheme thatmakes the entire network appear to any user to be a single computer.Insatiable's president, in her first attempt to exploit the ability ofthe network to extract administrative information from division files,is dismayed to discover that, although all the division files havebeen implemented as data structures in Scheme, the particular datastructure used varies from division to division.  A meeting ofdivision managers is hastily called to search for a strategy tointegrate the files that will satisfy headquarters' needs whilepreserving the existing autonomy of the divisions.</p>
<p>Show how such a strategy can be implemented with data-directedprogramming.  As an example, suppose that each division's personnelrecords consist of a single file, which contains a set of recordskeyed on employees' names.  The structure of the set varies fromdivision to division.  Furthermore, each employee's record is itself aset (structured differently from division to division) that containsinformation keyed under identifiers such as <code>address</code> and <code>salary</code>.  In particular:</p>
<p>a.  Implement for headquarters a <code>get-record</code> procedure thatretrieves a specified employee's record from a specified personnelfile.  The procedure should be applicable to any division's file.Explain how the individual divisions' files should be structured.  Inparticular, what type information must be supplied?</p>
<p>b.  Implement for headquarters a <code>get-salary</code> procedure thatreturns the salary information from a given employee's record from anydivision's personnel file.  How should the record be structured inorder to make this operation work?</p>
<p>c.  Implement for headquarters a <code>find-employee-record</code> procedure.This should search all the divisions' files for the record of a givenemployee and return the record.  Assume that this procedure takes asarguments an employee's name and a list of all the divisions' files.</p>
<p>d.  When Insatiable takes over a new company, what changes mustbe made in order to incorporate the new personnel information into thecentral system?</p>
<p><a name="%_sec_Temp_275" id="%_sec_Temp_275"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_275">Message passing</a></h4>
<p><a name="%_idx_2486" id="%_idx_2486"></a>The key idea of data-directed programming is to handle genericoperations in programs by dealing explicitly with operation-and-typetables, such as the table in figure <a href="#%_fig_2.22">2.22</a>.  Thestyle of programming we used in section <a href="#%_sec_2.4.2">2.4.2</a>organized the required dispatching on type by having each operationtake care of its own dispatching.  In effect, this decomposes theoperation-and-type table into rows, with each generic operationprocedure representing a row of the table.</p>
<p>An alternative implementation strategy is to decompose the table intocolumns and, instead of using “intelligent operations” that dispatchon data types, to work with “intelligent data objects” that dispatchon operation names.  We can do this by arranging things so that a dataobject, such as a rectangular number, is represented as a procedurethat takes as input the required operation name and performs theoperation indicated.  In such a discipline, <code>make-from-real-imag</code>could be written as</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_2488" id="%_idx_2488"></a>(define (make-from-real-imag x y)
  (define (dispatch op)
    (cond ((eq? op 'real-part) x)
          ((eq? op 'imag-part) y)
          ((eq? op 'magnitude)
           (sqrt (+ (square x) (square y))))
          ((eq? op 'angle) (atan y x))
          (else
           (error "Unknown op -- MAKE-FROM-REAL-IMAG" op))))
  dispatch)
</pre></p>
<p></p>
<p>The corresponding <code>apply-generic</code> procedure, which applies ageneric operation to an argument, now simply feeds the operation'sname to the data object and lets the object do the work:<a name="call_footnote_Temp_276" href="#footnote_Temp_276" id="call_footnote_Temp_276"><sup><small>48</small></sup></a></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_2490" id="%_idx_2490"></a>(define (apply-generic op arg) (arg op))
</pre></p>
<p></p>
<p>Note that the value returned by <code>make-from-real-imag</code> is aprocedure – the internal <code>dispatch</code> procedure.  This is theprocedure that is invoked when <code>apply-generic</code> requests an operation tobe performed.</p>
<p>This style of programming is called <em>message passing</em>.  The namecomes from the image that a data object is an entity that receives therequested operation name as a “message.”  We have already seen anexample of message passing in section <a href="book-Z-H-14.html#%_sec_2.1.3">2.1.3</a>, where we sawhow <code>cons</code>, <code>car</code>, and <code>cdr</code> could be defined with no dataobjects but only procedures.  Here we see that message passing is nota mathematical trick but a useful technique for organizing systemswith generic operations.  In the remainder of this chapter we willcontinue to use data-directed programming, rather than messagepassing, to discuss generic arithmetic operations.  In chapter 3 wewill return to message passing, and we will see that it can be apowerful tool for structuring simulation programs.</p>
<p></p>
<p><a name="%_thm_2.75" id="%_thm_2.75"></a><b>Exercise 2.75.</b>  <a name="%_idx_2492" id="%_idx_2492"></a>Implement the constructor <code>make-from-mag-ang</code> in message-passing style.This procedure should be analogous to the <code>make-from-real-imag</code>procedure given above.</p>
<p></p>
<p></p>
<p><a name="%_thm_2.76" id="%_thm_2.76"></a><b>Exercise 2.76.</b>  <a name="%_idx_2494" id="%_idx_2494"></a>As a large system with generic operations evolves, new types of dataobjects or new operations may be needed.  For each of the threestrategies – generic operations with explicit dispatch, data-directedstyle, and message-passing-style – describe the changes that must bemade to a system in order to add new types or new operations.  Whichorganization would be most appropriate for a system in which new typesmust often be added?  Which would be most appropriate for a system inwhich new operations must often be added?</p>
<p></p>
<p></p>
<p></p>
<div class="smallprint"><hr></div>
<p></p>
<div class="footnote">
<p><a name="footnote_Temp_268" href="#call_footnote_Temp_268" id="footnote_Temp_268"><sup><small>43</small></sup></a> In actual computational systems, rectangular form ispreferable to polar form most of the time because of <a name="%_idx_2308" id="%_idx_2308"></a>roundoff errorsin conversion between rectangular and polar form.  This is why thecomplex-number example is unrealistic.  Nevertheless, it provides aclear illustration of the design of a system using generic operationsand a good introduction to the more substantial systems to bedeveloped later in this chapter.</p>
<p><a name="footnote_Temp_269" href="#call_footnote_Temp_269" id="footnote_Temp_269"><sup><small>44</small></sup></a> The arctangent function referred to<a name="%_idx_2322" id="%_idx_2322"></a><a name="%_idx_2324" id="%_idx_2324"></a><a name="%_idx_2326" id="%_idx_2326"></a>here, computed by Scheme's <code>atan</code> procedure,is defined so as to take two arguments <em>y</em> and <em>x</em> and to returnthe angle whose tangent is <em>y</em>/<em>x</em>.  The signs of the argumentsdetermine the quadrant of the angle.</p>
<p><a name="footnote_Temp_270" href="#call_footnote_Temp_270" id="footnote_Temp_270"><sup><small>45</small></sup></a> We use the list <code>(rectangular)</code>rather than the symbol <code>rectangular</code> to allow for the possibilityof operations with multiple arguments, not all of the sametype.</p>
<p><a name="footnote_Temp_271" href="#call_footnote_Temp_271" id="footnote_Temp_271"><sup><small>46</small></sup></a> Thetype the constructors are installed under needn't be a list becausea constructor is always used to make an object of one particulartype.</p>
<p><a name="footnote_Temp_272" href="#call_footnote_Temp_272" id="footnote_Temp_272"><sup><small>47</small></sup></a> <code>Apply-generic</code> uses the <a name="%_idx_2456" id="%_idx_2456"></a>dotted-tail notation described inexercise <a href="book-Z-H-15.html#%_thm_2.20">2.20</a>, because different generic operationsmay take different numbers of arguments.  In <code>apply-generic</code>, <code>op</code> has as its value the first argument to <code>apply-generic</code> and<code>args</code> has as its value a list of the remaining arguments.</p>
<p><code>Apply-generic</code> also uses the primitive procedure <a name="%_idx_2458" id="%_idx_2458"></a><a name="%_idx_2460" id="%_idx_2460"></a><code>apply</code>,which takes two arguments, a procedure and a list.  <code>Apply</code>applies the procedure, using the elements in the list as arguments.For example,</p>
<p></p>
<p><pre>(apply + (list 1 2 3 4))
</pre></p>
<p></p>
<p>returns 10.</p>
<p><a name="footnote_Temp_276" href="#call_footnote_Temp_276" id="footnote_Temp_276"><sup><small>48</small></sup></a> Onelimitation of this organization is it permits only generic proceduresof one argument.</p>
</div></body>
</html>
