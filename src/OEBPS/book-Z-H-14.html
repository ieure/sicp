<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<?xml version="1.0" encoding="utf-8"?><html xmlns="http://www.w3.org/1999/xhtml" xmlns:ops="http://www.idpf.org/2007/ops">
<!-- Generated from TeX source by tex2page, v 4o,
     (c) Dorai Sitaram, http://www.cs.rice.edu/~dorai/tex2page --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Type: text/html; charset=utf-8">
<title>Structure and Interpretation of Computer Programs</title>
<link rel="stylesheet" type="text/css" href="book-Z-C.css" title="default">
</head>
<body><a name="%_sec_2.1" id="%_sec_2.1"></a><h2><a href="book-Z-H-4.html#%_toc_%_sec_2.1">2.1  Introduction to Data Abstraction</a></h2>
<p>In section <a href="book-Z-H-10.html#%_sec_1.1.8">1.1.8</a>, we notedthat a procedure used as an element in creating a more complexprocedure could be regarded not only as a collection of particularoperations but also as a procedural abstraction.  That is, the detailsof how the procedure was implemented could be suppressed, and theparticular procedure itself could be replaced by any other procedurewith the same overall behavior.  In other words, we could make anabstraction that would separate the way the procedure would be usedfrom the details of how the procedure would be implemented in terms ofmore primitive procedures.  The analogous notion for compound data iscalled <a name="%_idx_1280" id="%_idx_1280"></a><em>data abstraction</em>.  Data abstraction is a methodology thatenables us to isolate how a compound data object is used from thedetails of how it is constructed from more primitive data objects.</p>
<p>The basic idea of data abstraction is to structure the programs thatare to use compound data objects so that they operate on <a name="%_idx_1282" id="%_idx_1282"></a><a name="%_idx_1284" id="%_idx_1284"></a>“abstractdata.” That is, our programs should use data in such a way as to makeno assumptions about the data that are not strictly necessary forperforming the task at hand.  At the same time, a <a name="%_idx_1286" id="%_idx_1286"></a><a name="%_idx_1288" id="%_idx_1288"></a>“concrete” datarepresentation is defined independent of the programs that usethe data.  The interface between these two parts of our system will bea set of procedures, called <a name="%_idx_1290" id="%_idx_1290"></a><em>selectors</em> and <a name="%_idx_1292" id="%_idx_1292"></a><em>constructors</em>,that implement the abstract data in terms of the concreterepresentation.  To illustrate this technique, we will consider how todesign a set of procedures for manipulating rational numbers.</p>
<p><a name="%_sec_2.1.1" id="%_sec_2.1.1"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_2.1.1">2.1.1  Example: Arithmetic Operations for Rational Numbers</a></h3>
<p></p>
<p><a name="%_idx_1294" id="%_idx_1294"></a><a name="%_idx_1296" id="%_idx_1296"></a><a name="%_idx_1298" id="%_idx_1298"></a>Suppose we want to do arithmetic with rational numbers.  We want to beable to add, subtract, multiply, and divide them and to test whethertwo rational numbers are equal.</p>
<p>Let us begin by assuming that we already have a way of constructing arational number from a numerator and a denominator.  We also assumethat, given a rational number, we have a way of extracting (orselecting) its numerator and its denominator.  Let us further assumethat the constructor and selectors are available as procedures:</p>
<p></p>
<p></p>
<ul>
<a name="%_idx_1300" id="%_idx_1300"></a><li>
<code>(make-rat &lt;<em>n</em>&gt; &lt;<em>d</em>&gt;)</code> returns therational number whose  numerator is the integer <code>&lt;<em>n</em>&gt;</code>and whose denominator is the integer <code>&lt;<em>d</em>&gt;</code>. <p><a name="%_idx_1302" id="%_idx_1302"></a></p>
</li>
<li>
<code>(numer &lt;<em>x</em>&gt;)</code> returns the numerator of the rationalnumber <code>&lt;<em>x</em>&gt;</code>.<p><a name="%_idx_1304" id="%_idx_1304"></a></p>
</li>
<li>
<code>(denom &lt;<em>x</em>&gt;)</code> returns the denominator of therational number <code>&lt;<em>x</em>&gt;</code>.</li>
</ul>
<p></p>
<p>We are using here a powerful strategy of synthesis: <a name="%_idx_1306" id="%_idx_1306"></a><em>wishful thinking</em>.We haven't yet said how a rational number is represented, or how theprocedures <code>numer</code>, <code>denom</code>, and <code>make-rat</code> should beimplemented.  Even so, if we did have these three procedures, we couldthen add, subtract, multiply, divide, and test equality by using thefollowing relations:</p>
<p></p>
<p></p>
<div align="left"><img src="images/ch2-Z-G-1.gif" border="0"></div>
<p></p>
<p></p>
<p></p>
<div align="left"><img src="images/ch2-Z-G-2.gif" border="0"></div>
<p></p>
<p></p>
<p></p>
<div align="left"><img src="images/ch2-Z-G-3.gif" border="0"></div>
<p></p>
<p></p>
<p></p>
<div align="left"><img src="images/ch2-Z-G-4.gif" border="0"></div>
<p></p>
<p></p>
<p></p>
<div align="left"><img src="images/ch2-Z-G-5.gif" border="0"></div>
<p></p>
<p>We can express these rules as procedures:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_1308" id="%_idx_1308"></a>(define (add-rat x y)
  (make-rat (+ (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))
<a name="%_idx_1310" id="%_idx_1310"></a>(define (sub-rat x y)
  (make-rat (- (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))
<a name="%_idx_1312" id="%_idx_1312"></a>(define (mul-rat x y)
  (make-rat (* (numer x) (numer y))
            (* (denom x) (denom y))))
<a name="%_idx_1314" id="%_idx_1314"></a>(define (div-rat x y)
  (make-rat (* (numer x) (denom y))
            (* (denom x) (numer y))))
<a name="%_idx_1316" id="%_idx_1316"></a>(define (equal-rat? x y)
  (= (* (numer x) (denom y))
     (* (numer y) (denom x))))
</pre></p>
<p></p>
<p></p>
<p>Now we have the operations on rational numbers defined in terms of theselector and constructor procedures<code>numer</code>, <code>denom</code>, and <code>make-rat</code>.But we haven't yet defined these.What we need is some way to glue together a numerator and adenominator to form a rationalnumber.</p>
<p><a name="%_sec_Temp_132" id="%_sec_Temp_132"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_132">Pairs</a></h4>
<p>To enable us to implement the concrete level of our dataabstraction, our language provides a compound structure called a <a name="%_idx_1318" id="%_idx_1318"></a><em>pair</em>, which can be constructed with the primitive procedure <a name="%_idx_1320" id="%_idx_1320"></a><a name="%_idx_1322" id="%_idx_1322"></a><code>cons</code>.  This procedure takes two arguments and returns a compound dataobject that contains the two arguments as parts.  Given a pair, we canextract the parts using the primitive procedures <a name="%_idx_1324" id="%_idx_1324"></a><a name="%_idx_1326" id="%_idx_1326"></a><code>car</code> and <a name="%_idx_1328" id="%_idx_1328"></a><a name="%_idx_1330" id="%_idx_1330"></a><code>cdr</code>.<a name="call_footnote_Temp_133" href="#footnote_Temp_133" id="call_footnote_Temp_133"><sup><small>2</small></sup></a> Thus, we can use <code>cons</code>, <code>car</code>, and <code>cdr</code> as follows:</p>
<p></p>
<p></p>
<p><pre>(define x (cons 1 2))

(car x)
<i>1</i>

(cdr x)
<i>2</i>
</pre></p>
<p></p>
<p>Notice that a pair is a data object that can be given a name andmanipulated, just like a primitive data object.  Moreover, <code>cons</code>can be used to form pairs whose elements are pairs, and so on:</p>
<p></p>
<p></p>
<p><pre>(define x (cons 1 2))

(define y (cons 3 4))

(define z (cons x y))

(car (car z))
<i>1</i>

(car (cdr z))
<i>3</i>
</pre></p>
<p></p>
<p>In section <a href="book-Z-H-15.html#%_sec_2.2">2.2</a> we will see how this ability tocombine pairs means that pairs can be used as general-purpose buildingblocks to create all sorts of complex data structures.  The singlecompound-data primitive <em>pair</em>, implemented by the procedures <code>cons</code>, <code>car</code>, and <code>cdr</code>, is the only glue we need.  Dataobjects constructed from pairs are called <a name="%_idx_1342" id="%_idx_1342"></a><a name="%_idx_1344" id="%_idx_1344"></a><em>list-structured</em> data.</p>
<p><a name="%_sec_Temp_134" id="%_sec_Temp_134"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_134">Representing rational numbers</a></h4>
<p><a name="%_idx_1346" id="%_idx_1346"></a>Pairs offer a natural way to complete the rational-number system.Simply represent a rational number as a pair of two integers: anumerator and a denominator.  Then <code>make-rat</code>, <code>numer</code>, and<code>denom</code> are readily implemented as follows:<a name="call_footnote_Temp_135" href="#footnote_Temp_135" id="call_footnote_Temp_135"><sup><small>3</small></sup></a></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_1348" id="%_idx_1348"></a>(define (make-rat n d) (cons n d))

<a name="%_idx_1350" id="%_idx_1350"></a>(define (numer x) (car x))

<a name="%_idx_1352" id="%_idx_1352"></a>(define (denom x) (cdr x))
</pre></p>
<p></p>
<p>Also, in order to display the results of our computations,we can <a name="%_idx_1354" id="%_idx_1354"></a>print rational numbers by printing the numerator, aslash, and the denominator:<a name="call_footnote_Temp_136" href="#footnote_Temp_136" id="call_footnote_Temp_136"><sup><small>4</small></sup></a></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_1370" id="%_idx_1370"></a>(define (print-rat x)
  (newline)
  (display (numer x))
  (display "/")
  (display (denom x)))
</pre></p>
<p></p>
<p>Now we can try our rational-number procedures:</p>
<p></p>
<p></p>
<p><pre>(define one-half (make-rat 1 2))

(print-rat one-half)
<i>1/2</i>

(define one-third (make-rat 1 3))
(print-rat (add-rat one-half one-third))
<i>5/6</i>

(print-rat (mul-rat one-half one-third))
<i>1/6</i>

(print-rat (add-rat one-third one-third))
<i>6/9</i>
</pre></p>
<p></p>
<p></p>
<p><a name="%_idx_1372" id="%_idx_1372"></a><a name="%_idx_1374" id="%_idx_1374"></a>As the final example shows, our rational-number implementation doesnot reduce rational numbers to lowest terms.  We can remedy this bychanging <code>make-rat</code>. If we have a <a name="%_idx_1376" id="%_idx_1376"></a><code>gcd</code> procedure like the onein section <a href="book-Z-H-11.html#%_sec_1.2.5">1.2.5</a> that produces the greatest common divisor of twointegers, we can use <code>gcd</code> to reduce the numerator and thedenominator to lowest terms before constructing the pair:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_1378" id="%_idx_1378"></a>(define (make-rat n d)
  (let ((g (gcd n d)))
    (cons (/ n g) (/ d g))))
</pre></p>
<p></p>
<p>Now we have</p>
<p></p>
<p></p>
<p><pre>(print-rat (add-rat one-third one-third))
<i>2/3</i>
</pre></p>
<p></p>
<p>as desired.  This modification was accomplished by changing theconstructor <code>make-rat</code> without changing any of the procedures(such as <code>add-rat</code> and <code>mul-rat</code>)that implement the actual operations.</p>
<p></p>
<p><a name="%_thm_2.1" id="%_thm_2.1"></a><b>Exercise 2.1.</b>  Define a better version of <code>make-rat</code> thathandles both positive and negative arguments.  <code>Make-rat</code> shouldnormalize the sign so that if the rational number is positive, boththe numerator and denominator are positive, and if the rational numberis negative, only the numerator is negative.</p>
<p><a name="%_sec_2.1.2" id="%_sec_2.1.2"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_2.1.2">2.1.2  Abstraction Barriers</a></h3>
<p></p>
<p><a name="%_idx_1380" id="%_idx_1380"></a>Before continuing with more examples of compound data and dataabstraction, let us consider some of the issues raised by therational-number example.  We defined the rational-number operations interms of a constructor <code>make-rat</code> and selectors <code>numer</code> and<code>denom</code>.  In general, the underlying idea of data abstraction isto identify for each type of data object a basic set of operations interms of which all manipulations of data objects of that type will beexpressed, and then to use only those operations in manipulating thedata.</p>
<p>We can envision the structure of the rational-number system asshown in figure <a href="#%_fig_2.1">2.1</a>.  Thehorizontal lines represent <em>abstraction barriers</em> that isolatedifferent “levels” of the system.  At each level, the barrierseparates the programs (above) that use the data abstraction from theprograms (below) that implement the data abstraction.  Programs thatuse rational numbers manipulate them solely in terms of the proceduressupplied “for public use” by the rational-number package: <code>add-rat</code>, <code>sub-rat</code>, <code>mul-rat</code>, <code>div-rat</code>, and <code>equal-rat?</code>. These, in turn, are implemented solely in terms of the<a name="%_idx_1382" id="%_idx_1382"></a><a name="%_idx_1384" id="%_idx_1384"></a>constructor and selectors <code>make-rat</code>, <code>numer</code>, and <code>denom</code>, which themselves are implemented in terms of pairs.  Thedetails of how pairs are implemented are irrelevant to the rest of therational-number package so long as pairs can be manipulated by the useof <code>cons</code>, <code>car</code>, and <code>cdr</code>.  In effect, procedures ateach level are the interfaces that define the abstraction barriers andconnect the different levels.</p>
<p><a name="%_fig_2.1" id="%_fig_2.1"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td>
<div align="left">
<img src="images/ch2-Z-G-6.gif" border="0"> </div></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 2.1:</b>  Data-abstraction barriers in the rational-number package.</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p>This simple idea has many advantages.  One advantage is that it makesprograms much easier to maintain and to modify.  Any complex datastructure can be represented in a variety of ways with the primitivedata structures provided by a programming language.  Of course, thechoice of representation influences the programs that operate on it;thus, if the representation were to be changed at some later time, allsuch programs might have to be modified accordingly.  This task couldbe time-consuming and expensive in the case of large programs unlessthe dependence on the representation were to be confined by design toa very few program modules.</p>
<p><a name="%_idx_1386" id="%_idx_1386"></a><a name="%_idx_1388" id="%_idx_1388"></a>For example, an alternate way to address the problem of reducing rationalnumbers to lowest terms is to perform the reduction whenever weaccess the parts of a rational number, rather than when we constructit.  This leads to different constructor and selector procedures:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_1390" id="%_idx_1390"></a>(define (make-rat n d)
  (cons n d))
<a name="%_idx_1392" id="%_idx_1392"></a>(define (numer x)
  (let ((g (gcd (car x) (cdr x))))
    (/ (car x) g)))
<a name="%_idx_1394" id="%_idx_1394"></a>(define (denom x)
  (let ((g (gcd (car x) (cdr x))))
    (/ (cdr x) g)))
</pre></p>
<p></p>
<p>The difference between this implementation and the previous one liesin when we compute the <code>gcd</code>.If in our typical use of rational numbers we access thenumerators and denominators of the same rational numbers manytimes, it would be preferableto compute the <code>gcd</code> when the rational numbers are constructed.If not, we may be better off waiting until accesstime to compute the <code>gcd</code>.  In any case, whenwe change from one representation to the other, the procedures <code>add-rat</code>, <code>sub-rat</code>, and so on do not have to be modified at all.</p>
<p>Constraining the dependence on the representation to a few interfaceprocedures helps us design programs as well as modify them,because it allows us to maintain the flexibility to consider alternateimplementations.  To continue with our simple example, suppose we aredesigning a rational-number package and we can't decide initiallywhether to perform the <code>gcd</code> at construction time or at selectiontime.  The data-abstraction methodology gives us a way to defer thatdecision without losing the ability to make progress on the rest ofthe system.</p>
<p></p>
<p><a name="%_thm_2.2" id="%_thm_2.2"></a><b>Exercise 2.2.</b>  Consider the problem of representing<a name="%_idx_1396" id="%_idx_1396"></a>line segments in a plane.  Each segment isrepresented as a pair of points: a starting point and an ending point.Define a constructor <a name="%_idx_1398" id="%_idx_1398"></a><code>make-segment</code> and selectors <a name="%_idx_1400" id="%_idx_1400"></a><code>start-segment</code>and <a name="%_idx_1402" id="%_idx_1402"></a><code>end-segment</code> that define the representation of segments interms of points.  Furthermore, a point <a name="%_idx_1404" id="%_idx_1404"></a>can be represented as a pairof numbers: the <em>x</em> coordinate and the <em>y</em> coordinate.  Accordingly,specify a constructor <a name="%_idx_1406" id="%_idx_1406"></a><code>make-point</code> and selectors <code>x-point</code> and<code>y-point</code> that define this representation.  Finally, using yourselectors and constructors, define a procedure <a name="%_idx_1408" id="%_idx_1408"></a><code>midpoint-segment</code>that takes a line segment as argument and returns its midpoint (thepoint whose coordinates are the average of the coordinates of theendpoints).To try your procedures, you'll need a way to print points:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_1410" id="%_idx_1410"></a>(define (print-point p)
  (newline)
  (display "(")
  (display (x-point p))
  (display ",")
  (display (y-point p))
  (display ")"))
</pre></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_2.3" id="%_thm_2.3"></a><b>Exercise 2.3.</b>  <a name="%_idx_1412" id="%_idx_1412"></a>Implement a representation for rectangles in a plane.(Hint: You may want to make use of exercise <a href="#%_thm_2.2">2.2</a>.)In terms ofyour constructors and selectors, create procedures that compute theperimeter and the area of a given rectangle.  Now implement adifferent representation for rectangles.  Can you design your systemwith suitable abstraction barriers, so that the same perimeter andarea procedures will work using either representation?</p>
<p></p>
<p><a name="%_sec_2.1.3" id="%_sec_2.1.3"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_2.1.3">2.1.3  What Is Meant by Data?</a></h3>
<p><a name="%_idx_1414" id="%_idx_1414"></a>We began the rational-number implementation insection <a href="#%_sec_2.1.1">2.1.1</a> by implementing the rational-numberoperations <code>add-rat</code>, <code>sub-rat</code>, and so on in terms of threeunspecified procedures: <code>make-rat</code>, <code>numer</code>, and <code>denom</code>.At that point, we could think of the operations as being defined interms of data objects – numerators, denominators, and rationalnumbers – whose behavior was specified by the latter three procedures.</p>
<p>But exactly what is meant by <em>data</em>?  It is not enough to say“whatever is implemented by the given selectors and constructors.”Clearly, not every arbitrary set of three procedures can serve as anappropriate basis for the rational-number implementation.  We need toguarantee that, <a name="%_idx_1416" id="%_idx_1416"></a><a name="%_idx_1418" id="%_idx_1418"></a><a name="%_idx_1420" id="%_idx_1420"></a>if we construct a rational number <code>x</code> from a pairof integers <code>n</code> and <code>d</code>, then extracting the <code>numer</code> and the<code>denom</code> of <code>x</code> and dividing them should yield the same resultas dividing <code>n</code> by <code>d</code>.  In other words, <code>make-rat</code>,<code>numer</code>, and <code>denom</code> must satisfy the condition that, for anyinteger <code>n</code> and any non-zero integer <code>d</code>, if <code>x</code> is(<code>make-rat n d</code>), then</p>
<p></p>
<p></p>
<div align="left"><img src="images/ch2-Z-G-7.gif" border="0"></div>
<p></p>
<p>In fact, this is the only condition <code>make-rat</code>, <code>numer</code>, and<code>denom</code> must fulfill in order to form a suitable basis for arational-number representation.  In general, we can think of data asdefined by some collection of selectors and constructors, togetherwith specified conditions that these procedures must fulfill in orderto be a valid representation.<a name="call_footnote_Temp_140" href="#footnote_Temp_140" id="call_footnote_Temp_140"><sup><small>5</small></sup></a></p>
<p><a name="%_idx_1446" id="%_idx_1446"></a><a name="%_idx_1448" id="%_idx_1448"></a>This point of view can serve to define not only “high-level” dataobjects, such as rational numbers, but lower-level objects as well.<a name="%_idx_1450" id="%_idx_1450"></a>Consider the notion of a pair, which we used in order to define ourrational numbers.  We never actually said what a pair was, only thatthe language supplied procedures <code>cons</code>, <code>car</code>, and <code>cdr</code>for operating on pairs.  But the only thing we need to know aboutthese three operations <a name="%_idx_1452" id="%_idx_1452"></a><a name="%_idx_1454" id="%_idx_1454"></a><a name="%_idx_1456" id="%_idx_1456"></a><a name="%_idx_1458" id="%_idx_1458"></a>is that if we glue two objects together using<code>cons</code> we can retrieve the objects using <code>car</code> and <code>cdr</code>.That is, the operations satisfy the condition that, for any objects<code>x</code> and <code>y</code>, if <code>z</code> is <code>(cons x y)</code> then <code>(car z)</code>is <code>x</code> and <code>(cdr z)</code> is <code>y</code>.  Indeed, we mentioned thatthese three procedures are included as primitives in our language.However, any triple of procedures that satisfies the above conditioncan be used as the basis for implementing pairs.  This point isillustrated strikingly by the fact that we could implement <code>cons</code>,<code>car</code>, and <code>cdr</code> without using any data structures at all butonly using procedures.  Here are the definitions:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_1460" id="%_idx_1460"></a>(define (cons x y)
  (define (dispatch m)
    (cond ((= m 0) x)
          ((= m 1) y)
          (else (error "Argument not 0 or 1 -- CONS" m))))
  dispatch)

<a name="%_idx_1462" id="%_idx_1462"></a>(define (car z) (z 0))

<a name="%_idx_1464" id="%_idx_1464"></a>(define (cdr z) (z 1))
</pre></p>
<p></p>
<p>This use of procedures corresponds to nothing like our intuitivenotion of what data should be.  Nevertheless, all we need to do toshow that this is a valid way to represent pairs is to verify thatthese procedures satisfy the condition given above.</p>
<p>The subtle point to notice is that the value returned by <code>(cons xy)</code> is a procedure – namely the internally defined procedure <code>dispatch</code>, which takes one argument and returns either <code>x</code> or <code>y</code> depending on whether the argument is 0 or 1.  Correspondingly, <code>(car z)</code> is defined to apply <code>z</code> to 0.  Hence, if <code>z</code> is theprocedure formed by <code>(cons x y)</code>, then <code>z</code> applied to 0 willyield <code>x</code>. Thus, we have shown that <code>(car (cons x y))</code> yields<code>x</code>, as desired.  Similarly, <code>(cdr (cons x y))</code> applies theprocedure returned by <code>(cons x y)</code> to 1, which returns <code>y</code>.Therefore, this procedural implementation of pairs is a validimplementation, and if we access pairs using only <code>cons</code>, <code>car</code>, and <code>cdr</code> we cannot distinguish this implementation from onethat uses “real” data structures.</p>
<p>The point of exhibiting the procedural representation of pairs is notthat our language works this way (Scheme, and Lisp systems in general,implement pairs directly, for efficiency reasons) but that it couldwork this way.  The procedural representation, although obscure, is aperfectly adequate way to represent pairs, since it fulfills the onlyconditions that pairs need to fulfill.  This example also demonstratesthat the ability to manipulate procedures as objects automaticallyprovides the ability to represent compound data.  This may seem acuriosity now, but procedural representations of data will play acentral role in our programming repertoire.  This style of programmingis often called <a name="%_idx_1466" id="%_idx_1466"></a><em>message passing</em>, and we will be using it as abasic tool in chapter 3 when we address the issues of modeling andsimulation.</p>
<p></p>
<p><a name="%_thm_2.4" id="%_thm_2.4"></a><b>Exercise 2.4.</b>  Here is an alternative procedural representation of pairs.  For thisrepresentation, verify that <code>(car (cons x y))</code> yields <code>x</code> forany objects <code>x</code> and <code>y</code>.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_1468" id="%_idx_1468"></a>(define (cons x y)
  (lambda (m) (m x y)))

<a name="%_idx_1470" id="%_idx_1470"></a>(define (car z)
  (z (lambda (p q) p)))
</pre></p>
<p></p>
<p><a name="%_idx_1472" id="%_idx_1472"></a>What is the corresponding definition of <code>cdr</code>? (Hint: To verifythat this works, make use of the substitution model ofsection <a href="book-Z-H-10.html#%_sec_1.1.5">1.1.5</a>.)</p>
<p></p>
<p></p>
<p><a name="%_thm_2.5" id="%_thm_2.5"></a><b>Exercise 2.5.</b>  Show that we can represent pairs of nonnegative integers using onlynumbers and arithmetic operations if we represent the pair <em>a</em> and <em>b</em>as the integer that is the product 2<sup><em>a</em></sup> 3<sup><em>b</em></sup>.  Give the correspondingdefinitions of the procedures <code>cons</code>, <code>car</code>, and <code>cdr</code>.</p>
<p></p>
<p><a name="%_thm_2.6" id="%_thm_2.6"></a><b>Exercise 2.6.</b>  In case representing pairs as procedures wasn't mind-boggling enough,consider that, in a language that can manipulate procedures, we canget by without numbers (at least insofar as nonnegative integers areconcerned) by implementing 0 and the operation of adding 1 as</p>
<p></p>
<p></p>
<p><pre>(define zero (lambda (f) (lambda (x) x)))

(define (add-1 n)
  (lambda (f) (lambda (x) (f ((n f) x)))))
</pre></p>
<p></p>
<p>This representation is known as <a name="%_idx_1474" id="%_idx_1474"></a><em>Church numerals</em>, after itsinventor, <a name="%_idx_1476" id="%_idx_1476"></a>Alonzo Church, the logician who invented the λcalculus.</p>
<p>Define <code>one</code> and <code>two</code> directly (not in terms of <code>zero</code>and <code>add-1</code>).  (Hint: Use substitution to evaluate <code>(add-1 zero)</code>).Give a direct definition of the addition procedure <code>+</code> (not interms of repeated application of <code>add-1</code>).</p>
<p><a name="%_sec_2.1.4" id="%_sec_2.1.4"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_2.1.4">2.1.4  Extended Exercise: Interval Arithmetic</a></h3>
<p><a name="%_idx_1478" id="%_idx_1478"></a><a name="%_idx_1480" id="%_idx_1480"></a>Alyssa P. Hacker is designing a system to help people solveengineering problems.  One feature she wants to provide in her systemis the ability to manipulate inexact quantities (such as measuredparameters of physical devices) with known precision, so that whencomputations are done with such approximate quantities the resultswill be numbers of known precision.</p>
<p>Electrical engineers will be using Alyssa's system to computeelectrical quantities.  It is sometimes necessary for them to computethe value of a parallel equivalent resistance <em>R</em><sub><em>p</em></sub> of tworesistors <em>R</em><sub>1</sub> and <em>R</em><sub>2</sub> using the formula<a name="%_idx_1482" id="%_idx_1482"></a></p>
<p></p>
<div align="left"><img src="images/ch2-Z-G-8.gif" border="0"></div>
<p></p>
<p>Resistance values are usually known only up to some <a name="%_idx_1484" id="%_idx_1484"></a>toleranceguaranteed by the manufacturer of the resistor.  For example, if youbuy a resistor labeled “6.8 ohms with 10% tolerance” you can onlybe sure that the resistor has a resistance between 6.8 - 0.68 = 6.12 and6.8 + 0.68 = 7.48 ohms.  Thus, if you have a 6.8-ohm 10% resistor inparallel with a 4.7-ohm 5% resistor, the resistance of thecombination can range from about 2.58 ohms (if the two resistors areat the lower bounds) to about 2.97 ohms (if the two resistors are atthe upper bounds).</p>
<p>Alyssa's idea is to implement “interval arithmetic” as a set ofarithmetic operations for combining “intervals” (objectsthat represent the range of possible values of an inexact quantity).The result of adding, subtracting, multiplying, or dividing twointervals is itself an interval, representing the range of theresult.</p>
<p>Alyssa postulates the existence of an abstract object called an“interval” that has two endpoints: a lower bound and an upper bound.She also presumes that, given the endpoints of an interval, she canconstruct the interval using the data constructor <a name="%_idx_1486" id="%_idx_1486"></a><code>make-interval</code>.Alyssa first writes a procedure for adding two intervals.  Shereasons that the minimum value the sum could be is the sum of the twolower bounds and the maximum value it could be is the sum of the twoupper bounds:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_1488" id="%_idx_1488"></a>(define (add-interval x y)
  (make-interval (+ (lower-bound x) (lower-bound y))
                 (+ (upper-bound x) (upper-bound y))))
</pre></p>
<p></p>
<p>Alyssa also works out the product of two intervals by finding theminimum and the maximum of the products of the bounds and using themas the bounds of the resulting interval.  (<code>Min</code> and <code>max</code> are<a name="%_idx_1490" id="%_idx_1490"></a><a name="%_idx_1492" id="%_idx_1492"></a><a name="%_idx_1494" id="%_idx_1494"></a><a name="%_idx_1496" id="%_idx_1496"></a>primitives that find the minimum or maximum of any number ofarguments.)</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_1498" id="%_idx_1498"></a>(define (mul-interval x y)
  (let ((p1 (* (lower-bound x) (lower-bound y)))
        (p2 (* (lower-bound x) (upper-bound y)))
        (p3 (* (upper-bound x) (lower-bound y)))
        (p4 (* (upper-bound x) (upper-bound y))))
    (make-interval (min p1 p2 p3 p4)
                   (max p1 p2 p3 p4))))
</pre></p>
<p></p>
<p>To divide two intervals, Alyssa multiplies the first by the reciprocal ofthe second.  Note that the bounds of the reciprocal interval arethe reciprocal of the upper bound and the reciprocal of the lower bound, inthat order.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_1500" id="%_idx_1500"></a>(define (div-interval x y)
  (mul-interval x 
                (make-interval (/ 1.0 (upper-bound y))
                               (/ 1.0 (lower-bound y)))))
</pre></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_2.7" id="%_thm_2.7"></a><b>Exercise 2.7.</b>  Alyssa's program is incomplete because she has not specified theimplementation of the interval abstraction.  Here is a definition ofthe interval constructor:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_1502" id="%_idx_1502"></a>(define (make-interval a b) (cons a b))
</pre></p>
<p></p>
<p>Define selectors <a name="%_idx_1504" id="%_idx_1504"></a><code>upper-bound</code> and <a name="%_idx_1506" id="%_idx_1506"></a><code>lower-bound</code> to completethe implementation.</p>
<p></p>
<p></p>
<p><a name="%_thm_2.8" id="%_thm_2.8"></a><b>Exercise 2.8.</b>  Using reasoning analogous to Alyssa's, describe how the differenceof two intervals may be computed.  Define a corresponding subtractionprocedure, called <a name="%_idx_1508" id="%_idx_1508"></a><code>sub-interval</code>.</p>
<p></p>
<p></p>
<p><a name="%_thm_2.9" id="%_thm_2.9"></a><b>Exercise 2.9.</b>  <a name="%_idx_1510" id="%_idx_1510"></a>The <em>width</em> of an interval is half of the difference between itsupper and lower bounds.  The width is a measure of the uncertainty ofthe number specified by the interval.  For some arithmetic operationsthe width of the result of combining two intervals is a function onlyof the widths of the argument intervals, whereas for others the widthof the combination is not a function of the widths of the argumentintervals.  Show that the width of the sum (or difference) of twointervals is a function only of the widths of the intervals beingadded (or subtracted).  Give examples to show that this is not truefor multiplication or division.</p>
<p></p>
<p></p>
<p><a name="%_thm_2.10" id="%_thm_2.10"></a><b>Exercise 2.10.</b>  <a name="%_idx_1512" id="%_idx_1512"></a>Ben Bitdiddle, an expert systems programmer, looks over Alyssa'sshoulder and comments that it is not clear what it means todivide by an interval that spans zero.  Modify Alyssa's code tocheck for this condition and to signal an error if it occurs.</p>
<p></p>
<p></p>
<p><a name="%_thm_2.11" id="%_thm_2.11"></a><b>Exercise 2.11.</b>  <a name="%_idx_1514" id="%_idx_1514"></a>In passing, Ben also cryptically comments: “By testing the signs ofthe endpoints of the intervals, it is possible to break <code>mul-interval</code> into nine cases, only one of which requires more thantwo multiplications.”  Rewrite this procedure using Ben'ssuggestion.</p>
<p></p>
<p></p>
<p></p>
<p>After debugging her program, Alyssa shows it to a potential user,who complains that her program solves the wrong problem.  Hewants a program that can deal with numbers represented as a centervalue and an additive tolerance; for example, he wants to work withintervals such as 3.5± 0.15 rather than [3.35, 3.65].  Alyssareturns to her desk and fixes this problem by supplying an alternateconstructor and alternate selectors:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_1516" id="%_idx_1516"></a>(define (make-center-width c w)
  (make-interval (- c w) (+ c w)))
<a name="%_idx_1518" id="%_idx_1518"></a>(define (center i)
  (/ (+ (lower-bound i) (upper-bound i)) 2))
<a name="%_idx_1520" id="%_idx_1520"></a>(define (width i)
  (/ (- (upper-bound i) (lower-bound i)) 2))
</pre></p>
<p></p>
<p></p>
<p>Unfortunately, most of Alyssa's users are engineers.  Real engineeringsituations usually involve measurements with only a small uncertainty,measured as the ratio of the width of the interval to the midpoint ofthe interval.  Engineers usually specify percentage tolerances on theparameters of devices, as in the resistor specifications givenearlier.</p>
<p></p>
<p><a name="%_thm_2.12" id="%_thm_2.12"></a><b>Exercise 2.12.</b>  Define a constructor <a name="%_idx_1522" id="%_idx_1522"></a><code>make-center-percent</code> that takes a center anda percentage tolerance and produces the desired interval.  You mustalso define a selector <code>percent</code> that produces thepercentage tolerance for a given interval.  The <code>center</code> selectoris the same as the one shown above.</p>
<p></p>
<p></p>
<p><a name="%_thm_2.13" id="%_thm_2.13"></a><b>Exercise 2.13.</b>  Show that under the assumption of small percentage tolerances there isa simple formula for the approximate percentage tolerance of theproduct of two intervals in terms of the tolerances of the factors.You may simplify the problem by assuming that all numbers arepositive.</p>
<p></p>
<p></p>
<p></p>
<p>After considerable work, Alyssa P. Hacker delivers her finishedsystem.  Several years later, after she has forgotten all about it, shegets a frenzied call from an irate user,  Lem E. Tweakit.It seems that Lem hasnoticed that the formula for parallel resistors can be written in two<a name="%_idx_1524" id="%_idx_1524"></a>algebraically equivalent ways:</p>
<p></p>
<p></p>
<div align="left"><img src="images/ch2-Z-G-9.gif" border="0"></div>
<p></p>
<p>and</p>
<p></p>
<p></p>
<div align="left"><img src="images/ch2-Z-G-10.gif" border="0"></div>
<p></p>
<p>He has written the following two programs, each of which computes theparallel-resistors formula differently:</p>
<p></p>
<p></p>
<p><pre>(define (par1 r1 r2)
  (div-interval (mul-interval r1 r2)
                (add-interval r1 r2)))
(define (par2 r1 r2)
  (let ((one (make-interval 1 1))) 
    (div-interval one
                  (add-interval (div-interval one r1)
                                (div-interval one r2)))))
</pre></p>
<p></p>
<p>Lem complains that Alyssa's program gives different answers forthe two ways of computing. This is a serious complaint.</p>
<p></p>
<p><a name="%_thm_2.14" id="%_thm_2.14"></a><b>Exercise 2.14.</b>  Demonstrate that Lem is right. Investigate the behavior of thesystem on a variety of arithmetic expressions. Make some intervals <em>A</em> and <em>B</em>,and use them in computing the expressions <em>A</em>/<em>A</em> and <em>A</em>/<em>B</em>.  You willget the most insight by using intervals whose width is a smallpercentage of the center value. Examine the results of the computationin center-percent form (see exercise <a href="#%_thm_2.12">2.12</a>).</p>
<p></p>
<p></p>
<p><a name="%_thm_2.15" id="%_thm_2.15"></a><b>Exercise 2.15.</b>  Eva Lu Ator, another user, has also noticed the different intervalscomputed by different but algebraically equivalent expressions. Shesays that a formula to compute with intervals using Alyssa's systemwill produce tighter error bounds if it can be written in such a formthat no variable that represents an uncertain number is repeated.Thus, she says, <code>par2</code> is a “better” program for parallelresistances than <code>par1</code>.  Is she right?  Why?</p>
<p></p>
<p></p>
<p><a name="%_thm_2.16" id="%_thm_2.16"></a><b>Exercise 2.16.</b>  Explain, in general, why equivalent algebraic expressions may lead todifferent answers.  Can you devise an interval-arithmetic package thatdoes not have this shortcoming, or is this task impossible?  (Warning:This problem is very difficult.)</p>
<p></p>
<p></p>
<p></p>
<div class="smallprint"><hr></div>
<p></p>
<div class="footnote">
<p><a name="footnote_Temp_133" href="#call_footnote_Temp_133" id="footnote_Temp_133"><sup><small>2</small></sup></a> The name <a name="%_idx_1332" id="%_idx_1332"></a><code>cons</code> stands for “construct.”  Thenames <a name="%_idx_1334" id="%_idx_1334"></a><code>car</code> and <a name="%_idx_1336" id="%_idx_1336"></a><code>cdr</code> derive from the original implementation ofLisp on the <a name="%_idx_1338" id="%_idx_1338"></a><a name="%_idx_1340" id="%_idx_1340"></a>IBM 704.  That machine had an addressing scheme thatallowed one to reference the “address” and “decrement” parts of amemory location.  <code>Car</code> stands for “Contents of Address part ofRegister” and <code>cdr</code> (pronounced “could-er”) stands for“Contents of Decrement part of Register.”</p>
<p><a name="footnote_Temp_135" href="#call_footnote_Temp_135" id="footnote_Temp_135"><sup><small>3</small></sup></a> Another way to define the selectors and constructor is</p>
<p></p>
<p><pre>(define make-rat cons)
(define numer car)
(define denom cdr)
</pre></p>
<p></p>
<p>The first definition associates the name <code>make-rat</code>with the value of the expression <code>cons</code>, which is the primitiveprocedure that constructs pairs.  Thus <code>make-rat</code> and <code>cons</code>are names for the same primitive constructor.</p>
<p>Defining selectors and constructors in this way is efficient:Instead of <code>make-rat</code> <em>calling</em> <code>cons</code>, <code>make-rat</code><em>is</em> <code>cons</code>, so there is only one procedure called, not two,when <code>make-rat</code> is called.  On the other hand, doing this defeats debuggingaids that trace procedure calls or put breakpoints on procedure calls:You may want to watch <code>make-rat</code> being called, but you certainlydon't want to watch every call to <code>cons</code>.</p>
<p>We have chosen not to use this style of definition in this book.</p>
<p><a name="footnote_Temp_136" href="#call_footnote_Temp_136" id="footnote_Temp_136"><sup><small>4</small></sup></a> <a name="%_idx_1356" id="%_idx_1356"></a><a name="%_idx_1358" id="%_idx_1358"></a><a name="%_idx_1360" id="%_idx_1360"></a><a name="%_idx_1362" id="%_idx_1362"></a><a name="%_idx_1364" id="%_idx_1364"></a><code>Display</code> isthe Scheme primitive for printing data.  The Scheme primitive<code>newline</code> starts a new line for printing.<a name="%_idx_1366" id="%_idx_1366"></a><a name="%_idx_1368" id="%_idx_1368"></a>Neither of these procedures returns a useful value, so in the uses of<code>print-rat</code> below, we show only what <code>print-rat</code> prints,not what the interpreter prints as the value returned by <code>print-rat</code>.</p>
<p><a name="footnote_Temp_140" href="#call_footnote_Temp_140" id="footnote_Temp_140"><sup><small>5</small></sup></a> Surprisingly, this idea is verydifficult to formulate rigorously. There are two approaches to givingsuch a formulation.  One, pioneered by <a name="%_idx_1422" id="%_idx_1422"></a>C. A. R. Hoare (1972), is knownas the method of <a name="%_idx_1424" id="%_idx_1424"></a><a name="%_idx_1426" id="%_idx_1426"></a><em>abstract models</em>.  It formalizes the“procedures plus conditions” specification as outlined in therational-number example above.  Note that the condition on therational-number representation was stated in terms of facts aboutintegers (equality and division).  In general, abstract models definenew kinds of data objects in terms of previously defined types of dataobjects.  Assertions about data objects can therefore be checked byreducing them to assertions about previously defined data objects.Another approach, introduced by <a name="%_idx_1428" id="%_idx_1428"></a>Zilles at MIT, by <a name="%_idx_1430" id="%_idx_1430"></a>Goguen, <a name="%_idx_1432" id="%_idx_1432"></a>Thatcher,<a name="%_idx_1434" id="%_idx_1434"></a>Wagner, and <a name="%_idx_1436" id="%_idx_1436"></a>Wright at IBM (see Thatcher, Wagner, and Wright 1978), and by <a name="%_idx_1438" id="%_idx_1438"></a>Guttag at Toronto (see Guttag 1977),is called <a name="%_idx_1440" id="%_idx_1440"></a><a name="%_idx_1442" id="%_idx_1442"></a><em>algebraic specification</em>.  It regards the “procedures”as elements of an abstract algebraic system whose behavior isspecified by axioms that correspond to our “conditions,” and usesthe techniques of abstract algebra to check assertions about dataobjects.  Both methods are surveyed in the paper by <a name="%_idx_1444" id="%_idx_1444"></a>Liskov and Zilles(1975).</p>
</div></body>
</html>
