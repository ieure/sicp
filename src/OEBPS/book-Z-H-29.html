<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<?xml version="1.0" encoding="utf-8"?><html xmlns="http://www.w3.org/1999/xhtml" xmlns:ops="http://www.idpf.org/2007/ops">
<!-- Generated from TeX source by tex2page, v 4o,
     (c) Dorai Sitaram, http://www.cs.rice.edu/~dorai/tex2page --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Type: text/html; charset=utf-8">
<title>Structure and Interpretation of Computer Programs</title>
<link rel="stylesheet" type="text/css" href="book-Z-C.css" title="default">
</head>
<body><a name="%_sec_4.4" id="%_sec_4.4"></a><h2><a href="book-Z-H-4.html#%_toc_%_sec_4.4">4.4  Logic Programming</a></h2>
<p><a name="%_idx_5028" id="%_idx_5028"></a><a name="%_idx_5030" id="%_idx_5030"></a><a name="%_idx_5032" id="%_idx_5032"></a><a name="%_idx_5034" id="%_idx_5034"></a><a name="%_idx_5036" id="%_idx_5036"></a>In chapter 1 we stressed that computer science deals with imperative(how to) knowledge, whereas mathematics deals with declarative (whatis) knowledge.  Indeed, programming languages require that theprogrammer express knowledge in a form that indicates the step-by-stepmethods for solving particular problems.  On the other hand,high-level languages provide, as part of the language implementation,a substantial amount of methodological knowledge that freesthe user from concern with numerous details of how a specifiedcomputation will progress.</p>
<p>Most programming languages, including Lisp, are organized aroundcomputing the values of mathematical functions.  Expression-orientedlanguages (such as Lisp, Fortran, and Algol) capitalize on the “pun”that an expression that describes the value of a function may also beinterpreted as a means of computing that value.  Because of this, mostprogramming languages are strongly biased toward unidirectionalcomputations (computations with well-defined inputs and outputs).There are, however, radically different programming languages thatrelax this bias.  We saw one such example insection <a href="book-Z-H-22.html#%_sec_3.3.5">3.3.5</a>, where the objects of computation werearithmetic constraints.  In a constraint system the direction and theorder of computation are not so well specified; in carrying out acomputation the system must therefore provide more detailed “how to”knowledge than would be the case with an ordinary arithmeticcomputation.  This does not mean, however, that the user is releasedaltogether from the responsibility of providing imperative knowledge.There are many constraint networks that implement the same set ofconstraints, and the user must choose from the set of mathematicallyequivalent networks a suitable network to specify a particularcomputation.</p>
<p>The nondeterministic program evaluator ofsection <a href="book-Z-H-28.html#%_sec_4.3">4.3</a> also moves away from theview that programming is about constructing algorithms for computingunidirectional functions.  In a nondeterministic language, expressionscan have more than one value, and, as a result, the computation is<a name="%_idx_5038" id="%_idx_5038"></a>dealing with relations rather than withsingle-valued functions.  Logic programming extends this idea bycombining a relational vision of programming with a powerful kind ofsymbolic pattern matching called <em>unification</em>.<a name="call_footnote_Temp_645" href="#footnote_Temp_645" id="call_footnote_Temp_645"><sup><small>58</small></sup></a></p>
<p><a name="%_idx_5070" id="%_idx_5070"></a><a name="%_idx_5072" id="%_idx_5072"></a>This approach, when it works, can be a very powerful way to writeprograms.  Part of the power comes from the fact that a single “whatis” fact can be used to solve a number of different problems thatwould have different “how to” components.  As an example, considerthe <a name="%_idx_5074" id="%_idx_5074"></a><code>append</code> operation, which takes two lists as arguments andcombines their elements to form a single list.  In a procedurallanguage such as Lisp, we could define <code>append</code> in terms of thebasic list constructor <code>cons</code>, as we did insection <a href="book-Z-H-15.html#%_sec_2.2.1">2.2.1</a>:</p>
<p></p>
<p></p>
<p><pre>(define (append x y)
  (if (null? x)
      y
      (cons (car x) (append (cdr x) y))))
</pre></p>
<p></p>
<p>This procedure can be regarded as a translation into Lisp of thefollowing two rules, the first of which covers the case where thefirst list is empty and the second of which handles the case of anonempty list, which is a <code>cons</code> of two parts:</p>
<p></p>
<p></p>
<ul>
<li>For any list <code>y</code>, the empty list and <code>y</code> <code>append</code> to form <code>y</code>.<p></p>
</li>
<li>For any <code>u</code>,  <code>v</code>,  <code>y</code>, and <code>z</code>, <code>(cons u v)</code> and <code>y</code> <code>append</code> to form <code>(cons u z)</code>if <code>v</code> and <code>y</code> <code>append</code> to form <code>z</code>.<a name="call_footnote_Temp_646" href="#footnote_Temp_646" id="call_footnote_Temp_646"><sup><small>59</small></sup></a></li>
</ul>
<p></p>
<p>Using the <code>append</code> procedure, we can answer questions such as</p>
<blockquote>Find the <code>append</code> of <code>(a b)</code> and <code>(c d)</code>.</blockquote>
<p>But the same two rules are also sufficient for answering the followingsorts of questions, which the procedure can't answer:</p>
<p></p>
<blockquote>Find a list <code>y</code> that <code>append</code>s with <code>(a b)</code>to produce <code>(a b c d)</code>.<p>Find all <code>x</code> and <code>y</code> that <code>append</code> to form <code>(a b cd)</code>.</p>
</blockquote>
<p><a name="%_idx_5076" id="%_idx_5076"></a><a name="%_idx_5078" id="%_idx_5078"></a>In a logic programming language, the programmer writes an <code>append</code>“procedure” by stating the two rules about <code>append</code> given above.“How to” knowledge is provided automatically by the interpreter toallow this single pair of rules to be used to answer all three typesof questions about <code>append</code>.<a name="call_footnote_Temp_647" href="#footnote_Temp_647" id="call_footnote_Temp_647"><sup><small>60</small></sup></a></p>
<p>Contemporary logic programming languages (including the one weimplement here) have substantial deficiencies, in that their general“how to” methods can lead them into spurious infinite loops or otherundesirable behavior.Logic programming is an active field of research in computer science.<a name="call_footnote_Temp_648" href="#footnote_Temp_648" id="call_footnote_Temp_648"><sup><small>61</small></sup></a></p>
<p>Earlier in this chapter we explored the technology of implementinginterpreters and described the elements that are essential to aninterpreter for a Lisp-like language (indeed, to an interpreter forany conventional language).  Now we will apply these ideas to discussan interpreter for a logic programming language.  We call this<a name="%_idx_5090" id="%_idx_5090"></a>language the <em>query language</em>, because it is very useful forretrieving information from data bases by formulating <a name="%_idx_5092" id="%_idx_5092"></a><em>queries</em>,or questions, expressed in the language.  Even though the querylanguage is very different from Lisp, we will find it convenient todescribe the language in terms of the same general framework we havebeen using all along: as a collection of primitive elements, togetherwith means of combination that enable us to combine simple elements tocreate more complex elements and means of abstraction that enable usto regard complex elements as single conceptual units.  An interpreterfor a logic programming language is considerably more complex than aninterpreter for a language like Lisp.  Nevertheless, we will see<a name="%_idx_5094" id="%_idx_5094"></a>that our query-language interpreter contains many of the same elementsfound in the interpreter of section <a href="book-Z-H-26.html#%_sec_4.1">4.1</a>.  In particular,there will be an “eval” part that classifies expressions accordingto type and an “apply” part that implements the language'sabstraction mechanism (procedures in the case of Lisp, and <em>rules</em>in the case of logic programming).  Also, a central role is played inthe implementation by a frame data structure, which determines thecorrespondence between symbols and their associated values.  Oneadditional interesting aspect of our query-language implementation isthat we make substantial use of streams, which were introduced inchapter 3.<a name="%_sec_4.4.1" id="%_sec_4.4.1"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_4.4.1">4.4.1  Deductive Information Retrieval</a></h3>
<p><a name="%_idx_5096" id="%_idx_5096"></a><a name="%_idx_5098" id="%_idx_5098"></a>Logic programming excels in providing interfaces to data bases forinformation retrieval.  The query language we shall implement in thischapter is designed to be used in this way.</p>
<p>In order to illustrate what the query system does, we will show how itcan be used to manage the data base of personnel records for<a name="%_idx_5100" id="%_idx_5100"></a>Microshaft, a thriving high-technology company in theBoston area.  The language provides pattern-directed access topersonnel information and can also take advantage of general rules inorder to make logical deductions.</p>
<p><a name="%_sec_Temp_649" id="%_sec_Temp_649"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_649">A sample data base</a></h4>
<p><a name="%_idx_5102" id="%_idx_5102"></a><a name="%_idx_5104" id="%_idx_5104"></a><a name="%_idx_5106" id="%_idx_5106"></a>The personnel data base for Microshaftcontains <em>assertions</em> about company personnel.  Here is theinformation about Ben Bitdiddle, the resident computer wizard:</p>
<p></p>
<p></p>
<p><pre>(address (Bitdiddle Ben) (Slumerville (Ridge Road) 10))
(job (Bitdiddle Ben) (computer wizard))
(salary (Bitdiddle Ben) 60000)
</pre></p>
<p></p>
<p>Each assertion is a list (in this case a triple) whose elements canthemselves be lists.</p>
<p>As resident wizard, Ben is in charge of the company's computerdivision, and he supervises two programmers and one technician.  Hereis the information about them:</p>
<p></p>
<p></p>
<p><pre>(address (Hacker Alyssa P) (Cambridge (Mass Ave) 78))
(job (Hacker Alyssa P) (computer programmer))
(salary (Hacker Alyssa P) 40000)
(supervisor (Hacker Alyssa P) (Bitdiddle Ben))
(address (Fect Cy D) (Cambridge (Ames Street) 3))
(job (Fect Cy D) (computer programmer))
(salary (Fect Cy D) 35000)
(supervisor (Fect Cy D) (Bitdiddle Ben))
(address (Tweakit Lem E) (Boston (Bay State Road) 22))
(job (Tweakit Lem E) (computer technician))
(salary (Tweakit Lem E) 25000)
(supervisor (Tweakit Lem E) (Bitdiddle Ben))
</pre></p>
<p></p>
<p>There is also a programmer trainee, who is supervised by Alyssa:</p>
<p></p>
<p><pre>(address (Reasoner Louis) (Slumerville (Pine Tree Road) 80))
(job (Reasoner Louis) (computer programmer trainee))
(salary (Reasoner Louis) 30000)
(supervisor (Reasoner Louis) (Hacker Alyssa P))
</pre></p>
<p></p>
<p>All of these people are in the computer division, as indicated by theword <code>computer</code> as the first item in their job descriptions.</p>
<p>Ben is a high-level employee.  His supervisor is the company's bigwheel himself:</p>
<p></p>
<p></p>
<p><pre>(supervisor (Bitdiddle Ben) (Warbucks Oliver))
(address (Warbucks Oliver) (Swellesley (Top Heap Road)))
(job (Warbucks Oliver) (administration big wheel))
(salary (Warbucks Oliver) 150000)
</pre></p>
<p></p>
<p></p>
<p>Besides the computer division supervised by Ben, the company has anaccounting division, consisting of a chief accountant and hisassistant:</p>
<p></p>
<p></p>
<p><pre>(address (Scrooge Eben) (Weston (Shady Lane) 10))
(job (Scrooge Eben) (accounting chief accountant))
(salary (Scrooge Eben) 75000)
(supervisor (Scrooge Eben) (Warbucks Oliver))
(address (Cratchet Robert) (Allston (N Harvard Street) 16))
(job (Cratchet Robert) (accounting scrivener))
(salary (Cratchet Robert) 18000)
(supervisor (Cratchet Robert) (Scrooge Eben))
</pre></p>
<p></p>
<p>There is also a secretary for the big wheel:</p>
<p></p>
<p></p>
<p><pre>(address (Aull DeWitt) (Slumerville (Onion Square) 5))
(job (Aull DeWitt) (administration secretary))
(salary (Aull DeWitt) 25000)
(supervisor (Aull DeWitt) (Warbucks Oliver))
</pre></p>
<p></p>
<p></p>
<p>The data base also contains assertions about which kinds of jobs canbe done by people holding other kinds of jobs.  For instance, acomputer wizard can do the jobs of both a computer programmer and acomputer technician:</p>
<p></p>
<p></p>
<p><pre>(can-do-job (computer wizard) (computer programmer))
(can-do-job (computer wizard) (computer technician))
</pre></p>
<p></p>
<p>A computer programmer could fill in for a trainee:</p>
<p></p>
<p><pre>(can-do-job (computer programmer)
            (computer programmer trainee))
</pre></p>
<p></p>
<p><a name="%_idx_5108" id="%_idx_5108"></a>Also, as is well known,</p>
<p></p>
<p><pre>(can-do-job (administration secretary)
            (administration big wheel))
</pre></p>
<p></p>
<p><a name="%_sec_Temp_650" id="%_sec_Temp_650"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_650">Simple queries</a></h4>
<p><a name="%_idx_5110" id="%_idx_5110"></a>The query language allows users to retrieve information from the database by posing queries in response to the system's prompt.  Forexample, to find all computer programmers one can say</p>
<p></p>
<p></p>
<p><pre><i>;;; Query input:</i>
(job ?x (computer programmer))
</pre></p>
<p></p>
<p>The system will respond with the following items:</p>
<p></p>
<p></p>
<p><pre><i>;;; Query results:</i>
(job (Hacker Alyssa P) (computer programmer))
(job (Fect Cy D) (computer programmer))
</pre></p>
<p></p>
<p></p>
<p><a name="%_idx_5112" id="%_idx_5112"></a>The input query specifies that we are looking for entries in the database that match a certain <em>pattern</em>.  In this example, the patternspecifies entries consisting of three items, of which the first is theliteral symbol <code>job</code>, the second can be anything, and the third isthe literal list <code>(computer programmer)</code>.  The “anything” thatcan be the second item in the matching list is specified by a <a name="%_idx_5114" id="%_idx_5114"></a><em>pattern variable</em>, <code>?x</code>.  The general form of a pattern variableis a symbol, taken to be the name of the variable, preceded by aquestion mark.  We will see below why it is useful to specify namesfor pattern variables rather than just putting <code>?</code> into patternsto represent “anything.”  The system responds to a simple query byshowing all entries in the data base that match the specified pattern.</p>
<p>A pattern can have more than one variable.  For example, the query</p>
<p></p>
<p><pre>(address ?x ?y)
</pre></p>
<p></p>
<p>will list all the employees' addresses.</p>
<p>A pattern can have no variables, in which case the query simplydetermines whether that pattern is an entry in the data base.  If so,there will be one match; if not, there will be no matches.</p>
<p>The same pattern variable can appear more than once in a query,specifying that the same “anything” must appear in each position.This is why variables have names.  For example,</p>
<p></p>
<p></p>
<p><pre>(supervisor ?x ?x)
</pre></p>
<p></p>
<p>finds all people who supervise themselves (though there are no suchassertions in our sample data base).</p>
<p>The query</p>
<p></p>
<p><pre>(job ?x (computer ?type))
</pre></p>
<p></p>
<p>matches all job entries whose third item is a two-element list whosefirst item is <code>computer</code>:</p>
<p></p>
<p></p>
<p><pre>(job (Bitdiddle Ben) (computer wizard))
(job (Hacker Alyssa P) (computer programmer))
(job (Fect Cy D) (computer programmer))
(job (Tweakit Lem E) (computer technician))
</pre></p>
<p></p>
<p>This same pattern does <em>not</em> match</p>
<p></p>
<p><pre>(job (Reasoner Louis) (computer programmer trainee))
</pre></p>
<p></p>
<p>because the third item in the entry is a list of three elements, andthe pattern's third item specifies that there should be two elements.If we wanted to change the pattern so that the third item could be anylist beginning with <code>computer</code>, we could specify<a name="%_idx_5116" id="%_idx_5116"></a><a name="call_footnote_Temp_651" href="#footnote_Temp_651" id="call_footnote_Temp_651"><sup><small>62</small></sup></a></p>
<p></p>
<p></p>
<p><pre>(job ?x (computer . ?type))
</pre></p>
<p></p>
<p>For example,</p>
<p></p>
<p><pre>(computer . ?type)
</pre></p>
<p></p>
<p>matches the data</p>
<p></p>
<p></p>
<p><pre>(computer programmer trainee)
</pre></p>
<p></p>
<p>with <code>?type</code> as the list <code>(programmer trainee)</code>.  It alsomatches the data</p>
<p></p>
<p></p>
<p><pre>(computer programmer)
</pre></p>
<p></p>
<p>with <code>?type</code> as the list <code>(programmer)</code>, and matches the data</p>
<p></p>
<p></p>
<p><pre>(computer)
</pre></p>
<p></p>
<p>with <code>?type</code> as the empty list <code>()</code>.</p>
<p>We can describe the query language's processing of simple queries asfollows:</p>
<p></p>
<p></p>
<ul>
<li>The system finds all assignments to variables in the query<a name="%_idx_5118" id="%_idx_5118"></a>pattern that <em>satisfy</em> the pattern – that is, all sets of valuesfor the variables such that if the pattern variables are <a name="%_idx_5120" id="%_idx_5120"></a><em>instantiated with</em> (replaced by) the values, the result is in the database.<p></p>
</li>
<li>The system responds to the query by listing all instantiations of thequery pattern with the variable assignments that satisfy it.</li>
</ul>
<p></p>
<p>Note that if the pattern has no variables, the query reduces to adetermination of whether that pattern is in the data base.  If so, theempty assignment, which assigns no values to variables, satisfies thatpattern for that data base.</p>
<p></p>
<p><a name="%_thm_4.55" id="%_thm_4.55"></a><b>Exercise 4.55.</b>  Give simple queries that retrieve the following information from thedata base:</p>
<p></p>
<p></p>
<p>a. all people supervised by Ben Bitdiddle;</p>
<p></p>
<p></p>
<p>b. the names and jobs of all people in the accounting division;</p>
<p></p>
<p></p>
<p>c. the names and addresses of all people who livein Slumerville.</p>
<p><a name="%_sec_Temp_653" id="%_sec_Temp_653"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_653">Compound queries</a></h4>
<p><a name="%_idx_5122" id="%_idx_5122"></a>Simple queries form the primitive operations of the query language.In order to form compound operations, the query language providesmeans of combination.  One thing that makes the query language a logicprogramming language is that the means of combination mirror the meansof combination used in forming logical expressions: <code>and</code>, <code>or</code>, and <code>not</code>.  (Here <code>and</code>, <code>or</code>, and <code>not</code> are notthe Lisp primitives, but rather operations built into the querylanguage.)</p>
<p><a name="%_idx_5124" id="%_idx_5124"></a>We can use <code>and</code> as follows to find the addresses of all thecomputer programmers:</p>
<p></p>
<p></p>
<p><pre>(and (job ?person (computer programmer))
     (address ?person ?where))
</pre></p>
<p></p>
<p>The resulting output is</p>
<p></p>
<p><pre>(and (job (Hacker Alyssa P) (computer programmer))
     (address (Hacker Alyssa P) (Cambridge (Mass Ave) 78)))
(and (job (Fect Cy D) (computer programmer))
     (address (Fect Cy D) (Cambridge (Ames Street) 3)))
</pre></p>
<p></p>
<p><a name="%_idx_5126" id="%_idx_5126"></a>In general,</p>
<p></p>
<p><pre>(and &lt;<em>query<sub>1</sub></em>&gt; &lt;<em>query<sub>2</sub></em>&gt; <code>...</code> &lt;<em>query<sub><em>n</em></sub></em>&gt;)
</pre></p>
<p></p>
<p>is satisfied by all sets of values for the pattern variables thatsimultaneously satisfy &lt;<em>query<sub>1</sub></em>&gt; <code>...</code> &lt;<em>query<sub><em>n</em></sub></em>&gt;.</p>
<p>As for simple queries, the system processes a compound query byfinding all assignments to the pattern variables that satisfy thequery, then displaying instantiations of the query with those values.</p>
<p><a name="%_idx_5128" id="%_idx_5128"></a>Another means of constructing compound queries is through <code>or</code>.For example,</p>
<p></p>
<p></p>
<p><pre>(or (supervisor ?x (Bitdiddle Ben))
    (supervisor ?x (Hacker Alyssa P)))
</pre></p>
<p></p>
<p>will find all employees supervised by Ben Bitdiddle or Alyssa P.Hacker:</p>
<p></p>
<p></p>
<p><pre>(or (supervisor (Hacker Alyssa P) (Bitdiddle Ben))
    (supervisor (Hacker Alyssa P) (Hacker Alyssa P)))
(or (supervisor (Fect Cy D) (Bitdiddle Ben))
    (supervisor (Fect Cy D) (Hacker Alyssa P)))
(or (supervisor (Tweakit Lem E) (Bitdiddle Ben))
    (supervisor (Tweakit Lem E) (Hacker Alyssa P)))
(or (supervisor (Reasoner Louis) (Bitdiddle Ben))
    (supervisor (Reasoner Louis) (Hacker Alyssa P)))
</pre></p>
<p></p>
<p>In general,</p>
<p></p>
<p><pre>(or &lt;<em>query<sub>1</sub></em>&gt; &lt;<em>query<sub>2</sub></em>&gt; <code>...</code> &lt;<em>query<sub><em>n</em></sub></em>&gt;)
</pre></p>
<p></p>
<p>is satisfied by all sets of values for the pattern variables thatsatisfy at least one of &lt;<em>query<sub>1</sub></em>&gt; <code>...</code> &lt;<em>query<sub><em>n</em></sub></em>&gt;.</p>
<p><a name="%_idx_5130" id="%_idx_5130"></a>Compound queries can also be formed with <code>not</code>. For example,</p>
<p></p>
<p><pre>(and (supervisor ?x (Bitdiddle Ben))
     (not (job ?x (computer programmer))))
</pre></p>
<p></p>
<p>finds all people supervised by Ben Bitdiddle who are not computerprogrammers.  In general,</p>
<p></p>
<p></p>
<p><pre>(not &lt;<em>query<sub>1</sub></em>&gt;)
</pre></p>
<p></p>
<p>is satisfied by all assignments to the pattern variables that do notsatisfy &lt;<em>query<sub>1</sub></em>&gt;.<a name="call_footnote_Temp_654" href="#footnote_Temp_654" id="call_footnote_Temp_654"><sup><small>63</small></sup></a></p>
<p><a name="%_idx_5132" id="%_idx_5132"></a>The final combining form is called <code>lisp-value</code>.  When <code>lisp-value</code> is the first element of a pattern, it specifies that thenext element is a Lisp predicate to be applied to the rest of the(instantiated) elements as arguments.  In general,</p>
<p></p>
<p></p>
<p><pre>(lisp-value &lt;<em>predicate</em>&gt; &lt;<em>arg<sub>1</sub></em>&gt; <code>...</code> &lt;<em>arg<sub><em>n</em></sub></em>&gt;)
</pre></p>
<p></p>
<p>will be satisfied by assignments to the pattern variables for which the&lt;<em>predicate</em>&gt; applied to the instantiated&lt;<em>arg<sub>1</sub></em>&gt; <code>...</code> &lt;<em>arg<sub><em>n</em></sub></em>&gt;is true.  For example, to find all people whose salary is greater than$30,000 we could write<a name="call_footnote_Temp_655" href="#footnote_Temp_655" id="call_footnote_Temp_655"><sup><small>64</small></sup></a></p>
<p></p>
<p></p>
<p><pre>(and (salary ?person ?amount)
     (lisp-value &gt; ?amount 30000))
</pre></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_4.56" id="%_thm_4.56"></a><b>Exercise 4.56.</b>  Formulate compound queries that retrieve the following information:</p>
<p></p>
<p></p>
<p>a. the names of all people who are supervised by Ben Bitdiddle, togetherwith their addresses;</p>
<p></p>
<p></p>
<p>b. all people whose salary is less than Ben Bitdiddle's, together withtheir salary and Ben Bitdiddle's salary;</p>
<p></p>
<p></p>
<p>c. all people who are supervised by someone who is not in the computerdivision, together with the supervisor's name and job.</p>
<p></p>
<p><a name="%_sec_Temp_657" id="%_sec_Temp_657"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_657">Rules</a></h4>
<p><a name="%_idx_5136" id="%_idx_5136"></a><a name="%_idx_5138" id="%_idx_5138"></a>In addition to primitive queries and compound queries, the querylanguage provides means for abstracting queries.  These are given by<em>rules</em>.  The rule</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_5140" id="%_idx_5140"></a>(rule (lives-near ?person-1 ?person-2)
      (and (address ?person-1 (?town . ?rest-1))
           (address ?person-2 (?town . ?rest-2))
           (not (same ?person-1 ?person-2))))
</pre></p>
<p></p>
<p>specifies that two people live near each other if they live in thesame town.  The final <code>not</code> clause prevents the rule from sayingthat all people live near themselves.  The <code>same</code> relation isdefined by a very simple rule:<a name="call_footnote_Temp_658" href="#footnote_Temp_658" id="call_footnote_Temp_658"><sup><small>65</small></sup></a></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_5142" id="%_idx_5142"></a>(rule (same ?x ?x))
</pre></p>
<p></p>
<p></p>
<p>The following rule declares that a person is a “wheel” in anorganization if he supervises someone who is in turn a supervisor:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_5144" id="%_idx_5144"></a>(rule (wheel ?person)
      (and (supervisor ?middle-manager ?person)
           (supervisor ?x ?middle-manager)))
</pre></p>
<p></p>
<p></p>
<p>The general form of a rule is</p>
<p></p>
<p><pre>(rule &lt;<em>conclusion</em>&gt; &lt;<em>body</em>&gt;)
</pre></p>
<p></p>
<p>where &lt;<em>conclusion</em>&gt; is a pattern and &lt;<em>body</em>&gt; is anyquery.<a name="call_footnote_Temp_659" href="#footnote_Temp_659" id="call_footnote_Temp_659"><sup><small>66</small></sup></a> We can thinkof a rule as representing a large (even infinite) set of assertions,namely all instantiations of the rule conclusion with variableassignments that satisfy the rule body.  When we described simplequeries (patterns), we said that an assignment to variables satisfiesa pattern if the instantiated pattern is in the data base.  But thepattern needn't be explicitly in the data base as an assertion.  It<a name="%_idx_5148" id="%_idx_5148"></a>can be an implicit assertion implied by a rule.  For example, thequery</p>
<p></p>
<p><pre>(lives-near ?x (Bitdiddle Ben))
</pre></p>
<p></p>
<p>results in</p>
<p></p>
<p><pre>(lives-near (Reasoner Louis) (Bitdiddle Ben))
(lives-near (Aull DeWitt) (Bitdiddle Ben))
</pre></p>
<p></p>
<p>To find all computer programmers who live near Ben Bitdiddle, we canask</p>
<p></p>
<p><pre>(and (job ?x (computer programmer))
     (lives-near ?x (Bitdiddle Ben)))
</pre></p>
<p></p>
<p></p>
<p><a name="%_idx_5150" id="%_idx_5150"></a>As in the case of compound procedures, rules can be used as parts ofother rules (as we saw with the <code>lives-near</code> rule above)or even be defined recursively.  For instance, the rule</p>
<p></p>
<p><pre><a name="%_idx_5152" id="%_idx_5152"></a>(rule (outranked-by ?staff-person ?boss)
      (or (supervisor ?staff-person ?boss)
          (and (supervisor ?staff-person ?middle-manager)
               (outranked-by ?middle-manager ?boss))))
</pre></p>
<p></p>
<p>says that a staff person is outranked by a boss in the organization ifthe boss is the person's supervisor or (recursively) if the person'ssupervisor is outranked by the boss.</p>
<p></p>
<p><a name="%_thm_4.57" id="%_thm_4.57"></a><b>Exercise 4.57.</b>  Define a rule that says that person 1 can replace person 2 if eitherperson 1 does the same job as person 2 or someone who does person 1'sjob can also do person 2's job, and if person 1 and person 2 are notthe same person. Using your rule, give queries that find thefollowing:</p>
<p>a.  all people who can replace Cy D. Fect;</p>
<p>b.  all people who can replace someone who is being paid more than theyare, together with the two salaries.</p>
<p></p>
<p></p>
<p><a name="%_thm_4.58" id="%_thm_4.58"></a><b>Exercise 4.58.</b>  Define a rule that says that a person is a “big shot” in a divisionif the person works in the division but does not have a supervisor whoworks in the division.</p>
<p></p>
<p></p>
<p><a name="%_thm_4.59" id="%_thm_4.59"></a><b>Exercise 4.59.</b>  Ben Bitdiddle has missed one meeting too many.Fearing that his habit of forgetting meetings could cost him hisjob, Ben decides to do something about it.  He adds all the weeklymeetings of the firm to the Microshaft data base byasserting the following:</p>
<p></p>
<p><pre>(meeting accounting (Monday 9am))
(meeting administration (Monday 10am))
(meeting computer (Wednesday 3pm))
(meeting administration (Friday 1pm))
</pre></p>
<p></p>
<p>Each of the above assertions is for a meeting of an entire division.Ben also adds an entry for the company-wide meeting that spans all thedivisions.  All of the company's employees attend this meeting.</p>
<p></p>
<p><pre>(meeting whole-company (Wednesday 4pm))
</pre></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p>a. On Friday morning, Ben wants to query the data base for all the meetingsthat occur that day.  What query should he use?</p>
<p></p>
<p></p>
<p>b. Alyssa P. Hacker is unimpressed.  She thinks it would be much moreuseful to be able to ask for her meetings by specifying her name.  Soshe designs a rule that says that a person's meetings include all <code>whole-company</code> meetings plus all meetings of that person's division.Fill in the body of Alyssa's rule.</p>
<p></p>
<p><pre>(rule (meeting-time ?person ?day-and-time)
      &lt;<em>rule-body</em>&gt;)
</pre></p>
<p></p>
<p></p>
<p>c. Alyssa arrives at work on Wednesday morning and wonders what meetings shehas to attend that day.  Having defined the above rule,what query should she make to find this out?</p>
<p></p>
<p></p>
<p><a name="%_thm_4.60" id="%_thm_4.60"></a><b>Exercise 4.60.</b>  <a name="%_idx_5154" id="%_idx_5154"></a>By giving the query</p>
<p></p>
<p><pre>(lives-near ?person (Hacker Alyssa P))
</pre></p>
<p></p>
<p>Alyssa P. Hacker is able to find people who live near her, with whomshe can ride to work.  On the other hand, when she tries to find allpairs of people who live near each other by querying</p>
<p></p>
<p></p>
<p><pre>(lives-near ?person-1 ?person-2)
</pre></p>
<p></p>
<p>she notices that each pair of people who live near each other islisted twice; for example,</p>
<p></p>
<p></p>
<p><pre>(lives-near (Hacker Alyssa P) (Fect Cy D))
(lives-near (Fect Cy D) (Hacker Alyssa P))
</pre></p>
<p></p>
<p>Why does this happen?Is there a way to find a list of people who live near each other, inwhich each pair appears only once?  Explain.</p>
<p></p>
<p><a name="%_sec_Temp_664" id="%_sec_Temp_664"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_664">Logic as programs</a></h4>
<p><a name="%_idx_5156" id="%_idx_5156"></a>We can regard a rule as a kind of logical implication: <em>If</em> anassignment of values to pattern variables satisfies the body, <em>then</em> it satisfies the conclusion.  Consequently, we can regard thequery language as having the ability to perform <em>logicaldeductions</em> based upon the rules.  As an example, consider the <code>append</code> operation described at the beginning ofsection <a href="#%_sec_4.4">4.4</a>.  As we said, <code>append</code> can becharacterized by the following two rules:</p>
<p></p>
<p></p>
<ul>
<li>For any list <code>y</code>, the empty list and <code>y</code> <code>append</code> to form <code>y</code>.<p></p>
</li>
<li>For any <code>u</code>,  <code>v</code>,  <code>y</code>, and <code>z</code>, <code>(cons u v)</code> and <code>y</code> <code>append</code> to form <code>(cons u z)</code>if <code>v</code> and <code>y</code> <code>append</code> to form <code>z</code>.</li>
</ul>
<p></p>
<p>To express this in our query language, we define two rules for arelation</p>
<p></p>
<p><pre>(append-to-form x y z)
</pre></p>
<p></p>
<p>which we can interpret to mean “<code>x</code> and <code>y</code> <code>append</code> toform <code>z</code>”:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_5158" id="%_idx_5158"></a>(rule (append-to-form () ?y ?y))
(rule (append-to-form (?u . ?v) ?y (?u . ?z))
      (append-to-form ?v ?y ?z))
</pre></p>
<p></p>
<p><a name="%_idx_5160" id="%_idx_5160"></a>The first rule has no body, which means that the conclusion holds forany value of <code>?y</code>.  Note how the second rule makes use of<a name="%_idx_5162" id="%_idx_5162"></a>dotted-tail notation to name the <code>car</code> and <code>cdr</code> of a list.</p>
<p>Given these two rules, we can formulate queries that compute the <code>append</code> of two lists:</p>
<p></p>
<p><pre><i>;;; Query input:</i>
(append-to-form (a b) (c d) ?z)
<i>;;; Query results:</i>
(append-to-form (a b) (c d) (a b c d))
</pre></p>
<p></p>
<p>What is more striking, we can use the same rules to ask the question“Which list, when <code>append</code>ed to <code>(a b)</code>, yields <code>(a b c d)</code>?”This is done as follows:</p>
<p></p>
<p><pre><i>;;; Query input:</i>
(append-to-form (a b) ?y (a b c d))
<i>;;; Query results:</i>
(append-to-form (a b) (c d) (a b c d))
</pre></p>
<p></p>
<p>We can also ask for all pairs of lists that <code>append</code> to form <code>(a b c d)</code>:</p>
<p></p>
<p><pre><i>;;; Query input:</i>
(append-to-form ?x ?y (a b c d))
<i>;;; Query results:</i>
(append-to-form () (a b c d) (a b c d))
(append-to-form (a) (b c d) (a b c d))
(append-to-form (a b) (c d) (a b c d))
(append-to-form (a b c) (d) (a b c d))
(append-to-form (a b c d) () (a b c d))
</pre></p>
<p></p>
<p></p>
<p>The query system may seem to exhibit quite a bit of intelligence inusing the rules to deduce the answers to the queries above.  Actually,as we will see in the next section, the system is following awell-determined algorithm in unraveling the rules.  Unfortunately,although the system works impressively in the <code>append</code> case, thegeneral methods may break down in more complex cases, as we will seein section <a href="#%_sec_4.4.3">4.4.3</a>.</p>
<p></p>
<p><a name="%_thm_4.61" id="%_thm_4.61"></a><b>Exercise 4.61.</b>  The following rules implement a <code>next-to</code> relation that findsadjacent elements of a list:</p>
<p></p>
<p><pre><a name="%_idx_5164" id="%_idx_5164"></a>(rule (?x next-to ?y in (?x ?y . ?u)))

(rule (?x next-to ?y in (?v . ?z))
      (?x next-to ?y in ?z))
</pre></p>
<p></p>
<p>What will the response be to the following queries?</p>
<p></p>
<p><pre>(?x next-to ?y in (1 (2 3) 4))

(?x next-to 1 in (2 1 3 1))
</pre></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_4.62" id="%_thm_4.62"></a><b>Exercise 4.62.</b>  <a name="%_idx_5166" id="%_idx_5166"></a>Define rules to implement the <code>last-pair</code> operation ofexercise <a href="book-Z-H-15.html#%_thm_2.17">2.17</a>, which returns a list containing the lastelement of a nonempty list.  Check your rules on queries such as<code>(last-pair (3) ?x)</code>, <code>(last-pair (1 2 3) ?x)</code>, and <code>(last-pair (2 ?x) (3))</code>.Do your rules work correctly on queries such as <code>(last-pair ?x (3))</code> ?</p>
<p></p>
<p></p>
<p><a name="%_thm_4.63" id="%_thm_4.63"></a><b>Exercise 4.63.</b>  <a name="%_idx_5168" id="%_idx_5168"></a><a name="%_idx_5170" id="%_idx_5170"></a>The following data base (see Genesis 4) traces the genealogy of thedescendants of Ada back to Adam, by way of Cain:</p>
<p></p>
<p></p>
<p><pre>(son Adam Cain)
(son Cain Enoch)
(son Enoch Irad)
(son Irad Mehujael)
(son Mehujael Methushael)
(son Methushael Lamech)
(wife Lamech Ada)
(son Ada Jabal)
(son Ada Jubal)
</pre></p>
<p></p>
<p>Formulate rules such as “If <em>S</em> is the son of <em>F</em>, and <em>F</em> is the son of <em>G</em>, then <em>S</em> is the grandson of <em>G</em>”and “If <em>W</em> is the wife of <em>M</em>, and <em>S</em> is the son of<em>W</em>, then <em>S</em> is the son of <em>M</em>” (which was supposedlymore true in biblical times than today) that will enable the querysystem to find the grandson of Cain; the sons of Lamech; the grandsonsof Methushael.(See exercise <a href="#%_thm_4.69">4.69</a> for some rules todeduce more complicated relationships.)</p>
<p><a name="%_sec_4.4.2" id="%_sec_4.4.2"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_4.4.2">4.4.2  How the Query System Works</a></h3>
<p><a name="%_idx_5172" id="%_idx_5172"></a>In section <a href="#%_sec_4.4.4">4.4.4</a> we will present animplementation of the query interpreter as a collection of procedures.In this section we give an overview that explains the generalstructure of the system independent of low-level implementationdetails.  After describing the implementation of the interpreter, wewill be in a position to understand some of its limitations and someof the subtle ways in which the query language's logical operationsdiffer from the operations of mathematical logic.</p>
<p>It should be apparent that the query evaluator must perform some kindof search in order to match queries against facts and rules in thedata base.  One way to do this would be to implement the query systemas a nondeterministic program, using the <code>amb</code> evaluator ofsection <a href="book-Z-H-28.html#%_sec_4.3">4.3</a> (seeexercise <a href="#%_thm_4.78">4.78</a>).  Another possibility is to managethe search with the aid of streams.  Our implementation follows thissecond approach.</p>
<p>The query system is organized around two central operations called<em>pattern matching</em> and <em>unification</em>.  We first describepattern matching and explain how this operation, together with theorganization of information in terms of streams of frames, enables usto implement both simple and compound queries.  We next discussunification, a generalization of pattern matching needed to implementrules.  Finally, we show how the entire query interpreter fitstogether through a procedure that classifies expressions in a manneranalogous to the way <code>eval</code> classifies expressions for theinterpreter described in section <a href="book-Z-H-26.html#%_sec_4.1">4.1</a>.</p>
<p><a name="%_sec_Temp_668" id="%_sec_Temp_668"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_668">Pattern matching</a></h4>
<p><a name="%_idx_5174" id="%_idx_5174"></a><a name="%_idx_5176" id="%_idx_5176"></a>A <em>pattern matcher</em> is a program that tests whether some datumfits a specified pattern.  For example, the data list <code>((a b) c (ab))</code> matches the pattern <code>(?x c ?x)</code> with the pattern variable<code>?x</code> bound to <code>(a b)</code>.  The same data list matches the pattern<code>(?x ?y ?z)</code> with <code>?x</code> and <code>?z</code> both bound to <code>(a b)</code>and <code>?y</code> bound to <code>c</code>.  It also matches the pattern <code>((?x ?y) c (?x ?y))</code> with <code>?x</code> bound to <code>a</code> and <code>?y</code> boundto <code>b</code>.  However, it does not match the pattern <code>(?x a ?y)</code>,since that pattern specifies a list whose second element is the symbol<code>a</code>.</p>
<p><a name="%_idx_5178" id="%_idx_5178"></a><a name="%_idx_5180" id="%_idx_5180"></a>The pattern matcher used by the query system takes as inputs apattern, a datum, and a <em>frame</em> that specifies bindings forvarious pattern variables.  It checks whether the datum matches thepattern in a way that is consistent with the bindings already in theframe.  If so, it returns the given frame augmented by any bindingsthat may have been determined by the match.  Otherwise, it indicatesthat the match has failed.</p>
<p>For example, using the pattern <code>(?x ?y ?x)</code> to match <code>(a b a)</code>given an empty frame will return a frame specifying that <code>?x</code> isbound to <code>a</code> and <code>?y</code> is bound to <code>b</code>.  Trying the matchwith the same pattern, the same datum, and a frame specifying that<code>?y</code> is bound to <code>a</code> will fail.  Trying the match with thesame pattern, the same datum, and a frame in which <code>?y</code> is boundto <code>b</code> and <code>?x</code> is unbound will return the given frameaugmented by a binding of <code>?x</code> to <code>a</code>.</p>
<p><a name="%_idx_5182" id="%_idx_5182"></a>The pattern matcher is all the mechanism that is needed to processsimple queries that don't involve rules.  For instance, to process thequery</p>
<p></p>
<p></p>
<p><pre>(job ?x (computer programmer))
</pre></p>
<p></p>
<p>we scan through all assertions in the data base and select those thatmatch the pattern with respect to an initially empty frame.  For eachmatch we find, we use the frame returned by the match to instantiatethe pattern with a value for <code>?x</code>.<a name="%_sec_Temp_669" id="%_sec_Temp_669"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_669">Streams of frames</a></h4>
<p><a name="%_idx_5184" id="%_idx_5184"></a><a name="%_idx_5186" id="%_idx_5186"></a>The testing of patterns against frames is organized through the use ofstreams.  Given a single frame, the matching process runs through thedata-base entries one by one.  For each data-base entry, the matchergenerates either a special symbol indicating that the match has failedor an extension to the frame.  The results for all the data-baseentries are collected into a stream, which is passed through a filterto weed out the failures.  The result is a stream of all the framesthat extend the given frame via a match to some assertion in the database.<a name="call_footnote_Temp_670" href="#footnote_Temp_670" id="call_footnote_Temp_670"><sup><small>67</small></sup></a></p>
<p>In our system, a query takes an input stream of frames and performsthe above matching operation for every frame in the stream, asindicated in figure <a href="#%_fig_4.4">4.4</a>.  That is, for each frame inthe input stream, the query generates a new stream consisting of allextensions to that frame by matches to assertions in the data base.All these streams are then combined to form one huge stream, whichcontains all possible extensions of every frame in the input stream.This stream is the output of the query.</p>
<p><a name="%_fig_4.4" id="%_fig_4.4"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch4-Z-G-4.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 4.4:</b>  A query processes a stream of frames.</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p><a name="%_idx_5194" id="%_idx_5194"></a>To answer a simple query, we use the query with an input streamconsisting of a single empty frame.  The resulting output streamcontains all extensions to the empty frame (that is, all answers toour query).  This stream of frames is then used to generate a streamof copies of the original query pattern with the variablesinstantiated by the values in each frame, and this is the stream thatis finally printed.</p>
<p><a name="%_sec_Temp_671" id="%_sec_Temp_671"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_671">Compound queries</a></h4>
<p><a name="%_idx_5196" id="%_idx_5196"></a>The real elegance of the stream-of-frames implementation is evidentwhen we deal with compound queries.  The processing of compoundqueries makes use of the ability of our matcher to demand that a match<a name="%_idx_5198" id="%_idx_5198"></a>be consistent with a specified frame.  For example, to handle the <code>and</code> of two queries, such as</p>
<p></p>
<p></p>
<p><pre>(and (can-do-job ?x (computer programmer trainee))
     (job ?person ?x))
</pre></p>
<p></p>
<p>(informally, “Find all people who can do the job of a computerprogrammer trainee”), we first find all entries that match thepattern</p>
<p></p>
<p></p>
<p><pre>(can-do-job ?x (computer programmer trainee))
</pre></p>
<p></p>
<p>This produces a stream of frames, each of which contains a binding for<code>?x</code>.  Then for each frame in the stream we find all entries thatmatch</p>
<p></p>
<p></p>
<p><pre>(job ?person ?x)
</pre></p>
<p></p>
<p>in a way that is consistent with the given binding for <code>?x</code>.  Eachsuch match will produce a frame containing bindings for <code>?x</code> and<code>?person</code>.  The <code>and</code> of two queries can be viewed as a seriescombination of the two component queries, as shown infigure <a href="#%_fig_4.5">4.5</a>.  The frames that pass through the firstquery filter are filtered and further extended by the second query.</p>
<p><a name="%_fig_4.5" id="%_fig_4.5"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch4-Z-G-5.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 4.5:</b>  The <code>and</code> combination of two queries isproduced by operating on the stream of frames in series.</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p><a name="%_idx_5200" id="%_idx_5200"></a>Figure <a href="#%_fig_4.6">4.6</a> shows the analogous method for computing the<code>or</code> of two queries as a parallel combination of the two componentqueries.  The input stream of frames is extended separately by eachquery.  The two resulting streams are then merged to produce the finaloutput stream.</p>
<p><a name="%_fig_4.6" id="%_fig_4.6"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch4-Z-G-6.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 4.6:</b>  The <code>or</code> combination of two queries is produced byoperating on the stream of frames in parallel and merging theresults.</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p><a name="%_idx_5202" id="%_idx_5202"></a>Even from this high-level description, it is apparent that theprocessing of compound queries can be slow.For example, since a query may produce more than one output frame foreach input frame, and each query in an <code>and</code> gets its input framesfrom the previous query, an <code>and</code> query could, in the worst case,have to perform a number of matches that is exponential in the numberof queries (see exercise <a href="#%_thm_4.76">4.76</a>).<a name="call_footnote_Temp_672" href="#footnote_Temp_672" id="call_footnote_Temp_672"><sup><small>68</small></sup></a>Though systems for handling only simple queries are quite practical,dealing with complex queries is extremely difficult.<a name="call_footnote_Temp_673" href="#footnote_Temp_673" id="call_footnote_Temp_673"><sup><small>69</small></sup></a></p>
<p><a name="%_idx_5204" id="%_idx_5204"></a>From the stream-of-frames viewpoint, the <code>not</code> of some query actsas a filter that removes all frames for which the query can besatisfied.  For instance, given the pattern</p>
<p></p>
<p></p>
<p><pre>(not (job ?x (computer programmer)))
</pre></p>
<p></p>
<p>we attempt, for each frame in the input stream, to produce extensionframes that satisfy <code>(job ?x (computer programmer))</code>.  We removefrom the input stream all frames for which such extensions exist.  Theresult is a stream consisting of only those frames in which thebinding for <code>?x</code> does not satisfy <code>(job ?x (computerprogrammer))</code>.  For example, in processing the query</p>
<p></p>
<p></p>
<p><pre>(and (supervisor ?x ?y)
     (not (job ?x (computer programmer))))
</pre></p>
<p></p>
<p>the first clause will generate frames with bindings for <code>?x</code> and<code>?y</code>.  The <code>not</code> clause will then filterthese by removing all frames in which the binding for <code>?x</code>satisfies the restriction that <code>?x</code> is a computerprogrammer.<a name="call_footnote_Temp_674" href="#footnote_Temp_674" id="call_footnote_Temp_674"><sup><small>70</small></sup></a></p>
<p><a name="%_idx_5206" id="%_idx_5206"></a>The <code>lisp-value</code> special form is implemented as a similar filteron frame streams.  We use each frame in the stream to instantiate anyvariables in the pattern, then apply the Lisp predicate.  We removefrom the input stream all frames for which the predicate fails.<a name="%_sec_Temp_675" id="%_sec_Temp_675"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_675">Unification</a></h4>
<p><a name="%_idx_5208" id="%_idx_5208"></a><a name="%_idx_5210" id="%_idx_5210"></a>In order to handle rules in the query language, we must be able tofind the rules whose conclusions match a given query pattern.  Ruleconclusions are like assertions except that they can containvariables, so we will need a generalization of patternmatching – called <em>unification</em> – in which both the “pattern”and the “datum” may contain variables.</p>
<p>A unifier takes two patterns, each containing constants and variables,and determines whether it is possible to assign values to thevariables that will make the two patterns equal.  If so, it returns aframe containing these bindings.  For example, unifying <code>(?x a?y)</code> and <code>(?y ?z a)</code> will specify a frame in which <code>?x</code>,<code>?y</code>, and <code>?z</code> must all be bound to <code>a</code>.  On the otherhand, unifying <code>(?x ?y a)</code> and <code>(?x b ?y)</code> will fail, becausethere is no value for <code>?y</code> that can make the two patterns equal.(For the second elements of the patterns to be equal, <code>?y</code> wouldhave to be <code>b</code>; however, for the third elements to be equal, <code>?y</code> would have to be <code>a</code>.)  The unifier used in the query system,like the pattern matcher, takes a frame as input and performsunifications that are consistent with this frame.</p>
<p>The unification algorithm is the most technically difficult part ofthe query system.  With complex patterns, performing unification mayseem to require deduction.  To unify <code>(?x ?x)</code> and <code>((a ?y c)(a b ?z))</code>, for example, the algorithm must infer that <code>?x</code> shouldbe <code>(a b c)</code>,   <code>?y</code> should be <code>b</code>, and <code>?z</code> shouldbe <code>c</code>.  We may think of this process as solving a set ofequations among the pattern components.  In general, these aresimultaneous equations, which may require substantial manipulation tosolve.<a name="call_footnote_Temp_676" href="#footnote_Temp_676" id="call_footnote_Temp_676"><sup><small>71</small></sup></a>  For example, unifying <code>(?x?x)</code> and <code>((a ?y c) (a b ?z))</code> may be thought of as specifying thesimultaneous equations</p>
<p></p>
<p></p>
<p><pre>?x  =  (a ?y c)
?x  =  (a b ?z)
</pre></p>
<p></p>
<p>These equations imply that</p>
<p></p>
<p></p>
<p><pre>(a ?y c)  =  (a b ?z)
</pre></p>
<p></p>
<p>which in turn implies that</p>
<p></p>
<p></p>
<p><pre>a  =  a, ?y  =  b, c  =  ?z,
</pre></p>
<p></p>
<p>and hence that</p>
<p></p>
<p></p>
<p><pre>?x  =  (a b c)
</pre></p>
<p></p>
<p></p>
<p><a name="%_idx_5212" id="%_idx_5212"></a><a name="%_idx_5214" id="%_idx_5214"></a>In a successful pattern match, all pattern variables become bound, andthe values to which they are bound contain only constants.  This isalso true of all the examples of unification we have seen so far.  Ingeneral, however, a successful unification may not completelydetermine the variable values; some variables may remain unbound andothers may be bound to values that contain variables.</p>
<p>Consider the unification of <code>(?x a)</code> and <code>((b ?y) ?z)</code>.  Wecan deduce that <code>?x  =  (b ?y)</code> and <code>a  =  ?z</code>, but we cannotfurther solve for <code>?x</code> or <code>?y</code>.  The unification doesn't fail,since it is certainly possible to make the two patterns equal byassigning values to <code>?x</code> and <code>?y</code>.  Since this match in no wayrestricts the values <code>?y</code> can take on, no binding for <code>?y</code> isput into the result frame.  The match does, however, restrict thevalue of <code>?x</code>.  Whatever value <code>?y</code> has, <code>?x</code> must be <code>(b ?y)</code>.  A binding of <code>?x</code> to the pattern <code>(b ?y)</code> is thusput into the frame.  If a value for <code>?y</code> is later determined andadded to the frame (by a pattern match or unification that is requiredto be consistent with this frame), the previously bound <code>?x</code> willrefer to this value.<a name="call_footnote_Temp_677" href="#footnote_Temp_677" id="call_footnote_Temp_677"><sup><small>72</small></sup></a><a name="%_sec_Temp_678" id="%_sec_Temp_678"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_678">Applying rules</a></h4>
<p><a name="%_idx_5216" id="%_idx_5216"></a>Unification is the key to the component of the query system that makesinferences from rules. To see how this is accomplished, considerprocessing a query that involves applying a rule, such as</p>
<p></p>
<p></p>
<p><pre>(lives-near ?x (Hacker Alyssa P))
</pre></p>
<p></p>
<p>To process this query, we first use the ordinary pattern-matchprocedure described above to see if there are any assertions in thedata base that match this pattern.  (There will not be any in thiscase, since our data base includes no direct assertions about wholives near whom.)  The next step is to attempt to unify the querypattern with the conclusion of each rule.  We find that the patternunifies with the conclusion of the rule</p>
<p></p>
<p></p>
<p><pre>(rule (lives-near ?person-1 ?person-2)
      (and (address ?person-1 (?town . ?rest-1))
           (address ?person-2 (?town . ?rest-2))
           (not (same ?person-1 ?person-2))))
</pre></p>
<p></p>
<p>resulting in a frame specifying that <code>?person-2</code> is boundto <code>(Hacker Alyssa P)</code> and that <code>?x</code> should be bound to (havethe same value as) <code>?person-1</code>.  Now, relative to this frame, weevaluate the compound query given by the body of the rule.  Successfulmatches will extend this frame by providing a binding for <code>?person-1</code>, and consequently a value for <code>?x</code>, which we can use toinstantiate the original query pattern.</p>
<p>In general, the query evaluator uses the following method to apply arule when trying to establish a query pattern in a frame thatspecifies bindings for some of the pattern variables:</p>
<p></p>
<p></p>
<ul>
<li>Unify the query with the conclusion of the rule to form, ifsuccessful, an extension of the original frame.<p></p>
</li>
<li>Relative to the extended frame, evaluate the query formed bythe body of the rule.</li>
</ul>
<p></p>
<p><a name="%_idx_5218" id="%_idx_5218"></a>Notice how similar this is to the method for applying a procedure inthe <code>eval</code>/<code>apply</code> evaluator for Lisp:</p>
<p></p>
<ul>
<p></p>
<li>Bind the procedure's parameters to its arguments to form aframe that extends the original procedure environment.<p></p>
</li>
<li>Relative to the extended environment, evaluate the expressionformed by the body of the procedure.</li>
</ul>
<p></p>
<p>The similarity between the two evaluators should come as no surprise.Just as procedure definitions are the means of abstraction in Lisp,rule definitions are the means of abstraction in the query language.In each case, we unwind the abstraction by creating appropriatebindings and evaluating the rule or procedure body relative to these.</p>
<p><a name="%_sec_Temp_679" id="%_sec_Temp_679"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_679">Simple queries</a></h4>
<p><a name="%_idx_5220" id="%_idx_5220"></a>We saw earlier in this section how to evaluate simple queries in theabsence of rules.  Now that we have seen how to apply rules, we candescribe how to evaluate simple queries by using both rules andassertions.</p>
<p>Given the query pattern and a stream of frames, we produce, for eachframe in the input stream, two streams:</p>
<p></p>
<p></p>
<ul>
<li>a stream of extended frames obtained by matching the patternagainst all assertions in the data base (using the pattern matcher),and<p></p>
</li>
<li>a stream of extended frames obtained by applying allpossible rules (using the unifier).<a name="call_footnote_Temp_680" href="#footnote_Temp_680" id="call_footnote_Temp_680"><sup><small>73</small></sup></a></li>
</ul>
<p></p>
<p>Appending these two streams produces a stream that consists of all theways that the given pattern can be satisfied consistent with theoriginal frame.  These streams (one for each frame in the inputstream) are now all combined to form one large stream, which thereforeconsists of all the ways that any of the frames in the original inputstream can be extended to produce a match with the given pattern.<a name="%_sec_Temp_681" id="%_sec_Temp_681"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_681">The query evaluator and the driver loop</a></h4>
<p><a name="%_idx_5226" id="%_idx_5226"></a>Despite the complexity of the underlying matching operations, thesystem is organized much like an evaluator for any language.  Theprocedure that coordinates the matching operations is called <a name="%_idx_5228" id="%_idx_5228"></a><a name="%_idx_5230" id="%_idx_5230"></a><code>qeval</code>, and it plays a role analogous to that of the <code>eval</code>procedure for Lisp.  <code>Qeval</code> takes as inputs a query and a streamof frames.  Its output is a stream of frames, corresponding tosuccessful matches to the query pattern, that extend some frame in theinput stream, as indicated in figure <a href="#%_fig_4.4">4.4</a>.  Like<code>eval</code>, <code>qeval</code> classifies the different types of expressions(queries) and dispatches to an appropriate procedure for each.  Thereis a procedure for each special form (<code>and</code>, <code>or</code>, <code>not</code>,and <code>lisp-value</code>) and one for simple queries.</p>
<p><a name="%_idx_5232" id="%_idx_5232"></a><a name="%_idx_5234" id="%_idx_5234"></a>The driver loop, which is analogous to the <code>driver-loop</code> procedurefor the other evaluators in this chapter, reads queries from theterminal.  For each query, it calls <code>qeval</code> with the query and astream that consists of a single empty frame.  This will produce thestream of all possible matches (all possible extensions to the emptyframe).  For each frame in the resulting stream, it instantiates theoriginal query using the values of the variables found in the frame.This stream of instantiated queries is then printed.<a name="call_footnote_Temp_682" href="#footnote_Temp_682" id="call_footnote_Temp_682"><sup><small>74</small></sup></a></p>
<p><a name="%_idx_5240" id="%_idx_5240"></a><a name="%_idx_5242" id="%_idx_5242"></a>The driver also checks for the special command <code>assert!</code>, whichsignals that the input is not a query but rather an assertion or ruleto be added to the data base.  For instance,</p>
<p></p>
<p></p>
<p><pre>(assert! (job (Bitdiddle Ben) (computer wizard)))
(assert! (rule (wheel ?person)
               (and (supervisor ?middle-manager ?person)
                    (supervisor ?x ?middle-manager))))
</pre></p>
<p></p>
<p><a name="%_sec_4.4.3" id="%_sec_4.4.3"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_4.4.3">4.4.3  Is Logic Programming Mathematical Logic?</a></h3>
<p><a name="%_idx_5244" id="%_idx_5244"></a><a name="%_idx_5246" id="%_idx_5246"></a>The means of combination used in the query language may at first seemidentical to the operations <code>and</code>, <code>or</code>, and <code>not</code> ofmathematical logic, and the application of query-language rules is infact accomplished through a legitimate method of<a name="%_idx_5248" id="%_idx_5248"></a>inference.<a name="call_footnote_Temp_683" href="#footnote_Temp_683" id="call_footnote_Temp_683"><sup><small>75</small></sup></a> This identification of the query language with mathematicallogic is not really valid, though, because the query language providesa <a name="%_idx_5252" id="%_idx_5252"></a><em>control structure</em> that interprets the logical statementsprocedurally.  We can often take advantage of this control structure.For example, to find all of the supervisors of programmers we couldformulate a query in either of two logically equivalent forms:</p>
<p></p>
<p></p>
<p><pre>(and (job ?x (computer programmer))
     (supervisor ?x ?y))
</pre></p>
<p></p>
<p>or</p>
<p></p>
<p><pre>(and (supervisor ?x ?y)
     (job ?x (computer programmer)))
</pre></p>
<p></p>
<p><a name="%_idx_5254" id="%_idx_5254"></a>If a company has many more supervisors than programmers (the usualcase), it is better to use the first form rather than the secondbecause the data base must be scanned for each intermediate result(frame) produced by the first clause of the <code>and</code>.</p>
<p><a name="%_idx_5256" id="%_idx_5256"></a><a name="%_idx_5258" id="%_idx_5258"></a>The aim of logic programming is to provide the programmer withtechniques for decomposing a computational problem into two separateproblems: “what” is to be computed, and “how” this should becomputed.  This is accomplished by selecting a subset of thestatements of mathematical logic that is powerful enough to be able todescribe anything one might want to compute, yet weak enough to have acontrollable procedural interpretation.  The intention here is that,on the one hand, a program specified in a logic programming languageshould be an effective program that can be carried out by a computer.Control (“how” to compute) is effected by using the order ofevaluation of the language.  We should be able to arrange the order ofclauses and the order of subgoals within each clause so that thecomputation is done in an order deemed to be effective and efficient.At the same time, we should be able to view the result of thecomputation (“what” to compute) as a simple consequence of the lawsof logic.</p>
<p>Our query language can be regarded as just such a procedurallyinterpretable subset of mathematical logic.  An assertion represents asimple fact (an atomic proposition).  A rule represents theimplication that the rule conclusion holds for those cases where therule body holds.  A rule has a natural procedural interpretation: Toestablish the conclusion of the rule, establish the body of the rule.Rules, therefore, specify computations.  However, because rules canalso be regarded as statements of mathematical logic, we can justifyany “inference” accomplished by a logic program by asserting thatthe same result could be obtained by working entirely withinmathematical logic.<a name="call_footnote_Temp_684" href="#footnote_Temp_684" id="call_footnote_Temp_684"><sup><small>76</small></sup></a></p>
<p><a name="%_sec_Temp_685" id="%_sec_Temp_685"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_685">Infinite loops</a></h4>
<p><a name="%_idx_5260" id="%_idx_5260"></a>A consequence of the procedural interpretation of logic programs isthat it is possible to construct hopelessly inefficient programs forsolving certain problems.  An extreme case of inefficiency occurs whenthe system falls into infinite loops in making deductions.  As asimple example, suppose we are setting up a data base of famousmarriages, including</p>
<p><a name="%_idx_5262" id="%_idx_5262"></a></p>
<p></p>
<p><pre>(assert! (married Minnie Mickey))
</pre></p>
<p></p>
<p>If we now ask</p>
<p></p>
<p></p>
<p><pre>(married Mickey ?who)
</pre></p>
<p></p>
<p>we will get no response, because the system doesn't know that if <em>A</em>is married to <em>B</em>, then <em>B</em> is married to <em>A</em>.  So we assert the rule</p>
<p></p>
<p></p>
<p><pre>(assert! (rule (married ?x ?y)
               (married ?y ?x)))
</pre></p>
<p></p>
<p>and again query</p>
<p></p>
<p></p>
<p><pre>(married Mickey ?who)
</pre></p>
<p></p>
<p>Unfortunately, this will drive the system into an infinite loop, asfollows:</p>
<p></p>
<p></p>
<ul>
<li>The system finds that the <code>married</code> rule is applicable;that is, the rule conclusion <code>(married ?x ?y)</code> successfullyunifies with the query pattern <code>(married Mickey ?who)</code> to producea frame in which <code>?x</code> is bound to <code>Mickey</code> and <code>?y</code> isbound to <code>?who</code>.  So the interpreter proceeds to evaluate the rulebody <code>(married ?y ?x)</code> in this frame – in effect, to process thequery <code>(married ?who Mickey)</code>.<p></p>
</li>
<li>One answer appears directly as an assertion in the database: <code>(married Minnie Mickey)</code>.<p></p>
</li>
<li>The <code>married</code> rule is also applicable, so theinterpreter again evaluates the rule body, which this time isequivalent to <code>(married Mickey ?who)</code>.</li>
</ul>
<p></p>
<p>The system is now in an infinite loop.  Indeed, whether the systemwill find the simple answer <code>(married Minnie Mickey)</code> before itgoes into the loop depends on implementation details concerning theorder in which the system checks the items in the data base.  This isa very simple example of the kinds of loops that can occur.Collections of interrelated rules can lead to loops that are muchharder to anticipate, and the appearance of a loop can depend on the orderof clauses in an <code>and</code> (see exercise <a href="#%_thm_4.64">4.64</a>)or on low-level details concerning the order in which the systemprocesses queries.<a name="call_footnote_Temp_686" href="#footnote_Temp_686" id="call_footnote_Temp_686"><sup><small>77</small></sup></a><a name="%_sec_Temp_687" id="%_sec_Temp_687"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_687">Problems with <code>not</code></a></h4>
<p><a name="%_idx_5266" id="%_idx_5266"></a><a name="%_idx_5268" id="%_idx_5268"></a>Another quirk in the query system concerns <code>not</code>.  Given the database of section <a href="#%_sec_4.4.1">4.4.1</a>, consider thefollowing two queries:</p>
<p></p>
<p></p>
<p><pre>(and (supervisor ?x ?y)
     (not (job ?x (computer programmer))))
(and (not (job ?x (computer programmer)))
     (supervisor ?x ?y))
</pre></p>
<p></p>
<p>These two queries do not produce the same result.  The first querybegins by finding all entries in the data base that match <code>(supervisor ?x ?y)</code>, and then filters the resulting frames by removingthe ones in which the value of <code>?x</code> satisfies <code>(job ?x(computer programmer))</code>.  The second query begins by filtering theincoming frames to remove those that can satisfy <code>(job ?x(computer programmer))</code>.  Since the only incoming frame is empty, itchecks the data base to see if there are any patterns that satisfy<code>(job ?x (computer programmer))</code>.  Since there generally areentries of this form, the <code>not</code> clause filters out the empty frameand returns an empty stream of frames.  Consequently, the entirecompound query returns an empty stream.</p>
<p>The trouble is that our implementation of <code>not</code> really is meant toserve as a filter on values for the variables.  If a <code>not</code> clauseis processed with a frame in which some of the variables remainunbound (as does <code>?x</code> in the example above), the system willproduce unexpected results. Similar problems occur with the use of<a name="%_idx_5270" id="%_idx_5270"></a><code>lisp-value</code> – the Lisp predicate can't work if some of itsarguments are unbound.  See exercise <a href="#%_thm_4.77">4.77</a>.</p>
<p>There is also a much more serious way in which the <code>not</code> of thequery language differs from the <code>not</code> of mathematical logic.  Inlogic, we interpret the statement “not <em>P</em>” to mean that <em>P</em> is nottrue.  In the query system, however, “not <em>P</em>” means that <em>P</em> is notdeducible from the knowledge in the data base.  For example, given thepersonnel data base of section <a href="#%_sec_4.4.1">4.4.1</a>, thesystem would happily deduce all sorts of <code>not</code> statements, such asthat Ben Bitdiddle is not a baseball fan, that it is not rainingoutside, and that 2 + 2 is not 4.<a name="call_footnote_Temp_688" href="#footnote_Temp_688" id="call_footnote_Temp_688"><sup><small>78</small></sup></a> In other words, the <code>not</code>of logic programming languages reflects the so-called <a name="%_idx_5272" id="%_idx_5272"></a><em>closedworld assumption</em> that all relevant information has been included inthe data base.<a name="call_footnote_Temp_689" href="#footnote_Temp_689" id="call_footnote_Temp_689"><sup><small>79</small></sup></a></p>
<p><a name="%_thm_4.64" id="%_thm_4.64"></a><b>Exercise 4.64.</b>  <a name="%_idx_5276" id="%_idx_5276"></a>Louis Reasoner mistakenly deletes the <code>outranked-by</code> rule(section <a href="#%_sec_4.4.1">4.4.1</a>) from the data base.  Whenhe realizes this, he quickly reinstalls it.  Unfortunately, he makes aslight change in the rule, and types it in as</p>
<p></p>
<p></p>
<p><pre>(rule (outranked-by ?staff-person ?boss)
      (or (supervisor ?staff-person ?boss)
          (and (outranked-by ?middle-manager ?boss)
               (supervisor ?staff-person ?middle-manager))))
</pre></p>
<p></p>
<p>Just after Louis types this information into the system, DeWittAull comes by to find out who outranks Ben Bitdiddle. He issuesthe query</p>
<p></p>
<p></p>
<p><pre>(outranked-by (Bitdiddle Ben) ?who)
</pre></p>
<p></p>
<p>After answering, the system goes into an infinite loop.  Explain why.</p>
<p></p>
<p></p>
<p><a name="%_thm_4.65" id="%_thm_4.65"></a><b>Exercise 4.65.</b>  <a name="%_idx_5278" id="%_idx_5278"></a>Cy D. Fect, looking forward to the day when he will rise in theorganization, gives a query to find all the wheels(using the <code>wheel</code> rule of section <a href="#%_sec_4.4.1">4.4.1</a>):</p>
<p></p>
<p></p>
<p><pre>(wheel ?who)
</pre></p>
<p></p>
<p>To his surprise, the system responds</p>
<p></p>
<p></p>
<p><pre><i>;;; Query results:</i>
(wheel (Warbucks Oliver))
(wheel (Bitdiddle Ben))
(wheel (Warbucks Oliver))
(wheel (Warbucks Oliver))
(wheel (Warbucks Oliver))
</pre></p>
<p></p>
<p>Why is Oliver Warbucks listed four times?</p>
<p></p>
<p></p>
<p><a name="%_thm_4.66" id="%_thm_4.66"></a><b>Exercise 4.66.</b>  <a name="%_idx_5280" id="%_idx_5280"></a>Ben has been generalizing the query system to provide statisticsabout the company.  For example, to find the total salaries of all thecomputer programmers one will be able to say</p>
<p></p>
<p></p>
<p><pre>(sum ?amount
     (and (job ?x (computer programmer))
          (salary ?x ?amount)))
</pre></p>
<p></p>
<p>In general, Ben's new system allows expressions of the form</p>
<p></p>
<p></p>
<p><pre>(accumulation-function &lt;<em>variable</em>&gt;
                       &lt;<em>query pattern</em>&gt;)
</pre></p>
<p></p>
<p>where <code>accumulation-function</code> can be things like <code>sum</code>,<code>average</code>, or <code>maximum</code>.  Ben reasons that it should be acinch to implement this.  He will simply feed the query pattern to<code>qeval</code>.  This will produce a stream of frames.  He will then passthis stream through a mapping function that extracts the value of thedesignated variable from each frame in the stream and feed theresulting stream of values to the accumulation function.  Just as Bencompletes the implementation and is about to try it out, Cy walks by,still puzzling over the <code>wheel</code> query result inexercise <a href="#%_thm_4.65">4.65</a>.  When Cy shows Ben the system'sresponse, Ben groans, “Oh, no, my simple accumulation scheme won'twork!”</p>
<p>What has Ben just realized?  Outline a method he can use tosalvage the situation.</p>
<p></p>
<p></p>
<p><a name="%_thm_4.67" id="%_thm_4.67"></a><b>Exercise 4.67.</b>  <a name="%_idx_5282" id="%_idx_5282"></a><a name="%_idx_5284" id="%_idx_5284"></a>Devise a way to install a loop detector in the query system so as toavoid the kinds of simple loops illustrated in the text and inexercise <a href="#%_thm_4.64">4.64</a>.  The general idea is that thesystem should maintain some sort of history of its current chain ofdeductions and should not begin processing a query that it is alreadyworking on.  Describe what kind of information (patterns and frames)is included in this history, and how the check should be made.  (Afteryou study the details of the query-system implementation insection <a href="#%_sec_4.4.4">4.4.4</a>, you may want tomodify the system to include your loop detector.)</p>
<p></p>
<p></p>
<p><a name="%_thm_4.68" id="%_thm_4.68"></a><b>Exercise 4.68.</b>  <a name="%_idx_5286" id="%_idx_5286"></a>Define rules to implement the <code>reverse</code> operation ofexercise <a href="book-Z-H-15.html#%_thm_2.18">2.18</a>, which returns a list containing the sameelements as a given list in reverse order.  (Hint: Use <code>append-to-form</code>.)Can your rules answer both<code>(reverse (1 2 3) ?x)</code> and <code>(reverse ?x (1 2 3))</code> ?</p>
<p></p>
<p></p>
<p><a name="%_thm_4.69" id="%_thm_4.69"></a><b>Exercise 4.69.</b>  Beginning with the data base and the rules you formulated inexercise <a href="#%_thm_4.63">4.63</a>, devise a rule for adding “greats” toa grandson relationship. This should enable the system to deduce thatIrad is the great-grandson of Adam, or that Jabal and Jubal arethe great-great-great-great-great-grandsons of Adam.  (Hint: Representthe fact about Irad, for example, as <code>((great grandson) AdamIrad)</code>.  Write rules that determine if a list ends in the word<code>grandson</code>.  Use this to express a rule that allows one to derivethe relationship <code>((great .  ?rel) ?x ?y)</code>, where <code>?rel</code> is alist ending in <code>grandson</code>.)Check your rules on queries such as<code>((great grandson) ?g ?ggs)</code> and <code>(?relationship Adam Irad)</code>.</p>
<p><a name="%_sec_4.4.4" id="%_sec_4.4.4"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_4.4.4">4.4.4  Implementing the Query System</a></h3>
<p></p>
<p>Section <a href="#%_sec_4.4.2">4.4.2</a> described how the query systemworks. Now we fill in the details by presenting a completeimplementation of the system.</p>
<p><a name="%_sec_4.4.4.1" id="%_sec_4.4.4.1"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_4.4.4.1">4.4.4.1  The Driver Loop and Instantiation</a></h4>
<p></p>
<p><a name="%_idx_5288" id="%_idx_5288"></a><a name="%_idx_5290" id="%_idx_5290"></a>The driver loop for the query system repeatedly reads inputexpressions.  If the expression is a rule or assertion to be added tothe data base, then the information is added.  Otherwise theexpression is assumed to be a query.  The driver passes this query tothe evaluator <code>qeval</code> together with an initial frame streamconsisting of a single empty frame.  The result of the evaluation is astream of frames generated by satisfying the query with variablevalues found in the data base.  These frames are used to form a newstream consisting of copies of the original query in which thevariables are instantiated with values supplied by the stream offrames, and this final stream is printed at the terminal:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_5292" id="%_idx_5292"></a>(define input-prompt ";;; Query input:")
(define output-prompt ";;; Query results:")
<a name="%_idx_5294" id="%_idx_5294"></a>(define (query-driver-loop)
  (prompt-for-input input-prompt)
  (let ((q (query-syntax-process (read))))
    (cond ((assertion-to-be-added? q)
           (add-rule-or-assertion! (add-assertion-body q))
           (newline)
           (display "Assertion added to data base.")
           (query-driver-loop))
          (else
           (newline)
           (display output-prompt)
           (display-stream
            (stream-map
             (lambda (frame)
               (instantiate q
                            frame
                            (lambda (v f)
                              (contract-question-mark v))))
             (qeval q (singleton-stream '()))))
           (query-driver-loop)))))
</pre></p>
<p></p>
<p><a name="%_idx_5296" id="%_idx_5296"></a>Here, as in the other evaluators in this chapter, we use an abstractsyntax for the expressions of the query language.The implementation of the expression syntax, including the predicate<code>assertion-to-be-added?</code> and the selector <code>add-assertion-body</code>,is given in section <a href="#%_sec_4.4.4.7">4.4.4.7</a>.<code>Add-rule-or-assertion!</code> is defined in section <a href="#%_sec_4.4.4.5">4.4.4.5</a>.</p>
<p>Before doing any processing on an input expression, the driver looptransforms it syntactically into a form that makes the processing moreefficient.  This involves changing the <a name="%_idx_5298" id="%_idx_5298"></a><a name="%_idx_5300" id="%_idx_5300"></a>representation of patternvariables.  When the query is instantiated, any variables that remainunbound are transformed back to the input representation before beingprinted.  These transformations are performed by the two procedures<code>query-syntax-process</code> and <code>contract-question-mark</code>(section  <a href="#%_sec_4.4.4.7">4.4.4.7</a>).</p>
<p><a name="%_idx_5302" id="%_idx_5302"></a>To instantiate an expression, we copy it, replacing any variables inthe expression by their values in a given frame.  The values arethemselves instantiated, since they could contain variables (forexample, if <code>?x</code> in <code>exp</code> is bound to <code>?y</code> as the resultof unification and <code>?y</code> is in turn bound to 5).  The action totake if a variable cannot be instantiated is given by a proceduralargument to <code>instantiate</code>.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_5304" id="%_idx_5304"></a>(define (instantiate exp frame unbound-var-handler)
  (define (copy exp)
    (cond ((var? exp)
           (let ((binding (binding-in-frame exp frame)))
             (if binding
                 (copy (binding-value binding))
                 (unbound-var-handler exp frame))))
          ((pair? exp)
           (cons (copy (car exp)) (copy (cdr exp))))
          (else exp)))
  (copy exp))
</pre></p>
<p></p>
<p>The procedures that manipulate bindings are defined insection <a href="#%_sec_4.4.4.8">4.4.4.8</a>.</p>
<p><a name="%_sec_4.4.4.2" id="%_sec_4.4.4.2"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_4.4.4.2">4.4.4.2  The Evaluator</a></h4>
<p></p>
<p><a name="%_idx_5306" id="%_idx_5306"></a>The <code>qeval</code> procedure, called by the <code>query-driver-loop</code>, isthe basic evaluator of the query system.  It takes as inputs a queryand a stream of frames, and it returns a stream of extended frames.It identifies special forms by a <a name="%_idx_5308" id="%_idx_5308"></a>data-directed dispatch using <code>get</code> and <code>put</code>, just as we did in implementing generic operationsin chapter 2.  Any query that is not identified as a special form isassumed to be a simple query, to be processed by <code>simple-query</code>.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_5310" id="%_idx_5310"></a>(define (qeval query frame-stream)
  (let ((qproc (get (type query) 'qeval)))
    (if qproc
        (qproc (contents query) frame-stream)
        (simple-query query frame-stream))))
</pre></p>
<p></p>
<p><code>Type</code> and <code>contents</code>, defined in section <a href="#%_sec_4.4.4.7">4.4.4.7</a>,implement the abstract syntax of the special forms.</p>
<p><a name="%_sec_Temp_696" id="%_sec_Temp_696"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_696">Simple queries</a></h4>
<p><a name="%_idx_5312" id="%_idx_5312"></a>The <code>simple-query</code> procedure handles simple queries.  It takes asarguments a simple query (a pattern) together with a stream of frames,and it returns the stream formed by extending each frame by alldata-base matches of the query.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_5314" id="%_idx_5314"></a>(define (simple-query query-pattern frame-stream)
  (stream-flatmap
   (lambda (frame)
     (stream-append-delayed
      (find-assertions query-pattern frame)
      (delay (apply-rules query-pattern frame))))
   frame-stream))
</pre></p>
<p></p>
<p></p>
<p>For each frame in the input stream, we use <code>find-assertions</code>(section <a href="#%_sec_4.4.4.3">4.4.4.3</a>) to match the pattern against allassertions in the data base, producing a stream of extended frames,and we use <code>apply-rules</code> (section <a href="#%_sec_4.4.4.4">4.4.4.4</a>) to applyall possible rules, producing another stream of extended frames.These two streams are combined (using <code>stream-append-delayed</code>,section <a href="#%_sec_4.4.4.6">4.4.4.6</a>) to make a stream of all the ways thatthe given pattern can be satisfied consistent with the original frame(see exercise <a href="#%_thm_4.71">4.71</a>).  The streams for theindividual input frames are combined using <code>stream-flatmap</code>(section <a href="#%_sec_4.4.4.6">4.4.4.6</a>) to form one large stream of all theways that any of the frames in the original input stream can beextended to produce a match with the given pattern.<a name="%_sec_Temp_697" id="%_sec_Temp_697"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_697">Compound queries</a></h4>
<p><a name="%_idx_5316" id="%_idx_5316"></a><a name="%_idx_5318" id="%_idx_5318"></a><code>And</code> queries are handled as illustrated infigure <a href="#%_fig_4.5">4.5</a> by the <code>conjoin</code> procedure.  <code>Conjoin</code> takes as inputs the conjuncts and the frame stream andreturns the stream of extended frames.  First, <code>conjoin</code> processesthe stream of frames to find the stream of all possible frame extensionsthat satisfy the first query in the conjunction.  Then, using this as the newframe stream, it recursively applies <code>conjoin</code> to the rest of thequeries.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_5320" id="%_idx_5320"></a>(define (conjoin conjuncts frame-stream)
  (if (empty-conjunction? conjuncts)
      frame-stream
      (conjoin (rest-conjuncts conjuncts)
               (qeval (first-conjunct conjuncts)
                      frame-stream))))
</pre></p>
<p></p>
<p>The expression</p>
<p></p>
<p><pre>(put 'and 'qeval conjoin)
</pre></p>
<p></p>
<p>sets up <code>qeval</code> to dispatch to <code>conjoin</code> when an <code>and</code>form is encountered.</p>
<p><a name="%_idx_5322" id="%_idx_5322"></a><code>Or</code> queries are handled similarly, as shown infigure <a href="#%_fig_4.6">4.6</a>.  The output streams for the variousdisjuncts of the <code>or</code> are computed separately and merged using the<code>interleave-delayed</code> procedure from section <a href="#%_sec_4.4.4.6">4.4.4.6</a>.(See exercises <a href="#%_thm_4.71">4.71</a> and <a href="#%_thm_4.72">4.72</a>.)</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_5324" id="%_idx_5324"></a>(define (disjoin disjuncts frame-stream)
  (if (empty-disjunction? disjuncts)
      the-empty-stream
      (interleave-delayed
       (qeval (first-disjunct disjuncts) frame-stream)
       (delay (disjoin (rest-disjuncts disjuncts)
                       frame-stream)))))
(put 'or 'qeval disjoin)
</pre></p>
<p></p>
<p>The predicates and selectors for the syntax of conjuncts and disjunctsare given in section <a href="#%_sec_4.4.4.7">4.4.4.7</a>.</p>
<p><a name="%_sec_Temp_698" id="%_sec_Temp_698"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_698">Filters</a></h4>
<p><a name="%_idx_5326" id="%_idx_5326"></a><code>Not</code> is handled by the method outlined insection <a href="#%_sec_4.4.2">4.4.2</a>.  We attempt to extend each frame inthe input stream to satisfy the query being negated, and we include agiven frame in the output stream only if it cannot be extended.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_5328" id="%_idx_5328"></a>(define (negate operands frame-stream)
  (stream-flatmap
   (lambda (frame)
     (if (stream-null? (qeval (negated-query operands)
                              (singleton-stream frame)))
         (singleton-stream frame)
         the-empty-stream))
   frame-stream))
(put 'not 'qeval negate)
</pre></p>
<p></p>
<p></p>
<p><a name="%_idx_5330" id="%_idx_5330"></a><code>Lisp-value</code> is a filter similar to <code>not</code>.  Each frame in thestream is used to instantiate the variables in the pattern, theindicated predicate is applied, and the frames for which the predicatereturns false are filtered out of the input stream.  An error resultsif there are unbound pattern variables.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_5332" id="%_idx_5332"></a>(define (lisp-value call frame-stream)
  (stream-flatmap
   (lambda (frame)
     (if (execute
          (instantiate
           call
           frame
           (lambda (v f)
             (error "Unknown pat var -- LISP-VALUE" v))))
         (singleton-stream frame)
         the-empty-stream))
   frame-stream))
(put 'lisp-value 'qeval lisp-value)
</pre></p>
<p></p>
<p></p>
<p><code>Execute</code>, which applies the predicate to the arguments, must <code>eval</code> the predicate expression to get the procedure to apply.However, it must not evaluate the arguments, since they are alreadythe actual arguments, not expressions whose evaluation (in Lisp) willproduce the arguments.  Note that <code>execute</code> is implemented using<a name="%_idx_5334" id="%_idx_5334"></a><code>eval</code> and <code>apply</code> from the underlying Lisp system.</p>
<p></p>
<p></p>
<p><pre>(define (execute exp)
  (apply (eval (predicate exp) user-initial-environment)
         (args exp)))
</pre></p>
<p></p>
<p></p>
<p>The <code>always-true</code> special form provides for a query that is alwayssatisfied.  It ignores its contents (normally empty) and simply passesthrough all the frames in the input stream.  <code>Always-true</code> is usedby the <code>rule-body</code> selector (section <a href="#%_sec_4.4.4.7">4.4.4.7</a>)<a name="%_idx_5336" id="%_idx_5336"></a>to provide bodies for rules that weredefined without bodies (that is, rules whose conclusions are alwayssatisfied).</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_5338" id="%_idx_5338"></a>(define (always-true ignore frame-stream) frame-stream)
(put 'always-true 'qeval always-true)
</pre></p>
<p></p>
<p>The selectors that define the syntax of <code>not</code> and <code>lisp-value</code>are given in section <a href="#%_sec_4.4.4.7">4.4.4.7</a>.</p>
<p><a name="%_sec_4.4.4.3" id="%_sec_4.4.4.3"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_4.4.4.3">4.4.4.3  Finding Assertions by Pattern Matching</a></h4>
<p></p>
<p><a name="%_idx_5340" id="%_idx_5340"></a><a name="%_idx_5342" id="%_idx_5342"></a><code>Find-assertions</code>, called by <code>simple-query</code>(section <a href="#%_sec_4.4.4.2">4.4.4.2</a>), takes as input a pattern and a frame.It returns a stream of frames, each extending the given one by adata-base match of the given pattern.  It uses <code>fetch-assertions</code>(section <a href="#%_sec_4.4.4.5">4.4.4.5</a>) to get a stream of all the assertions inthe data base that should be checked for a match against the patternand the frame.  The reason for <code>fetch-assertions</code> here is that wecan often apply simple tests that will eliminate many of the entriesin the data base from the pool of candidates for a successful match.The system would still work if we eliminated <code>fetch-assertions</code>and simply checked a stream of all assertions in the data base, butthe computation would be less efficient because we would need to makemany more calls to the matcher.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_5344" id="%_idx_5344"></a>(define (find-assertions pattern frame)
  (stream-flatmap (lambda (datum)
                    (check-an-assertion datum pattern frame))
                  (fetch-assertions pattern frame)))
</pre></p>
<p></p>
<p></p>
<p><code>Check-an-assertion</code> takes as arguments a pattern, a data object(assertion), and a frame and returns either a one-element streamcontaining the extended frame or <code>the-empty-stream</code> if the matchfails.</p>
<p></p>
<p></p>
<p><pre>(define (check-an-assertion assertion query-pat query-frame)
  (let ((match-result
         (pattern-match query-pat assertion query-frame)))
    (if (eq? match-result 'failed)
        the-empty-stream
        (singleton-stream match-result))))
</pre></p>
<p></p>
<p>The basic pattern matcher returns either the symbol <code>failed</code> or anextension of the given frame.  The basic idea of the matcher is tocheck the pattern against the data, element by element, accumulatingbindings for the pattern variables.  If the pattern and the dataobject are the same, the match succeeds and we return the frame ofbindings accumulated so far.  Otherwise, if the pattern is a variablewe extend the current frame by binding the variable to the data, solong as this is consistent with the bindings already in the frame.  Ifthe pattern and the data are both pairs, we (recursively) match the<code>car</code> of the pattern against the <code>car</code> of the data to producea frame; in this frame we then match the <code>cdr</code> of the patternagainst the <code>cdr</code> of the data.  If none of these cases areapplicable, the match fails and we return the symbol <code>failed</code>.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_5346" id="%_idx_5346"></a>(define (pattern-match pat dat frame)
  (cond ((eq? frame 'failed) 'failed)
        ((equal? pat dat) frame)
        ((var? pat) (extend-if-consistent pat dat frame))
        ((and (pair? pat) (pair? dat))
         (pattern-match (cdr pat)
                        (cdr dat)
                        (pattern-match (car pat)
                                       (car dat)
                                       frame)))
        (else 'failed)))
</pre></p>
<p></p>
<p></p>
<p>Here is the procedure that extends a frame by adding a new binding, ifthis is consistent with the bindings already in the frame:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_5348" id="%_idx_5348"></a>(define (extend-if-consistent var dat frame)
  (let ((binding (binding-in-frame var frame)))
    (if binding
        (pattern-match (binding-value binding) dat frame)
        (extend var dat frame))))
</pre></p>
<p></p>
<p>If there is no binding for the variable in the frame, we simply addthe binding of the variable to the data.  Otherwise we match, in theframe, the data against the value of the variable in the frame.  Ifthe stored value contains only constants, as it must if it was storedduring pattern matching by <code>extend-if-consistent</code>, then the matchsimply tests whether the stored and new values are the same.  If so,it returns the unmodified frame; if not, it returns a failureindication.  The stored value may, however, contain pattern variablesif it was stored during unification (see section <a href="#%_sec_4.4.4.4">4.4.4.4</a>).The recursive match of the stored pattern against the new data will add orcheck bindings for the variables in this pattern.  For example,suppose we have a frame in which <code>?x</code> is bound to <code>(f ?y)</code> and<code>?y</code> is unbound, and we wish to augment this frame by a binding of<code>?x</code> to <code>(f b)</code>.  We look up <code>?x</code> and find that it isbound to <code>(f ?y)</code>.  This leads us to match <code>(f ?y)</code> againstthe proposed new value <code>(f b)</code> in the same frame.  Eventuallythis match extends the frame by adding a binding of <code>?y</code> to <code>b</code>.  <code>?X</code> remains bound to <code>(f ?y)</code>.  We never modify a storedbinding and we never store more than one binding for a given variable.</p>
<p>The procedures used by <code>extend-if-consistent</code> to manipulatebindings are defined in section <a href="#%_sec_4.4.4.8">4.4.4.8</a>.</p>
<p><a name="%_sec_Temp_699" id="%_sec_Temp_699"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_699">Patterns with dotted tails</a></h4>
<p><a name="%_idx_5350" id="%_idx_5350"></a>If a pattern contains a dot followed by a pattern variable, thepattern variable matches the rest of the data list (rather than thenext element of the data list), just as one would expect with thedotted-tail notation described in exercise <a href="book-Z-H-15.html#%_thm_2.20">2.20</a>.Although the pattern matcher we have just implemented doesn't look fordots, it does behave as we want.  This is because the Lisp <code>read</code>primitive, which is used by <code>query-driver-loop</code> to read the queryand represent it as a list structure, treats dots in a special way.</p>
<p><a name="%_idx_5352" id="%_idx_5352"></a><a name="%_idx_5354" id="%_idx_5354"></a>When <code>read</code> sees a dot, instead of making the next item be thenext element of a list (the <code>car</code> of a <code>cons</code> whose <code>cdr</code>will be the rest of the list) it makes the next item be the <code>cdr</code>of the list structure.  For example, the list structure produced by<code>read</code> for the pattern <code>(computer ?type)</code> could be constructedby evaluating the expression <code>(cons 'computer (cons '?type '()))</code>,and that for <code>(computer . ?type)</code> could be constructed byevaluating the expression <code>(cons 'computer '?type)</code>.</p>
<p>Thus, as <code>pattern-match</code> recursively compares <code>car</code>s and <code>cdr</code>s of a data list and a pattern that had a dot, it eventuallymatches the variable after the dot (which is a <code>cdr</code> of thepattern) against a sublist of the data list, binding the variable tothat list.  For example, matching the pattern <code>(computer . ?type)</code> against<code>(computer programmer trainee)</code> will match <code>?type</code> against thelist <code>(programmer trainee)</code>.<a name="%_sec_4.4.4.4" id="%_sec_4.4.4.4"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_4.4.4.4">4.4.4.4  Rules and Unification</a></h4>
<p></p>
<p><a name="%_idx_5356" id="%_idx_5356"></a><code>Apply-rules</code> is the rule analog of <code>find-assertions</code>(section <a href="#%_sec_4.4.4.3">4.4.4.3</a>).  Ittakes as input a pattern and a frame, and it forms a stream ofextension frames by applying rules from the data base.  <code>Stream-flatmap</code> maps <code>apply-a-rule</code> down the stream of possiblyapplicable rules (selected by <code>fetch-rules</code>, section <a href="#%_sec_4.4.4.5">4.4.4.5</a>)and combines the resulting streams of frames.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_5358" id="%_idx_5358"></a>(define (apply-rules pattern frame)
  (stream-flatmap (lambda (rule)
                    (apply-a-rule rule pattern frame))
                  (fetch-rules pattern frame)))
</pre></p>
<p></p>
<p></p>
<p><code>Apply-a-rule</code> applies rules using the method outlined insection <a href="#%_sec_4.4.2">4.4.2</a>.  It first augments its argumentframe by unifying the rule conclusion with the pattern in the givenframe.  If this succeeds, it evaluates the rule body in this newframe.</p>
<p>Before any of this happens, however, the program renames all thevariables in the rule with unique new names.  The reason for this isto prevent the variables for different rule applications from becomingconfused with each other.  For instance, if two rules both use avariable named <code>?x</code>, then each one may add a binding for <code>?x</code>to the frame when it is applied.  These two <code>?x</code>'s have nothing todo with each other, and we should not be fooled into thinking that thetwo bindings must be consistent.  Rather than rename variables, wecould devise a more clever environment structure; however, therenaming approach we have chosen here is the most straightforward,even if not the most efficient.  (Seeexercise <a href="#%_thm_4.79">4.79</a>.)  Here is the <code>apply-a-rule</code>procedure:</p>
<p></p>
<p></p>
<p><pre>(define (apply-a-rule rule query-pattern query-frame)
  (let ((clean-rule (rename-variables-in rule)))
    (let ((unify-result
           (unify-match query-pattern
                        (conclusion clean-rule)
                        query-frame)))
      (if (eq? unify-result 'failed)
          the-empty-stream
          (qeval (rule-body clean-rule)
                 (singleton-stream unify-result))))))
</pre></p>
<p></p>
<p>The selectors <code>rule-body</code> and <code>conclusion</code> that extract partsof a rule are defined in section <a href="#%_sec_4.4.4.7">4.4.4.7</a>.</p>
<p>We generate unique variable names by associating a unique identifier(such as a number) with each rule application and combining thisidentifier with the original variable names.  For example, if therule-application identifier is 7, we might change each <code>?x</code> inthe rule to <code>?x-7</code> and each <code>?y</code> in the rule to <code>?y-7</code>.(<code>Make-new-variable</code> and <code>new-rule-application-id</code> areincluded with the syntax procedures in section <a href="#%_sec_4.4.4.7">4.4.4.7</a>.)</p>
<p></p>
<p></p>
<p><pre>(define (rename-variables-in rule)
  (let ((rule-application-id (new-rule-application-id)))
    (define (tree-walk exp)
      (cond ((var? exp)
             (make-new-variable exp rule-application-id))
            ((pair? exp)
             (cons (tree-walk (car exp))
                   (tree-walk (cdr exp))))
            (else exp)))
    (tree-walk rule)))
</pre></p>
<p></p>
<p><a name="%_idx_5360" id="%_idx_5360"></a><a name="%_idx_5362" id="%_idx_5362"></a>The unification algorithm is implemented as a procedure that takes asinputs two patterns and a frame and returns either the extended frameor the symbol <code>failed</code>.The unifier is like the pattern matcher except that it issymmetrical – variables are allowed on both sides of the match.<code>Unify-match</code> is basically the same as <code>pattern-match</code>,except that there is extra code (marked “<code>***</code>” below) to handlethe case where the object on the right side of the match is a variable.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_5364" id="%_idx_5364"></a>(define (unify-match p1 p2 frame)
  (cond ((eq? frame 'failed) 'failed)
        ((equal? p1 p2) frame)
        ((var? p1) (extend-if-possible p1 p2 frame))
        ((var? p2) (extend-if-possible p2 p1 frame))  <em>; ***</em>
        ((and (pair? p1) (pair? p2))
         (unify-match (cdr p1)
                      (cdr p2)
                      (unify-match (car p1)
                                   (car p2)
                                   frame)))
        (else 'failed)))
</pre></p>
<p></p>
<p></p>
<p>In unification, as in one-sided pattern matching, we want to accept aproposed extension of the frame only if it is consistent with existingbindings.  The procedure <code>extend-if-possible</code> used in unificationis the same as the <code>extend-if-consistent</code> used in pattern matchingexcept for two special checks, marked “<code>***</code>” in the programbelow.  In the first case, if the variable we are trying to match isnot bound, but the value we are trying to match it withis itself a (different) variable, it isnecessary to check to see if the value is bound, and if so, to matchits value.  If both parties to the match are unbound, we may bindeither to the other.</p>
<p>The second check deals with attempts to bind a variable to a patternthat includes that variable.  Such a situation can occur whenever avariable is repeated in both patterns.  Consider, for example,unifying the two patterns <code>(?x ?x)</code> and <code>(?y&lt;<em>expression involving <code>?y</code></em>&gt;)</code> in a frame where both <code>?x</code>and <code>?y</code> are unbound.  First <code>?x</code> is matchedagainst <code>?y</code>, making a binding of <code>?x</code> to <code>?y</code>.  Next, the same <code>?x</code> is matched against the given expressioninvolving <code>?y</code>.Since <code>?x</code> is already bound to <code>?y</code>, thisresults in matching <code>?y</code> against the expression.If we think of theunifier as finding a set of values for the pattern variables that makethe patterns the same, then these patterns imply instructions to finda <code>?y</code> such that <code>?y</code> is equal to the expression involving <code>?y</code>.There is no general method for solving suchequations, so we reject such bindings; these cases are recognized bythe predicate <code>depends-on?</code>.<a name="call_footnote_Temp_700" href="#footnote_Temp_700" id="call_footnote_Temp_700"><sup><small>80</small></sup></a>On the other hand, we do not want to reject attemptsto bind a variable to itself.  For example, consider unifying <code>(?x ?x)</code>and <code>(?y ?y)</code>.  The second attempt to bind <code>?x</code> to <code>?y</code> matches <code>?y</code> (the stored value of <code>?x</code>) against <code>?y</code>(the new value of <code>?x</code>).  This is taken care of by the <code>equal?</code> clauseof <code>unify-match</code>.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_5370" id="%_idx_5370"></a>(define (extend-if-possible var val frame)
  (let ((binding (binding-in-frame var frame)))
    (cond (binding
           (unify-match
            (binding-value binding) val frame))
          ((var? val)                      <em>; ***</em>
           (let ((binding (binding-in-frame val frame)))
             (if binding
                 (unify-match
                  var (binding-value binding) frame)
                 (extend var val frame))))
          ((depends-on? val var frame)     <em>; ***</em>
           'failed)
          (else (extend var val frame)))))
</pre></p>
<p></p>
<p></p>
<p><code>Depends-on?</code> is a predicate that tests whether an expressionproposed to be the value of a pattern variable depends on the variable.This must be done relative to the current frame because the expressionmay contain occurrences of a variable that already has a value thatdepends on our test variable.  The structure of <code>depends-on?</code> is asimple recursive tree walk in which we substitute for the values ofvariables whenever necessary.</p>
<p></p>
<p></p>
<p><pre>(define (depends-on? exp var frame)
  (define (tree-walk e)
    (cond ((var? e)
           (if (equal? var e)
               true
               (let ((b (binding-in-frame e frame)))
                 (if b
                     (tree-walk (binding-value b))
                     false))))
          ((pair? e)
           (or (tree-walk (car e))
               (tree-walk (cdr e))))
          (else false)))
  (tree-walk exp))
</pre></p>
<p></p>
<p><a name="%_sec_4.4.4.5" id="%_sec_4.4.4.5"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_4.4.4.5">4.4.4.5  Maintaining the Data Base</a></h4>
<p><a name="%_idx_5372" id="%_idx_5372"></a><a name="%_idx_5374" id="%_idx_5374"></a><a name="%_idx_5376" id="%_idx_5376"></a>One important problem in designing logic programming languages is thatof arranging things so that as few irrelevant data-base entries aspossible will be examined in checking a given pattern.  In oursystem, in addition to storing all assertions in one big stream,we store all assertions whose <code>car</code>s are constant symbolsin separate streams, in a table indexed by the symbol.  To fetch anassertion that may match a pattern, we first check to see if the <code>car</code> of the pattern is a constant symbol.  If so, we return (to betested using the matcher) all the stored assertions that have the same<code>car</code>.  If the pattern's <code>car</code> is not a constant symbol, wereturn all the stored assertions.  Cleverer methods could also takeadvantage of information in the frame, or try also to optimize thecase where the <code>car</code> of the pattern is not a constant symbol.  Weavoid building our criteria for indexing (using the <code>car</code>,handling only the case of constant symbols) into the program; insteadwe call on predicates and selectors that embody our criteria.</p>
<p></p>
<p></p>
<p><pre>(define THE-ASSERTIONS the-empty-stream)
<a name="%_idx_5378" id="%_idx_5378"></a>(define (fetch-assertions pattern frame)
  (if (use-index? pattern)
      (get-indexed-assertions pattern)
      (get-all-assertions)))
(define (get-all-assertions) THE-ASSERTIONS)
(define (get-indexed-assertions pattern)
  (get-stream (index-key-of pattern) 'assertion-stream))
</pre></p>
<p></p>
<p><code>Get-stream</code> looks up a stream in the table and returns an emptystream if nothing is stored there.</p>
<p></p>
<p></p>
<p><pre>(define (get-stream key1 key2)
  (let ((s (get key1 key2)))
    (if s s the-empty-stream)))
</pre></p>
<p></p>
<p></p>
<p>Rules are stored similarly, using the <code>car</code> of the ruleconclusion.  Rule conclusions are arbitrary patterns, however, so theydiffer from assertions in that they can contain variables.  A patternwhose <code>car</code> is a constant symbol can match rules whose conclusionsstart with a variable as well as rules whose conclusions have the same<code>car</code>.  Thus, when fetching rules that might match a pattern whose<code>car</code> is a constant symbol we fetch all rules whose conclusionsstart with a variable as well as those whose conclusions have the same<code>car</code> as the pattern.  For this purpose we store all rules whoseconclusions start with a variable in a separate stream in our table,indexed by the symbol <code>?</code>.</p>
<p></p>
<p></p>
<p><pre>(define THE-RULES the-empty-stream)
<a name="%_idx_5380" id="%_idx_5380"></a>(define (fetch-rules pattern frame)
  (if (use-index? pattern)
      (get-indexed-rules pattern)
      (get-all-rules)))
(define (get-all-rules) THE-RULES)
(define (get-indexed-rules pattern)
  (stream-append
   (get-stream (index-key-of pattern) 'rule-stream)
   (get-stream '? 'rule-stream)))
</pre></p>
<p></p>
<p></p>
<p><code>Add-rule-or-assertion!</code> is used by <code>query-driver-loop</code> toadd assertions and rules to the data base.  Each item is stored in theindex, if appropriate, and in a stream of all assertions or rules inthe data base.</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_5382" id="%_idx_5382"></a>(define (add-rule-or-assertion! assertion)
  (if (rule? assertion)
      (add-rule! assertion)
      (add-assertion! assertion)))
(define (add-assertion! assertion)
  (store-assertion-in-index assertion)
  (let ((old-assertions THE-ASSERTIONS))
    (set! THE-ASSERTIONS
          (cons-stream assertion old-assertions))
    'ok))
(define (add-rule! rule)
  (store-rule-in-index rule)
  (let ((old-rules THE-RULES))
    (set! THE-RULES (cons-stream rule old-rules))
    'ok))
</pre></p>
<p></p>
<p></p>
<p>To actually store an assertion or a rule, we check to see if it can beindexed.  If so, we store it in the appropriate stream.</p>
<p></p>
<p></p>
<p><pre>(define (store-assertion-in-index assertion)
  (if (indexable? assertion)
      (let ((key (index-key-of assertion)))
        (let ((current-assertion-stream
               (get-stream key 'assertion-stream)))
          (put key
               'assertion-stream
               (cons-stream assertion
                            current-assertion-stream))))))
(define (store-rule-in-index rule)
  (let ((pattern (conclusion rule)))
    (if (indexable? pattern)
        (let ((key (index-key-of pattern)))
          (let ((current-rule-stream
                 (get-stream key 'rule-stream)))
            (put key
                 'rule-stream
                 (cons-stream rule
                              current-rule-stream)))))))
</pre></p>
<p></p>
<p></p>
<p>The following procedures define how the data-base index is used.  Apattern (an assertion or a rule conclusion) will be stored in thetable if it starts with a variable or a constant symbol.</p>
<p></p>
<p></p>
<p><pre>(define (indexable? pat)
  (or (constant-symbol? (car pat))
      (var? (car pat))))
</pre></p>
<p></p>
<p>The key under which a pattern is stored in the table is either <code>?</code> (if it starts with a variable) or the constant symbol with whichit starts.</p>
<p></p>
<p></p>
<p><pre>(define (index-key-of pat)
  (let ((key (car pat)))
    (if (var? key) '? key)))
</pre></p>
<p></p>
<p>The index will be used to retrieve items that might match a pattern ifthe pattern starts with a constant symbol.</p>
<p></p>
<p></p>
<p><pre>(define (use-index? pat)
  (constant-symbol? (car pat)))
</pre></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_4.70" id="%_thm_4.70"></a><b>Exercise 4.70.</b>  What is the purpose of the <code>let</code> bindings in the procedures <code>add-assertion!</code> and <code>add-rule!</code> ?  What would be wrong with thefollowing implementation of <code>add-assertion!</code> ?Hint: Recall the definition of the infinite stream of ones insection <a href="book-Z-H-24.html#%_sec_3.5.2">3.5.2</a>: <code>(define ones (cons-stream 1 ones))</code>.</p>
<p></p>
<p></p>
<p><pre>(define (add-assertion! assertion)
  (store-assertion-in-index assertion)
  (set! THE-ASSERTIONS
        (cons-stream assertion THE-ASSERTIONS))
  'ok)
</pre></p>
<p></p>
<p></p>
<p><a name="%_sec_4.4.4.6" id="%_sec_4.4.4.6"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_4.4.4.6">4.4.4.6  Stream Operations</a></h4>
<p><a name="%_idx_5384" id="%_idx_5384"></a>The query system uses a few stream operations that were not presentedin chapter 3.</p>
<p><code>Stream-append-delayed</code> and <code>interleave-delayed</code>are just like <code>stream-append</code> and <code>interleave</code>(section <a href="book-Z-H-24.html#%_sec_3.5.3">3.5.3</a>),except that they take a delayed argument (like the <code>integral</code>procedure in section <a href="book-Z-H-24.html#%_sec_3.5.4">3.5.4</a>).This postpones looping in some cases (see exercise <a href="#%_thm_4.71">4.71</a>).</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_5386" id="%_idx_5386"></a>(define (stream-append-delayed s1 delayed-s2)
  (if (stream-null? s1)
      (force delayed-s2)
      (cons-stream
       (stream-car s1)
       (stream-append-delayed (stream-cdr s1) delayed-s2))))
<a name="%_idx_5388" id="%_idx_5388"></a>(define (interleave-delayed s1 delayed-s2)
  (if (stream-null? s1)
      (force delayed-s2)
      (cons-stream
       (stream-car s1)
       (interleave-delayed (force delayed-s2)
                           (delay (stream-cdr s1))))))
</pre></p>
<p></p>
<p></p>
<p><code>Stream-flatmap</code>, which is used throughout the query evaluator tomap a procedure over a stream of frames and combine the resultingstreams of frames, is the stream analog of the <code>flatmap</code> procedureintroduced for ordinary lists in section <a href="book-Z-H-15.html#%_sec_2.2.3">2.2.3</a>.Unlike ordinary <code>flatmap</code>, however, we accumulate the streams withan interleaving process, rather than simply appending them (seeexercises <a href="#%_thm_4.72">4.72</a> and  <a href="#%_thm_4.73">4.73</a>).</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_5390" id="%_idx_5390"></a>(define (stream-flatmap proc s)
  (flatten-stream (stream-map proc s)))
<a name="%_idx_5392" id="%_idx_5392"></a>(define (flatten-stream stream)
  (if (stream-null? stream)
      the-empty-stream
      (interleave-delayed
       (stream-car stream)
       (delay (flatten-stream (stream-cdr stream))))))
</pre></p>
<p></p>
<p></p>
<p>The evaluator also uses the following simple procedureto generate a stream consisting of a single element:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_5394" id="%_idx_5394"></a>(define (singleton-stream x)
  (cons-stream x the-empty-stream))
</pre></p>
<p></p>
<p><a name="%_sec_4.4.4.7" id="%_sec_4.4.4.7"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_4.4.4.7">4.4.4.7  Query Syntax Procedures</a></h4>
<p><a name="%_idx_5396" id="%_idx_5396"></a><code>Type</code> and <code>contents</code>, used by <code>qeval</code>(section <a href="#%_sec_4.4.4.2">4.4.4.2</a>), specify that aspecial form is identified by the symbol in its <code>car</code>.They are the same as the <code>type-tag</code> and <code>contents</code> procedures insection <a href="book-Z-H-17.html#%_sec_2.4.2">2.4.2</a>, except for the error message.</p>
<p></p>
<p></p>
<p><pre>(define (type exp)
  (if (pair? exp)
      (car exp)
      (error "Unknown expression TYPE" exp)))
(define (contents exp)
  (if (pair? exp)
      (cdr exp)
      (error "Unknown expression CONTENTS" exp)))
</pre></p>
<p></p>
<p></p>
<p>The following procedures, used by <code>query-driver-loop</code>(in section <a href="#%_sec_4.4.4.1">4.4.4.1</a>), specifythat rules and assertions are added to the data base by expressions ofthe form <code>(assert! &lt;<em>rule-or-assertion</em>&gt;):</code></p>
<p></p>
<p></p>
<p><pre>(define (assertion-to-be-added? exp)
  (eq? (type exp) 'assert!))
(define (add-assertion-body exp)
  (car (contents exp)))
</pre></p>
<p></p>
<p></p>
<p>Here are the syntax definitions for the <code>and</code>,  <code>or</code>,  <code>not</code>, and <code>lisp-value</code> special forms(section <a href="#%_sec_4.4.4.2">4.4.4.2</a>):</p>
<p></p>
<p></p>
<p><pre>(define (empty-conjunction? exps) (null? exps))
(define (first-conjunct exps) (car exps))
(define (rest-conjuncts exps) (cdr exps))
(define (empty-disjunction? exps) (null? exps))
(define (first-disjunct exps) (car exps))
(define (rest-disjuncts exps) (cdr exps))
(define (negated-query exps) (car exps))
(define (predicate exps) (car exps))
(define (args exps) (cdr exps))
</pre></p>
<p></p>
<p></p>
<p>The following three procedures define the syntax of rules:</p>
<p></p>
<p></p>
<p><pre>(define (rule? statement)
  (tagged-list? statement 'rule))
(define (conclusion rule) (cadr rule))
(define (rule-body rule)
  (if (null? (cddr rule))
      '(always-true)
      (caddr rule)))
</pre></p>
<p></p>
<p></p>
<p><a name="%_idx_5398" id="%_idx_5398"></a><a name="%_idx_5400" id="%_idx_5400"></a><code>Query-driver-loop</code> (section <a href="#%_sec_4.4.4.1">4.4.4.1</a>)calls <code>query-syntax-process</code> totransform pattern variables in the expression, which have the form<code>?symbol</code>, into the internal format <code>(? symbol)</code>.  That is tosay, a pattern such as <code>(job ?x ?y)</code> is actually representedinternally by the system as <code>(job (? x) (? y))</code>.  This increasesthe efficiency of query processing, since it means that the system cancheck to see if an expression is a pattern variable by checkingwhether the <code>car</code> of the expression is the symbol <code>?</code>, ratherthan having to extract characters from the symbol.  The syntaxtransformation is accomplished by the followingprocedure:<a name="call_footnote_Temp_702" href="#footnote_Temp_702" id="call_footnote_Temp_702"><sup><small>81</small></sup></a></p>
<p></p>
<p></p>
<p><pre>(define (query-syntax-process exp)
  (map-over-symbols expand-question-mark exp))
<a name="%_idx_5412" id="%_idx_5412"></a>(define (map-over-symbols proc exp)
  (cond ((pair? exp)
         (cons (map-over-symbols proc (car exp))
               (map-over-symbols proc (cdr exp))))
        ((symbol? exp) (proc exp))
        (else exp)))
(define (expand-question-mark symbol)
  (let ((chars (symbol-&gt;string symbol)))
    (if (string=? (substring chars 0 1) "?")
        (list '?
              (string-&gt;symbol
               (substring chars 1 (string-length chars))))
        symbol)))
</pre></p>
<p></p>
<p></p>
<p>Once the variables are transformed in this way, the variables in apattern are lists starting with <code>?</code>,and the constant symbols (which need to be recognized fordata-base indexing, section <a href="#%_sec_4.4.4.5">4.4.4.5</a>) are just the symbols.</p>
<p></p>
<p></p>
<p><pre>(define (var? exp)
  (tagged-list? exp '?))
(define (constant-symbol? exp) (symbol? exp))
</pre></p>
<p></p>
<p></p>
<p>Unique variables are constructed during rule application(in section <a href="#%_sec_4.4.4.4">4.4.4.4</a>) by means ofthe following procedures.  The unique identifier for a ruleapplication is a number, which is incremented each time a rule isapplied.</p>
<p></p>
<p></p>
<p><pre>(define rule-counter 0)
(define (new-rule-application-id)
  (set! rule-counter (+ 1 rule-counter))
  rule-counter)
(define (make-new-variable var rule-application-id)
  (cons '? (cons rule-application-id (cdr var))))
</pre></p>
<p></p>
<p></p>
<p>When <code>query-driver-loop</code> instantiates the query to print theanswer, it converts any unbound pattern variables back to the rightform for printing, using</p>
<p></p>
<p></p>
<p><pre>(define (contract-question-mark variable)
  (string-&gt;symbol
   (string-append "?" 
     (if (number? (cadr variable))
         (string-append (symbol-&gt;string (caddr variable))
                        "-"
                        (number-&gt;string (cadr variable)))
         (symbol-&gt;string (cadr variable))))))
</pre></p>
<p></p>
<p><a name="%_sec_4.4.4.8" id="%_sec_4.4.4.8"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_4.4.4.8">4.4.4.8  Frames and Bindings</a></h4>
<p></p>
<p><a name="%_idx_5414" id="%_idx_5414"></a><a name="%_idx_5416" id="%_idx_5416"></a>Frames are represented as lists of bindings, which arevariable-value pairs:</p>
<p></p>
<p></p>
<p><pre>(define (make-binding variable value)
  (cons variable value))
(define (binding-variable binding)
  (car binding))
(define (binding-value binding)
  (cdr binding))
(define (binding-in-frame variable frame)
  (assoc variable frame))
(define (extend variable value frame)
  (cons (make-binding variable value) frame))
</pre></p>
<p></p>
<p></p>
<p><a name="%_thm_4.71" id="%_thm_4.71"></a><b>Exercise 4.71.</b>  Louis Reasoner wonders why the <code>simple-query</code> and <code>disjoin</code>procedures (section <a href="#%_sec_4.4.4.2">4.4.4.2</a>) are implemented usingexplicit <code>delay</code> operations, rather than being defined as follows:</p>
<p></p>
<p></p>
<p><pre>(define (simple-query query-pattern frame-stream)
  (stream-flatmap
   (lambda (frame)
     (stream-append (find-assertions query-pattern frame)
                    (apply-rules query-pattern frame)))
   frame-stream))
(define (disjoin disjuncts frame-stream)
  (if (empty-disjunction? disjuncts)
      the-empty-stream
      (interleave
       (qeval (first-disjunct disjuncts) frame-stream)
       (disjoin (rest-disjuncts disjuncts) frame-stream))))
</pre></p>
<p></p>
<p>Can you give examples of queries where these simpler definitions wouldlead to undesirable behavior?</p>
<p></p>
<p></p>
<p><a name="%_thm_4.72" id="%_thm_4.72"></a><b>Exercise 4.72.</b>  Why do <code>disjoin</code> and <code>stream-flatmap</code> interleave thestreams rather than simply append them?  Give examples that illustratewhy interleaving works better.  (Hint: Why did we use <code>interleave</code> insection <a href="book-Z-H-24.html#%_sec_3.5.3">3.5.3</a>?)</p>
<p></p>
<p></p>
<p><a name="%_thm_4.73" id="%_thm_4.73"></a><b>Exercise 4.73.</b>  Why does <code>flatten-stream</code> use <code>delay</code> explicitly?What would be wrong with defining it as follows:</p>
<p></p>
<p><pre>(define (flatten-stream stream)
  (if (stream-null? stream)
      the-empty-stream
      (interleave
       (stream-car stream)
       (flatten-stream (stream-cdr stream)))))
</pre></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_4.74" id="%_thm_4.74"></a><b>Exercise 4.74.</b>  <a name="%_idx_5418" id="%_idx_5418"></a>Alyssa P. Hacker proposes to use a simpler version of <code>stream-flatmap</code>in <code>negate</code>, <code>lisp-value</code>, and <code>find-assertions</code>.She observes that the procedure that is mapped over the frame streamin these cases always produces either the empty stream or a singletonstream, so no interleaving is needed when combining these streams.</p>
<p></p>
<p></p>
<p>a. Fill in the missing expressions in Alyssa's program.</p>
<p></p>
<p><pre>(define (simple-stream-flatmap proc s)
  (simple-flatten (stream-map proc s)))

(define (simple-flatten stream)
  (stream-map &lt;<em>??</em>&gt;
              (stream-filter &lt;<em>??</em>&gt; stream)))
</pre></p>
<p></p>
<p></p>
<p></p>
<p>b. Does the query system's behavior change if we change it in this way?</p>
<p></p>
<p></p>
<p><a name="%_thm_4.75" id="%_thm_4.75"></a><b>Exercise 4.75.</b>  <a name="%_idx_5420" id="%_idx_5420"></a><a name="%_idx_5422" id="%_idx_5422"></a><a name="%_idx_5424" id="%_idx_5424"></a>Implement for the query language a new special form called <code>unique</code>.  <code>Unique</code> should succeed if there is precisely one itemin the data base satisfying a specified query.  For example,</p>
<p></p>
<p></p>
<p><pre>(unique (job ?x (computer wizard)))
</pre></p>
<p></p>
<p>should print the one-item stream</p>
<p></p>
<p></p>
<p><pre>(unique (job (Bitdiddle Ben) (computer wizard)))
</pre></p>
<p></p>
<p>since Ben is the only computer wizard, and</p>
<p></p>
<p></p>
<p><pre>(unique (job ?x (computer programmer)))
</pre></p>
<p></p>
<p>should print the empty stream, since there is more than one computerprogrammer.  Moreover,</p>
<p></p>
<p></p>
<p><pre>(and (job ?x ?j) (unique (job ?anyone ?j)))
</pre></p>
<p></p>
<p>should list all the jobs that are filled by only one person, and thepeople who fill them.</p>
<p>There are two parts to implementing <code>unique</code>.  The first is towrite a procedure that handles this special form, and the second is to make<code>qeval</code> dispatch to that procedure.  The second part is trivial,since <code>qeval</code> does its dispatching in a data-directed way.  Ifyour procedure is called <code>uniquely-asserted</code>, all you need to dois</p>
<p></p>
<p></p>
<p><pre>(put 'unique 'qeval uniquely-asserted)
</pre></p>
<p></p>
<p>and <code>qeval</code> will dispatch to this procedure for every query whose<code>type</code> (<code>car</code>) is the symbol <code>unique</code>.</p>
<p>The real problem is to write the procedure <code>uniquely-asserted</code>.This should take as input the <code>contents</code> (<code>cdr</code>) of the <code>unique</code> query, together with a stream of frames.  For each frame inthe stream, it should use <code>qeval</code> to find the stream of allextensions to the frame that satisfy the given query.  Any stream thatdoes not have exactly one item in it should be eliminated.  Theremaining streams should be passed back to be accumulated into one bigstream that is the result of the <code>unique</code> query.  This is similarto the implementation of the <code>not</code> special form.</p>
<p>Test your implementation by forming a query that lists all people whosupervise precisely one person.</p>
<p></p>
<p></p>
<p><a name="%_thm_4.76" id="%_thm_4.76"></a><b>Exercise 4.76.</b>  <a name="%_idx_5426" id="%_idx_5426"></a><a name="%_idx_5428" id="%_idx_5428"></a><a name="%_idx_5430" id="%_idx_5430"></a>Our implementation of <code>and</code> as a series combination of queries(figure <a href="#%_fig_4.5">4.5</a>) is elegant, but it is inefficient because inprocessing the second query of the <code>and</code> we must scan the database for each frame produced by the first query.  If the data base has<em>N</em> elements, and a typical query produces a number of output framesproportional to <em>N</em> (say <em>N</em>/<em>k</em>), then scanning the data base for eachframe produced by the first query will require <em>N</em><sup>2</sup>/<em>k</em> calls to thepattern matcher.  Another approach would be to process the two clausesof the <code>and</code> separately, then look for all pairs of output framesthat are compatible.  If each query produces <em>N</em>/<em>k</em> output frames, thenthis means that we must perform <em>N</em><sup>2</sup>/<em>k</em><sup>2</sup> compatibility checks – afactor of <em>k</em> fewer than the number of matches required in our currentmethod.</p>
<p>Devise an implementation of <code>and</code> that uses this strategy.  Youmust implement a procedure that takes two frames as inputs, checkswhether the bindings in the frames are compatible, and, if so,produces a frame that merges the two sets of bindings.  This operationis similar to unification.</p>
<p></p>
<p></p>
<p><a name="%_thm_4.77" id="%_thm_4.77"></a><b>Exercise 4.77.</b>  <a name="%_idx_5432" id="%_idx_5432"></a><a name="%_idx_5434" id="%_idx_5434"></a><a name="%_idx_5436" id="%_idx_5436"></a><a name="%_idx_5438" id="%_idx_5438"></a><a name="%_idx_5440" id="%_idx_5440"></a>In section <a href="#%_sec_4.4.3">4.4.3</a> we saw that <code>not</code> and <code>lisp-value</code> can cause the query language to give “wrong” answers ifthese filtering operations are applied to frames in which variablesare unbound.  Devise a way to fix this shortcoming.  One idea is toperform the filtering in a “delayed” manner by appending to theframe a “promise” to filter that is fulfilled only when enoughvariables have been bound to make the operation possible.  We couldwait to perform filtering until all other operations have beenperformed.  However, for efficiency's sake, we would like to performfiltering as soon as possible so as to cut down on the number ofintermediate frames generated.</p>
<p></p>
<p></p>
<p><a name="%_thm_4.78" id="%_thm_4.78"></a><b>Exercise 4.78.</b>  <a name="%_idx_5442" id="%_idx_5442"></a>Redesign the query language as a nondeterministic program to beimplemented using the evaluator ofsection <a href="book-Z-H-28.html#%_sec_4.3">4.3</a>, rather than as a streamprocess.  In this approach, each query will produce a single answer(rather than the stream of all answers) and the user can type <code>try-again</code> to see more answers.  You should find that much of themechanism we built in this section is subsumed by nondeterministicsearch and backtracking.  You will probably also find, however, thatyour new query language has subtle differences in behavior from theone implemented here.  Can you find examples that illustrate thisdifference?</p>
<p></p>
<p></p>
<p><a name="%_thm_4.79" id="%_thm_4.79"></a><b>Exercise 4.79.</b>  <a name="%_idx_5444" id="%_idx_5444"></a><a name="%_idx_5446" id="%_idx_5446"></a>When we implemented the Lisp evaluator in section <a href="book-Z-H-26.html#%_sec_4.1">4.1</a>,we saw how to use local environments to avoid name conflicts betweenthe parameters of procedures.  For example, in evaluating</p>
<p></p>
<p></p>
<p><pre>(define (square x)
  (* x x))
(define (sum-of-squares x y)
  (+ (square x) (square y)))
(sum-of-squares 3 4)
</pre></p>
<p></p>
<p>there is no confusion between the <code>x</code> in <code>square</code> and the <code>x</code>in <code>sum-of-squares</code>, because we evaluate the body of eachprocedure in an environment that is specially constructed to containbindings for the local variables.  In the query system, we used adifferent strategy to avoid name conflicts in applying rules.  Eachtime we apply a rule we rename the variables with new names that areguaranteed to be unique.  The analogous strategy for the Lispevaluator would be to do away with local environments and simplyrename the variables in the body of a procedure each time we apply theprocedure.</p>
<p><a name="%_idx_5448" id="%_idx_5448"></a><a name="%_idx_5450" id="%_idx_5450"></a><a name="%_idx_5452" id="%_idx_5452"></a><a name="%_idx_5454" id="%_idx_5454"></a>Implement for the query language a rule-application method that usesenvironments rather than renaming.  See if you can build on yourenvironment structure to create constructs in the query language fordealing with large systems, such as the rule analog ofblock-structured procedures.  Can you relate any of this to theproblem of making deductions in a context (e.g., “If I supposed that<em>P</em> were true, then I would be able to deduce <em>A</em> and <em>B</em>.”) as amethod of problem solving?  (This problem is open-ended.  A goodanswer is probably worth a Ph.D.)</p>
<p></p>
<p></p>
<p></p>
<div class="smallprint"><hr></div>
<p></p>
<div class="footnote">
<p><a name="footnote_Temp_645" href="#call_footnote_Temp_645" id="footnote_Temp_645"><sup><small>58</small></sup></a> Logic programming has grown out of a long<a name="%_idx_5040" id="%_idx_5040"></a><a name="%_idx_5042" id="%_idx_5042"></a>history of research in automatic theorem proving.  Earlytheorem-proving programs could accomplish very little, because theyexhaustively searched the space of possible proofs.  The majorbreakthrough that made such a search plausible was the discovery inthe early 1960s of the <a name="%_idx_5044" id="%_idx_5044"></a><em>unification algorithm</em> and the <a name="%_idx_5046" id="%_idx_5046"></a><em>resolution principle</em> (Robinson 1965).  Resolution was used, forexample, by <a name="%_idx_5048" id="%_idx_5048"></a><a name="%_idx_5050" id="%_idx_5050"></a>Green and Raphael (1968) (see also Green 1969) as thebasis for a deductive question-answering system.  During most of thisperiod, researchers concentrated on algorithms that are guaranteed tofind a proof if one exists.  Such algorithms were difficult to controland to direct toward a proof.  <a name="%_idx_5052" id="%_idx_5052"></a>Hewitt (1969) recognized thepossibility of merging the control structure of a programming languagewith the operations of a logic-manipulation system, leading to thework in automatic search mentioned in section <a href="book-Z-H-28.html#%_sec_4.3.1">4.3.1</a>(footnote <a href="book-Z-H-28.html#footnote_Temp_603">47</a>).  At the same time that this was being done,<a name="%_idx_5054" id="%_idx_5054"></a>Colmerauer, in Marseille, was developing rule-based systems formanipulating natural language (see Colmerauer et al. 1973).  Heinvented a programming language called <a name="%_idx_5056" id="%_idx_5056"></a>Prolog for representing thoserules.  <a name="%_idx_5058" id="%_idx_5058"></a>Kowalski (1973; 1979), in Edinburgh, recognized that executionof a Prolog program could be interpreted as proving theorems (using aproof technique called linear <a name="%_idx_5060" id="%_idx_5060"></a>Horn-clause resolution).  The merging ofthe last two strands led to the logic-programming movement.  Thus, inassigning credit for the development of logic programming, the Frenchcan point to Prolog's genesis at the <a name="%_idx_5062" id="%_idx_5062"></a>University of Marseille, whilethe British can highlight the work at the <a name="%_idx_5064" id="%_idx_5064"></a>University of Edinburgh.According to people at <a name="%_idx_5066" id="%_idx_5066"></a>MIT, logic programming was developed by thesegroups in an attempt to figure out what Hewitt was talking about inhis brilliant but impenetrable Ph.D. thesis.  For a history of logic<a name="%_idx_5068" id="%_idx_5068"></a>programming, see Robinson 1983.</p>
<p><a name="footnote_Temp_646" href="#call_footnote_Temp_646" id="footnote_Temp_646"><sup><small>59</small></sup></a> Tosee the correspondence between the rules and the procedure, let <code>x</code> in the procedure (where <code>x</code> is nonempty) correspond to <code>(cons u v)</code> in the rule.  Then <code>z</code> in the rule corresponds to the<code>append</code> of <code>(cdr x)</code> and <code>y</code>.</p>
<p><a name="footnote_Temp_647" href="#call_footnote_Temp_647" id="footnote_Temp_647"><sup><small>60</small></sup></a> This certainly does notrelieve the user of the entire problem of how to compute the answer.There are many different mathematically equivalent sets of rules forformulating the <code>append</code> relation, only some of which can beturned into effective devices for computing in any direction.  Inaddition, sometimes “what is” information gives no clue “how to”compute an answer.  For example, consider the problem of computing the<em>y</em> such that <em>y</em><sup>2</sup>  =  <em>x</em>.</p>
<p><a name="footnote_Temp_648" href="#call_footnote_Temp_648" id="footnote_Temp_648"><sup><small>61</small></sup></a> Interest in logic programming peaked<a name="%_idx_5080" id="%_idx_5080"></a><a name="%_idx_5082" id="%_idx_5082"></a><a name="%_idx_5084" id="%_idx_5084"></a>during the early 80s when the Japanese government began an ambitiousproject aimed at building superfast computers optimized to run logicprogramming languages.  The speed of such computers was to be measuredin LIPS (Logical Inferences Per Second) rather than the usual FLOPS(FLoating-point Operations Per Second).  Although the projectsucceeded in developing hardware and software as originally planned,the international computer industry moved in a different direction.See <a name="%_idx_5086" id="%_idx_5086"></a><a name="%_idx_5088" id="%_idx_5088"></a>Feigenbaum and Shrobe 1993 for an overview evaluation of theJapanese project.  The logic programming community has also moved onto consider relational programming based on techniques other thansimple pattern matching, such as the ability to deal with numericalconstraints such as the ones illustrated in the constraint-propagationsystem of section <a href="book-Z-H-22.html#%_sec_3.3.5">3.3.5</a>.</p>
<p><a name="footnote_Temp_651" href="#call_footnote_Temp_651" id="footnote_Temp_651"><sup><small>62</small></sup></a> This uses the dotted-tail notation introduced inexercise <a href="book-Z-H-15.html#%_thm_2.20">2.20</a>.</p>
<p><a name="footnote_Temp_654" href="#call_footnote_Temp_654" id="footnote_Temp_654"><sup><small>63</small></sup></a> Actually, this description of <code>not</code> is valid only for simple cases.  The real behavior of <code>not</code>is more complex.  We will examine <code>not</code>'s peculiarities insections <a href="#%_sec_4.4.2">4.4.2</a> and <a href="#%_sec_4.4.3">4.4.3</a>.</p>
<p><a name="footnote_Temp_655" href="#call_footnote_Temp_655" id="footnote_Temp_655"><sup><small>64</small></sup></a> <code>Lisp-value</code> should be used only to perform an operation not<a name="%_idx_5134" id="%_idx_5134"></a>provided in the query language.  In particular, it should notbe used to test equality (since that is what the matching in thequery language is designed to do) or inequality (since that canbe done with the <code>same</code> rule shown below).</p>
<p><a name="footnote_Temp_658" href="#call_footnote_Temp_658" id="footnote_Temp_658"><sup><small>65</small></sup></a> Notice that we do not need <code>same</code> in order to make two things bethe same: We just use the same pattern variable for each – in effect,we have one thing instead of two things in the first place.  Forexample, see <code>?town</code> in the <code>lives-near</code> rule and <code>?middle-manager</code> in the <code>wheel</code> rule below.<code>Same</code> is useful when we want to force two things to bedifferent, such as <code>?person-1</code> and <code>?person-2</code> in the <code>lives-near</code> rule.  Although using the same pattern variable in twoparts of a query forces the same value to appear in both places, usingdifferent pattern variables does not force different values to appear.(The values assigned to different pattern variables may be the same ordifferent.)</p>
<p><a name="footnote_Temp_659" href="#call_footnote_Temp_659" id="footnote_Temp_659"><sup><small>66</small></sup></a> We will also allow rules without bodies, as in <code><a name="%_idx_5146" id="%_idx_5146"></a>same</code>, and we will interpret such a rule to mean that the ruleconclusion is satisfied by any values of the variables.</p>
<p><a name="footnote_Temp_670" href="#call_footnote_Temp_670" id="footnote_Temp_670"><sup><small>67</small></sup></a> Because matching is generally very expensive, we would<a name="%_idx_5188" id="%_idx_5188"></a>like to avoid applying the full matcher to every element of the database.  This is usually arranged by breaking up the process into afast, coarse match and the final match.  The coarse match filters thedata base to produce a small set of candidates for the final match.With care, we can arrange our data base so that some of the work ofcoarse matching can be done when the data base is constructed rather<a name="%_idx_5190" id="%_idx_5190"></a><a name="%_idx_5192" id="%_idx_5192"></a>then when we want to select the candidates.  This is called <em>indexing</em> the data base.  There is a vast technology built arounddata-base-indexing schemes.  Our implementation, described insection <a href="#%_sec_4.4.4">4.4.4</a>, contains asimple-minded form of such an optimization.</p>
<p><a name="footnote_Temp_672" href="#call_footnote_Temp_672" id="footnote_Temp_672"><sup><small>68</small></sup></a> But this kind of exponential explosion is not common in <code>and</code>queries because the added conditions tend to reduce rather than expandthe number of frames produced.</p>
<p><a name="footnote_Temp_673" href="#call_footnote_Temp_673" id="footnote_Temp_673"><sup><small>69</small></sup></a> There is a large literature on data-base-managementsystems that is concerned with how to handle complex queriesefficiently.</p>
<p><a name="footnote_Temp_674" href="#call_footnote_Temp_674" id="footnote_Temp_674"><sup><small>70</small></sup></a> There is a subtle difference between this filterimplementation of <code>not</code> and the usual meaning of <code>not</code> inmathematical logic.  See section <a href="#%_sec_4.4.3">4.4.3</a>.</p>
<p><a name="footnote_Temp_676" href="#call_footnote_Temp_676" id="footnote_Temp_676"><sup><small>71</small></sup></a> In one-sided pattern matching, all the equations thatcontain pattern variables are explicit and already solved for theunknown (the pattern variable).</p>
<p><a name="footnote_Temp_677" href="#call_footnote_Temp_677" id="footnote_Temp_677"><sup><small>72</small></sup></a> Another way to think of unification is that it generates the mostgeneral pattern that is a specialization of the two input patterns.That is, the unification of <code>(?x a)</code> and <code>((b ?y) ?z)</code> is <code>((b ?y) a)</code>, and the unification of <code>(?x a ?y)</code> and <code>(?y ?za)</code>, discussed above, is <code>(a a a)</code>.For our implementation, it is more convenient to think of the resultof unification as a frame rather than a pattern.</p>
<p><a name="footnote_Temp_680" href="#call_footnote_Temp_680" id="footnote_Temp_680"><sup><small>73</small></sup></a> Since unification is a<a name="%_idx_5222" id="%_idx_5222"></a><a name="%_idx_5224" id="%_idx_5224"></a>generalization of matching, we could simplify the system by using theunifier to produce both streams.  Treating the easy case with thesimple matcher, however, illustrates how matching (as opposed tofull-blown unification) can be useful in its own right.</p>
<p><a name="footnote_Temp_682" href="#call_footnote_Temp_682" id="footnote_Temp_682"><sup><small>74</small></sup></a> The reason we use streams (rather than lists) of frames is that the<a name="%_idx_5236" id="%_idx_5236"></a><a name="%_idx_5238" id="%_idx_5238"></a>recursive application of rules can generateinfinite numbers of values that satisfy a query.  The delayedevaluation embodied in streams is crucial here: The system will printresponses one by one as they are generated, regardless of whetherthere are a finite or infinite number of responses.</p>
<p><a name="footnote_Temp_683" href="#call_footnote_Temp_683" id="footnote_Temp_683"><sup><small>75</small></sup></a> That a particular method of inference islegitimate is not a trivial assertion.  One must prove that if onestarts with true premises, only true conclusions can be derived.  Themethod of inference represented by rule applications is <a name="%_idx_5250" id="%_idx_5250"></a><em>modusponens</em>, the familiar method of inference that says that if <em>A</em> istrue and <em>A implies B</em> is true, then we may conclude that <em>B</em>is true.</p>
<p><a name="footnote_Temp_684" href="#call_footnote_Temp_684" id="footnote_Temp_684"><sup><small>76</small></sup></a> We must qualify this statement byagreeing that, in speaking of the “inference” accomplished by alogic program, we assume that the computation terminates.Unfortunately, even this qualified statement is false for ourimplementation of the query language (and also false for programs inProlog and most other current logic programming languages) because ofour use of <code>not</code> and <code>lisp-value</code>.  As we will describe below,the <code>not</code> implemented in the query language is not alwaysconsistent with the <code>not</code> of mathematical logic, and <code>lisp-value</code> introduces additional complications.  We could implement alanguage consistent with mathematical logic by simply removing <code>not</code> and <code>lisp-value</code> from the language and agreeing to writeprograms using only simple queries, <code>and</code>, and <code>or</code>.  However,this would greatly restrict the expressive power of the language.  Oneof the major concerns of research in logic programming is to find waysto achieve more consistency with mathematical logic without undulysacrificing expressive power.</p>
<p><a name="footnote_Temp_686" href="#call_footnote_Temp_686" id="footnote_Temp_686"><sup><small>77</small></sup></a> This is not a problem of the logic but one of theprocedural interpretation of the logic provided by our interpreter.We could write an interpreter that would not fall into a loop here.For example, we could enumerate all the proofs derivable from ourassertions and our rules in a breadth-first rather than a depth-firstorder.  However, such a system makes it more difficult to takeadvantage of the order of deductions in our programs.  One attempt tobuild sophisticated control into such a program is described in<a name="%_idx_5264" id="%_idx_5264"></a>deKleer et al. 1977.  Another technique, which does not lead to suchserious control problems, is to put in special knowledge, such asdetectors for particular kinds of loops(exercise <a href="#%_thm_4.67">4.67</a>).  However, there can be nogeneral scheme for reliably preventing a system from going downinfinite paths in performing deductions.  Imagine a diabolical rule ofthe form “To show <em>P</em>(<em>x</em>) is true, show that <em>P</em>(<em>f</em>(<em>x</em>)) is true,” forsome suitably chosen function <em>f</em>.</p>
<p><a name="footnote_Temp_688" href="#call_footnote_Temp_688" id="footnote_Temp_688"><sup><small>78</small></sup></a> Consider the query <code>(not (baseball-fan (Bitdiddle Ben)))</code>.  The system finds that <code>(baseball-fan (Bitdiddle Ben))</code> is not in the data base, so the emptyframe does not satisfy the pattern and is not filtered out of theinitial stream of frames.  The result of the query is thus the emptyframe, which is used to instantiate the input query to produce <code>(not (baseball-fan (Bitdiddle Ben)))</code>.</p>
<p><a name="footnote_Temp_689" href="#call_footnote_Temp_689" id="footnote_Temp_689"><sup><small>79</small></sup></a> A discussion and justification of this<a name="%_idx_5274" id="%_idx_5274"></a>treatment of <code>not</code> can be found in the article by Clark (1978).</p>
<p><a name="footnote_Temp_700" href="#call_footnote_Temp_700" id="footnote_Temp_700"><sup><small>80</small></sup></a> In general, unifying <code>?y</code> with an expression involving<a name="%_idx_5366" id="%_idx_5366"></a><code>?y</code> would require our being able to find a fixed point of theequation <code>?y</code>  =  &lt;<em>expression involving <code>?y</code></em>&gt;.  It issometimes possible to syntactically form an expression that appears tobe the solution.  For example, <code>?y</code>  =  <code>(f ?y)</code> seems to havethe fixed point <code>(f (f (f <code>...</code> )))</code>, which we can produce bybeginning with the expression <code>(f ?y)</code> and repeatedly substituting<code>(f ?y)</code> for <code>?y</code>.  Unfortunately, not every such equation hasa meaningful fixed point.  The issues that arise here are similar tothe issues of manipulating <a name="%_idx_5368" id="%_idx_5368"></a>infinite series in mathematics.  Forexample, we know that 2 is the solution to the equation <em>y</em>  =  1  +  <em>y</em>/2.Beginning with the expression 1  +  <em>y</em>/2 and repeatedly substituting 1 +  <em>y</em>/2 for <em>y</em> gives</p>
<p></p>
<div align="left"><img src="images/ch4-Z-G-7.gif" border="0"></div>
<p>which leads to</p>
<p></p>
<div align="left"><img src="images/ch4-Z-G-8.gif" border="0"></div>
<p>However, if we try the same manipulation beginning with theobservation that  - 1 is the solution to the equation <em>y</em>  =  1  +  2<em>y</em>, weobtain</p>
<p></p>
<div align="left"><img src="images/ch4-Z-G-9.gif" border="0"></div>
<p>which leads to</p>
<p></p>
<div align="left"><img src="images/ch4-Z-G-10.gif" border="0"></div>
<p>Although the formal manipulations used in deriving these two equationsare identical, the first result is a valid assertion about infiniteseries but the second is not.  Similarly, for our unification results,reasoning with an arbitrary syntactically constructed expression maylead to errors.</p>
<p><a name="footnote_Temp_702" href="#call_footnote_Temp_702" id="footnote_Temp_702"><sup><small>81</small></sup></a> Most Lisp systems give the user the ability tomodify the ordinary <code>read</code> procedure to perform suchtransformations by defining <a name="%_idx_5402" id="%_idx_5402"></a><a name="%_idx_5404" id="%_idx_5404"></a><a name="%_idx_5406" id="%_idx_5406"></a><a name="%_idx_5408" id="%_idx_5408"></a><em>reader macro characters</em>.  Quotedexpressions are already handled in this way: The reader automaticallytranslates <code>'expression</code> into <code>(quote expression)</code> before theevaluator sees it.  We could arrange for <code>?expression</code> to betransformed into <code>(? expression)</code> in the same way; however, forthe sake of clarity we have included the transformation procedure hereexplicitly.</p>
<p><a name="%_idx_5410" id="%_idx_5410"></a><code>Expand-question-mark</code> and <code>contract-question-mark</code> useseveral procedures with <code>string</code> in their names.These are Scheme primitives.</p>
</div></body>
</html>
