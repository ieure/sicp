<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<?xml version="1.0" encoding="utf-8"?><html xmlns="http://www.w3.org/1999/xhtml" xmlns:ops="http://www.idpf.org/2007/ops">
<!-- Generated from TeX source by tex2page, v 4o,
     (c) Dorai Sitaram, http://www.cs.rice.edu/~dorai/tex2page --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Type: text/html; charset=utf-8">
<title>Structure and Interpretation of Computer Programs</title>
<link rel="stylesheet" type="text/css" href="book-Z-C.css" title="default">
</head>
<body><a name="%_chap_2" id="%_chap_2"></a><h1 class="chapter"><div class="chapterheading"><a href="book-Z-H-4.html#%_toc_%_chap_2">Chapter 2</a></div>
</h1>
<p><a href="book-Z-H-4.html#%_toc_%_chap_2">Building Abstractions with Data</a></p>
<p></p>
<p></p>
<div align="right"><table width="60%"><tr><td><span class="epigraph"><p>We now come to the decisive step of mathematical abstraction: weforget about what the symbols stand for. <code>...</code>[The mathematician]need not be idle; there are many operations which he may carry outwith these symbols, without ever having to look at the things theystand for.</p>
<p><a name="%_idx_1254" id="%_idx_1254"></a>Hermann Weyl, <em>The Mathematical Way of Thinking</em></p>
<p></p></span></td></tr></table>
</div><p></p>
<p><a name="%_idx_1256" id="%_idx_1256"></a><a name="%_idx_1258" id="%_idx_1258"></a>We concentrated in chapter 1 on computational processes and on therole of procedures in program design.  We saw how to use primitivedata (numbers) and primitive operations (arithmetic operations), how tocombine procedures to form compound procedures through composition,conditionals, and the use of parameters, and how to abstractprocedures by using <code>define</code>.  We saw that a procedure can beregarded as a pattern for the local evolution of a process, and weclassified, reasoned about, and performed simple algorithmic analysesof some common patterns for processes as embodied in procedures.  Wealso saw that higher-order procedures enhance the power of ourlanguage by enabling us to manipulate, and thereby to reason in termsof, general methods of computation.  This is much of the essence ofprogramming.</p>
<p>In this chapter we are going to look at more complex data.  All theprocedures in chapter 1 operate on simple numerical data, and simpledata are not sufficient for many of the problems we wish to addressusing computation.  Programs are typically designed to model complexphenomena, and more often than not one must construct computationalobjects that have several parts in order to model real-world phenomenathat have several aspects.  Thus, whereas our focus in chapter 1 wason building abstractions by combining procedures to form compoundprocedures, we turn in this chapter to another key aspect of anyprogramming language: the means it provides for building abstractionsby combining data objects to form <em>compound data</em>.</p>
<p>Why do we want compound data in a programming language?  For the samereasons that we want compound procedures: to elevate the conceptuallevel at which we can design our programs, to increase the modularityof our designs, and to enhance the expressive power of our language.Just as the ability to define procedures enables us to deal withprocesses at a higher conceptual level than that of the primitiveoperations of the language, the ability to construct compound dataobjects enables us to deal with data at a higher conceptual level thanthat of the primitive data objects of the language.</p>
<p><a name="%_idx_1260" id="%_idx_1260"></a>Consider the task of designing a system to perform arithmetic withrational numbers.  We could imagine an operation <code>add-rat</code> that takestwo rational numbers and produces their sum.  In terms ofsimple data, a rational number can be thought of as two integers: anumerator and a denominator.  Thus, we could design a program in whicheach rational number would be represented by two integers (a numeratorand a denominator) and where <code>add-rat</code> would be implemented by twoprocedures (one producing the numerator of the sum and one producingthe denominator).  But this would be awkward, because we would thenneed to explicitly keep track of which numerators corresponded towhich denominators.  In a system intended to perform many operationson many rational numbers, such bookkeeping details would clutter theprograms substantially, to say nothing of what they would do to ourminds.  It would be much better if we could “glue together” anumerator and denominator to form a pair – a <em>compound dataobject</em> – that our programs could manipulate in a way that would beconsistent with regarding a rational number as a single conceptualunit.</p>
<p>The use of compound data also enables us to increase the modularity ofour programs.  If we can manipulate rational numbers directly asobjects in their own right, then we can separate the part of ourprogram that deals with rational numbers per se from the details ofhow rational numbers may be represented as pairs of integers.  Thegeneral technique of isolating the parts of a program that deal withhow data objects are represented from the parts of a program that dealwith how data objects are used is a powerful design methodology called<a name="%_idx_1262" id="%_idx_1262"></a><em>data abstraction</em>.  We will see how data abstraction makesprograms much easier to design, maintain, and modify.</p>
<p>The use of compound data leads to a real increase in the expressivepower of our programming language.  Consider the idea of forming a“linear combination” <em>a</em><em>x</em> + <em>b</em><em>y</em>.  We might like to write a procedurethat would accept <em>a</em>, <em>b</em>, <em>x</em>, and <em>y</em> as arguments and return thevalue of <em>a</em><em>x</em> + <em>b</em><em>y</em>.  This presents no difficulty if the arguments are tobe numbers, because we can readily define the procedure</p>
<p></p>
<p></p>
<p><pre>(define (linear-combination a b x y) 
  (+ (* a x) (* b y)))
</pre></p>
<p></p>
<p>But suppose we are not concerned only with numbers.  Suppose we wouldlike to express, in procedural terms, the idea that one can formlinear combinations whenever addition and multiplication aredefined – for rational numbers, complex numbers, polynomials, orwhatever.  We could express this as a procedure of the form</p>
<p></p>
<p></p>
<p><pre>(define (linear-combination a b x y)     
  (add (mul a x) (mul b y))) 
</pre></p>
<p></p>
<p>where <code>add</code> and <code>mul</code> are not the primitive procedures <code>+</code>and <code>*</code> but rather more complex things that will perform theappropriate operations for whatever kinds of data we pass in as thearguments <code>a</code>, <code>b</code>, <code>x</code>, and <code>y</code>. The key point isthat the only thing <code>linear-combination</code> should need to know about<code>a</code>, <code>b</code>, <code>x</code>, and <code>y</code> is that the procedures <code>add</code>and <code>mul</code> will perform the appropriate manipulations.  From theperspective of the procedure <code>linear-combination</code>, it isirrelevant what <code>a</code>, <code>b</code>, <code>x</code>, and <code>y</code> are and evenmore irrelevant how they might happen to be represented in terms ofmore primitive data.  This same example shows why it is important thatour programming language provide the ability to manipulate compoundobjects directly: Without this, there is no way for a procedure suchas <code>linear-combination</code> to pass its arguments along to <code>add</code>and <code>mul</code> without having to know their detailedstructure.<a name="call_footnote_Temp_131" href="#footnote_Temp_131" id="call_footnote_Temp_131"><sup><small>1</small></sup></a>We begin this chapter by implementing the rational-number arithmeticsystem mentioned above.  This will form the background for ourdiscussion of compound data and data abstraction.  As with compoundprocedures, the main issue to be addressed is that of abstraction as atechnique for coping with complexity, and we will see how dataabstraction enables us to erect suitable <a name="%_idx_1264" id="%_idx_1264"></a><em>abstraction barriers</em>between different parts of a program.</p>
<p>We will see that the key to forming compound data is that aprogramming language should provide some kind of “glue” so that dataobjects can be combined to form more complex data objects.  There aremany possible kinds of glue.  Indeed, we will discover how to formcompound data using no special “data” operations at all, onlyprocedures.  This will further blur the distinction between“procedure” and “data,” which was already becoming tenuous towardthe end of chapter 1.  We will also explore some conventionaltechniques for representing sequences and trees.  One key idea indealing with compound data is the notion of <a name="%_idx_1266" id="%_idx_1266"></a><em>closure</em> – that theglue we use for combining data objects should allow us to combine notonly primitive data objects, but compound data objects as well.Another key idea is that compound data objects can serve as <a name="%_idx_1268" id="%_idx_1268"></a><em>conventional interfaces</em> for combining program modules inmix-and-match ways.  We illustrate some of these ideas by presenting asimple graphics language that exploits closure.</p>
<p>We will then augment the representational power of our language byintroducing <a name="%_idx_1270" id="%_idx_1270"></a><a name="%_idx_1272" id="%_idx_1272"></a><em>symbolic expressions</em> – data whose elementary partscan be arbitrary symbols rather than only numbers.  We explore variousalternatives for representing sets of objects.  We will find that,just as a given numerical function can be computed by many differentcomputational processes, there are many ways in which a given datastructure can be represented in terms of simpler objects, and thechoice of representation can have significant impact on the time andspace requirements of processes that manipulate the data.  We willinvestigate these ideas in the context of symbolic differentiation,the representation of sets, and the encoding of information.</p>
<p>Next we will take up the problem of working with data that may berepresented differently by different parts of a program.  This leadsto the need to implement <a name="%_idx_1274" id="%_idx_1274"></a><a name="%_idx_1276" id="%_idx_1276"></a><em>generic operations</em>, which must handlemany different types of data.  Maintaining modularity in thepresence of generic operations requires more powerful abstractionbarriers than can be erected with simple data abstraction alone.  Inparticular, we introduce <em>data-directed programming</em> as atechnique that allows individual data representations to be designedin isolation and then combined <a name="%_idx_1278" id="%_idx_1278"></a><em>additively</em> (i.e., withoutmodification).  To illustrate the power of this approach to systemdesign, we close the chapter by applying what we have learned to theimplementation of a package for performing symbolic arithmetic onpolynomials, in which the coefficients of the polynomials can beintegers, rational numbers, complex numbers, and even otherpolynomials.</p>
<p></p>
<p></p>
<div class="smallprint"><hr></div>
<p></p>
<div class="footnote"><p><a name="footnote_Temp_131" href="#call_footnote_Temp_131" id="footnote_Temp_131"><sup><small>1</small></sup></a> The ability to directly manipulate proceduresprovides an analogous increase in the expressive power of aprogramming language.  For example, insection <a href="book-Z-H-12.html#%_sec_1.3.1">1.3.1</a> we introduced the <code>sum</code>procedure, which takes a procedure <code>term</code> as an argument andcomputes the sum of the values of <code>term</code> over some specifiedinterval.  In order to define <code>sum</code>, it is crucial that we be ableto speak of a procedure such as <code>term</code> as an entity in its ownright, without regard for how <code>term</code> might be expressed with moreprimitive operations.  Indeed, if we did not have the notion of “aprocedure,” it is doubtful that we would ever even think of thepossibility of defining an operation such as <code>sum</code>.  Moreover,insofar as performing the summation is concerned, the details of how<code>term</code> may be constructed from more primitive operations areirrelevant.</p></div></body>
</html>
