<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<?xml version="1.0" encoding="utf-8"?><html xmlns="http://www.w3.org/1999/xhtml" xmlns:ops="http://www.idpf.org/2007/ops">
<!-- Generated from TeX source by tex2page, v 4o,
     (c) Dorai Sitaram, http://www.cs.rice.edu/~dorai/tex2page --><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Type: text/html; charset=utf-8">
<title>Structure and Interpretation of Computer Programs</title>
<link rel="stylesheet" type="text/css" href="book-Z-C.css" title="default">
</head>
<body><a name="%_sec_1.1" id="%_sec_1.1"></a><h2><a href="book-Z-H-4.html#%_toc_%_sec_1.1">1.1  The Elements of Programming</a></h2>
<p><a name="%_idx_118" id="%_idx_118"></a>A powerful programming language is more than just a means forinstructing a computer to perform tasks.  The language also serves asa framework within which we organize our ideas about processes.  Thus,when we describe a language, we should pay particular attention to themeans that the language provides for combining simple ideas to formmore complex ideas.  Every powerful language has three mechanisms foraccomplishing this:</p>
<p></p>
<p></p>
<ul>
<a name="%_idx_120" id="%_idx_120"></a><li>
<strong>primitive expressions</strong>, which represent the simplestentities the language is concerned with,<p><a name="%_idx_122" id="%_idx_122"></a><a name="%_idx_124" id="%_idx_124"></a></p>
</li>
<li>
<strong>means of combination</strong>, by which compoundelements are built from simpler ones, and<p><a name="%_idx_126" id="%_idx_126"></a></p>
</li>
<li>
<strong>means of abstraction</strong>, bywhich compound elements can be named and manipulated as units.<p></p>
</li>
</ul>
<p></p>
<p>In programming, we deal with two kinds of elements: <a name="%_idx_128" id="%_idx_128"></a>procedures and<a name="%_idx_130" id="%_idx_130"></a>data. (Later we will discover that they are really not so distinct.)Informally, data is “stuff” that we want to manipulate, andprocedures are descriptions of the rules for manipulating the data.Thus, any powerful programming language should be able to describeprimitive data and primitive procedures and should have methods forcombining and abstracting procedures and data.</p>
<p>In this chapter we will deal only with simple <a name="%_idx_132" id="%_idx_132"></a><a name="%_idx_134" id="%_idx_134"></a>numerical data so thatwe can focus on the rules for building procedures.<a name="call_footnote_Temp_10" href="#footnote_Temp_10" id="call_footnote_Temp_10"><sup><small>4</small></sup></a> In later chapters we will see thatthese same rules allow us to build procedures to manipulate compounddata as well.</p>
<p><a name="%_sec_1.1.1" id="%_sec_1.1.1"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_1.1.1">1.1.1  Expressions</a></h3>
<p></p>
<p>One easy way to get started at programming is to examine some typicalinteractions with an interpreter for the Scheme dialect of Lisp.Imagine that you are sitting at a computer terminal.  You type an<em>expression</em>, and the interpreter responds by displaying the result ofits <em>evaluating</em> that expression.</p>
<p><a name="%_idx_148" id="%_idx_148"></a><a name="%_idx_150" id="%_idx_150"></a>One kind of primitive expression you might type is a number.  (Moreprecisely, the expression that you type consists of the numerals thatrepresent the number in base 10.)  If you present Lisp witha number</p>
<p></p>
<p></p>
<p><pre>486
</pre></p>
<p></p>
<p>the interpreter will respond by printing<a name="call_footnote_Temp_11" href="#footnote_Temp_11" id="call_footnote_Temp_11"><sup><small>5</small></sup></a></p>
<p></p>
<p></p>
<p><pre><i>486</i>
</pre></p>
<p></p>
<p></p>
<p><a name="%_idx_154" id="%_idx_154"></a><a name="%_idx_156" id="%_idx_156"></a>Expressions representing numbers may be combined with an <a name="%_idx_158" id="%_idx_158"></a>expressionrepresenting a <a name="%_idx_160" id="%_idx_160"></a><a name="%_idx_162" id="%_idx_162"></a><a name="%_idx_164" id="%_idx_164"></a><a name="%_idx_166" id="%_idx_166"></a><a name="%_idx_168" id="%_idx_168"></a>primitive procedure (such as <code>+</code> or <code>*</code>) to form acompound expression that represents theapplication of the procedure to those numbers.  For example:</p>
<p></p>
<p></p>
<p><pre>(+ 137 349)
<i>486</i>
<a name="%_idx_170" id="%_idx_170"></a><a name="%_idx_172" id="%_idx_172"></a>(- 1000 334)
<i>666</i>
(* 5 99)
<i>495</i>
<a name="%_idx_174" id="%_idx_174"></a><a name="%_idx_176" id="%_idx_176"></a>(/ 10 5)
<i>2</i>
(+ 2.7 10)
<i>12.7</i>
</pre></p>
<p></p>
<p></p>
<p>Expressions such as these, formed by <a name="%_idx_178" id="%_idx_178"></a>delimiting a list of expressionswithin parentheses in order to denote <a name="%_idx_180" id="%_idx_180"></a>procedure application,are called <em>combinations</em>.  The leftmostelement in the list is called the <a name="%_idx_182" id="%_idx_182"></a><em>operator</em>, and the otherelements are called <a name="%_idx_184" id="%_idx_184"></a><em>operands</em>.  The <a name="%_idx_186" id="%_idx_186"></a>value of a combination isobtained by applying the procedure specified by the operator to the<a name="%_idx_188" id="%_idx_188"></a><em>arguments</em> that are the values of the operands.</p>
<p>The convention of placing the operator to the left of the operands isknown as <a name="%_idx_190" id="%_idx_190"></a><em>prefix notation</em>, and it may be somewhat confusing atfirst because it departs significantly from the customary mathematicalconvention.  Prefix notation has several advantages, however.  One ofthem is that it can accommodate <a name="%_idx_192" id="%_idx_192"></a><a name="%_idx_194" id="%_idx_194"></a>procedures that may take an arbitrarynumber of arguments, as in the following examples:</p>
<p></p>
<p></p>
<p><pre>(+ 21 35 12 7)
<i>75</i>

(* 25 4 12)
<i>1200</i>
</pre></p>
<p></p>
<p>No ambiguity can arise, because the operator is always the leftmostelement and the entire combination is delimited by theparentheses.</p>
<p><a name="%_idx_196" id="%_idx_196"></a>A second advantage of prefix notation is that it extends in astraightforward way to allow combinations to be <em>nested</em>, that is,to have combinations whose elements are themselvescombinations:</p>
<p></p>
<p></p>
<p><pre>(+ (* 3 5) (- 10 6))
<i>19</i>
</pre></p>
<p></p>
<p></p>
<p>There is no limit (in principle) to the depth of such nesting and tothe overall complexity of the expressions that the Lisp interpretercan evaluate.It is we humans who get confused by still relativelysimple expressions such as</p>
<p></p>
<p></p>
<p><pre>(+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6))
</pre></p>
<p></p>
<p>which the interpreter would readily evaluate to be 57.  We can helpourselves by writing such an expression in the form</p>
<p></p>
<p></p>
<p><pre>(+ (* 3
      (+ (* 2 4)
         (+ 3 5)))
   (+ (- 10 7)
      6))
</pre></p>
<p></p>
<p>following a formatting convention known as <a name="%_idx_198" id="%_idx_198"></a><em>pretty-printing</em>, inwhich each long combination is written so that the operands arealigned vertically.  The resulting indentations display clearly thestructure of the expression.<a name="call_footnote_Temp_12" href="#footnote_Temp_12" id="call_footnote_Temp_12"><sup><small>6</small></sup></a></p>
<p>Even with complex expressions, the interpreter always operates in thesame basic cycle: It reads an expression from the terminal,evaluates the expression, and prints the result.This mode of operation is often expressed by saying that theinterpreter runs in a <a name="%_idx_204" id="%_idx_204"></a><a name="%_idx_206" id="%_idx_206"></a><em>read-eval-print loop</em>.Observe in particular that it is not necessary to explicitlyinstruct the interpreter to print the value of the expression.<a name="call_footnote_Temp_13" href="#footnote_Temp_13" id="call_footnote_Temp_13"><sup><small>7</small></sup></a></p>
<p><a name="%_sec_1.1.2" id="%_sec_1.1.2"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_1.1.2">1.1.2  Naming and the Environment</a></h3>
<p>A critical aspect of a programming language is the means it providesfor using <a name="%_idx_216" id="%_idx_216"></a>names to refer to computational objects.  We say that the<a name="%_idx_218" id="%_idx_218"></a>name identifies a <a name="%_idx_220" id="%_idx_220"></a><em>variable</em> whose <a name="%_idx_222" id="%_idx_222"></a><em>value</em> is the object.</p>
<p>In the Scheme dialect of Lisp, wename things with <a name="%_idx_224" id="%_idx_224"></a><a name="%_idx_226" id="%_idx_226"></a><code>define</code>.  Typing</p>
<p></p>
<p></p>
<p><pre>(define size 2)
</pre></p>
<p></p>
<p>causes the interpreter to associate the value 2 with thename <code>size</code>.<a name="call_footnote_Temp_14" href="#footnote_Temp_14" id="call_footnote_Temp_14"><sup><small>8</small></sup></a>Once the name <code>size</code> has been associated with the number 2, we canrefer to the value 2 by name:</p>
<p></p>
<p></p>
<p><pre>size
<i>2</i>
(* 5 size)
<i>10</i>
</pre></p>
<p></p>
<p></p>
<p>Here are further examples of the use of <code>define</code>:</p>
<p></p>
<p></p>
<p><pre>(define pi 3.14159)
(define radius 10)
(* pi (* radius radius))
<i>314.159</i>
(define circumference (* 2 pi radius))
circumference
<i>62.8318</i>
</pre></p>
<p></p>
<p></p>
<p><a name="%_idx_232" id="%_idx_232"></a><code>Define</code> is our language'ssimplest means of abstraction, for it allows us to use simple names torefer to the results of compound operations, such as the<code>circumference</code> computed above.In general, computational objects may have very complexstructures, and it would be extremely inconvenient to have to rememberand repeat their details each time we want to use them.  Indeed,complex programs are constructed by building, step by step,computational objects of increasing complexity. Theinterpreter makes this step-by-step program construction particularlyconvenient because name-object associations can be createdincrementally in successive interactions.  This feature encourages the<a name="%_idx_234" id="%_idx_234"></a><a name="%_idx_236" id="%_idx_236"></a>incremental development and testing of programs and is largelyresponsible for the fact that <a name="%_idx_238" id="%_idx_238"></a>a Lisp program usually consists of a largenumber of relatively simple procedures.</p>
<p>It should be clear that the possibility of associating values withsymbols and later retrieving them means that the interpreter mustmaintain some sort of memory that keeps track of the name-objectpairs.  This memory is called the <a name="%_idx_240" id="%_idx_240"></a><em>environment</em> (more preciselythe <a name="%_idx_242" id="%_idx_242"></a><em>global environment</em>, since we will see later that acomputation may involve a number of differentenvironments).<a name="call_footnote_Temp_15" href="#footnote_Temp_15" id="call_footnote_Temp_15"><sup><small>9</small></sup></a></p>
<p><a name="%_sec_1.1.3" id="%_sec_1.1.3"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_1.1.3">1.1.3  Evaluating Combinations</a></h3>
<p><a name="%_idx_244" id="%_idx_244"></a><a name="%_idx_246" id="%_idx_246"></a>One of our goals in this chapter is to isolate issues about thinkingprocedurally.  As a case in point, let us consider that, in evaluatingcombinations, the interpreter is itself following a procedure.</p>
<p></p>
<p></p>
<ul><li>To evaluate a combination, do the following:</li></ul>
<p></p>
<p></p>
<blockquote><p>1.  Evaluate the subexpressions of the combination.</p>
<p></p>
<p>2.  Apply the procedure that is the value of the leftmostsubexpression (the operator) to the arguments that are the values ofthe other subexpressions (the operands).</p>
</blockquote>
<p>Even this simple rule illustrates some important points aboutprocesses in general.  First, observe that the first step dictatesthat in order to accomplish the evaluation process for a combinationwe must first perform the evaluation process on each element of thecombination.  Thus, the evaluation rule is <a name="%_idx_248" id="%_idx_248"></a><em>recursive</em> in nature;that is, it includes, as one of its steps, the need to invoke the ruleitself.<a name="call_footnote_Temp_16" href="#footnote_Temp_16" id="call_footnote_Temp_16"><sup><small>10</small></sup></a></p>
<p><a name="%_idx_250" id="%_idx_250"></a>Notice how succinctly the idea of recursion can be used to expresswhat, in the case of a deeply nested combination, would otherwise beviewed as a rather complicated process.  For example, evaluating</p>
<p></p>
<p></p>
<p><pre>(* (+ 2 (* 4 6))
   (+ 3 5 7))
</pre></p>
<p></p>
<p>requires that the evaluation rule be applied to four differentcombinations.  We can obtain a picture of this process by <a name="%_idx_252" id="%_idx_252"></a>representingthe combination in the form of a <a name="%_idx_254" id="%_idx_254"></a>tree, as shown infigure <a href="#%_fig_1.1">1.1</a>.  Each combination is represented by a<a name="%_idx_256" id="%_idx_256"></a>node with <a name="%_idx_258" id="%_idx_258"></a>branches corresponding to the operator and theoperands of the combination stemming from it.The <a name="%_idx_260" id="%_idx_260"></a>terminal nodes (that is, nodes withno branches stemming from them) represent either operators or numbers.Viewing evaluation in terms of the tree, we can imagine that thevalues of the operands percolate upward, starting from the terminalnodes and then combining at higher and higher levels.  In general, weshall see that recursion is a very powerful technique for dealing withhierarchical, treelike objects.  In fact, the “percolate valuesupward” form of the evaluation rule is an example of a general kindof process known as <a name="%_idx_262" id="%_idx_262"></a><em>tree accumulation</em>.</p>
<p><a name="%_fig_1.1" id="%_fig_1.1"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch1-Z-G-1.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 1.1:</b>  Tree representation, showing the value of each subcombination.</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p>Next, observe that the repeated application of the first step bringsus to the point where we need to evaluate, not combinations, butprimitive expressions such as numerals, built-in operators, or othernames.  We take care of the primitive cases by stipulating that</p>
<p><a name="%_idx_264" id="%_idx_264"></a><a name="%_idx_266" id="%_idx_266"></a></p>
<p></p>
<ul>
<li>the values of numerals are the numbers that they name,<p></p>
</li>
<li>the values of built-in operators are the machineinstruction sequences that carry out the corresponding operations, and<p></p>
</li>
<li>the values of other names are the objects associatedwith those names in the environment.</li>
</ul>
<p></p>
<p>We may regard the second rule as a special case of the third one bystipulating that symbols such as <code>+</code> and <code>*</code> are also includedin the global environment, and are associated with the sequences ofmachine instructions that are their “values.”  The key point tonotice is the role of the <a name="%_idx_268" id="%_idx_268"></a>environment in determining the meaning ofthe symbols in expressions.  In an interactive language such asLisp, it is meaningless to speak of the value of an expression such as<code>(+ x 1)</code> without specifying any information about the environmentthat would provide a meaning for the symbol <code>x</code> (or even for thesymbol <code>+</code>).  As we shall see in chapter 3, the general notion ofthe environment as providing a context in which evaluation takes placewill play an important role in our understanding of program execution.</p>
<p><a name="%_idx_270" id="%_idx_270"></a>Notice that theevaluation rule given above does not handle definitions.For instance, evaluating<code>(define x 3)</code> does not apply <code>define</code> to two arguments, oneof which is the value of the symbol <code>x</code> and the other of which is3, since the purpose of the <code>define</code> is precisely to associate<code>x</code> with a value.(That is, <code>(define x 3)</code> is not a combination.)</p>
<p><a name="%_idx_272" id="%_idx_272"></a>Such exceptions to the general evaluation rule are called <em>specialforms</em>.  <code>Define</code> is the only example of a special form that wehave seen so far, but we will meet others shortly.  <a name="%_idx_274" id="%_idx_274"></a>Each special formhas its own evaluation rule. The various kinds of expressions (eachwith its associated evaluation rule) constitute the <a name="%_idx_276" id="%_idx_276"></a>syntax of theprogramming language.  In comparison with most other programminglanguages, Lisp has a very simple syntax; that is, the evaluation rulefor expressions can be described by a simple general rule togetherwith specialized rules for a small number of specialforms.<a name="call_footnote_Temp_17" href="#footnote_Temp_17" id="call_footnote_Temp_17"><sup><small>11</small></sup></a></p>
<p><a name="%_sec_1.1.4" id="%_sec_1.1.4"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_1.1.4">1.1.4  Compound Procedures</a></h3>
<p></p>
<p>We have identified in Lisp some of the elements that must appear inany powerful programming language:</p>
<p></p>
<p></p>
<ul>
<li>Numbers and arithmetic operations areprimitive data and procedures.<p></p>
</li>
<li>Nesting of combinations provides a means ofcombining operations.<p></p>
</li>
<li>Definitions that associate names with values provide alimited means of abstraction.</li>
</ul>
<p></p>
<p>Now we will learn about<a name="%_idx_292" id="%_idx_292"></a><em>procedure definitions</em>, a much more powerful abstractiontechnique by which a compound operation can be given a name and thenreferred to as a unit.</p>
<p>We begin by examining how to express the idea of “squaring.”  Wemight say, “To square something, multiply it by itself.”  This isexpressed in our language as </p>
<p></p>
<p></p>
<p><pre><a name="%_idx_294" id="%_idx_294"></a>(define (square x) (* x x))
</pre></p>
<p></p>
<p></p>
<p>We can understand this in the following way:</p>
<p></p>
<p></p>
<p><pre>(define (square  x)        (*         x     x))
   ↑        ↑     ↑          ↑         ↑    ↑
 To      square something, multiply   it by itself.
</pre></p>
<p></p>
<p><a name="%_idx_296" id="%_idx_296"></a><a name="%_idx_298" id="%_idx_298"></a>We have here a <em>compound procedure</em>, which has been given the name<code>square</code>.  The procedure represents the operation of multiplyingsomething by itself.  The thing to be multiplied is given a localname, <code>x</code>, which plays the same role that a pronoun plays innatural language.  <a name="%_idx_300" id="%_idx_300"></a><a name="%_idx_302" id="%_idx_302"></a><a name="%_idx_304" id="%_idx_304"></a>Evaluating the definition creates thiscompound procedure and associates it with the name <code>square</code>.<a name="call_footnote_Temp_18" href="#footnote_Temp_18" id="call_footnote_Temp_18"><sup><small>12</small></sup></a></p>
<p><a name="%_idx_306" id="%_idx_306"></a><a name="%_idx_308" id="%_idx_308"></a>The general form of a procedure definition is</p>
<p></p>
<p></p>
<p><pre>(define (&lt;<em>name</em>&gt; &lt;<em>formal parameters</em>&gt;) &lt;<em>body</em>&gt;)
</pre></p>
<p></p>
<p><a name="%_idx_310" id="%_idx_310"></a><a name="%_idx_312" id="%_idx_312"></a>The &lt;<em>name</em>&gt; is a symbol to be associated with the proceduredefinition in the environment.<a name="call_footnote_Temp_19" href="#footnote_Temp_19" id="call_footnote_Temp_19"><sup><small>13</small></sup></a>The <a name="%_idx_318" id="%_idx_318"></a><a name="%_idx_320" id="%_idx_320"></a>&lt;<em>formal parameters</em>&gt; arethe names used within the body of the procedure to refer to thecorresponding arguments of the procedure.  The<a name="%_idx_322" id="%_idx_322"></a><a name="%_idx_324" id="%_idx_324"></a>&lt;<em>body</em>&gt; is an expression that will yield the value ofthe procedure application when the formal parameters are replaced bythe actual arguments to which the procedure is applied.<a name="call_footnote_Temp_20" href="#footnote_Temp_20" id="call_footnote_Temp_20"><sup><small>14</small></sup></a>The &lt;<em>name</em>&gt;and the &lt;<em>formal parameters</em>&gt;are grouped within <a name="%_idx_328" id="%_idx_328"></a>parentheses, just as theywould be in an actual call to the procedure being defined.</p>
<p>Having defined <code>square</code>, we can now use it:</p>
<p></p>
<p></p>
<p><pre>(square 21)
<i>441</i>

(square (+ 2 5))
<i>49</i>

(square (square 3))
<i>81</i>
</pre></p>
<p></p>
<p></p>
<p>We can also use <code>square</code> as a building block in defining otherprocedures.  For example, <em>x</em><sup>2</sup>  + <em>y</em><sup>2</sup> can be expressed as</p>
<p></p>
<p></p>
<p><pre>(+ (square x) (square y))
</pre></p>
<p></p>
<p>We can easily define a procedure<code>sum-of-squares</code> that, given any two numbers as arguments, produces thesum of their squares:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_330" id="%_idx_330"></a>(define (sum-of-squares x y)
  (+ (square x) (square y)))

(sum-of-squares 3 4)
<i>25</i>
</pre></p>
<p></p>
<p>Now we can use <code>sum-of-squares</code> as a building block in constructingfurther procedures:</p>
<p></p>
<p></p>
<p><pre>(define (f a)
  (sum-of-squares (+ a 1) (* a 2)))

(f 5)
<i>136</i>
</pre></p>
<p></p>
<p><a name="%_idx_332" id="%_idx_332"></a>Compound procedures are used in exactly the same way as primitiveprocedures.  Indeed, one could not tell by looking at the definitionof <code>sum-of-squares</code> given above whether <code>square</code> was built intothe interpreter, like <code>+</code> and <code>*</code>, or defined as a compound procedure.</p>
<p><a name="%_sec_1.1.5" id="%_sec_1.1.5"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_1.1.5">1.1.5  The Substitution Model for Procedure Application</a></h3>
<p><a name="%_idx_334" id="%_idx_334"></a>To evaluate a combination whose operator names a compound procedure, theinterpreter follows much the same process as for combinations whoseoperators name primitive procedures, which we described insection <a href="#%_sec_1.1.3">1.1.3</a>.  That is, the interpreterevaluates the elements of the combination and applies the procedure(which is the value of the operator of the combination) to thearguments (which are the values of the operands of the combination).</p>
<p>We can assume that the mechanism for applying primitive procedures toarguments is built into the interpreter.  For compound procedures, theapplication process is as follows:</p>
<p></p>
<p></p>
<ul><li>To apply a compound procedure to arguments, evaluate the body of theprocedure with each formal parameter replaced by the correspondingargument.</li></ul>
<p></p>
<p>To illustrate this process, let's evaluate the combination</p>
<p></p>
<p></p>
<p><pre>(f 5)
</pre></p>
<p></p>
<p>where <code>f</code> is the procedure defined insection <a href="#%_sec_1.1.4">1.1.4</a>.  We begin by retrieving thebody of <code>f</code>:</p>
<p></p>
<p></p>
<p><pre>(sum-of-squares (+ a 1) (* a 2))
</pre></p>
<p></p>
<p>Then we replace the formal parameter <code>a</code> by the argument 5:</p>
<p></p>
<p></p>
<p><pre>(sum-of-squares (+ 5 1) (* 5 2))
</pre></p>
<p></p>
<p>Thus the problem reduces to the evaluation of a combination with twooperands and an operator <code>sum-of-squares</code>.  Evaluating thiscombination involves three subproblems.  We must evaluate theoperator to get the procedure to be applied, and we must evaluate theoperands to get the arguments.  Now <code>(+ 5 1)</code> produces 6 and<code>(* 5 2)</code> produces 10, so we must apply the<code>sum-of-squares</code> procedure to 6 and 10.  These values are substitutedfor the formal parameters <code>x</code> and <code>y</code> in the body of <code>sum-of-squares</code>,reducing the expression to</p>
<p></p>
<p></p>
<p><pre>(+ (square 6) (square 10))
</pre></p>
<p></p>
<p>If we use the definition of <code>square</code>, this reduces to</p>
<p></p>
<p></p>
<p><pre>(+ (* 6 6) (* 10 10))
</pre></p>
<p></p>
<p>which reduces by multiplication to</p>
<p></p>
<p></p>
<p><pre>(+ 36 100)
</pre></p>
<p></p>
<p>and finally to</p>
<p></p>
<p></p>
<p><pre>136
</pre></p>
<p></p>
<p></p>
<p>The process we have just described is called the <em>substitutionmodel</em> for procedure application.  It can be taken as a model thatdetermines the “meaning” of procedure application, insofar as theprocedures in this chapter are concerned.  However, there are twopoints that should be stressed:</p>
<p></p>
<p></p>
<ul>
<li>The purpose of the substitution is to help us think aboutprocedure application, not to provide a description of howthe interpreter really works.  Typical interpreters do not evaluateprocedure applications by manipulating the text of a procedure tosubstitute values for the formal parameters.  In practice, the“substitution” is accomplished by using a local environment for theformal parameters.  We will discuss this more fully in chapters 3 and4 when we examine the implementation of an interpreter in detail.<p></p>
</li>
<li>Over the course of this book, we will present a sequence ofincreasingly elaborate models of how interpreters work, culminatingwith a complete implementation of an interpreter and compiler inchapter 5.  The substitution model is only the first of thesemodels – a way to get started thinking formally about the evaluationprocess.  In general, when <a name="%_idx_336" id="%_idx_336"></a>modeling phenomena in science andengineering, we begin with simplified, incomplete models.  As weexamine things in greater detail, these simple models becomeinadequate and must be replaced by more refined models.  Thesubstitution model is no exception.  In particular, when we address inchapter 3 the use of procedures with “mutable data,” we will see thatthe substitution model breaks down and must be replaced by a morecomplicated model of procedure application.<a name="call_footnote_Temp_21" href="#footnote_Temp_21" id="call_footnote_Temp_21"><sup><small>15</small></sup></a></li>
</ul>
<p></p>
<p><a name="%_sec_Temp_22" id="%_sec_Temp_22"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_22">Applicative order versus normal order</a></h4>
<p>According to the description of evaluation given insection <a href="#%_sec_1.1.3">1.1.3</a>, the interpreter firstevaluates the operator and operands and then applies the resulting procedureto the resulting arguments.  This is not the only way to performevaluation.  An alternative evaluation model would not evaluate theoperands until their values were needed.  Instead it would first substituteoperand expressions for parameters untilit obtained an expression involving only primitive operators, andwould then perform the evaluation.  If we used this method, theevaluation of</p>
<p></p>
<p></p>
<p><pre>(f 5)
</pre></p>
<p></p>
<p>would proceed according to the sequence of expansions</p>
<p></p>
<p></p>
<p><pre>(sum-of-squares (+ 5 1) (* 5 2))

(+    (square (+ 5 1))      (square (* 5 2))  )

(+    (* (+ 5 1) (+ 5 1))   (* (* 5 2) (* 5 2)))
</pre></p>
<p></p>
<p>followed by the reductions</p>
<p></p>
<p></p>
<p><pre>(+         (* 6 6)             (* 10 10))

(+           36                   100)

                    136
</pre></p>
<p></p>
<p>This gives the same answer as our previous evaluation model, but theprocess is different.  In particular, the evaluationsof <code>(+ 5 1)</code> and <code>(* 5 2)</code> are each performed twice here,corresponding to the reduction of the expression</p>
<p></p>
<p></p>
<p><pre>(* x x)
</pre></p>
<p></p>
<p>with <code>x</code> replaced respectively by <code>(+ 5 1)</code> and <code>(* 5 2)</code>.</p>
<p>This alternative “fully expand and then reduce” evaluation method isknown as <a name="%_idx_340" id="%_idx_340"></a><em>normal-order evaluation</em>, in contrast to the “evaluatethe arguments and then apply” method that the interpreter actuallyuses, which is called <a name="%_idx_342" id="%_idx_342"></a><em>applicative-order evaluation</em>.  It can beshown that, for procedure applications that can be modeled usingsubstitution (including all the procedures in the first two chaptersof this book) and that yield legitimate values, normal-order andapplicative-order evaluation produce the same value.  (Seeexercise <a href="#%_thm_1.5">1.5</a> for an instance ofan “illegitimate” value where normal-order and applicative-orderevaluation do not give the same result.)</p>
<p><a name="%_idx_344" id="%_idx_344"></a><a name="%_idx_346" id="%_idx_346"></a>Lisp uses applicative-order evaluation, partly because of theadditional efficiency obtained from avoiding multiple evaluations ofexpressions such as those illustrated with <code>(+ 5 1)</code> and <code>(* 52)</code> above and, more significantly, because normal-order evaluationbecomes much more complicated to deal with when we leave the realm ofprocedures that can be modeled by substitution.  On the other hand,normal-order evaluation can be an extremely valuable tool, and we willinvestigate some of its implications in chapters 3 and 4.<a name="call_footnote_Temp_23" href="#footnote_Temp_23" id="call_footnote_Temp_23"><sup><small>16</small></sup></a></p>
<p><a name="%_sec_1.1.6" id="%_sec_1.1.6"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_1.1.6">1.1.6  Conditional Expressions and Predicates</a></h3>
<p></p>
<p>The expressive power of the class of procedures that we can define atthis point is very limited, because we have no way to make tests andto perform different operations depending on the result of a test.For instance, we cannot define a procedure that computes the <a name="%_idx_348" id="%_idx_348"></a>absolutevalue of a number by testing whether the number is positive, negative,or zero and taking different actions in the different cases accordingto the rule</p>
<p></p>
<p></p>
<div align="left"><img src="images/ch1-Z-G-2.gif" border="0"></div>
<p></p>
<p><a name="%_idx_350" id="%_idx_350"></a>This construct is called a <em>case analysis</em>, andthere is a special form in Lisp for notating such a caseanalysis.  It is called <a name="%_idx_352" id="%_idx_352"></a><a name="%_idx_354" id="%_idx_354"></a><a name="%_idx_356" id="%_idx_356"></a><code>cond</code> (which stands for“conditional”), and it is used as follows:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_358" id="%_idx_358"></a>(define (abs x)
  (cond ((&gt; x 0) x)
        ((= x 0) 0)
        ((&lt; x 0) (- x))))
</pre></p>
<p></p>
<p>The general form of a conditional expression is</p>
<p></p>
<p></p>
<p><pre>(cond (&lt;<em>p<sub>1</sub></em>&gt; &lt;<em>e<sub>1</sub></em>&gt;)
      (&lt;<em>p<sub>2</sub></em>&gt; &lt;<em>e<sub>2</sub></em>&gt;)
      ⋮
      (&lt;<em>p<sub><em>n</em></sub></em>&gt; &lt;<em>e<sub><em>n</em></sub></em>&gt;))
</pre></p>
<p></p>
<p>consisting of the symbol <code>cond</code> followed by<a name="%_idx_360" id="%_idx_360"></a>parenthesized pairs of expressions <code>(&lt;<em>p</em>&gt; &lt;<em>e</em>&gt;)</code>called <a name="%_idx_362" id="%_idx_362"></a><a name="%_idx_364" id="%_idx_364"></a><em>clauses</em>. The first expression in each pair is a <a name="%_idx_366" id="%_idx_366"></a><em>predicate</em> – that is, an expression whose value is interpreted aseither true or false.<a name="call_footnote_Temp_24" href="#footnote_Temp_24" id="call_footnote_Temp_24"><sup><small>17</small></sup></a></p>
<p><a name="%_idx_384" id="%_idx_384"></a><a name="%_idx_386" id="%_idx_386"></a>Conditional expressions are evaluated as follows.  The predicate&lt;<em>p<sub>1</sub></em>&gt; is evaluated first.  If its value is false, then&lt;<em>p<sub>2</sub></em>&gt; is evaluated.  If &lt;<em>p<sub>2</sub></em>&gt;'s value is also false, then&lt;<em>p<sub>3</sub></em>&gt; is evaluated.  This process continues until a predicate isfound whose value is true, in which case the interpreter returns thevalue of the corresponding <a name="%_idx_388" id="%_idx_388"></a><em>consequent expression</em> &lt;<em>e</em>&gt; of theclause as the value of the conditional expression.  If none of the&lt;<em>p</em>&gt;'s is found to be true, the value of the <code>cond</code> isundefined.</p>
<p><a name="%_idx_390" id="%_idx_390"></a>The word <em>predicate</em> is used for procedures that return trueor false, as well as for expressions that evaluate to true or false.The absolute-value procedure <code>abs</code> makes use of the <a name="%_idx_392" id="%_idx_392"></a><a name="%_idx_394" id="%_idx_394"></a><a name="%_idx_396" id="%_idx_396"></a><a name="%_idx_398" id="%_idx_398"></a><a name="%_idx_400" id="%_idx_400"></a><a name="%_idx_402" id="%_idx_402"></a><a name="%_idx_404" id="%_idx_404"></a><a name="%_idx_406" id="%_idx_406"></a><a name="%_idx_408" id="%_idx_408"></a>primitivepredicates <code>&gt;</code>, <code>&lt;</code>, and <code>=</code>.<a name="call_footnote_Temp_25" href="#footnote_Temp_25" id="call_footnote_Temp_25"><sup><small>18</small></sup></a> These take twonumbers as arguments and test whether the first number is,respectively, greater than, less than, or equal to the second number,returning true or false accordingly.</p>
<p>Another way to write the absolute-value procedure is</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_414" id="%_idx_414"></a>(define (abs x)
  (cond ((&lt; x 0) (- x))
        (else x)))
</pre></p>
<p></p>
<p>which could be expressed in English as “If <em>x</em> is less than zeroreturn  - <em>x</em>; otherwise return <em>x</em>.”  <a name="%_idx_416" id="%_idx_416"></a><code>Else</code> is a special symbolthat can be used in place of the &lt;<em>p</em>&gt; in the final clause of a <code>cond</code>.  This causes the <code>cond</code> to return as its value the value ofthe corresponding &lt;<em>e</em>&gt; whenever all previous clauses have beenbypassed.  In fact, any expression that always evaluates to a truevalue could be used as the &lt;<em>p</em>&gt; here.</p>
<p>Here is yet another way to write the absolute-value procedure:</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_418" id="%_idx_418"></a>(define (abs x)
  (if (&lt; x 0)
      (- x)
      x))
</pre></p>
<p></p>
<p><a name="%_idx_420" id="%_idx_420"></a><a name="%_idx_422" id="%_idx_422"></a><a name="%_idx_424" id="%_idx_424"></a>This uses the special form <code>if</code>, a restricted type of conditionalthat can be used when there are precisely <a name="%_idx_426" id="%_idx_426"></a>two cases in the caseanalysis.  The general form of an <code>if</code> expression is</p>
<p></p>
<p></p>
<p><pre>(if &lt;<em>predicate</em>&gt; &lt;<em>consequent</em>&gt; &lt;<em>alternative</em>&gt;)
</pre></p>
<p></p>
<p><a name="%_idx_428" id="%_idx_428"></a><a name="%_idx_430" id="%_idx_430"></a><a name="%_idx_432" id="%_idx_432"></a>To evaluate an <code>if</code> expression, the interpreter starts by evaluatingthe <a name="%_idx_434" id="%_idx_434"></a>&lt;<em>predicate</em>&gt; part of the expression.  If the &lt;<em>predicate</em>&gt;evaluates to a true value, the interpreter then evaluatesthe <a name="%_idx_436" id="%_idx_436"></a>&lt;<em>consequent</em>&gt; and returns its value.  Otherwise it evaluatesthe <a name="%_idx_438" id="%_idx_438"></a>&lt;<em>alternative</em>&gt; and returns its value.<a name="call_footnote_Temp_26" href="#footnote_Temp_26" id="call_footnote_Temp_26"><sup><small>19</small></sup></a></p>
<p>In addition to primitivepredicates such as <code>&lt;</code>, <code>=</code>, and <code>&gt;</code>, there are logicalcomposition operations, which enable us to construct compoundpredicates.  The three most frequently used are these:</p>
<p></p>
<p></p>
<ul>
<a name="%_idx_446" id="%_idx_446"></a><a name="%_idx_448" id="%_idx_448"></a><a name="%_idx_450" id="%_idx_450"></a><a name="%_idx_452" id="%_idx_452"></a><li>
<code>(and &lt;<em>e<sub>1</sub></em>&gt; <code>...</code> &lt;<em>e<sub><em>n</em></sub></em>&gt;)</code><p>The interpreterevaluates the expressions &lt;<em>e</em>&gt; one at a time, in left-to-right order.  Ifany &lt;<em>e</em>&gt; evaluates to false, the value of the <code>and</code>expression is false, and the rest of the &lt;<em>e</em>&gt;'s are not evaluated.If all &lt;<em>e</em>&gt;'s evaluate to true values, the value of the <code>and</code>expression is the value of the last one.</p>
<p><a name="%_idx_454" id="%_idx_454"></a><a name="%_idx_456" id="%_idx_456"></a><a name="%_idx_458" id="%_idx_458"></a><a name="%_idx_460" id="%_idx_460"></a></p>
</li>
<li>
<code>(or &lt;<em>e<sub>1</sub></em>&gt; <code>...</code> &lt;<em>e<sub><em>n</em></sub></em>&gt;)</code><p>The interpreterevaluates the expressions &lt;<em>e</em>&gt; one at a time, in left-to-right order.  Ifany &lt;<em>e</em>&gt; evaluates to a true value, that value isreturned as the value of the <code>or</code> expression,and the rest of the &lt;<em>e</em>&gt;'s are not evaluated.If all &lt;<em>e</em>&gt;'s evaluate to false,the value of the <code>or</code> expression is false.</p>
<p><a name="%_idx_462" id="%_idx_462"></a><a name="%_idx_464" id="%_idx_464"></a></p>
</li>
<li>
<code>(not &lt;<em>e</em>&gt;)</code><p>The value of a <code>not</code> expression is truewhen the expression &lt;<em>e</em>&gt; evaluates to false, and false otherwise.</p>
</li>
</ul>
<p></p>
<p><a name="%_idx_466" id="%_idx_466"></a><a name="%_idx_468" id="%_idx_468"></a>Notice that <code>and</code> and <code>or</code> are special forms, not procedures,because the subexpressions are not necessarily all evaluated.<code>Not</code> is an ordinary procedure.</p>
<p>As an example of how these are used, the condition that a number <em>x</em>be in the range 5 &lt; <em>x</em> &lt; 10 may be expressed as</p>
<p></p>
<p></p>
<p><pre>(and (&gt; x 5) (&lt; x 10))
</pre></p>
<p></p>
<p>As another example, we can define a predicate to test whether onenumber is greater than or equal to another as</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_470" id="%_idx_470"></a>(define (&gt;= x y)
  (or (&gt; x y) (= x y)))
</pre></p>
<p></p>
<p>or alternatively as</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_472" id="%_idx_472"></a>(define (&gt;= x y)
  (not (&lt; x y)))
</pre></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_1.1" id="%_thm_1.1"></a><b>Exercise 1.1.</b>  Below is a sequence of expressions.What is the result printed by the interpreter in response to eachexpression?  Assume that the sequence is to be evaluated in the orderin which it is presented.</p>
<p></p>
<p></p>
<p><pre>10
(+ 5 3 4)
(- 9 1)
(/ 6 2)
(+ (* 2 4) (- 4 6))
(define a 3)
(define b (+ a 1))
(+ a b (* a b))
(= a b)
(if (and (&gt; b a) (&lt; b (* a b)))
    b
    a)
(cond ((= a 4) 6)
      ((= b 4) (+ 6 7 a))
      (else 25))
(+ 2 (if (&gt; b a) b a))
(* (cond ((&gt; a b) a)
         ((&lt; a b) b)
         (else -1))
   (+ a 1))
</pre></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_1.2" id="%_thm_1.2"></a><b>Exercise 1.2.</b>  Translate the following expression into prefix form</p>
<p></p>
<div align="left"><img src="images/ch1-Z-G-3.gif" border="0"></div>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_1.3" id="%_thm_1.3"></a><b>Exercise 1.3.</b>  Define a procedure that takes three numbers as arguments and returnsthe sum of the squares of the two larger numbers.</p>
<p></p>
<p></p>
<p><a name="%_thm_1.4" id="%_thm_1.4"></a><b>Exercise 1.4.</b>  <a name="%_idx_474" id="%_idx_474"></a><a name="%_idx_476" id="%_idx_476"></a><a name="%_idx_478" id="%_idx_478"></a>Observe that our model of evaluation allows for combinations whoseoperators are compound expressions.  Use this observation todescribe the behavior of the following procedure:</p>
<p></p>
<p><pre>(define (a-plus-abs-b a b)
  ((if (&gt; b 0) + -) a b))
</pre></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p><a name="%_thm_1.5" id="%_thm_1.5"></a><b>Exercise 1.5.</b>  <a name="%_idx_480" id="%_idx_480"></a><a name="%_idx_482" id="%_idx_482"></a>Ben Bitdiddle has invented a test to determine whether the interpreterhe is faced with is using applicative-order evaluation or normal-orderevaluation.  He defines the following two procedures:</p>
<p></p>
<p><pre>(define (p) (p))

(define (test x y)
  (if (= x 0)
      0
      y))
</pre></p>
<p></p>
<p>Then he evaluates the expression</p>
<p></p>
<p><pre>(test 0 (p))
</pre></p>
<p></p>
<p>What behavior will Ben observe with an interpreter that usesapplicative-order evaluation?  What behavior will he observe with aninterpreter that uses normal-order evaluation?  Explain your answer.<a name="%_idx_484" id="%_idx_484"></a><a name="%_idx_486" id="%_idx_486"></a>(Assume that the evaluation rule for the special form <code>if</code> is thesame whether the interpreter is using normal or applicative order:The predicate expression is evaluated first, and the resultdetermines whether to evaluatethe consequent or the alternative expression.)</p>
<p></p>
<p><a name="%_sec_1.1.7" id="%_sec_1.1.7"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_1.1.7">1.1.7  Example: Square Roots by Newton's Method</a></h3>
<p></p>
<p><a name="%_idx_488" id="%_idx_488"></a><a name="%_idx_490" id="%_idx_490"></a>Procedures, as introduced above, are much like ordinary mathematicalfunctions.  They specify a value that is determined by one or moreparameters.  But there is an important difference betweenmathematical functions and computer procedures.  Procedures must beeffective.</p>
<p>As a case in point, consider the problem of computing squareroots.  We can define the square-root function as</p>
<p></p>
<div align="left"><img src="images/ch1-Z-G-4.gif" border="0"></div>
<p></p>
<p>This describes a perfectly legitimate mathematical function.  We coulduse it to recognize whether one number is the square root of another, orto derive facts about square roots in general.  On the other hand, thedefinition does not describe a procedure.  Indeed, it tells us almostnothing about how to actually find the square root of a given number.  Itwill not help matters to rephrase this definition in pseudo-Lisp:</p>
<p></p>
<p></p>
<p><pre>(define (sqrt x)
  (the y (and (&gt;= y 0)
              (= (square y) x))))
</pre></p>
<p></p>
<p>This only begs the question.</p>
<p>The contrast between function and procedure is a reflection of thegeneral distinction between describing properties of things anddescribing how to do things, or, as it is sometimes referred to, thedistinction between <a name="%_idx_492" id="%_idx_492"></a><a name="%_idx_494" id="%_idx_494"></a>declarative knowledge and imperative knowledge.In <a name="%_idx_496" id="%_idx_496"></a><a name="%_idx_498" id="%_idx_498"></a>mathematics we are usually concerned with declarative (what is)descriptions, whereas in computer science we are usually concernedwith imperative (how to) descriptions.<a name="call_footnote_Temp_32" href="#footnote_Temp_32" id="call_footnote_Temp_32"><sup><small>20</small></sup></a></p>
<p><a name="%_idx_508" id="%_idx_508"></a><a name="%_idx_510" id="%_idx_510"></a>How does one compute square roots?  The most common way is to useNewton's method of successive approximations, which says that wheneverwe have a guess <em>y</em> for the value of the square root of a number <em>x</em>,we can perform a simple manipulation to get a better guess (one closerto the actual square root) by averaging <em>y</em> with<em>x</em>/<em>y</em>.<a name="call_footnote_Temp_33" href="#footnote_Temp_33" id="call_footnote_Temp_33"><sup><small>21</small></sup></a> For example, we can computethe square root of 2 as follows.  Suppose our initial guess is 1:</p>
<p></p>
<table border="0">
<tr>
<td valign="top">Guess </td>
<td valign="top">Quotient </td>
<td valign="top">Average</td>
</tr>
<tr><td valign="top">  </td></tr>
<tr>
<td valign="top">1      </td>
<td valign="top"> (2/1)  =  2        </td>
<td valign="top">((2 + 1)/2)  =  1.5 </td>
</tr>
<tr><td valign="top">  </td></tr>
<tr>
<td valign="top">1.5    </td>
<td valign="top"> (2/1.5)  =  1.3333 </td>
<td valign="top">((1.3333 + 1.5)/2)  =  1.4167 </td>
</tr>
<tr><td valign="top">  </td></tr>
<tr>
<td valign="top">1.4167 </td>
<td valign="top"> (2/1.4167)  =  1.4118 </td>
<td valign="top">((1.4167 + 1.4118)/2)  =  1.4142 </td>
</tr>
<tr><td valign="top">  </td></tr>
<tr>
<td valign="top">1.4142 </td>
<td valign="top"><code>...</code></td>
<td valign="top"><code>...</code></td>
</tr>
<tr><td valign="top"></td></tr>
</table>
<p>Continuing this process, we obtain better and betterapproximations to the square root.</p>
<p>Now let's formalize the process in terms of procedures.  We start witha value for the <a name="%_idx_514" id="%_idx_514"></a>radicand (the number whose square root we are tryingto compute) and a value for the guess.  If the guess is good enoughfor our purposes, we are done; if not, we must repeat the process with animproved guess.  We write this basic strategy as a procedure:</p>
<p></p>
<p></p>
<p><pre>(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x)
                 x)))
</pre></p>
<p></p>
<p>A guess is improved by averagingit with the quotient of the radicand and the old guess:</p>
<p></p>
<p></p>
<p><pre>(define (improve guess x)
  (average guess (/ x guess)))
</pre></p>
<p></p>
<p>where</p>
<p></p>
<p></p>
<p><pre><a name="%_idx_516" id="%_idx_516"></a>(define (average x y)
  (/ (+ x y) 2))
</pre></p>
<p></p>
<p>We also have to say what we mean by “good enough.”  Thefollowing will do for illustration, but it is not really a very goodtest.  (See exercise <a href="#%_thm_1.7">1.7</a>.)The idea is to improve the answer until it is close enough so that itssquare differs from the radicand by less than a predeterminedtolerance (here 0.001):<a name="call_footnote_Temp_34" href="#footnote_Temp_34" id="call_footnote_Temp_34"><sup><small>22</small></sup></a></p>
<p></p>
<p></p>
<p><pre>(define (good-enough? guess x)
  (&lt; (abs (- (square guess) x)) 0.001))
</pre></p>
<p></p>
<p>Finally, we need a way to get started.  For instance, we canalways guess that the square root of any number is 1:<a name="call_footnote_Temp_35" href="#footnote_Temp_35" id="call_footnote_Temp_35"><sup><small>23</small></sup></a></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_550" id="%_idx_550"></a>(define (sqrt x)
  (sqrt-iter 1.0 x))
</pre></p>
<p></p>
<p>If we type these definitions to the interpreter, we can use <code>sqrt</code>just as we can use any procedure:</p>
<p></p>
<p></p>
<p><pre>(sqrt 9)
<i>3.00009155413138</i>
(sqrt (+ 100 37))
<i>11.704699917758145</i>
(sqrt (+ (sqrt 2) (sqrt 3)))
<i>1.7739279023207892</i>
(square (sqrt 1000))
<i>1000.000369924366</i>
</pre></p>
<p></p>
<p></p>
<p><a name="%_idx_552" id="%_idx_552"></a>The <code>sqrt</code> program also illustrates that the simple procedurallanguage we have introduced so far is sufficient for writing anypurely numerical program that one could write in, say, C orPascal.  This might seem surprising, since we have not included inour language any iterative <a name="%_idx_554" id="%_idx_554"></a>(looping) constructs that direct thecomputer to do something over and over again.  <code>Sqrt-iter</code>, on theother hand, demonstrates how iteration can be accomplished using nospecial construct other than the ordinary ability to call aprocedure.<a name="call_footnote_Temp_36" href="#footnote_Temp_36" id="call_footnote_Temp_36"><sup><small>24</small></sup></a></p>
<p><a name="%_thm_1.6" id="%_thm_1.6"></a><b>Exercise 1.6.</b>  <a name="%_idx_556" id="%_idx_556"></a><a name="%_idx_558" id="%_idx_558"></a>Alyssa P. Hacker doesn't see why <code>if</code> needsto be provided as a special form.  “Why can't I just define it as anordinary procedure in terms of <code>cond</code>?” she asks.Alyssa's friend Eva Lu Ator claims this can indeed be done, andshe defines a new version of <code>if</code>:</p>
<p></p>
<p></p>
<p><pre>(define (new-if predicate then-clause else-clause)
  (cond (predicate then-clause)
        (else else-clause)))
</pre></p>
<p></p>
<p>Eva demonstrates the program for Alyssa:</p>
<p></p>
<p></p>
<p><pre>(new-if (= 2 3) 0 5)
<i>5</i>

(new-if (= 1 1) 0 5)
<i>0</i>
</pre></p>
<p></p>
<p>Delighted, Alyssa uses <code>new-if</code> to rewrite the square-rootprogram:</p>
<p></p>
<p></p>
<p><pre>(define (sqrt-iter guess x)
  (new-if (good-enough? guess x)
          guess
          (sqrt-iter (improve guess x)
                     x)))
</pre></p>
<p></p>
<p>What happens when Alyssa attempts to use this to compute square roots?Explain.</p>
<p></p>
<p></p>
<p><a name="%_thm_1.7" id="%_thm_1.7"></a><b>Exercise 1.7.</b>  The <code>good-enough?</code> test used in computing square roots will not bevery effective for finding the square roots of very small numbers.Also, in real computers, arithmetic operations are almost alwaysperformed with limited precision.  This makes our test inadequate forvery large numbers.  Explain these statements, with examples showinghow the test fails for small and large numbers.  An alternativestrategy for implementing <code>good-enough?</code> is to watch how <code>guess</code> changes from one iteration to the next and to stop when thechange is a very small fraction of the guess.  Design a square-rootprocedure that uses this kind of end test.  Does this work better forsmall and large numbers?</p>
<p></p>
<p></p>
<p><a name="%_thm_1.8" id="%_thm_1.8"></a><b>Exercise 1.8.</b>  <a name="%_idx_560" id="%_idx_560"></a><a name="%_idx_562" id="%_idx_562"></a>Newton's method for cube roots is based on the fact that if <em>y</em> is anapproximation to the cube root of <em>x</em>, then a better approximation isgiven by the value</p>
<p></p>
<div align="left"><img src="images/ch1-Z-G-5.gif" border="0"></div>
<p>Use this formula to implement a cube-root procedure analogous to thesquare-root procedure.  (In section <a href="book-Z-H-12.html#%_sec_1.3.4">1.3.4</a> wewill see how to implement Newton's method in general as an abstractionof these square-root and cube-root procedures.)</p>
<p></p>
<p><a name="%_sec_1.1.8" id="%_sec_1.1.8"></a></p>
<h3><a href="book-Z-H-4.html#%_toc_%_sec_1.1.8">1.1.8  Procedures as Black-Box Abstractions</a></h3>
<p></p>
<p><code>Sqrt</code> is our first example of a process defined by a set ofmutually defined procedures.  Notice that the definition of <code>sqrt-iter</code> is <a name="%_idx_564" id="%_idx_564"></a><em>recursive</em>; that is, the procedure is defined interms of itself.  The idea of being able to define a procedure interms of itself may be disturbing; it may seem unclear how such a“circular” definition could make sense at all, much less specify awell-defined process to be carried out by a computer.  This will beaddressed more carefully insection <a href="book-Z-H-11.html#%_sec_1.2">1.2</a>.  But first let's considersome other important points illustrated by the <code>sqrt</code> example.</p>
<p><a name="%_idx_566" id="%_idx_566"></a>Observe that the problem of computing square roots breaks up naturallyinto a number of subproblems: how to tell whether a guess is goodenough, how to improve a guess, and so on.  Each of these tasks isaccomplished by a separate procedure.  The entire <code>sqrt</code> programcan be viewed as a cluster of procedures (shown infigure <a href="#%_fig_1.2">1.2</a>) that mirrors the decomposition ofthe problem into subproblems.</p>
<p><a name="%_fig_1.2" id="%_fig_1.2"></a></p>
<p></p>
<div align="left"><table width="100%">
<tr><td><img src="images/ch1-Z-G-6.gif" border="0"></td></tr>
<caption align="bottom"><div align="left">
<b>Figure 1.2:</b>  Procedural decomposition of the <code>sqrt</code> program.</div></caption>
<tr><td></td></tr>
</table></div>
<p></p>
<p><a name="%_idx_568" id="%_idx_568"></a>The importance of this decomposition strategy is not simply that oneis dividing the program into parts.  After all, we could take anylarge program and divide it into parts – the first ten lines, the nextten lines, the next ten lines, and so on.  Rather, it is crucial thateach procedure accomplishes an identifiable task that can be used as amodule in defining other procedures.  <a name="%_idx_570" id="%_idx_570"></a>For example, when we define the<code>good-enough?</code> procedure in terms of <code>square</code>, we are able toregard the <code>square</code> procedure as a <a name="%_idx_572" id="%_idx_572"></a>“black box.”  We are not atthat moment concerned with <em>how</em> the procedure computes itsresult, only with the fact that it computes the square.  The detailsof how the square is computed can be suppressed, to be considered at alater time.  Indeed, as far as the <code>good-enough?</code> procedure isconcerned, <code>square</code> is not quite a procedure but rather anabstraction of a procedure, a so-called <a name="%_idx_574" id="%_idx_574"></a><a name="%_idx_576" id="%_idx_576"></a><em>procedural abstraction</em>.At this level of abstraction, any procedure that computes the squareis equally good.</p>
<p>Thus, considering only the values they return, the following two procedures forsquaring a number should be indistinguishable.  Each takes a numericalargument and produces the square of that number as thevalue.<a name="call_footnote_Temp_40" href="#footnote_Temp_40" id="call_footnote_Temp_40"><sup><small>25</small></sup></a></p>
<p></p>
<p></p>
<p><pre>(define (square x) (* x x))

(define (square x) 
  (exp (double (log x))))

(define (double x) (+ x x))
</pre></p>
<p></p>
<p></p>
<p>So a procedure definition should be able to suppress detail.  Theusers of the procedure may not have written the procedure themselves,but may have obtained it from another programmer as a black box.  Auser should not need to know how the procedure is implemented in orderto use it.</p>
<p><a name="%_sec_Temp_41" id="%_sec_Temp_41"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_41">Local names</a></h4>
<p><a name="%_idx_578" id="%_idx_578"></a>One detail of a procedure's implementation that should not matter tothe user of the procedure is the implementer's choice of names for theprocedure's formal parameters.  Thus, the following procedures shouldnot be distinguishable:</p>
<p></p>
<p></p>
<p><pre>(define (square x) (* x x))

(define (square y) (* y y))
</pre></p>
<p></p>
<p>This principle – that the meaning of a procedure should be independentof the parameter names used by its author – seems on the surface to beself-evident, but its consequences are profound.  The simplestconsequence is that the parameter names of a procedure must be localto the body of the procedure.  For example, we used <code>square</code> inthe definition of <code>good-enough?</code> in our square-root procedure:</p>
<p></p>
<p></p>
<p><pre>(define (good-enough? guess x)
  (&lt; (abs (- (square guess) x)) 0.001))
</pre></p>
<p></p>
<p>The intention of the author of <code>good-enough?</code> is to determine ifthe square of the first argument is within a given tolerance of thesecond argument.  We see that the author of <code>good-enough?</code> usedthe name <code>guess</code> to refer to the first argument and <code>x</code> torefer to the second argument.  The argument of <code>square</code> is <code>guess</code>.  If the author of <code>square</code> used <code>x</code> (as above)to refer to that argument, we see that the <code>x</code> in <code>good-enough?</code> must be a different <code>x</code> than the one in <code>square</code>.  Running the procedure <code>square</code> must not affect the valueof <code>x</code> that is used by <code>good-enough?</code>, because that value of<code>x</code> may be needed by <code>good-enough?</code> after <code>square</code> is donecomputing.</p>
<p>If the parameters were not local to the bodies of their respectiveprocedures, then the parameter <code>x</code> in <code>square</code> could beconfused with the parameter <code>x</code> in <code>good-enough?</code>, and thebehavior of <code>good-enough?</code> would depend upon which version of<code>square</code> we used.  Thus, <code>square</code> would not be the black boxwe desired.</p>
<p><a name="%_idx_580" id="%_idx_580"></a><a name="%_idx_582" id="%_idx_582"></a>A formal parameter of a procedure has a very special role in theprocedure definition, in that it doesn't matter what name the formalparameter has.  Such a name is called a <a name="%_idx_584" id="%_idx_584"></a><a name="%_idx_586" id="%_idx_586"></a><em>bound variable</em>, and wesay that the procedure definition <a name="%_idx_588" id="%_idx_588"></a><em>binds</em> its formal parameters.The meaning of a procedure definition is unchanged if a bound variableis consistently renamed throughout the definition.<a name="call_footnote_Temp_42" href="#footnote_Temp_42" id="call_footnote_Temp_42"><sup><small>26</small></sup></a>  If a variable is not bound, we say that it is <a name="%_idx_590" id="%_idx_590"></a><a name="%_idx_592" id="%_idx_592"></a><em>free</em>.  Theset of expressions for which a binding defines a name is called the<a name="%_idx_594" id="%_idx_594"></a><a name="%_idx_596" id="%_idx_596"></a><em>scope</em> of that name.In a procedure definition, the bound variablesdeclared as the <a name="%_idx_598" id="%_idx_598"></a><a name="%_idx_600" id="%_idx_600"></a><a name="%_idx_602" id="%_idx_602"></a>formal parameters of the procedure have the body ofthe procedure as their scope.</p>
<p>In the definition of <code>good-enough?</code> above, <code>guess</code> and <code>x</code> arebound variables but <code>&lt;</code>, <code>-</code>, <code>abs</code>, and <code>square</code> are free.The meaning of <code>good-enough?</code> should be independent of the names wechoose for <code>guess</code> and <code>x</code> so long as they are distinct anddifferent from <code>&lt;</code>, <code>-</code>, <code>abs</code>, and <code>square</code>.  (If we renamed<code>guess</code> to <code>abs</code> we would have introduced a bug by <a name="%_idx_604" id="%_idx_604"></a><a name="%_idx_606" id="%_idx_606"></a><a name="%_idx_608" id="%_idx_608"></a><em>capturing</em>the variable <code>abs</code>.  It would have changed from free to bound.)  Themeaning of <code>good-enough?</code> is not independent of the names of itsfree variables, however.  It surely depends upon the fact (external tothis definition) that the symbol <code>abs</code> names a procedure forcomputing the absolute value of a number.  <code>Good-enough?</code> willcompute a different function if we substitute <code>cos</code> for <code>abs</code> inits definition.</p>
<p><a name="%_sec_Temp_43" id="%_sec_Temp_43"></a></p>
<h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_43">Internal definitions and block structure</a></h4>
<p></p>
<p>We have one kind of name isolation available to us so far: The formalparameters of a procedure are local to the body of the procedure.  Thesquare-root program illustrates another way in which we would like tocontrol the use of names.  <a name="%_idx_610" id="%_idx_610"></a>The existing program consists ofseparate procedures:</p>
<p></p>
<p></p>
<p><pre>(define (sqrt x)
  (sqrt-iter 1.0 x))
(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x) x)))
(define (good-enough? guess x)
  (&lt; (abs (- (square guess) x)) 0.001))
(define (improve guess x)
  (average guess (/ x guess)))
</pre></p>
<p></p>
<p></p>
<p>The problem with this program is that the only procedure that isimportant to users of <code>sqrt</code> is <code>sqrt</code>.  The otherprocedures (<code>sqrt-iter</code>, <code>good-enough?</code>, and <code>improve</code>)only clutter up their minds.  They may not define any other procedurecalled <code>good-enough?</code> as part of another program to work togetherwith the square-root program, because <code>sqrt</code> needs it.  Theproblem is especially severe in the construction of large systems bymany separate programmers.  For example, in the construction of alarge library of numerical procedures, many numerical functions arecomputed as successive approximations and thus might have proceduresnamed <code>good-enough?</code> and <code>improve</code> as auxiliary procedures.We would like to localize the subprocedures, hiding them inside <code>sqrt</code> so that <code>sqrt</code> could coexist with other successiveapproximations, each having its own private<code>good-enough?</code> procedure.  To make this possible, we allow aprocedure to have<a name="%_idx_612" id="%_idx_612"></a><a name="%_idx_614" id="%_idx_614"></a>internal definitions that are local to that procedure.  For example,in the square-root problem we can write</p>
<p></p>
<p></p>
<p><pre>(define (sqrt x)
  (define (good-enough? guess x)
    (&lt; (abs (- (square guess) x)) 0.001))
  (define (improve guess x)
    (average guess (/ x guess)))
  (define (sqrt-iter guess x)
    (if (good-enough? guess x)
        guess
        (sqrt-iter (improve guess x) x)))
  (sqrt-iter 1.0 x))
</pre></p>
<p></p>
<p></p>
<p>Such nesting of definitions, called <em>block structure</em>,is basically the right solution to the simplestname-packaging problem.  But there is a better idea lurking here.  Inaddition to internalizing the definitions of the auxiliary procedures,we can simplify them.  Since <code>x</code> is bound in the definition of<code>sqrt</code>, the procedures <code>good-enough?</code>, <code>improve</code>, and<code>sqrt-iter</code>, which are defined internally to <code>sqrt</code>, are in thescope of <code>x</code>.  Thus, it is not necessary to pass <code>x</code> explicitly toeach of these procedures.  Instead, we allow <code>x</code> to be a <a name="%_idx_616" id="%_idx_616"></a><a name="%_idx_618" id="%_idx_618"></a>freevariable in the internal definitions, as shown below. Then <code>x</code>gets its value from the argument with which the enclosingprocedure <code>sqrt</code> is called.  This discipline is called <a name="%_idx_620" id="%_idx_620"></a><em>lexicalscoping</em>.<a name="call_footnote_Temp_44" href="#footnote_Temp_44" id="call_footnote_Temp_44"><sup><small>27</small></sup></a></p>
<p></p>
<p></p>
<p><pre><a name="%_idx_624" id="%_idx_624"></a>(define (sqrt x)
  (define (good-enough? guess)
    (&lt; (abs (- (square guess) x)) 0.001))
  (define (improve guess)
    (average guess (/ x guess)))
  (define (sqrt-iter guess)
    (if (good-enough? guess)
        guess
        (sqrt-iter (improve guess))))
  (sqrt-iter 1.0))
</pre></p>
<p></p>
<p></p>
<p>We will use block structure extensively to help us breakup large programs into tractable pieces.<a name="call_footnote_Temp_45" href="#footnote_Temp_45" id="call_footnote_Temp_45"><sup><small>28</small></sup></a>The idea of block structure originated with theprogramming language <a name="%_idx_628" id="%_idx_628"></a>Algol 60.  It appears in most advancedprogramming languages and is an important tool for helping to organizethe construction of large programs.</p>
<p></p>
<p></p>
<div class="smallprint"><hr></div>
<p></p>
<div class="footnote">
<p><a name="footnote_Temp_10" href="#call_footnote_Temp_10" id="footnote_Temp_10"><sup><small>4</small></sup></a> Thecharacterization of numbers as “simple data” is a barefaced bluff.In fact, the treatment of numbers is one of the trickiest and mostconfusing aspects of any programming language.  Some typical issuesinvolved are these:<a name="%_idx_136" id="%_idx_136"></a><a name="%_idx_138" id="%_idx_138"></a><a name="%_idx_140" id="%_idx_140"></a>Some computer systems distinguish <em>integers</em>, such as 2, from<em>real numbers</em>, such as 2.71.  Is the real number 2.00 differentfrom the integer 2?Are the arithmetic operations usedfor integers the same as the operations used for real numbers?  Does 6divided by 2 produce 3, or 3.0?  How large a number can we represent?How many decimal places of accuracy can we represent?  Is the range ofintegers the same as the range of real numbers?  <a name="%_idx_142" id="%_idx_142"></a><a name="%_idx_144" id="%_idx_144"></a><a name="%_idx_146" id="%_idx_146"></a>Above and beyondthese questions, of course, lies a collection of issues concerningroundoff and truncation errors – the entire science of numericalanalysis.  Since our focus in this book is on large-scale programdesign rather than on numerical techniques, we are going to ignorethese problems.  The numerical examples in this chapter will exhibitthe usual roundoff behavior that one observes when using arithmeticoperations that preserve a limited number of decimal places ofaccuracy in noninteger operations.</p>
<p><a name="footnote_Temp_11" href="#call_footnote_Temp_11" id="footnote_Temp_11"><sup><small>5</small></sup></a> Throughout this book,<a name="%_idx_152" id="%_idx_152"></a>when we wish to emphasize the distinction between the input typed bythe user and the response printed by the interpreter, we will show thelatter in slanted characters.</p>
<p><a name="footnote_Temp_12" href="#call_footnote_Temp_12" id="footnote_Temp_12"><sup><small>6</small></sup></a> <a name="%_idx_200" id="%_idx_200"></a><a name="%_idx_202" id="%_idx_202"></a>Lisp systems typically providefeatures to aid the user in formatting expressions.  Two especiallyuseful features are one that automatically indents to the properpretty-print position whenever a new line is started and one thathighlights the matching left parenthesis whenever a right parenthesisis typed.</p>
<p><a name="footnote_Temp_13" href="#call_footnote_Temp_13" id="footnote_Temp_13"><sup><small>7</small></sup></a> <a name="%_idx_208" id="%_idx_208"></a><a name="%_idx_210" id="%_idx_210"></a><a name="%_idx_212" id="%_idx_212"></a><a name="%_idx_214" id="%_idx_214"></a>Lisp obeys the convention that everyexpression has a value. This convention, together with the oldreputation of Lisp as an inefficient language, is the source of thequip by Alan Perlis (paraphrasing Oscar Wilde)that “Lisp programmers know the value ofeverything but the cost of nothing.”</p>
<p><a name="footnote_Temp_14" href="#call_footnote_Temp_14" id="footnote_Temp_14"><sup><small>8</small></sup></a> <a name="%_idx_228" id="%_idx_228"></a><a name="%_idx_230" id="%_idx_230"></a>In this book, we do not show the interpreter's response toevaluating definitions, since this is highlyimplementation-dependent.</p>
<p><a name="footnote_Temp_15" href="#call_footnote_Temp_15" id="footnote_Temp_15"><sup><small>9</small></sup></a> Chapter 3 will show that this notion ofenvironment is crucial, both for understanding how the interpreterworks and for implementing interpreters.</p>
<p><a name="footnote_Temp_16" href="#call_footnote_Temp_16" id="footnote_Temp_16"><sup><small>10</small></sup></a> It may seem strange that the evaluation rule says, aspart of the first step, that we should evaluate the leftmost elementof a combination, since at this point that can only be an operatorsuch as <code>+</code> or <code>*</code>representing a built-in primitive procedure such as addition ormultiplication.  We will see later that it is useful to be able to work withcombinations whose operators are themselves compound expressions.</p>
<p><a name="footnote_Temp_17" href="#call_footnote_Temp_17" id="footnote_Temp_17"><sup><small>11</small></sup></a> <a name="%_idx_278" id="%_idx_278"></a><a name="%_idx_280" id="%_idx_280"></a><a name="%_idx_282" id="%_idx_282"></a><a name="%_idx_284" id="%_idx_284"></a><a name="%_idx_286" id="%_idx_286"></a><a name="%_idx_288" id="%_idx_288"></a><a name="%_idx_290" id="%_idx_290"></a>Special syntactic forms that are simply convenientalternative surface structures for things that can be written in moreuniform ways are sometimes called <em>syntactic sugar</em>, to use aphrase coined by Peter Landin.  In comparison with users of otherlanguages, Lisp programmers, as a rule, are less concerned withmatters of syntax.  (By contrast, examine any Pascal manual and noticehow much of it is devoted to descriptions of syntax.)  This disdainfor syntax is due partly to the flexibility of Lisp, which makes iteasy to change surface syntax, and partly to the observation that many“convenient” syntactic constructs, which make the language lessuniform, end up causing more trouble than they are worth when programsbecome large and complex.  In the words of Alan Perlis, “Syntacticsugar causes cancer of the semicolon.”</p>
<p><a name="footnote_Temp_18" href="#call_footnote_Temp_18" id="footnote_Temp_18"><sup><small>12</small></sup></a> Observe that there are two different operationsbeing combined here: we are creating the procedure, and we are givingit the name <code>square</code>.  It is possible, indeed important, to beable to separate these two notions – to create procedures withoutnaming them, and to give names to procedures that have already beencreated.  We will see how to do this in section <a href="book-Z-H-12.html#%_sec_1.3.2">1.3.2</a>.</p>
<p><a name="footnote_Temp_19" href="#call_footnote_Temp_19" id="footnote_Temp_19"><sup><small>13</small></sup></a> Throughout this book, we will<a name="%_idx_314" id="%_idx_314"></a><a name="%_idx_316" id="%_idx_316"></a>describe the general syntax of expressions by using italic symbolsdelimited by angle brackets – e.g., &lt;<em>name</em>&gt; – to denote the“slots” in the expression to be filled in when such an expression isactually used.</p>
<p><a name="footnote_Temp_20" href="#call_footnote_Temp_20" id="footnote_Temp_20"><sup><small>14</small></sup></a> More<a name="%_idx_326" id="%_idx_326"></a>generally, the body of the procedure can be a sequence of expressions.In this case, the interpreter evaluates each expression in thesequence in turn and returns the value of the final expression as thevalue of the procedure application.</p>
<p><a name="footnote_Temp_21" href="#call_footnote_Temp_21" id="footnote_Temp_21"><sup><small>15</small></sup></a> Despite thesimplicity of the substitution idea, it turns out to be surprisinglycomplicated to give a rigorous mathematical definition of thesubstitution process.  The problem arises from the possibility ofconfusion between the names used for the formal parameters of aprocedure and the (possibly identical) names used in the expressionsto which the procedure may be applied.  Indeed, there is a longhistory of erroneous definitions of <em>substitution</em> in theliterature of logic and programming semantics.  <a name="%_idx_338" id="%_idx_338"></a>See Stoy 1977 for acareful discussion of substitution.</p>
<p><a name="footnote_Temp_23" href="#call_footnote_Temp_23" id="footnote_Temp_23"><sup><small>16</small></sup></a> Inchapter 3 we will introduce <em>stream processing</em>, which is a way ofhandling apparently “infinite” data structures by incorporating alimited form of normal-order evaluation.  Insection <a href="book-Z-H-27.html#%_sec_4.2">4.2</a> we will modify the Schemeinterpreter to produce a normal-order variant of Scheme.</p>
<p><a name="footnote_Temp_24" href="#call_footnote_Temp_24" id="footnote_Temp_24"><sup><small>17</small></sup></a> <a name="%_idx_368" id="%_idx_368"></a><a name="%_idx_370" id="%_idx_370"></a><a name="%_idx_372" id="%_idx_372"></a><a name="%_idx_374" id="%_idx_374"></a><a name="%_idx_376" id="%_idx_376"></a><a name="%_idx_378" id="%_idx_378"></a><a name="%_idx_380" id="%_idx_380"></a><a name="%_idx_382" id="%_idx_382"></a>“Interpreted as either true or false”means this: In Scheme, there are two distinguished values that aredenoted by the constants <code>#t</code> and <code>#f</code>.  When the interpreterchecks a predicate's value, it interprets <code>#f</code> as false.  Any other valueis treated as true.  (Thus, providing <code>#t</code> is logicallyunnecessary, but it is convenient.)  In this book we will usenames <code>true</code> and <code>false</code>, which are associatedwith the values <code>#t</code> and <code>#f</code> respectively.</p>
<p><a name="footnote_Temp_25" href="#call_footnote_Temp_25" id="footnote_Temp_25"><sup><small>18</small></sup></a> <code>Abs</code> also uses<a name="%_idx_410" id="%_idx_410"></a><a name="%_idx_412" id="%_idx_412"></a>the “minus” operator <code>-</code>, which, when used with a singleoperand, as in <code>(- x)</code>, indicates negation.</p>
<p><a name="footnote_Temp_26" href="#call_footnote_Temp_26" id="footnote_Temp_26"><sup><small>19</small></sup></a> A minor difference<a name="%_idx_440" id="%_idx_440"></a><a name="%_idx_442" id="%_idx_442"></a><a name="%_idx_444" id="%_idx_444"></a>between <code>if</code> and <code>cond</code> is that the&lt;<em>e</em>&gt; part of each <code>cond</code> clause may be a sequence of expressions.If the corresponding &lt;<em>p</em>&gt; is found to be true, the expressions&lt;<em>e</em>&gt; are evaluated in sequence and the value of the finalexpression in the sequence is returned as the value of the <code>cond</code>.In an <code>if</code> expression, however, the &lt;<em>consequent</em>&gt; and&lt;<em>alternative</em>&gt; must be single expressions.</p>
<p><a name="footnote_Temp_32" href="#call_footnote_Temp_32" id="footnote_Temp_32"><sup><small>20</small></sup></a> Declarative andimperative descriptions are intimately related, as indeed aremathematics and computer science.  For instance, to say that theanswer produced by a program is <a name="%_idx_500" id="%_idx_500"></a>“correct” is to make a declarativestatement about the program.  There is a large amount of researchaimed at establishing techniques for <a name="%_idx_502" id="%_idx_502"></a>proving that programs arecorrect, and much of the technical difficulty of this subject has todo with negotiating the transition between imperative statements (fromwhich programs are constructed) and declarative statements (which canbe used to deduce things).  In a related vein, an important currentarea in programming-language design is the exploration of so-called<a name="%_idx_504" id="%_idx_504"></a><a name="%_idx_506" id="%_idx_506"></a>very high-level languages, in which one actually programs in terms ofdeclarative statements.  The idea is to make interpreterssophisticated enough so that, given “what is” knowledge specified bythe programmer, they can generate “how to” knowledge automatically.This cannot be done in general, but there are important areas whereprogress has been made.  We shall revisit this idea in chapter 4.</p>
<p><a name="footnote_Temp_33" href="#call_footnote_Temp_33" id="footnote_Temp_33"><sup><small>21</small></sup></a> This square-root algorithm is actually a special caseof Newton's method, which is a general technique for finding roots ofequations.  The square-root algorithm itself was developed by Heron of<a name="%_idx_512" id="%_idx_512"></a>Alexandria in the first century <font size="-2">A</font>.<font size="-2">D</font>.  We will see how to expressthe general Newton's method as a Lisp procedure insection <a href="book-Z-H-12.html#%_sec_1.3.4">1.3.4</a>.</p>
<p><a name="footnote_Temp_34" href="#call_footnote_Temp_34" id="footnote_Temp_34"><sup><small>22</small></sup></a> We will usually give<a name="%_idx_518" id="%_idx_518"></a><a name="%_idx_520" id="%_idx_520"></a><a name="%_idx_522" id="%_idx_522"></a><a name="%_idx_524" id="%_idx_524"></a>predicates names ending with question marks, to help usremember that they are predicates.  Thisis just a stylistic convention.  As far as the interpreter isconcerned, the question mark is just an ordinary character.</p>
<p><a name="footnote_Temp_35" href="#call_footnote_Temp_35" id="footnote_Temp_35"><sup><small>23</small></sup></a> Observe that we express our initial guess as 1.0 rather than1.  This would not make any difference in many Lisp implementations.<a name="%_idx_526" id="%_idx_526"></a><a name="%_idx_528" id="%_idx_528"></a><a name="%_idx_530" id="%_idx_530"></a><a name="%_idx_532" id="%_idx_532"></a><a name="%_idx_534" id="%_idx_534"></a><a name="%_idx_536" id="%_idx_536"></a><a name="%_idx_538" id="%_idx_538"></a><a name="%_idx_540" id="%_idx_540"></a><a name="%_idx_542" id="%_idx_542"></a><a name="%_idx_544" id="%_idx_544"></a><a name="%_idx_546" id="%_idx_546"></a><a name="%_idx_548" id="%_idx_548"></a>MIT Scheme, however, distinguishes between exact integers and decimalvalues, and dividing two integers produces a rational number ratherthan a decimal.  For example, dividing 10 by 6 yields 5/3, whiledividing 10.0 by 6.0 yields 1.6666666666666667.  (We will learn how toimplement arithmetic on rational numbers insection <a href="book-Z-H-14.html#%_sec_2.1.1">2.1.1</a>.)  If we start with an initial guess of 1in our square-root program, and <em>x</em> is an exact integer, allsubsequent values produced in the square-root computation will berational numbers rather than decimals.  Mixed operations on rationalnumbers and decimals always yield decimals, so starting with aninitial guess of 1.0 forces all subsequent values to be decimals.</p>
<p><a name="footnote_Temp_36" href="#call_footnote_Temp_36" id="footnote_Temp_36"><sup><small>24</small></sup></a> Readers who are worried about the efficiencyissues involved in using procedure calls to implement iteration shouldnote the remarks on “tail recursion” insection <a href="book-Z-H-11.html#%_sec_1.2.1">1.2.1</a>.</p>
<p><a name="footnote_Temp_40" href="#call_footnote_Temp_40" id="footnote_Temp_40"><sup><small>25</small></sup></a> It is not even clear which of these procedures is amore efficient implementation.  This depends upon the hardwareavailable.  There are machines for which the “obvious”implementation is the less efficient one.  Consider a machine that hasextensive tables of logarithms and antilogarithms stored in a veryefficient manner.</p>
<p><a name="footnote_Temp_42" href="#call_footnote_Temp_42" id="footnote_Temp_42"><sup><small>26</small></sup></a> Theconcept of consistent renaming is actually subtle and difficult todefine formally.  Famous logicians have made embarrassing errorshere.</p>
<p><a name="footnote_Temp_44" href="#call_footnote_Temp_44" id="footnote_Temp_44"><sup><small>27</small></sup></a> Lexicalscoping dictates that free variables in a procedure are taken to refer tobindings made by enclosing procedure definitions;that is, they are looked up in<a name="%_idx_622" id="%_idx_622"></a>the environment in which the procedure was defined.  We will see howthis works in detail in chapter 3 when we study environments and thedetailed behavior of the interpreter.</p>
<p><a name="footnote_Temp_45" href="#call_footnote_Temp_45" id="footnote_Temp_45"><sup><small>28</small></sup></a> Embedded definitions<a name="%_idx_626" id="%_idx_626"></a>must come first in a procedure body.  The management is not responsiblefor the consequences of running programs that intertwine definitionand use.</p>
</div></body>
</html>
